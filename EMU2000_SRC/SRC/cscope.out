cscope 15 /mnt/hgfs/SVN/EMU2000/EMU2000_Linux/EMU2000_SRC/SRC -q 0000004162 0001095406
	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/BusManger.cpp

5 
	~"BusMg.h
"

6 
	#DNSFILE
 "/c/sv.cf"

	)

14 
BOOL
 
	$WreLolDns
 ( *
pDns
 )

16 
FILE
 *

 = 
NULL
;

17 
R
 = 0;

19 

 = 
	`fݒ

DNSFILE
, "w");

20 if(

 =
NULL
)

22  
FALSE
;

25 
R
 = 
	`fwre
(
pDns
, 
	`
Dns), 1, 

);

27 
	`fo
(

);

28  
R
;

29 
	}
}

36 
	gCBusMg
::
	$CBusMg
()

38 
m_GProc
 = 
w
 
CGProc
 ;

39 
	`memt

m_sysDns
 , 0 , ( m_sysDns ) );

40 
	}
}

43 
	gCBusMg
::~
	$CBusMg
()

45 
	`RemoveBus
( ) ;

46 if
m_GProc
 )

47 
de
 
m_GProc
 ;

48 
	}
}

51 
BOOL
 
	gCBusMg
::
	$AddBus

CProc
 * 
pProc
 , 
CBaPt
 * 
pBaPt
 , 
WORD
 
wIv
 , 
BYTE
 
byMsgTy
 ,

52 
CMhod
 * 
pMhod
, *
pNCd
, *
pRemeIp
, 
DWORD
 
dwPtNum
 )

54 if
pProc
 =
NULL
 || 
pBaPt
 =NULL || 
pMhod
 == NULL )

56 
	`tf
( "AddBus Failed ! \n" ) ;

57  
FALSE
 ;

60 
PBUSMANAGER
 
bus
 = 
w
 
BUSMANAGER
 ;

61 
bus
->
m_Pt
 = 
pBaPt
 ;

62 
bus
->
m_Proc
 = 
pProc
 ;

63 
bus
->
wIv
 = wInterval ;

64 
bus
->
byBusNo
 = 
byMsgTy
 - 1 ;

65 
bus
->
m_pMhod
 = 
pMhod
 ;

67 
bus
->
m_Debug
.
	`In
(
byMsgTy
, 
pNCd
, 
pRemeIp
, 
dwPtNum
);

69 
bus
->
m_msg
.
	`CeMsgQueue

byMsgTy
 );

70 
m_sbus
.
	`push_back

bus
 ) ;

71  
TRUE
 ;

72 
	}
}

74 
BOOL
 
	gCBusMg
::
	$AddPauBus
( )

76 
PBUSMANAGER
 
bus
 = 
w
 
BUSMANAGER
 ;

77 
m_sbus
.
	`push_back

bus
 ) ;

78  
TRUE
 ;

79 
	}
}

82 
BOOL
 
	gCBusMg
::
	$RemoveBus
( )

84 
size
 = 
m_sbus
.
	`size
() ;

85  
i
 = 0 ; i < 
size
 ; i++ )

87 
CBaPt
 * 
pBa
 = 
NULL
 ;

88 
CProc
 * 
pProc
 = 
NULL
 ;

89 
CMhod
 * 
pMhod
 = 
NULL
 ;

90 
PBUSMANAGER
 
pbus

m_sbus
[ 
i
 ] ;

92 if
pbus
 )

94 
pBa
 = 
pbus
->
m_Pt
 ;

95 
pProc
 = 
pbus
->
m_Proc
 ;

96 
pMhod
 = 
pbus
->
m_pMhod
 ;

98 if
pBa
 !
NULL
 )

100 
de
 
pBa
 ;

101 
pBa
 = 
NULL
 ;

102 
	`tf
"DpBa %d \n" , 
i
 );

105 if
pProc
 !
NULL
 )

107 
de
 
pProc
 ;

108 
pProc
 = 
NULL
 ;

109 
	`tf
"DpProc %d \n" , 
i
 );

112 if
pMhod
 !
NULL
 )

114 
de
 
pMhod
 ;

115 
pMhod
 = 
NULL
 ;

116 
	`tf
"DpMhod %d \n" , 
i
 ) ;

119 
de
 
pbus
 ;

120 
pbus
 = 
NULL
 ;

121 
	`tf
" DpBuDeru %d! \" , 
i
 );

125 
m_sbus
.
	`r
( ) ;

126 
m_VeTCl
.
	`r
() ;

127  
TRUE
 ;

128 
	}
}

130 
BOOL
 
	gCBusMg
::
	$AddClPt

CBaPt
 * 
pPtTCl
)

132 
m_VeTCl
.
	`push_back

pPtTCl
 ) ;

133  
TRUE
 ;

134 
	}
}

136 
	gCBusMg
::
	$GClSize
( )

138  
m_VeTCl
.
	`size
() ;

139 
	}
}

141 
	gve
<
	gCBaPt
*> *
	gCBusMg
::
	$GSSvVe
( )

143 if!
	`GClSize
() )

144  
NULL
 ;

146  &
m_VeTCl
 ;

147 
	}
}

149 
BOOL
 
	gCBusMg
::
	$SNCdPam

NETWORKPARAM
 *
pNPam
 )

151 if
pNPam
 =
NULL
 )

152  
FALSE
 ;

154 
NETWORKPARAM
 
pPam
 ;

155 
	`ry

pPam
.
pNCdName
 , 
pNPam
->pNetCardName ) ;

156 
	`ry

pPam
.
sIp
 , 
pNPam
->sIp ) ;

157 
	`ry

pPam
.
sSubNMask
 , 
pNPam
->sSubNetMask ) ;

158 
	`ry

pPam
.
sGeWay
 , 
pNPam
->sGateWay ) ;

159 
	`ry

pPam
.
sDNS
 , 
pNPam
->sDNS ) ;

160 if0 !
	`

pNPam
->
sRouIp
 ) )

162 
	`ry

pPam
.
sRouIp
 , 
pNPam
->sRouteIp ) ;

165 
m_NPamAay
.
	`push_back

pPam
 ) ;

166  
TRUE
 ;

167 
	}
}

169 
BOOL
 
	gCBusMg
::
	$GNCdPam
* 
prNCdName
 , 
NETWORKPARAM
 *
pNPam
 )

171 if
prNCdName
 =
NULL
 || 
pNPam
 == NULL )

172  
FALSE
 ;

174 
BYTE
 
bySize
 = 
m_NPamAay
.
	`size
() ;

175 
BOOL
 
bFg
 = 
FALSE
 ;

176  
BYTE
 
i
 = 0 ; i < 
bySize
 ; i++ )

178 
NETWORKPARAM
 
tWkPam
 ;

179 
tWkPam
 = 
m_NPamAay
[ 
i
 ] ;

180 if
	`rcmp

tWkPam
.
pNCdName
 , 
prNCdName
 ) == 0 )

182 *
pNPam
 ) << &
tWkPam
 ;

183 
bFg
 = 
TRUE
 ;

188  
bFg
 ;

189 
	}
}

191 
BOOL
 
	gCBusMg
::
	$EbNCdPam
( )

193 
size
 = 
m_NPamAay
.
	`size
() ;

194 if
size
 == 0 )

195  
FALSE
 ;

197  
i
 = 0 ; i < 
size
 ; i++ )

199 
NETWORKPARAM
 
tWksPam
 ;

200 
tWksPam
 = 
m_NPamAay
[ 
i
 ] ;

202 
buf
[ 300 ] = { 0 } ;

203 
	`rtf

buf
 , "ifconfig %s %setmask %s",

204 
tWksPam
.
pNCdName
 ,

205 
tWksPam
.
sIp
,

206 
tWksPam
.
sSubNMask
);

207 
	`syem
(
buf
);

211 if0 !
	`

tWksPam
.
sRouIp
 ) )

213 
	`rtf
(
buf
, "routedd -net %setmask %s gw %s",

214 
tWksPam
.
sRouIp
,

215 
tWksPam
.
sSubNMask
,

216 
tWksPam
.
sGeWay
);

217 
	`syem
(
buf
);

221 
	`rtf
(
buf
, "routedd default gw %s %s",

222 
tWksPam
.
sGeWay
,

223 
tWksPam
.
pNCdName
 );

224 
	`syem
(
buf
);

233 if(
FALSE
 =
	`WreLolDns

m_sysDns
 ) )

235 
	`tf
(" WriteDns false \n");

241  
TRUE
 ;

242 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/BusManger.h

5 #i!
defed
(
AFX_BUSMANGER_H__8FD47E1A_DCA2_4AB0_8996_B31E7B86EC02__INCLUDED_
)

6 
	#AFX_BUSMANGER_H__8FD47E1A_DCA2_4AB0_8996_B31E7B86EC02__INCLUDED_


	)

8 
	~"ma.h
"

9 
	~"GProc.h
"

11 as
	cCBusMg


13 
	mpublic
:

14 
CBusMg
( );

15 
	mvtu
 ~
CBusMg
( );

16 
BOOL
 
AddBus

CProc
 * 
pProc
 , 
CBaPt
 * 
pBaPt
 , 
WORD
 
wIv
 , 
BYTE
 
byMsgTy
 ,

17 
CMhod
 * 
pMhod
 , *
pNCd
, *
pRemeIp
, 
DWORD
 
dwPtNum
);

18 
CGProc
 *
	mm_GProc
 ;

19 
	mpublic
:

20 
BUSARRAY
 
m_sbus
 ;

21 
	mm_sysDns
[20];

22 
BOOL
 
RemoveBus
( ) ;

23 
BOOL
 
AddPauBus
( ) ;

24 
BOOL
 
AddClPt

CBaPt
 * 
pPtTCl
 ) ;

25 
BOOL
 
GClSize
( ) ;

26 
	mve
<
	mCBaPt
*>*
GSSvVe
( ) ;

27 
BOOL
 
SNCdPam

NETWORKPARAM
 *
pNPam
 ) ;

28 
BOOL
 
GNCdPam
* 
rNCdName
 , 
NETWORKPARAM
 *
pNPam
 ) ;

29 
BOOL
 
EbNCdPam
( );

31 
	mive
:

32 
ve
<
CBaPt
*> 
m_VeTCl
;

33 
NETWORKPARAM_ARRAY
 
	mm_NPamAay
 ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/CBusDebug.cpp

19 
	~"CBusDebug.h
"

20 
	~<sys/tys.h
>

21 
	~<sys/m.h
>

22 
	~<sys/iol.h
>

23 
	~<sys/sock.h
>

24 
	~<t/if.h
>

25 
	~<t/.h
>

26 
	~<t/if_p.h
>

27 
	~</.h
>

28 
	~<unid.h
>

29 
	~<rg.h
>

31 
	~"../she/glob.h
"

40 
	gCBusDebug
::
	$CBusDebug
 ()

42 
pUdpObj
 = 
NULL
;

47 
	}
}

57 
	gCBusDebug
::~
	$CBusDebug
 ()

59 
de
 
pUdpObj
;

63 
	`tf
 ( "CBusDebug destructor\n" );

64 
	}
}

113 
	#MAXINTERFACES
 16

	)

195 
BOOL
 
	gCBusDebug
::
	$GLolIp
 ( *
pNCd
 )

197 
fd
, 

;

198 
ieq
 
buf
[
MAXINTERFACES
];

200 
ifcf
 
ifc
;

202 i((
fd
 = 
	`sock
 (
AF_INET
, 
SOCK_DGRAM
, 0)) >= 0)

204 
ifc
.
ifc_n
 =  
buf
;

205 
ifc
.
ifc_buf
 = (
ddr_t

buf
;

206 i(!
	`iol
 (
fd
, 
SIOCGIFCONF
, (*&
ifc
))

209 

 = 
ifc
.
ifc_n
 /  (
ieq
);

212  (

--) > 0)

216 if(
	`rcmp
(
buf
[

].
i_me
, 
pNCd
) == 0)

222 i(!(
	`iol
 (
fd
, 
SIOCGIFADDR
, (*&
buf
[

])))

224 
	`ry
(
m_szLolAddr
, (*)
	`_
(((
sockaddr_
*)(&
buf
[

].
i_addr
))->
s_addr
));

225  
TRUE
;

229 
r
[256];

230 
	`rtf
 (
r
, "m: iodevi %s", 
buf
[

].
i_me
);

231 
	`
 (
r
);

237 
	`
 ("cpm: ioctl");

240 
	`
 ("cpm: socket");

241 
	`o
 (
fd
);

242  
FALSE
;

243 
	}
}

255 
BOOL
 
	gCBusDebug
::
	$In
 ( 
BYTE
 
byBue
, *
pNCd
, *
pRemeIp
, 
DWORD
 
dzPtNum
 )

257 
EBuf
[256];

258 if(
pUdpObj
 =
NULL
)

259 
pUdpObj
 = 
w
 
CUdpPt
;

261  
FALSE
;

263 if
	`GLolIp

pNCd
 ) )

265 
pUdpObj
->
m_uThePt
 = 
dzPtNum
 + 
byBue
;

267 
	`ry
(
pUdpObj
->
m_szLolAddr
, m_szLocalAddr);

268 
	`ry
(
m_szRemeAddr
, 
pRemeIp
);

270 
	`tf
 ( "CBusDebug:NCd=%s, LolIp=%RemeIp=%Pt=%d\n", 
pNCd
, 
m_szLolAddr
,
m_szRemeAddr
,
pUdpObj
->
m_uThePt
 );

272  
pUdpObj
->
	`OnPt

EBuf
 );

275  
FALSE
;

276 
	}
}

323 
	gCBusDebug
::
	$SdDebugMsg
 ( 
BYTE
 *
buf
, 
L
 )

325 
SdL
 = 0;

326 if
buf
 =
NULL
 || 
L
 < 0 || L > 
MAX_DEBUG_BUFFER
 )

328 
	`tf
("SendDebugMsgeturn -1\n");

331 if(
L
 >= 1024)

332 
L
 = 1024;

335 if(
pUdpObj
)

336 
SdL
 = 
pUdpObj
->
	`WreTo

buf
, 
L
, 
m_szRemeAddr
,UdpObj->
m_uThePt
);

345  
SdL
;

346 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/CBusDebug.h

19 #ide 
__CBUSDEBUG_H__


20 
	#__CBUSDEBUG_H__


	)

23 
	~<dio.h
>

24 
	~<rg.h
>

25 
	~"../she/BaPt.h
"

26 
	~"../she/UdpPt.h
"

27 
	~"../she/tydef.h
"

29 
	#START_PORT
 50000

	)

36 as
	cCBusDebug


38 
	mpublic
:

40 
CBusDebug
 ();

41 ~
CBusDebug
 ();

42 
BOOL
 
In
(
BYTE
 
byBusLe
);

43 
BOOL
 
In
 ( 
BYTE
 
byBue
, *
pNCd
, *
pRemeIp
, 
DWORD
 
dzPtNum
 );

47 
SdDebugMsg
 ( 
BYTE
 *
buf
, 
L
 );

48 
	meed
:

49 
BOOL
 
SDebugAri
(
BYTE
 
byBue
, 

, *
szLolIp
, *
szBrdIp
);

50 
BOOL
 
SDebugN
(
BYTE
 
byBue
);

51 
BOOL
 
GLolIp
*
pNCd
 );

53 
	mive
:

55 
CUdpPt
 *
pUdpObj
;

60 
	mm_szRemeAddr
[24];

61 
	mm_szLolAddr
[16];

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/CPublicMethod.cpp

20 
	~"CPublicMhod.h
"

23 "C" 
time_t
 
MakeSecd

wYr
, 
wMth
, 
wDay
,

24 
wHour
, 
wMu
, 
wSecd
 );

25 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

46 
BOOL
 
	gCPublicMhod
::
m_bDDBBusLkStus
[ 
MAX_LINE
 ];

47 
BOOL
 
	gCPublicMhod
::
m_bDDBSLkStus
[ 
MAX_STN_SUM
 ];

55 
	gCPublicMhod
::
	$CPublicMhod
 ()

57 
m_wGhDevCou
 = 0 ;

58 
	}
}

67 
	gCPublicMhod
::~
	$CPublicMhod
 ()

69 
	`tf
 ( "publicmethod destructor\n" );

70 
	}
}

81 
BOOL
 
	gCPublicMhod
::
	$GBusLeAndAddr
 ( 
WORD
 
wSlNum
, 
BYTE
 &
byBusNo
, WORD &
wDevAddr
 )

83 
CProc
 *
pMoud
 = 
	`GProcMoud

wSlNum
 );

84 if
NULL
 =
pMoud
 )

86  
FALSE
;

89 
byBusNo
 = 
pMoud
->
m_byLeNo
;

90 
wDevAddr
 = 
pMoud
->
m_wDevAddr
;

92  
TRUE
;

93 
	}
}

105 
CProc
 * 
	gCPublicMhod
::
	$GProcMoud
 ( 
WORD
 
wSlNo
 )

107 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

108 
PBUSMANAGER
 
pBus
 = 
NULL
;

109 
CProc
 *
pPrObj
, *
pMoud
;

110 
i
;

111 
nSlNo
 = 0;

113 
i
 = 0; i < 
nCou
; i++)

115 
nMoudSize
;

116 
pBus
 = 
m_pBusMag
->
m_sbus
[
i
];

117 if
pBus
 =
NULL
 )

120  
NULL
;

123 if
pBus
->
byBusNo
 == 0xFF )

127 
pPrObj
 = 
pBus
->
m_Proc
;

128 i
pPrObj
 =
NULL
 )

131  
NULL
;

135 
nMoudSize
 = 
pPrObj
->
m_modu
.
	`size
();

138 if
pPrObj
->
m_ProTy
 =
PROTOCO_GATHER
 )

139 
nSlNo
 +
nMoudSize
;

141 if(
nSlNo
 <
wSlNo
)

145 
pMoud
 = 
pPrObj
->
m_modu
[
wSlNo
 - (
nSlNo
 - 
nMoudSize
)];

146 i
pMoud
 =
NULL
 )

149  
NULL
;

152 if
wSlNo
 !
pMoud
->
m_SlNo
 ||Moud->
m_wModuTy
 == 0 )

154 
	`tf
 ( "[CPUBLICMETHOD]:n'fd wSlNo=%d \n", 
wSlNo
 );

155  
NULL
;

158  
pMoud
;

162 if(
i
 >
nCou
)

164 
	`tf
("i=%dCou:%d c'fdhSlNo=%d\n", 
i
, 
nCou
, 
wSlNo
 );

165  
NULL
;

168  
NULL
;

169 
	}
}

180 
	gCPublicMhod
::
	$GSlNo
 ( 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
 )

182 
PBUSMANAGER
 
pBus
 = 
NULL
;

183 
CProc
 *
pPrObj
 = 
NULL
, *
pMoud
 = NULL;

184 
nMoudSize
 = -1;

187 if
m_pBusMag
 =
NULL
 )

190 
size
 = 
m_pBusMag
->
m_sbus
.
	`size
() ;

191 if
byBusNo
 >
size
 )

194 
pBus
 = 
m_pBusMag
->
m_sbus
[
byBusNo
];

195 if(
pBus
 =
NULL
)

200 
pPrObj
 = 
pBus
->
m_Proc
;

201 i
pPrObj
 =
NULL
 )

207 
nMoudSize
 = 
pPrObj
->
m_modu
.
	`size
();

208 
k
 = 0; k < 
nMoudSize
; k++)

210 
pMoud
 = 
pPrObj
->
m_modu
[
k
];

211 i
pMoud
 =
NULL
 )

216 if(
wDevAddr
 =
pMoud
->
m_wDevAddr
)

222  
pMoud
->
m_SlNo
;

223 
	}
}

240 
	gCPublicMhod
::
	$YcUpde
 ( 
WORD
 
SlNo
, 
YC_DATA
 
YcDa
[], 
UINT
 
YcNum
 )

243 
UINT
 
i
;

250  
i
 = 0; i < 
YcNum
; i++ )

252 
YcDa
[
i
].
byYcTy
)

260 
	`SYcDa

SlNo
, 
YcDa
[
i
].
wP
, YcDa[i].
YcVue
);

309 
	}
}

320 
	gCPublicMhod
::
	$SYcDa
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
fV
 )

323 
YC_DATA
 
ycDa
 ;

324 
ycDa
.
wSlNo
 = wSerialNo ;

325 
ycDa
.
wP
 = wPnt ;

326 
ycDa
.
fYcVue
 = 
fV
 ;

327 
ycDa
.
byYcTy
 = 0 ;

329 
m_pRdbObj
->
	`WreV

wSlNo
 , 
YC_TYPE
 , &
ycDa
 ) ;

332 
	}
}

343 
	gCPublicMhod
::
	$SYcDaWhTime
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
fV
, 
TIMEDATA
 *
pTime
 )

345 
YC_DATA
 
ycDa
 ;

346 
ycDa
.
wSlNo
 = wSerialNo ;

347 
ycDa
.
wP
 = wPnt ;

348 
ycDa
.
fYcVue
 = 
fV
 ;

349 
ycDa
.
byYcTy
 = 2 ;

352 
ycDa
.
MSecd
 = 
pTime
->
MiSec
 ;

353 
ycDa
.
Secd
 = 
pTime
->Second ;

354 
ycDa
.
Mu
 = 
pTime
->Minute ;

355 
ycDa
.
Hour
 = 
pTime
->Hour ;

356 
ycDa
.
Day
 = 
pTime
->Day ;

357 
ycDa
.
Mth
 = 
pTime
->Month ;

358 
ycDa
.
Yr
 = 
pTime
->Year ;

360 
m_pRdbObj
->
	`WreV

wSlNo
 , 
YC_TYPE
 , &
ycDa
 ) ;

364 
	}
}

378 
	gCPublicMhod
::
	$YxUpde
 ( 
WORD
 
SlNo
, 
YX_DATA
 
YxDa
[], 
UINT
 
YxNum
)

382 
UINT
 
i
;

386  
i
 = 0; i < 
YxNum
; i++ )

388 
YxDa
[
i
].
byYxTy
)

430 
	}
}

441 
	gCPublicMhod
::
	$SYxDa
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
BYTE
 
byV
 )

443 if(
byV
 != 0 && byVal != 1)

445 
	`tf
 ( "YX SlN%d Pڙ = %d vu%d \n", 
wSlNo
, 
wP
, 
byV
 );

449 
YX_DATA
 
yxDa
 ;

450 
yxDa
.
byYxTy
 = 0 ;

451 
yxDa
.
YxVue
 = 
byV
 ;

452 
yxDa
.
wSlNo
 = wSerialNo ;

453 
yxDa
.
wP
 = wPnt ;

455 
m_pRdbObj
->
	`WreV

wSlNo
 , 
YX_TYPE
 , &
yxDa
 ) ;

458 
	}
}

469 
	gCPublicMhod
::
	$SYxDaWhTime
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
BYTE
 
byV
, 
TIMEDATA
 *
pTime
 )

471 if(
byV
 != 0 && byVal != 1)

473 
	`tf
 ( "YXS SlN%d Pڙ = %d vu%d\n", 
wSlNo
, 
wP
, 
byV
 );

476 if!
	`IsSTime

pTime
->
MiSec
,

477 
pTime
->
Secd
,

478 
pTime
->
Mu
,

479 
pTime
->
Hour
,

480 
pTime
->
Day
,

481 
pTime
->
Mth
,

482 
pTime
->
Yr
) )

489 
YX_DATA
 
yxDa
 ;

490 
yxDa
.
byYxTy
 = 2 ;

491 
yxDa
.
YxVue
 = 
byV
 ;

492 
yxDa
.
wSlNo
 = wSerialNo ;

493 
yxDa
.
wP
 = wPnt ;

494 
yxDa
.
MSecd
 = 
pTime
->
MiSec
 ;

495 
yxDa
.
Secd
 = 
pTime
->Second ;

496 
yxDa
.
Mu
 = 
pTime
->Minute ;

497 
yxDa
.
Hour
 = 
pTime
->Hour ;

498 
yxDa
.
Day
 = 
pTime
->Day ;

499 
yxDa
.
Mth
 = 
pTime
->Month ;

500 
yxDa
.
Yr
 = 
pTime
->Year ;

502 
m_pRdbObj
->
	`WreV

wSlNo
 , 
YX_TYPE
 , &
yxDa
 ) ;

505 
	}
}

519 
	gCPublicMhod
::
	$YmUpDe
 ( 
WORD
 
SlNo
, 
YM_DATA
 
YmDa
[], 
UINT
 
YmNum
 )

523 
UINT
 
i
;

529 
i
 = 0; i < 
YmNum
; i++)

534 
	`SYmDa

SlNo
, 
YmDa
[
i
].
wP
, YmDa[i].
YmVue
);

539 
	}
}

552 
	gCPublicMhod
::
	$SYmDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, 
fV
 )

554 
YM_DATA
 
ymDa
 ;

555 
ymDa
.
YmVue
 = 
fV
 ;

556 
ymDa
.
wSlNo
 = 
wSlNO
 ;

557 
ymDa
.
wP
 = wPnt ;

559 
m_pRdbObj
->
	`WreV

wSlNO
 , 
YM_TYPE
 , &
ymDa
 ) ;

562 
	}
}

564 
BOOL
 
	gCPublicMhod
::
	$GYmDa

WORD
 
wSlNo
, WORD 
wP
, 
DWORD
 &
dwV
 )

567 
iR
 = 
m_pRdbObj
->
	`GPulV

wSlNo
 , 
wP
 , &
dwV
 ) ;

568 if
iR
 == -1 )

569  
FALSE
 ;

571  
TRUE
 ;

572 
	}
}

585 
	gCPublicMhod
::
	$SYkSR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 )

587 
	`tf
 ( "YK_SEL_RTN\n" );

588 if!
	`ProssDDB
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_SEL_RTN
 ) )

590 
	`SYkDl
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_SEL_RTN
 );

593 
	}
}

604 
	gCPublicMhod
::
	$SYkExeR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 )

606 
	`tf
 ( "YK_EXCT_RTN\n" );

607 if!
	`ProssDDB
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_EXCT_RTN
 ) )

609 
	`SYkDl
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_EXCT_RTN
 );

612 
	}
}

623 
	gCPublicMhod
::
	$SYkClR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 )

625 
	`tf
 ( "YK_CANCEL_RTN\n" );

626 if!
	`ProssDDB
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_CANCEL_RTN
 ) )

628 
	`SYkDl
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_CANCEL_RTN
 );

631 
	}
}

649 
	gCPublicMhod
::
	$RdAYcDa
 ( *
pDa
 )

651 
m_pRtuObj
->
	`RdAlogDa

pDa
 );

653 
	}
}

664 
DWORD
 
	gCPublicMhod
::
	$RdYcDa
 ( 
WORD
 
wSlNO
, WORD 
wP
 )

666 cڡ 
ANALOGITEM
 *
pIm
 =

667 
m_pRdbObj
->
	`GAlogObj
(
wSlNO
, 
wP
 );

668  
pIm
->
dwRawV
;

669 
	}
}

682 
	gCPublicMhod
::
	$RdAYxDa
 ( 
BYTE
 *
pDa
 )

684 
m_pRtuObj
->
	`RdDigDa

pDa
 );

686 
	}
}

697 
	gCPublicMhod
::
	$RdYxDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, WORD *
pwV
)

699 
R
 = 
m_pRdbObj
->
	`GDigV

wSlNO
, 
wP
, 
pwV
);

700  
R
;

701 
	}
}

714 
	gCPublicMhod
::
	$RdAYmDa
 ( 
DWORD
 *
pdwDa
 )

716 
m_pRtuObj
->
	`RdPulDa

pdwDa
 );

718 
	}
}

729 
	gCPublicMhod
::
	$RdYmDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, 
DWORD
 *
pdwV
 )

731 
R
 = 
m_pRdbObj
->
	`GPulV

wSlNO
, 
wP
, 
pdwV
 );

732  
R
;

733 
	}
}

746 
	gCPublicMhod
::
	$SYkS
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 )

748 
	`tf
 ( "YK_SEL\n" );

749 if!
	`ProssDDB

pProc
 ,
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_SEL
 ) )

751 
	`SYkDl
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
 , 
byV
, 
YK_SEL
 );

754 
	}
}

765 
	gCPublicMhod
::
	$SYkExe
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 )

767 
	`tf
 ( "YK_EXCT\n" );

768 if!
	`ProssDDB

pProc
 ,
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_EXCT
 ) )

770 
	`SYkDl
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_EXCT
 );

774 
	}
}

776 
BOOL
 
	gCPublicMhod
::
	$ProssDDB
cڡ 
CProc
 *
pProc
 , 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ,
iFg
 )

778 if
YK_SEL_RTN
 =
iFg


779 || 
YK_EXCT_RTN
 =
iFg


780 || 
YK_CANCEL_RTN
 =
iFg
 )

783 if!
CPublicMhod
::
	`IsHaveDDB
() ||

784 
CPublicMhod
::
	`GDDBSyncS
(!
STATUS_SLAVE
 ) ||

785 
pProc
->
m_ProTy
 !
PROTOCO_TRANSPROT


788  
FALSE
;

791 
BYTE
 
byDDBBusNo
 = 0xFF ;

792 
WORD
 
wDDBAddr
 = 0xFF ;

794 if!
CPublicMhod
::
	`GDDBBusAndAddr

byDDBBusNo
 , 
wDDBAddr
 ) )

796  
FALSE
;

799 i
byBusNo
 =
byDDBBusNo


800 && 
wDevAddr
 =
wDDBAddr
)

802  
FALSE
;

805 
	`SDDBYkRDl

pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
iFg
 );

807 
	`tf
 ( "DDB YK_RTN\n" );

808  
TRUE
;

811 if
YK_SEL
 =
iFg


812 || 
YK_EXCT
 =
iFg


813 || 
YK_CANCEL
 =
iFg
)

816 if!
CPublicMhod
::
	`IsHaveDDB
() ||

817 
CPublicMhod
::
	`GDDBSyncS
(!
STATUS_SLAVE
 ) ||

818 
pProc
->
m_ProTy
 =
PROTOCO_GATHER


821  
FALSE
 ;

825 
BYTE
 
byDDBBusNo
 = 0xFF ;

826 
WORD
 
wDDBAddr
 = 0xFF ;

827 if!
CPublicMhod
::
	`GDDBBusAndAddr

byDDBBusNo
 , 
wDDBAddr
 ) )

829  
FALSE
;

833 i
byBusNo
 =
byDDBBusNo


834 && 
wDevAddr
 =
wDDBAddr
)

836  
FALSE
;

839 
PDDBYK_DATA
 
pYkDa
 = 
w
 
DDBYK_DATA
 ;

840 
pYkDa
->
byDeBusNo
 = 
byBusNo
 ;

841 
pYkDa
->
wDeAddr
 = 
wDevAddr
 ;

842 
pYkDa
->
wP
 = wPnt ;

843 
pYkDa
->
byV
 = byVal ;

844 
pYkDa
->
byTy
 = 0 ;

846 
	`SDDBYkDl

pProc
 , 
byDDBBusNo
 , 
wDDBAddr
 , 
pYkDa
 , 
iFg
 ) ;

848 
	`tf
 ( "DDB YK\n" );

849  
TRUE
;

853  
FALSE
;

854 
	}
}

856 
	gCPublicMhod
::
	$SDDBYkDl
 ( cڡ 
CProc
 *
pProc
 , 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, *
pVoid
 , 
iFg
 )

858 if
pProc
 =
NULL
 || 
pVoid
 == NULL )

861 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

862 
PBUSMANAGER
 
pBus
;

864 i
byBusNo
 >
nCou
 ) )

868 
PBUSMSG
 
busMsg
 = 
w
 
BUSMSG
 ;

869 
busMsg
->
byMsgTy
 = 
YK_PROTO
 ;

871 
busMsg
->
DInfo
.
byBusNo
 = byBusNo ;

872 
busMsg
->
DInfo
.
wDevNo
 = 
wDevAddr
;

874 
busMsg
->
SrcInfo
.
byBusNo
 = 
pProc
->
m_byLeNo
 ;

875 
busMsg
->
SrcInfo
.
wDevNo
 = 
pProc
->
m_wDevAddr
;

877 
busMsg
->
dwDaTy
 = 
iFg
 ;

878 
busMsg
->
DaNum
 = 1;

880 
PDDBYK_DATA
 
pYk_Da
 = ( PDDBYK_DATA ) 
pVoid
 ;

881 
busMsg
->
pDa
 = 
pYk_Da
;

882 
busMsg
->
DaL
 =(
DDBYK_DATA
);

884 
LMSG
 
msg
 ;

885 
msg
.
pVoid
 = 
busMsg
 ;

888 
pBus
 = 
m_pBusMag
->
m_sbus
[
byBusNo
] ;

889 
pBus
->
	`SdMsg
&
msg
 );

890 
	}
}

901 
	gCPublicMhod
::
	$SDDBYkRDl
 ( cڡ 
CProc
 *
pProc
 , 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ,
iFg
 )

903 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

904 
PBUSMANAGER
 
pBus
;

906 i
byBusNo
 >
nCou
 ) )

910 
PBUSMSG
 
busMsg
 = 
w
 
BUSMSG
 ;

911 
busMsg
->
byMsgTy
 = 
YK_PROTO
 ;

913 
busMsg
->
DInfo
.
byBusNo
 = byBusNo ;

914 
busMsg
->
DInfo
.
wDevNo
 = 
wDevAddr
;

916 if!
CPublicMhod
::
	`GDDBDevBusAndAddr

busMsg
->
SrcInfo
.
byBusNo
 , busMsg->SrcInfo.
wDevNo
) )

918 
de
 
busMsg
;

924 
busMsg
->
dwDaTy
 = 
iFg
;

925 
busMsg
->
DaNum
 = 1;

927 
YK_DATA
 * 
pYk_Da
 = 
w
 YK_DATA ;

928 
pYk_Da
->
wP
 = wPnt;

929 
pYk_Da
->
byV
 = byVal;

930 
pYk_Da
->
byTy
 = 0;

931 
busMsg
->
pDa
 = 
pYk_Da
;

933 
busMsg
->
DaL
 =(
YK_DATA
);

934 
LMSG
 
msg
 ;

935 
msg
.
pVoid
 = 
busMsg
 ;

938 
pBus
 = 
m_pBusMag
->
m_sbus
[
byBusNo
] ;

939 
pBus
->
	`SdMsg
&
msg
 );

943 
	}
}

954 
	gCPublicMhod
::
	$SYkCl
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 )

956 
	`tf
 ( "YK_CANCEL\n" );

957 if!
	`ProssDDB

pProc
 ,
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_CANCEL
 ) )

959 
	`SYkDl
 ( 
pProc
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byV
, 
YK_CANCEL
 );

963 
	}
}

974 
	gCPublicMhod
::
	$SYkDl
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
, 
iFg
 )

976 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

977 
PBUSMANAGER
 
pBus
;

979 i
byBusNo
 >
nCou
 ) )

983 
PBUSMSG
 
busMsg
 = 
w
 
BUSMSG
 ;

984 
busMsg
->
byMsgTy
 = 
YK_PROTO
 ;

986 
busMsg
->
DInfo
.
byBusNo
 = byBusNo ;

987 
busMsg
->
DInfo
.
wDevNo
 = 
wDevAddr
;

989 
busMsg
->
SrcInfo
.
byBusNo
 = 
pProc
->
m_byLeNo
 ;

990 
busMsg
->
SrcInfo
.
wDevNo
 = 
pProc
->
m_wDevAddr
;

992 
busMsg
->
dwDaTy
 = 
iFg
;

993 
busMsg
->
DaNum
 = 1;

995 
YK_DATA
 * 
pYk_Da
 = 
w
 YK_DATA ;

996 
pYk_Da
->
wP
 = wPnt;

997 
pYk_Da
->
byV
 = byVal;

998 
pYk_Da
->
byTy
 = 0;

999 
busMsg
->
pDa
 = 
pYk_Da
;

1001 
busMsg
->
DaL
 =(
YK_DATA
);

1002 
LMSG
 
msg
 ;

1003 
msg
.
pVoid
 = 
busMsg
 ;

1006 
pBus
 = 
m_pBusMag
->
m_sbus
[
byBusNo
] ;

1007 
pBus
->
	`SdMsg
&
msg
 );

1010 
	}
}

1023 
	gCPublicMhod
::
	$SDzZeCl
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1025 
	`tf
 ( "DZZONE_CALL\n" );

1026 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_CALL
 );

1027 
	}
}

1038 
	gCPublicMhod
::
	$SDzZeClR
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1040 
	`tf
 ( "DZZONE_CALL_RTN DzZeN = %d\n", 
byDzZeNo
 );

1041 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_CALL
 );

1042 
	}
}

1053 
	gCPublicMhod
::
	$SDzZeSwchPt
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1055 
	`tf
 ( "DZZONE_SWITCH_PRESET DzZeN = %d\n", 
byDzZeNo
 );

1056 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_SWITCH_PRESET
 );

1057 
	}
}

1068 
	gCPublicMhod
::
	$SDzZeSwchPtR
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1070 
	`tf
 ( "DZZONE_SWITCH_PRESET_RTN DzZeN = %d\n", 
byDzZeNo
 );

1071 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_SWITCH_PRESET_RTN
 );

1072 
	}
}

1083 
	gCPublicMhod
::
	$SDzZeSwchEx
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1085 
	`tf
 ( "DZZONE_SWITCH_EXCT DzZeN = %d\n", 
byDzZeNo
 );

1086 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_SWITCH_EXCT
 );

1087 
	}
}

1098 
	gCPublicMhod
::
	$SDzZeSwchExR
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1100 
	`tf
 ( "DZZONE_SWITCH_EXCT_RTN DzZeN = %d\n", 
byDzZeNo
 );

1101 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_SWITCH_EXCT_RTN
 );

1102 
	}
}

1113 
	gCPublicMhod
::
	$SDzZeSwchCl
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1115 
	`tf
 ( "DZZONE_SWITCH_CANCEL DzZeN = %d\n", 
byDzZeNo
 );

1116 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_SWITCH_CANCEL
 );

1117 
	}
}

1128 
	gCPublicMhod
::
	$SDzZeSwchClR
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1130 
	`tf
 ( "DZZONE_SWITCH_CANCEL_RTN DzZeN = %d\n", 
byDzZeNo
 );

1131 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_SWITCH_CANCEL_RTN
 );

1132 
	}
}

1143 
	gCPublicMhod
::
	$SDzZeE
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 )

1145 
	`tf
 ( "DZZONE_ERROR DzZeN = %d\n", 
byDzZeNo
 );

1146 
	`SDzZeDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DZZONE_SWITCH_CANCEL_RTN
 );

1147 
	}
}

1158 
	gCPublicMhod
::
	$SDzCl
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1160 
	`tf
 ( "DZ_CALL DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1161 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_CALL
 );

1162 
	}
}

1173 
	gCPublicMhod
::
	$SDzClR
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1175 
	`tf
 ( "DZ_CALL_RTN DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1176 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_CALL_RTN
 );

1177 
	}
}

1188 
	gCPublicMhod
::
	$SDzWrePt
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1190 
	`tf
 ( "DZ_WRITE_PRESET DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1191 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_WRITE_PRESET
 );

1192 
	}
}

1203 
	gCPublicMhod
::
	$SDzWrePtR
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1205 
	`tf
 ( "DZ_WRITE_PRESET_RTN DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1206 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_WRITE_PRESET_RTN
 );

1207 
	}
}

1218 
	gCPublicMhod
::
	$SDzWreEx
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1220 
	`tf
 ( "DZ_WRITE_EXCT DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1221 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_WRITE_EXCT
 );

1222 
	}
}

1233 
	gCPublicMhod
::
	$SDzWreExR
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1235 
	`tf
 ( "DZ_WRITE_EXCT_RTN DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1236 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_WRITE_EXCT_RTN
 );

1237 
	}
}

1248 
	gCPublicMhod
::
	$SDzWreCl
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1250 
	`tf
 ( "DZ_WRITE_CANCEL DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1251 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_WRITE_CANCEL
 );

1252 
	}
}

1263 
	gCPublicMhod
::
	$SDzWreClR
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1265 
	`tf
 ( "DZ_WRITE_CANCEL_RTN DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1266 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_WRITE_CANCEL_RTN
 );

1267 
	}
}

1278 
	gCPublicMhod
::
	$SDzE
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
 )

1280 
	`tf
 ( "DZ_ERROR DzZeN = %d DzDaNum=%d\n", 
byDzZeNo
, 
iDzDaNum
 );

1281 
	`SDzDl

pProc
, 
byBusNo
, 
wDevAddr
, 
byDzZeNo
, 
DzDa
,
iDzDaNum
, 
DZ_ERROR
 );

1282 
	}
}

1293 
	gCPublicMhod
::
	$SDzDl
 ( cڡ 
CProc
 *
pProc
,

1294 
BYTE
 
byBusNo
,

1295 
WORD
 
wDevAddr
,

1296 
BYTE
 
byDzZeNo
,

1297 
DZ_DATA
 
DzDa
[],

1298 
iDzDaNum
,

1299 
iFg
 )

1301 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

1302 
PBUSMANAGER
 
pBus
;

1304 i
byBusNo
 >
nCou
 ) )

1310 
PBUSMSG
 
busMsg
 = 
w
 
BUSMSG
 ;

1311 
busMsg
->
byMsgTy
 = 
DZ_PROTO
 ;

1313 
busMsg
->
DInfo
.
byBusNo
 = byBusNo ;

1314 
busMsg
->
DInfo
.
wDevNo
 = 
wDevAddr
;

1316 
busMsg
->
SrcInfo
.
byBusNo
 = 
pProc
->
m_byLeNo
 ;

1317 
busMsg
->
SrcInfo
.
wDevNo
 = 
pProc
->
m_wDevAddr
;

1319 
busMsg
->
dwDaTy
 = 
iFg
 & 0x7F;

1320 
busMsg
->
DaNum
 = 
iDzDaNum
 + 1;

1322 
DZ_DATA
 * 
pDzDa
 = 
w
 DZ_DATA[
iDzDaNum
+1] ;

1323 
DZ_DATA
 * 
pDa
 = 
pDzDa
;

1324 
pDa
->
wP
 = 0xFFFF;

1325 
pDa
->
byV
[0] = 
byDzZeNo
;

1326 
pDa
->
byTy
 = 0;

1328 
pDa
 ++;

1329 
	`memy

pDa
, 
DzDa
, 
DZ_DATA
 ) * 
iDzDaNum
 );

1331 
busMsg
->
pDa
 = (*)
DzDa
;

1332 
busMsg
->
DaL
 =(
DZ_DATA
* (
iDzDaNum
 + 1);

1334 
LMSG
 
msg
 ;

1335 
msg
.
pVoid
 = 
busMsg
 ;

1338 
pBus
 = 
m_pBusMag
->
m_sbus
[
byBusNo
] ;

1339 
pBus
->
	`SdMsg
&
msg
 );

1340 
	}
}

1351 
	gCPublicMhod
::
	$SDzZeDl
 ( cڡ 
CProc
 *
pProc
,

1352 
BYTE
 
byBusNo
,

1353 
WORD
 
wDevAddr
,

1354 
BYTE
 
byDzZeNo
,

1355 
iFg
 )

1357 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

1358 
PBUSMANAGER
 
pBus
;

1360 i
byBusNo
 >
nCou
 ) )

1366 
PBUSMSG
 
busMsg
 = 
w
 
BUSMSG
 ;

1367 
busMsg
->
byMsgTy
 = 
DZ_PROTO
 ;

1369 
busMsg
->
DInfo
.
byBusNo
 = byBusNo ;

1370 
busMsg
->
DInfo
.
wDevNo
 = 
wDevAddr
;

1372 
busMsg
->
SrcInfo
.
byBusNo
 = 
pProc
->
m_byLeNo
 ;

1373 
busMsg
->
SrcInfo
.
wDevNo
 = 
pProc
->
m_wDevAddr
;

1375 
busMsg
->
dwDaTy
 = 
iFg
;

1376 
busMsg
->
DaNum
 = 1;

1378 
DZ_DATA
 * 
pDa
 = 
w
 DZ_DATA ;

1379 
pDa
->
wP
 = 0xFFFF;

1380 
pDa
->
byV
[0] = 
byDzZeNo
;

1381 
pDa
->
byTy
 = 0;

1383 
busMsg
->
pDa
 = (*)pData;

1384 
busMsg
->
DaL
 =(
DZ_DATA
);

1386 
LMSG
 
msg
 ;

1387 
msg
.
pVoid
 = 
busMsg
 ;

1390 
pBus
 = 
m_pBusMag
->
m_sbus
[
byBusNo
] ;

1391 
pBus
->
	`SdMsg
&
msg
 );

1392 
	}
}

1394 
	gCPublicMhod
::
	$CloSock

BYTE
 
byBusLe
 )

1396 if
m_pRtuObj
 )

1397 if
m_pRtuObj
->
m_byLeNo
 !
byBusLe
 )

1400 if
m_pPt
 )

1402 if
m_pPt
->
	`IsPtVid
() )

1403 
m_pPt
->
	`CloPt
() ;

1405 
	}
}

1416 
	gCPublicMhod
::
	$OnSock
 ( 
BYTE
 
byBusLe
 )

1418 
szBuf
[256];

1419 if
m_pRtuObj
 )

1420 if
m_pRtuObj
->
m_byLeNo
 !
byBusLe
 )

1425 if
m_pPt
 )

1427 
iRu
 = 
	`rcmp

m_pPt
->
	`CssName
() , "CTcpClientShort" ) ;

1428 if!
m_pPt
->
	`IsPtVid
(&& ( 
iRu
 == 0 ) )

1429 
m_pPt
->
	`OnPt
(
szBuf
) ;

1431 
	}
}

1433 
BOOL
 
	gCPublicMhod
::
	$IsPtVid
( )

1435  
m_pPt
->
	`IsPtVid
() ;

1436 
	}
}

1438 
BOOL
 
	gCPublicMhod
::
	$GDevCommS

BYTE
 
byLeNo
 , 
WORD
 
wDevNo
 )

1440 
WORD
 
wSlNo
 = 
	`GSlNo

byLeNo
, 
wDevNo
 );

1441  
	`GDevCommS

wSlNo
 );

1442 
	}
}

1444 
BOOL
 
	gCPublicMhod
::
	$GDevCommS

WORD
 
wSlNo
 )

1446 if
wSlNo
 == 0xFFFF )

1447  
COM_ABNORMAL
 ;

1452 
CProc
 *
pMoud
 = 
	`GProcMoud

wSlNo
 );

1453 if
NULL
 =
pMoud
 )

1455  
COM_ABNORMAL
 ;

1460 
BOOL
 
bStus
 = 
COM_DEV_ABNORMAL
 ;

1461 if
CPublicMhod
::
	`IsHaveDDB
() &&

1462 
CPublicMhod
::
	`GDDBSyncS
(=
STATUS_SLAVE
 ) &&

1463 
pMoud
->
m_ProTy
 =
PROTOCO_GATHER


1466 if!
CPublicMhod
::
	`GDDBSLkStus

wSlNo
 , 
bStus
 ) )

1467 
bStus
 = 
COM_DEV_ABNORMAL
 ;

1468  
bStus
 ;

1472  
pMoud
->
	`GDevCommS
( );

1475  
COM_ABNORMAL
;

1481 
	}
}

1483 
BOOL
 
	gCPublicMhod
::
	$GCommS

BYTE
 
byLeNo
 )

1485 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

1486 i
byLeNo
 >
nCou
 )

1487  
COM_ABNORMAL
 ;

1491 
PBUSMANAGER
 
pBus
 = 
m_pBusMag
->
m_sbus
[ 
byLeNo
 ] ;

1492 if
pBus
 =
NULL
 || NULL =pBus->
m_pMhod
)

1493  
COM_ABNORMAL
 ;

1495 
CProc
 * 
pProc
 = 
pBus
->
m_Proc
 ;

1496 if!
pProc
 )

1497  
COM_ABNORMAL
 ;

1499 
BOOL
 
bStus
 = 
COM_ABNORMAL
 ;

1500 if
CPublicMhod
::
	`IsHaveDDB
() &&

1501 
CPublicMhod
::
	`GDDBSyncS
(=
STATUS_SLAVE
 ) &&

1502 
pProc
->
m_ProTy
 =
PROTOCO_GATHER


1505 if!
CPublicMhod
::
	`GDDBBusLkStus

byLeNo
 , 
bStus
 ) )

1506 
bStus
 = 
COM_ABNORMAL
 ;

1508  
bStus
;

1512 if
pBus
->
m_pMhod
->
	`IsPtVid
() )

1513  
COM_NORMAL
 ;

1515  
COM_ABNORMAL
 ;

1519 
	}
}

1521 
BYTE
 
	gCPublicMhod
::
	$GToTBusNum
( )

1523  
m_pBusMag
->
m_sbus
.
	`size
( ) ;

1524 
	}
}

1526 
BYTE
 
	gCPublicMhod
::
	$GDevNum

BYTE
 
byBusNo
 )

1528 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

1529 i
byBusNo
 >
nCou
 )

1534 
PBUSMANAGER
 
pBus
 = 
m_pBusMag
->
m_sbus
[ 
byBusNo
 ] ;

1535 if
pBus
 =
NULL
 )

1538 if(
pBus
->
m_Proc
->
m_ProTy
 =
PROTOCO_TRANSPROT
)

1541  
pBus
->
m_Proc
->
m_modu
.
	`size
() ;

1542 
	}
}

1555 
WORD
 
	gCPublicMhod
::
	$GAddrByLeNoAndModuNo
 ( 
BYTE
 
byLeNo
, 
WORD
 
wModuNo
 )

1557 
PBUSMANAGER
 
pBus
 = 
NULL
;

1558 
CProc
 *
pPrObj
 = 
NULL
, *
pMoud
 = NULL;

1559 
nMoudSize
 = -1;

1562 if
m_pBusMag
 =
NULL
 )

1565 
size
 = 
m_pBusMag
->
m_sbus
.
	`size
() ;

1566 if
byLeNo
 >
size
 )

1569 
pBus
 = 
m_pBusMag
->
m_sbus
[
byLeNo
];

1570 if(
pBus
 =
NULL
)

1575 
pPrObj
 = 
pBus
->
m_Proc
;

1576 i
pPrObj
 =
NULL
 )

1582 
nMoudSize
 = 
pPrObj
->
m_modu
.
	`size
();

1583 if
wModuNo
 > 
nMoudSize
 )

1588 
pMoud
 = 
pPrObj
->
m_modu
[
wModuNo
];

1589 i
pMoud
 =
NULL
 )

1594  
pMoud
->
m_wDevAddr
;

1595 
	}
}

1598 
BYTE
 
	gCPublicMhod
::
	$GBusLeProcTy

BYTE
 
byLeNo
 )

1600 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

1601 i
byLeNo
 >
nCou
 )

1604 
PBUSMANAGER
 
pBus
 = 
m_pBusMag
->
m_sbus
[ 
byLeNo
 ] ;

1605 if
pBus
 =
NULL
 )

1608 if
pBus
->
byBusNo
 =0xFF || !pBus->
m_Proc
 )

1611  
pBus
->
m_Proc
->
m_ProTy
 ;

1612 
	}
}

1614 
BOOL
 
	gCPublicMhod
::
m_IshaveDDB
 = 
FALSE
 ;

1615 
BYTE
 
	gCPublicMhod
::
m_DDBS
 = 
STATUS_SLAVE
 ;

1616 
BYTE
 
	gCPublicMhod
::
m_DDBBusNo
 = 0xFF ;

1617 
WORD
 
	gCPublicMhod
::
m_DDBwAddr
 = 0xFFFF ;

1618 
BYTE
 
	gCPublicMhod
::
m_DDBDevBusNo
 = 0xFF ;

1619 
WORD
 
	gCPublicMhod
::
m_DDBDevwAddr
 = 0xFFFF ;

1621 
BOOL
 
	gCPublicMhod
::
	$IsHaveDDB
( )

1623  
CPublicMhod
::
m_IshaveDDB
 ;

1624 
	}
}

1626 
BYTE
 
	gCPublicMhod
::
	$GDDBSyncS
( )

1628  
CPublicMhod
::
m_DDBS
 ;

1629 
	}
}

1631 
	gCPublicMhod
::
	$SDDBProc
( )

1633 
CPublicMhod
::
m_IshaveDDB
 = 
TRUE
 ;

1634 
	}
}

1636 
	gCPublicMhod
::
	$SDDBSyncS

BYTE
 
bySyncS
 )

1638 
CPublicMhod
::
m_DDBS
 = 
bySyncS
 ;

1639 
	}
}

1641 
	gCPublicMhod
::
	$SDDBBusAndAddr

BYTE
 
byBusNo
 , 
WORD
 
wAddr
 )

1643 
CPublicMhod
::
m_DDBBusNo
 = 
byBusNo
 ;

1644 
CPublicMhod
::
m_DDBwAddr
 = 
wAddr
 ;

1645 
	}
}

1647 
BOOL
 
	gCPublicMhod
::
	$GDDBBusAndAddr

BYTE
 &
byBusNo
 , 
WORD
 &
wAddr
 )

1649 if!
	`IsHaveDDB
( ) )

1650  
FALSE
 ;

1652 
byBusNo
 = 
CPublicMhod
::
m_DDBBusNo
 ;

1653 
wAddr
 = 
CPublicMhod
::
m_DDBwAddr
 ;

1654  
TRUE
 ;

1655 
	}
}

1657 
	gCPublicMhod
::
	$SDDBDevBusAndAddr

BYTE
 
byBusNo
 , 
WORD
 
wAddr
 )

1659 
CPublicMhod
::
m_DDBDevBusNo
 = 
byBusNo
 ;

1660 
CPublicMhod
::
m_DDBDevwAddr
 = 
wAddr
 ;

1661 
	}
}

1663 
BOOL
 
	gCPublicMhod
::
	$GDDBDevBusAndAddr

BYTE
 &
byBusNo
 , 
WORD
 &
wAddr
 )

1665 if!
	`IsHaveDDB
( ) )

1666  
FALSE
 ;

1668 
byBusNo
 = 
CPublicMhod
::
m_DDBDevBusNo
 ;

1669 
wAddr
 = 
CPublicMhod
::
m_DDBDevwAddr
 ;

1670  
TRUE
 ;

1671 
	}
}

1683 
BOOL
 
	gCPublicMhod
::
	$IsLpYr
 ( 
UINT
 
uiYr
 ) const

1685 i((
uiYr
 % 100)==0)

1687 i((
uiYr
 % 400)==0)

1689  
TRUE
;

1694 i((
uiYr
 % 4)==0)

1696  
TRUE
;

1700  
FALSE
;

1701 
	}
}

1718 
BOOL
 
	gCPublicMhod
::
	$IsSTime
 ( 
UINT
 
uiMSec
,

1719 
UINT
 
uiSec
,

1720 
UINT
 
uiM
,

1721 
UINT
 
uiHour
,

1722 
UINT
 
uiDay
,

1723 
UINT
 
uiMth
,

1724 
UINT
 
uiYr
) const

1726 if
uiMSec
 > 999

1727 || 
uiSec
 > 59

1728 || 
uiM
 > 59

1729 || 
uiHour
 > 23

1730 || 
uiMth
 > 12)

1732  
FALSE
;

1735 if
uiYr
 < 1900 && uiYear > 3000 )

1737  
FALSE
;

1740  
uiMth
 )

1749 if
uiDay
 > 31 )

1751  
FALSE
;

1759 if
uiDay
 > 30 )

1761  
FALSE
;

1766 if
	`IsLpYr

uiYr
 ) )

1768 if
uiDay
 > 29 )

1770  
FALSE
;

1775 if
uiDay
 > 28 )

1777  
FALSE
;

1786  
TRUE
;

1787 
	}
}

1789 
WORD
 
	gCPublicMhod
::
	$GGhDevCou
( )

1791  
m_wGhDevCou
 ;

1792 
	}
}

1794 
BOOL
 
	gCPublicMhod
::
	$SGhDevCou

WORD
 
wCou
 )

1796 
m_wGhDevCou
 = 
wCou
 ;

1797  
TRUE
 ;

1798 
	}
}

1800 
BYTE
 
	gCPublicMhod
::
	$GSgGhDevCou

BYTE
 
byBusNo
 , BYTE 
byDevIndex
 , 
WORD
 * 
pAddr
 )

1802 
nCou
 = 
m_pBusMag
->
m_sbus
.
	`size
();

1803 i
byBusNo
 >
nCou
 )

1808 
PBUSMANAGER
 
pBus
 = 
m_pBusMag
->
m_sbus
[ 
byBusNo
 ] ;

1809 if
pBus
 =
NULL
 )

1812 if
pBus
->
m_Proc
 =
NULL
 || !pBus->m_Proc->
m_modu
.
	`size
()

1813 || 
pBus
->
m_Proc
->
m_ProTy
 !
PROTOCO_GATHER
 )

1816 
size
 = 
pBus
->
m_Proc
->
m_modu
.
	`size
() ;

1817 if
pAddr
 =
NULL
 )

1818  
size
 ;

1821 if
byDevIndex
 >
size
 )

1823 *
pAddr
 = 0 ;

1827 
CProc
 * 
pProc
 = 
pBus
->
m_Proc
->
m_modu
[ 
byDevIndex
 ] ;

1828 *
pAddr
 = 
pProc
->
m_wDevAddr
 ;

1831 
	}
}

1833 
PBUSMANAGER
 
	gCPublicMhod
::
	$GBus

BYTE
 
byIndex
 )

1835 if
byIndex
 > 
MAX_LINE
 )

1836  
NULL
 ;

1838 
size
 = 
m_pBusMag
->
m_sbus
.
	`size
() ;

1839 if
byIndex
 >
size
 )

1840  
NULL
 ;

1842 
PBUSMANAGER
 
pBusMag
 = 
m_pBusMag
->
m_sbus
[ 
byIndex
 ] ;

1843  
pBusMag
 ;

1844 
	}
}

1854 
BOOL
 
	gCPublicMhod
::
	$SDDBBusLkStus
(
BYTE
 
byBusNo
, 
BOOL
 
bStus
)

1856 if
MAX_LINE
 <
byBusNo
 )

1858 
	`tf
("SetDDBBusLinkStatus byBusNo:%d is biggerhan %d\n",

1859 
byBusNo
,
MAX_LINE
);

1860  
FALSE
;

1863 
CPublicMhod
::
m_bDDBBusLkStus
[ 
byBusNo
 ] = 
bStus
;

1865  
TRUE
;

1866 
	}
}

1876 
BOOL
 
	gCPublicMhod
::
	$GDDBBusLkStus

BYTE
 
byBusNo
, 
BOOL
 &
bStus
 )

1878 if
MAX_LINE
 <
byBusNo
 )

1880 
	`tf
("GetDDBBusLinkStatus byBusNo:%d is biggerhan %d\n",

1881 
byBusNo
,
MAX_LINE
);

1882  
FALSE
;

1885 
bStus
 = 
CPublicMhod
::
m_bDDBBusLkStus
[ 
byBusNo
 ];

1887  
TRUE
;

1888 
	}
}

1898 
BOOL
 
	gCPublicMhod
::
	$SDDBSLkStus

WORD
 
wSlNo
, 
BOOL
 
bStus
 )

1900 i(
MAX_STN_SUM
 <
wSlNo
 )

1902 
	`tf
("SetDDBStnLinkStatus wSerialNo:%d is biggerhan %d\n",

1903 
wSlNo
, 
MAX_STN_SUM
);

1904  
FALSE
;

1907 
CPublicMhod
::
m_bDDBSLkStus
[ 
wSlNo
 ] = 
bStus
;

1909  
TRUE
;

1911 
	}
}

1921 
BOOL
 
	gCPublicMhod
::
	$GDDBSLkStus

WORD
 
wSlNo
, 
BOOL
 &
bStus
 )

1923 i(
MAX_STN_SUM
 <
wSlNo
 )

1925 
	`tf
("GetDDBStnLinkStatus wSerialNo:%d is biggerhan %d\n",

1926 
wSlNo
, 
MAX_STN_SUM
);

1927  
FALSE
;

1930 
bStus
 = 
CPublicMhod
::
m_bDDBSLkStus
[ 
wSlNo
 ];

1932  
TRUE
;

1933 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/CPublicMethod.h

19 #ide 
_PUBLICMETHOD_H__


20 
	#_PUBLICMETHOD_H__


	)

23 
	~<dio.h
>

24 
	~<dlib.h
>

25 
	~<time.h
>

26 
	~<sys/time.h
>

28 
	~"../libdb/rdbObj.h
"

29 
	~"../she/CMhod.h
"

30 
	~"../she/Rtu.h
"

31 
	~"BusMg.h
"

35 
	#STATUS_SLAVE
 1

	)

36 
	#STATUS_MASTER
 0

	)

38 as
	cCPublicMhod
 : 
public
 
CMhod


40 
public
:

43 
CPublicMhod
 ();

44 
	mvtu
 ~
CPublicMhod
 ();

52 
vtu
 
BOOL
 
GBusLeAndAddr

WORD
 
wSlNo
, 
BYTE
 &
byBusNo
, WORD &
wDevAddr
 );

54 
vtu
 
GSlNo
 ( 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
 );

56 
vtu
 
YcUpde
 ( 
WORD
 
SlNo
, 
YC_DATA
 
YcDa
[], 
UINT
 
YcNum
 );

58 
vtu
 
SYcDa
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
fV
 );

60 
vtu
 
SYcDaWhTime
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
fV
, 
TIMEDATA
 *
pTime
 );

62 
vtu
 
RdAYcDa
 ( *
pDa
 );

64 
vtu
 
DWORD
 
RdYcDa
 ( 
WORD
 
wSlNO
, WORD 
wP
 );

66 
vtu
 
YxUpde
 ( 
WORD
 
SlNo
, 
YX_DATA
 
YxDa
[], 
UINT
 
YxNum
);

68 
vtu
 
SYxDa
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
BYTE
 
byV
 );

70 
vtu
 
SYxDaWhTime
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
BYTE
 
byV
, 
TIMEDATA
 *
pTime
 );

72 
vtu
 
RdAYxDa
 ( 
BYTE
 *
pDa
 ) ;

74 
vtu
 
RdYxDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, WORD *
pwV
);

76 
vtu
 
YmUpDe
 ( 
WORD
 
SlNo
, 
YM_DATA
 
YmDa
[], 
UINT
 
YmNum
 );

78 
vtu
 
SYmDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, 
fV
 );

80 
vtu
 
BOOL
 
GYmDa

WORD
 
wSlNo
, WORD 
wP
, 
DWORD
 &
dwV
 );

83 
vtu
 
RdAYmDa
 ( 
DWORD
 *
pdwDa
 );

85 
vtu
 
RdYmDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, 
DWORD
 *
pdwV
 );

88 
vtu
 
SYkSR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 );

90 
vtu
 
SYkExeR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 );

92 
vtu
 
SYkClR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 );

94 
vtu
 
SYkS
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 );

96 
vtu
 
SYkExe
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 );

98 
vtu
 
SYkCl
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 );

101 
vtu
 
SDzZeCl
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 );

103 
vtu
 
SDzZeClR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 );

105 
vtu
 
SDzZeSwchPt
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 );

107 
vtu
 
SDzZeSwchPtR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 );

109 
vtu
 
SDzZeSwchEx
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 );

111 
vtu
 
SDzZeSwchExR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 );

113 
vtu
 
SDzZeSwchCl
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 );

115 
vtu
 
SDzZeSwchClR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 );

117 
vtu
 
SDzZeE
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
 );

119 
vtu
 
SDzCl
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

121 
vtu
 
SDzClR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

123 
vtu
 
SDzWrePt
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

125 
vtu
 
SDzWrePtR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

127 
vtu
 
SDzWreEx
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

129 
vtu
 
SDzWreExR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

131 
vtu
 
SDzWreCl
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

133 
vtu
 
SDzWreClR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

135 
vtu
 
SDzE
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
);

137 
vtu
 
BYTE
 
GBusLeProcTy
BYTE 
byLeNo
 );

140 
vtu
 
CloSock

BYTE
 
byBusLe
 ) ;

142 
vtu
 
OnSock
 ( 
BYTE
 
byBusLe
 );

143 
vtu
 
BOOL
 
IsPtVid
( ) ;

144 
vtu
 
BOOL
 
	$IsSTime
 ( 
UINT
 
uiMSec
, UINT 
uiSec
, UINT 
uiM
, UINT 
uiHour
, UINT 
uiDay
, UINT 
uiMth
, UINT 
uiYr
) const;

147 
vtu
 
BOOL
 
	`GDevCommS

BYTE
 
byLeNo
 , 
WORD
 
wDevNo
 ) ;

148 
vtu
 
BOOL
 
	`GDevCommS

WORD
 
wSlNo
 ) ;

150 
vtu
 
BOOL
 
	`GCommS

BYTE
 
byLeNo
 ) ;

153 
vtu
 
BYTE
 
	`GToTBusNum
( ) ;

155 
vtu
 
BYTE
 
	`GDevNum
BYTE 
byBusNo
 );

157 
vtu
 
WORD
 
	`GAddrByLeNoAndModuNo
 ( 
BYTE
 
byLeNo
, WORD 
wModuNo
 );

160 
WORD
 
	`GGhDevCou
( ) ;

162 
BOOL
 
	`SGhDevCou

WORD
 
wCou
 ) ;

164 
BYTE
 
	`GSgGhDevCou
BYTE 
byBusNo
 , BYTE 
byDevIndex
 = 0 , 
WORD
 * 
pAddr
 = 
NULL
 ) ;

166 
vtu
 
PBUSMANAGER
 
	`GBus

BYTE
 
byIndex
 ) ;

167 
ive
:

169 
	`SYkDl
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
, 
iFg
 );

171 
	`SDzDl
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
, 
iFg
 );

173 
	`SDzZeDl
 ( cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
, 
iFg
 );

175 
BOOL
 
	$IsLpYr

UINT
 
uiYr
 ) const;

176 
BOOL
 
	`ProssDDB
cڡ 
CProc
 *
pProc
 , 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 , 
iFg
 );

177 
	`SDDBYkDl
 ( cڡ 
CProc
 *
pProc
 , 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, *
pVoid
 , 
iFg
 );

179 
public
:

180 
	`SDDBProc
( ) ;

181 
	`SDDBSyncS

BYTE
 
bySyncS
 ) ;

182 
BOOL
 
	`IsHaveDDB
( ) ;

183 
BYTE
 
	`GDDBSyncS
( ) ;

184 
	`SDDBBusAndAddr

BYTE
 
byBusNo
 , 
WORD
 
wAddr
 ) ;

185 
BOOL
 
	`GDDBBusAndAddr

BYTE
 &
byBusNo
 , 
WORD
 &
wAddr
 ) ;

186 
	`SDDBDevBusAndAddr

BYTE
 
byBusNo
 , 
WORD
 
wAddr
 ) ;

187 
BOOL
 
	`GDDBDevBusAndAddr

BYTE
 &
byBusNo
 , 
WORD
 &
wAddr
 ) ;

190 
BOOL
 
	`SDDBBusLkStus

BYTE
 
byBusNo
, BOOL 
bStus
);

192 
BOOL
 
	`GDDBBusLkStus

BYTE
 
byBusNo
, BOOL &
bStus
);

194 
BOOL
 
	`SDDBSLkStus

WORD
 
wSlNo
 , BOOL 
bStus
);

196 
BOOL
 
	`GDDBSLkStus

WORD
 
wSlNo
, BOOL &
bStus
);

198 
ive
:

199 
BOOL
 
m_IshaveDDB
 ;

200 
BYTE
 
m_DDBS
 ;

201 
BYTE
 
m_DDBBusNo
 ;

202 
WORD
 
m_DDBwAddr
 ;

203 
BYTE
 
m_DDBDevBusNo
 ;

204 
WORD
 
m_DDBDevwAddr
 ;

206 
BOOL
 
m_bDDBBusLkStus
[ 
MAX_LINE
 ];

207 
BOOL
 
m_bDDBSLkStus
[ 
MAX_STN_SUM
 ];

208 
WORD
 
m_wGhDevCou
 ;

210 
CProc
 * 
	`GProcMoud
 ( 
WORD
 
wSlNo
 );

211 
	`SDDBYkRDl
 ( cڡ 
CProc
 *
pProc
 , 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ,
iFg
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/GetProtocol.cpp

5 
	~"GProc.h
"

6 
	~"globDef.h
"

7 
	~<dlf.h
>

8 
	~<f.h
>

14 
	gCGProc
::
	$CGProc
()

17 
	`ModifyPh
( ) ;

18 
	}
}

20 
	gCGProc
::~
	$CGProc
()

22 
	`RHd
( ) ;

23 
	}
}

25 
	gCGProc
::
	$AddHd
* 
pHd
 )

27 if
pHd
 =
NULL
 )

30 
m_dhd
.
	`push_back

pHd
 ) ;

31 
	}
}

33 
	gCGProc
::
	$RHd
( )

35 
size
 = 
m_dhd
.
	`size
() ;

36  
i
 = 0 ; i < 
size
 ; i++ )

38 * 
hd
 = 
m_dhd
[ 
i
 ] ;

39 if
hd
 )

40 
	`dlo
(
hd
);

43 
	`tf
( "Close All Dll \n " );

44 
m_dhd
.
	`r
() ;

45 
	}
}

47 
CProc
 * 
	gCGProc
::
	$GProObj
* 
pDPh
, 
CMhod
 * 
pMhod
 )

49 *
hd
=
NULL
;

50 *
r
;

52 
hd
 = 
	`OnD

pDPh
 ) ;

53 if
hd
 =
NULL
 )

55 
	`tf
"OD = %Faed ! \" , 
pDPh
 );

56  
NULL
 ;

59 
	`tf
"OD = %Sucs! \" , 
pDPh
) ;

61 
CProc
 * ( * 
	tICe
 )
	tCMhod
 * ) ;

63 
ICe
 
pObj
 = 
NULL
 ;

64 
pObj
 = ( 
ICe
 )
	`dlsym
(
hd
, "CreateProtocol");

65 if
pObj
 =
NULL
 )

67 
	`tf
( "Open Dll Failed ! \n " );

70 i((
r
 = 
	`d˼
()!
NULL
) {

71 
	`tf
 ( "%s\n", 
r
);

72 
	`dlo

hd
 ) ;

73  
NULL
;

76 
CProc
 * 
pProc
 = 
NULL
 ;

77 
pProc
 = 
	`pObj

pMhod
 ) ;

78 if
pProc
 =
NULL
 )

80 
	`tf
 ( "Get ProtoObj Failed ! \n " );

81 
	`dlo

hd
 ) ;

82  
NULL
;

85 
	`AddHd

hd
 ) ;

87  
pProc
 ;

88 
	}
}

90 
BOOL
 
	gCGProc
::
	$ModifyPh
( )

92 
BOOL
 
bFg
 = 
FALSE
 ;

93 
fd
 = 
	`ݒ

SYSTEM_PATH
 ,
O_RDONLY
);

94 if
fd
 < 0)

96 
	`tf
("CuExcuPh = %C'O\n", 
SYSTEM_PATH
 );

97 
	`
("open");

99 if
	`fchd
(
fd
) == 0 )

101 
	`syem
("pwd");

102 
	`tf
("CuExcuPh = %OSucs\n", 
SYSTEM_PATH
 );

103 
bFg
 = 
TRUE
 ;

105 
	`o
(
fd
);

107  
bFg
 ;

108 
	}
}

110 * 
	gCGProc
::
	$OnD
* 
pDPh
 )

112 *
hd
=
NULL
;

113 *
r
;

114 if
pDPh
 =
NULL
 )

115  
NULL
 ;

118 
hd
 = 
	`dlݒ
 ( 
pDPh
, 
RTLD_LAZY
 | 
RTLD_GLOBAL
);

120 i((
r
 = 
	`d˼
()!
NULL
)

122 
	`tf
 ( "%s\n", 
r
);

123  
NULL
;

126  
hd
 ;

127 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/GetProtocol.h

5 #i!
defed
(
AFX_GETPROTOCOL_H__FCF96365_0A8A_48D7_87A9_29895F3546B7__INCLUDED_
)

6 
	#AFX_GETPROTOCOL_H__FCF96365_0A8A_48D7_87A9_29895F3546B7__INCLUDED_


	)

8 #i
_MSC_VER
 > 1000

9 #agm



12 
	~"../she/CProc.h
"

13 
	~<ve
>

14 
	~"../she/CMhod.h
"

17 as
	cCGProc


19 
	mpublic
:

21 
CGProc
();

23 
	mvtu
 ~
CGProc
();

25 
CProc
 * 
GProObj
* 
pDPh
, 
CMhod
 *
pMhod
 ) ;

27 
	meed
:

29 
d
::
ve
< * > 
m_dhd
 ;

31 * 
OnD
* 
pDPh
 ) ;

33 
AddHd
* 
pHd
 ) ;

35 
RHd
( ) ;

36 
BOOL
 
ModifyPh
( ) ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/cmsg.cpp

1 
	~<dio.h
>

2 
	~<sys/msg.h
>

3 
	~<unid.h
>

4 
	~"cmsg.h
"

6 
	gCMsg
::
m_MsgID
 = -1 ;

8 
	gCMsg
::
	$CMsg
()

10 
m_MsgKey
 = 2014 ;

11 
m_MsgTy
 = -1 ;

13 
m_msgSize
 = ( * ) + ( ) ;

14 
	}
}

16 
	gCMsg
::~
	$CMsg
()

22 if
m_MsgID
 != -1 )

37 if
	`CloMsgQueue
() )

38 
	`tf
( "\nCMsg Destructor OK.\n" ) ;

41 
	}
}

43 
	gCMsg
::
	$CeMsgQueue

msgChl
 )

45 if
msgChl
 <= 0 )

48 
m_MsgTy
 = 
msgChl
 ;

50 if
m_MsgID
 != -1 )

51  
m_MsgID
 ;

53 
msgID
 = -1 ;

54 
msgID
 = 
	`msgg

m_MsgKey
, 
IPC_CREAT
|0666);

55 if
msgID
 != -1 )

56 
m_MsgID
 = 
msgID
 ;

58  
msgID
 ;

59 
	}
}

61 
bo
 
	gCMsg
::
	$IsMsgQueue
( )

63 if
m_MsgID
 =-1 || 
m_MsgTy
 == -1 )

64  
l
 ;

66  
ue
 ;

67 
	}
}

69 
bo
 
	gCMsg
::
	$CloMsgQueue
()

71 
Ru
 = 
	`msgl

m_MsgID
, 
IPC_RMID
, 
NULL
 ) ;

72 if
Ru
 == 0 )

74 
m_MsgID
 = -1;

75 
	`tf
( "\nClose Msg Queue Success OK. \n" );

76  
ue
 ;

79  
l
 ;

80 
	}
}

82 
bo
 
	gCMsg
::
	$SdMsg
* 
pVoid
 )

84 if
pVoid
 =
NULL
 || 
m_MsgID
 =-1 || !
	`IsMsgQueue
() )

85  
l
 ;

89 
PLMSG
 
pMsg
 = ( PLMSG )
pVoid
 ;

90 
pMsg
->
msgTy
 = 
m_MsgTy
 ;

92 
iRu
 = 
	`msgd

m_MsgID
, 
pVoid
 , 
m_msgSize
 , 
IPC_NOWAIT
 ) ;

93 if
iRu
 == 0 )

94  
ue
 ;

96  
l
 ;

97 
	}
}

99 
bo
 
	gCMsg
::
	$RecvMsg
* 
pVoid
 )

101 if
pVoid
 =
NULL
 || 
m_MsgID
 =-1 || !
	`IsMsgQueue
() )

102  
l
 ;

104 
cv_by
 = 
	`msgrcv
(
m_MsgID
, 
pVoid
, 
m_msgSize
, 
m_MsgTy
 , 
IPC_NOWAIT
 );

105 if
cv_by
 <= 0)

106  
l
;

108  
ue
;

109 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/cmsg.h

1 #ide
_CMSG_H__


2 
	#_CMSG_H__


	)

4 
	~"../she/rdbFun.h
"

5 #agm
ck
( 1 )

6 
	sgMsg


8 
gMsg
( )

10 
	mmsgTy
 = 0 ;

11 
	mpVoid
 = 
NULL
 ;

12 
	mmsgSize
 = ( * ) + ( ) ;

14 ~
gMsg
()

18 
	mmsgTy
 ;

19 * 
	mpVoid
 ;

20 
	mmsgSize
 ;

21 }
	tLMSG
, *
	tPLMSG
 ;

23 as
	cCMsg


25 
	mpublic
:

26 
CMsg
() ;

27 ~
CMsg
() ;

29 
	meed
:

30 
m_MsgID
 ;

31 
	mm_MsgKey
 ;

32 
	mm_msgSize
 ;

33 
	mpublic
:

34 
CeMsgQueue

msgChl
 );

35 
bo
 
SdMsg
* 
pVoid
 ) ;

36 
bo
 
RecvMsg
* 
pVoid
 ) ;

37 
bo
 
CloMsgQueue
() ;

38 
bo
 
IsMsgQueue
( );

39 
	mm_MsgTy
 ;

41 #agm
ck
( )

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/globleDef.h

1 #ide 
_GLOBLEDEF_H


2 
	#_GLOBLEDEF_H


	)

5 
	#R


	)

7 #ifde
Debug


8 
	#SYSTEM_PATH
 "/m"

	)

10 
	#SYSTEM_PATH
 "/mynd"

	)

14 
	#MODBUS_RTU
 1

	)

15 
	#IEC104_SLAVE
 2

	)

16 
	#IEC103_RTU
 3

	)

17 
	#DDB_RTU


	)

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/main.cpp

1 
	~"ma.h
"

2 
	~"BusMg.h
"

3 
	~"CPublicMhod.h
"

4 
	~"../she/glob.h
"

7 
	#GPIO_DEV_NAME
 "/dev/gpio_drv"

	)

8 
	#CMD_SET_UT1_RS485
 11

	)

9 
	#CMD_SET_UT1_NON_RS485
 12

	)

10 
	#CMD_SET_UT2_RS485
 13

	)

11 
	#CMD_SET_UT2_NON_RS485
 14

	)

12 
	#CMD_SET_UT3_RS485
 15

	)

13 
	#CMD_SET_UT3_NON_RS485
 16

	)

14 
	#CMD_SET_UT4_RS485
 17

	)

15 
	#CMD_SET_UT4_NON_RS485
 18

	)

16 
	#CMD_GET_UT_STATUS
 19

	)

18 
	#CMD_SET_LEDRUN_ON
 21

19 
	#CMD_SET_LEDRUN_OFF
 22

20 
	#CMD_SET_LEDALARM_ON
 23

21 
	#CMD_SET_LEDALARM_OFF
 24

22 
	#CMD_SET_LEDRES3_ON
 25

23 
	#CMD_SET_LEDRES3_OFF
 26

24 

	)

25 
	#CMD_GET_NET_MODE
 31

	)

27 "C" 
GCutTime

REALTIME
 *
pRlTime
 ) ;

30 
CBusMg
 
	gm_busMag
 ;

33 
	#LED_BEGIN
 1

	)

34 
	#LED_END
 2

	)

36 
	$SSlMode
()

38 
gpiofd
;

40 
gpiofd
 = 
	`ݒ
(
GPIO_DEV_NAME
, 
O_RDWR
);

41 if
gpiofd
 < 0 ) ;

42 
	`iol
(
gpiofd
, 
CMD_SET_UT1_RS485
, 0);

43 
	`iol
(
gpiofd
, 
CMD_SET_UT2_RS485
, 0);

44 
	`iol
(
gpiofd
, 
CMD_SET_UT3_RS485
, 0);

45 
	`iol
(
gpiofd
, 
CMD_SET_UT4_RS485
, 0);

46 
	`o
(
gpiofd
);

47 
	}
}

49 
BOOL
 
	gg_bDebugA
 = 
TRUE
;

50 
BOOL
 
	gg_bARun
 = 
TRUE
;

53 
	#THREAD_EXIT_TIME
 50

	)

55 
	#MSGSET_OPTION
 ((1<<
MSGSET_CTRL_DATA
| (1<<
MSGSET_DEVS_COMM
))

	)

56 
	gg_nBusKeyID
 = -1;

58 
	gg_szAName
[24] = {"modbus"};

59 
CRTDBObj
 *
g_pRTDBObj
;

62 #ifdef 
__lulus


66 
ady_rug
(cڡ *
fame
);

69 
rim
(*
s
);

72 
rim
(*
s
);

83 
	#MAX_DEBUG_LEN
 1024

	)

84 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
)

86 
nCou
 = 
m_busMag
.
m_sbus
.
size
();

87 
PBUSMANAGER
 
pBus
;

88 
szBuff
[ 3 * 
MAX_DEBUG_LEN
 + 100 ];

89 
i
, 
k
=0;

92 i
n
 > 
MAX_DEBUG_LEN
 )

93 
n
 = 
MAX_DEBUG_LEN
;

94 i(
nCou
 <= 0)

99  
i
 = 0; i <
nCou
; i++)

101 
pBus
 = 
m_busMag
.
m_sbus
[ 
i
 ] ;

102 if!
pBus
->
m_Proc
 || !pBus->
m_pMhod
 || !pBus->
m_Pt
 )

105 i(
byBusNo
 =
pBus
->byBusNo)

110 if
i
 >
nCou
 )

112 
tf
 ( "OutBusDebug fd bue=%d\n", 
byBusNo
 );

115 if(
ag
 == 0x01)

116 
k
 = 
rtf
(
szBuff
, "RX:(BUS%d=%d)", 
byBusNo
 + 1, 
n
);

117 if(
ag
 == 0)

118 
k
 = 
rtf
(
szBuff
, "TX:(BUS%d=%d)", 
byBusNo
 + 1, 
n
);

120 
k
 = 
rtf
(
szBuff
, " ");

121 if(
ag
 & 0x2) != 0 )

123 
memy
(&
szBuff
[
k
], 
buf
, 
n
);

124 
k
 +
n
;

128  
i
=0; i<
n
; i++ )

130 
k
 +
rtf
(&
szBuff
[k], "%02X ", 
buf
[
i
]);

133 
k
 +
rtf
(&
szBuff
[k], "\n");

135 
pBus
->
m_Debug
.
SdDebugMsg
((
BYTE
 *)
szBuff
, 
k
);

137 
OutPromText
(*
szText
);

143 
LogPromText
(cڡ *
fmt
, ...);

152 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
);

178 
SignHdr
(
signum
, 
sigfo_t
 *
pInfo
, *
pRerved
)

180 
g_bARun
 = 
FALSE
;

183 #ifdef 
__lulus


262 
	#CONFIG_TYPE_PARAM
 0x0001

	)

263 
	#CONFIG_APP_ALIAS
 0x1001

	)

264 
	#CONFIG_SCAN_CYCLE
 0x1002

	)

265 
	#CONFIG_DEBUG_MODE
 0x1003

	)

266 
	#CONFIG_PORT_PARAM
 0x2001

	)

267 
	#CONFIG_UNIT_PARAM
 0x3001

	)

269 
	$PCfigIm
(*
rIm
, 
WORD
 *
pwNum
)

271 
rTy
[32];

272 
i
, 
nL
;

274 if
	`rr
(
rIm
, "s" 
CONFIG_APP_ALIAS
;

275 if
	`rr
(
rIm
, "debug" 
CONFIG_DEBUG_MODE
;

276 if
	`rr
(
rIm
, "cye" 
CONFIG_SCAN_CYCLE
;

278 
i
 = 0;

279 
nL
 = 
	`
(
rIm
);

280  !
	`isdig
(
rIm
[
i
]&& i<()(
rTy
) )

282 
rTy
[
i
] = 
	`tou
(
rIm
[i]);

283 if++
i
 >
nL
 ) ;

285 
rTy
[
i
] = '\0';

286 if
i
 >
nL
 ) *
pwNum
 = 0;

287 *
pwNum
 = (
WORD
)
	`oi
(&
rIm
[
i
]);

288 if
	`rcmp
(
rTy
, "TYPE") == 0 )

289  
CONFIG_PORT_PARAM
;

290 if
	`rcmp
(
rTy
, "PORT") == 0 )

291  
CONFIG_PORT_PARAM
;

292 if
	`rcmp
(
rTy
, "UNIT") == 0 )

293  
CONFIG_UNIT_PARAM
;

295 
	}
}

440 (*
	tLPSIGPROC
)(, 
	tsigfo_t
*, *);

442 
	$SiglHook
(
iSigNo
, 
LPSIGPROC
 
func
)

444 
sigai
 
a
, 

;

446 
a
.
_sigai
 = 
func
;

447 
	`sigemyt
(&
a
.
_mask
);

448 
a
.
_ags
 = 
SA_SIGINFO
|
SA_RESTART
;

450 if(
	`sigai
(
iSigNo
, &
a
, &

) < 0)

453 
	}
}

462 
	#PRINT_MINI_PORTNUM
 20000

	)

463 
	#PRINT_MAX_PORTNUM
 60000

	)

464 
BOOL
 
	$RdPrtPa
 (
CProfe
 *
pProfe
, *
pNCd
, *
pRemeIp
, 
DWORD
 &
dwPtNum
 )

466 
sSe
[] = "PRINT_PROTOCOL_MSG";

467 
sNCd
[] = "NetCard" ;

468 
sRemeIp
[] = "RemoteIP" ;

469 
sPt
[] = "StartPortNum" ;

471 if
pProfe
 =
NULL
 )

473 
	`tf
 ( "ReadPrintPararror\n" );

474  
FALSE
;

478 
pProfe
->
	`GProfeSg

sSe
 , 
sNCd
 , (*)"NULL" , 
pNCd
 , 5 ) ;

479 if
	`cmp

pNCd
, "NULL", 4 ) == 0 )

481 
	`tf
 ( "ReadPrintPara NetCardrror!!! default setth0\n" );

482 
	`ry
(
pNCd
, "eth0");

486 
pProfe
->
	`GProfeSg

sSe
 , 
sRemeIp
 , (*)"NULL" , 
pRemeIp
 , 16 ) ;

487 if
	`cmp

pRemeIp
, "NULL", 4 ) == 0 )

489 
	`tf
 ( "ReadPrintPara RemoteIprr default set 192.168.1.128\n" );

490 
	`ry
(
pRemeIp
, "192.168.1.128");

493 
dwPtNum
 = (
DWORD

pProfe
->
	`GProfeI

sSe
, 
sPt
, 0 );

494 if
dwPtNum
 < 
PRINT_MINI_PORTNUM
 || dwPtNum > 
PRINT_MAX_PORTNUM
)

496 
	`tf
 ( "StartPortNumrr !!! StartPortNum=%ld(>%d or <%d) default set %d\n",

497 
dwPtNum
, 
PRINT_MAX_PORTNUM
, 
PRINT_MINI_PORTNUM
, PRINT_MINI_PORTNUM );

498 
dwPtNum
 = 
PRINT_MINI_PORTNUM
;

501 
	`tf
 ( "RdPrtPNCd=%RemeIp=%SPtNum=%ld\n", 
pNCd
, 
pRemeIp
, 
dwPtNum
 );

503  
TRUE
;

504 
	}
}

506 
BOOL
 
	$RdPtPa

INITBUS
 & 
bus
 )

508 
sBusLe
[ ] = 
BUS_PATH
 ;

509 
CProfe
 
	`Profe

sBusLe
 ) ;

510 
BYTE
 
byLeNum
 = 0 ;

512 
NCd
[5];

513 
RemeIp
[16];

514 
DWORD
 
SPtNum
;

517 if!
	`SLolNPa

Profe
 ) )

518  
FALSE
 ;

520 i!
	`RdPrtPa
(&
Profe
, 
NCd
, 
RemeIp
, 
SPtNum
) )

522  
FALSE
;

525 
byLeNum
 = ( 
BYTE
 )
Profe
.
	`GProfeI
( (*)"LINE-NUM" , (*)"NUM" , 0 );

526 if
byLeNum
 == 0 || byLineNum > 22 )

528 
	`tf
"LNumbxed MaxL: CuLNumb = %d \" , 
byLeNum
 ) ;

529  
FALSE
 ;

532  
BYTE
 
i
 = 0 ; i < 
byLeNum
 ; i++ )

534 
sPt
[ ] = "port" ;

535 
sPa
[ ] = "para" ;

536 
sIv
[ ] = "internal";

537 
sSe
[ ] = "PORT";

538 
iIv
 = 0 ;

539 
sizebuff
 = 0 ;

540 
sbufr
[ 200 ] = { 0 } ;

541 
sizebuff
 = 
sbufr
 ) ;

542 
sDPh
[ 200 ] ;

543 
BOOL
 
bPau
 = 
FALSE
 ;

544 
	`memt

sDPh
 , 0 , ( sDllPath ) ) ;

545 
sTemp
[ 200 ] ;

546 
	`memt

sTemp
 , 0 , ( sTemp ) ) ;

548 
	`memt

sbufr
 , 0 , 
sizebuff
 ) ;

551 
	`rtf

sTemp
 , "%s%02d" , 
sPt
 , 
i
 + 1 ) ;

552 
Profe
.
	`GProfeSg

sSe
 , 
sTemp
 , (*)"NULL" , 
sbufr
 , 
sizebuff
 ) ;

553 if
	`rcmp
"NULL" , 
sbufr
 ) == 0 )

555 
	`tf
( "Bus Config Error OK. \n" ) ;

556  
FALSE
 ;

558 if
	`rcmp

PASUE
 , 
sbufr
 ) == 0 )

560 
	`tf
"Bus%d iPASUE \" , 
i
 + 1 ) ;

561 
bPau
 = 
TRUE
 ;

564 if!
bPau
 )

567 
	`rtf

sTemp
 , "%s%02d" , 
sPa
 , 
i
 + 1 ) ;

568 
Profe
.
	`GProfeSg

sSe
 , 
sTemp
 , (*)"NULL" , 
sDPh
 , ( sDllPath ) ) ;

569 if
	`rcmp
"NULL" , 
sDPh
 ) == 0 )

571 
	`tf
( "Bus Config Error OK. \n" ) ;

572  
FALSE
 ;

576 
	`rtf

sTemp
 , "%s%02d" , 
sIv
 , 
i
 + 1 ) ;

577 
iIv
 = 
	`GBusProIv

Profe
 , 
sSe
 , 
sTemp
 ) ;

578 if
iIv
 == -1 )

579  
FALSE
 ;

582 
PBUSDATA
 
pBusDa
 = 
w
 
BUSDATA
 ;

583 
	`ry

pBusDa
->
m_BusSg
 , 
sbufr
 ) ;

584 
pBusDa
->
m_BusIv
 = 
iIv
 ;

585 
	`ry

pBusDa
->
m_ProcDPh
 , 
sDPh
 ) ;

587 if!
bPau
 )

590 if!
	`AddPtOthPa

pBusDa
 , 
Profe
 , 
sbufr
 , 
i
 + 1 ) )

592 
de
 
pBusDa
 ;

593  
FALSE
 ;

597 
	`ry

pBusDa
->
m_szPrtNCd
, 
NCd
 );

598 
	`ry

pBusDa
->
m_szPrtRemeIp
, 
RemeIp
 );

599 
pBusDa
->
m_dwPrtSPtNum
 = 
SPtNum
;

602 
bus
.
	`AddBusSg

pBusDa
 ) ;

605 
	`PrtCfigMsg

i
 + 1 , 
pBusDa
 ) ;

608  
TRUE
 ;

609 
	}
}

611 
	$PrtCfigMsg

BYTE
 
leNo
 , 
PBUSDATA
 
pBusDa
 )

613  
pBusDa
->
m_BusTy
 )

615 
COMRS232
:
COMRS422
:
COMRS485
:

616 
	`tf
( "Bus Config%02d = %s ProtoType = %d Interval = %d OK . \n" , \

617 
leNo
 , 
pBusDa
->
m_BusSg
 ,BusDa->
m_BusTy
 ,BusDa->
m_BusIv
 ) ;

619 
SOCKETTCP
:

621 
	`tf
( "Bus Config%02d = %s ProtoType = %d Interval = %d NetCardName = %s OK . \n" , \

622 
leNo
 , 
pBusDa
->
m_BusSg
 ,BusDa->
m_BusTy
 , \

623 
pBusDa
->
m_BusIv
 ,BusDa->
m_NCdName
 ) ;

625 
TCP_CLIENT
:

626 
	`tf
( "Bus Config%02d = %s ProtoType = %d Interval = %d ServerIP = %s OK . \n" , \

627 
leNo
 , 
pBusDa
->
m_BusSg
 ,BusDa->
m_BusTy
 , \

628 
pBusDa
->
m_BusIv
 ,BusDa->
m_szIP


632 
	}
}

634 
BOOL
 
	$AddPtOthPa

PBUSDATA
 
pBusDa
 , 
CProfe
 &
ofe
 , * 
busSg
 , 
BYTE
 
byNo
)

636 
sArib
[ 100 ];

637 
UINT
 
nPt
 = 0 ;

638 
BYTE
 
byTy
 = 
CBaPt
::
	`GCommArib

busSg
 , 
sArib
 , 
nPt
 ) ;

639 
BOOL
 
bag
 = 
TRUE
 ;

641  
byTy
 )

643 
COMRS232
:
COMRS422
:
COMRS485
:

645 
SOCKETTCP
:

647 
bag
 = 
	`AddNPa

pBusDa
 , 
ofe
 , 
byNo
 ) ;

653 
TCP_CLIENT
:

654 
TCP_CLIENT_SHORT
:

655 
	`ry

pBusDa
->
m_szIP
 , 
sArib
 ) ;

661 
pBusDa
->
m_BusTy
 = 
byTy
 ;

662  
bag
 ;

663 
	}
}

665 
BOOL
 
	$AddNPa

PBUSDATA
 
pBusDa
 , 
CProfe
 &
ofe
 , 
BYTE
 
byNo
 )

667 if
pBusDa
 =
NULL
 || !
ofe
.
	`IsVid
())

668  
FALSE
 ;

699 
sNCd
[ ] = "NetCard" ;

700 
sSe
[ ] = "PORT";

701 
sTemp
[ 200 ] = { 0 } ;

702 
sKey
[ 200 ] = { 0 } ;

703 
sizebuff
 = 
sTemp
 ) ;

705 
	`rtf

sKey
 , "%s%02d" , 
sNCd
 , 
byNo
 ) ;

706 
	`memt

sTemp
 , 0 , ( sTemp ) ) ;

707 if!
	`GBusProfeSg

ofe
 , 
sSe
 , 
sKey
 , 
sTemp
 , 
sizebuff
 ) )

708  
FALSE
 ;

710 
	`ry

pBusDa
->
m_NCdName
 , 
sTemp
 ) ;

712  
TRUE
 ;

713 
	}
}

715 
BOOL
 
	$GBusProfeSg

CProfe
 &
Profe
 , * 
sSe
 , * 
sKey
 , * 
sTemp
 , &
size
 )

717 if!
Profe
.
	`IsVid
() )

718  
FALSE
 ;

720 
Profe
.
	`GProfeSg

sSe
 , 
sKey
 , (*)"NULL" , 
sTemp
 , 
size
 ) ;

721 if
	`rcmp
"NULL" , 
sTemp
 ) == 0 )

722  
FALSE
 ;

724  
TRUE
 ;

725 
	}
}

727 
	$GBusProIv

CProfe
 &
Profe
 , * 
sSe
 , * 
sKey
 )

729 
wV
 = 0 ;

731 
wV
 = 
Profe
.
	`GProfeI

sSe
 , 
sKey
 , -1 ) ;

732 if
wV
 == -1 )

734 
	`tf
"G %E OK. \n" , 
sKey
 ) ;

735  
wV
 ;

737  
wV
 ;

738 
	}
}

740 
BOOL
 
	$InBusLe
( )

742 
INITBUS
 
bus
;

744 if
	`RdPtPa

bus
 ) )

745 
	`tf
( "ReadPortPara OK.\n" );

748 
	`tf
( "ReadPortPara Failed. \n " );

749  
FALSE
 ;

753 if!
	`CeBusLe

bus
 ) )

755 
	`tf
( "CreateBusLine Failed. \n " );

756  
FALSE
 ;

760 if!
	`InComThad
( ) )

762 
	`tf
( "InitComThread Failed. \n " );

763  
FALSE
 ;

766  
TRUE
 ;

767 
	}
}

769 
BOOL
 
	$SLolNPa

CProfe
 &
ofe
 )

771 
sNCd
[ ] = "NetCard" ;

772 
sSe
[ ] = "NetCard";

773 
sDNS
[ ] = "DNS" ;

774 
sGeWay
[ ] = "GateWay" ;

775 
sSubNMask
[ ] = "SubNetMask";

776 
sIP
[ ] = "IP" ;

777 
sRouIp
[] = "RouteIp";

779 
sTemp
[ 200 ] = { 0 } ;

780 
sizebuff
 = 
sTemp
 ) ;

782 
sSysDNS
[ ] = "SYSTEM-DNS";

783 
sSysDNS_Key
[ ] = "DNS";

784 
sTemp_Dns
[ 20 ] = { 0 } ;

785 
sizebuff_Dns
 = 
sTemp_Dns
 ) ;

787 
sKey
[ 200 ] = { 0 } ;

789  
BYTE
 
byNo
 = 1 ; byNo < 5 ; byNo++ )

791 
	`memt

sKey
 , 0 , ( sKey ) ) ;

792 
	`rtf

sKey
 , "%s%02d" , 
sDNS
 , 
byNo
 ) ;

793 
NETWORKPARAM
 
tPam
 ;

799 
	`ry

tPam
.
sDNS
 , 
sTemp
 ) ;

802 
	`rtf

sKey
 , "%s%02d" , 
sGeWay
 , 
byNo
 ) ;

803 
	`memt

sTemp
 , 0 , ( sTemp ) ) ;

804 if!
	`GBusProfeSg

ofe
 , 
sSe
 , 
sKey
 , 
sTemp
 , 
sizebuff
 ) )

805  
FALSE
 ;

807 
	`ry

tPam
.
sGeWay
 , 
sTemp
 ) ;

810 
	`rtf

sKey
 , "%s%02d" , 
sSubNMask
 , 
byNo
 ) ;

811 
	`memt

sTemp
 , 0 , ( sTemp ) ) ;

812 if!
	`GBusProfeSg

ofe
 , 
sSe
 , 
sKey
 , 
sTemp
 , 
sizebuff
 ) )

813  
FALSE
 ;

815 
	`ry

tPam
.
sSubNMask
 , 
sTemp
 ) ;

818 
	`rtf

sKey
 , "%s%02d" , 
sNCd
 , 
byNo
 ) ;

819 
	`memt

sTemp
 , 0 , ( sTemp ) ) ;

820 if!
	`GBusProfeSg

ofe
 , 
sSe
 , 
sKey
 , 
sTemp
 , 
sizebuff
 ) )

821  
FALSE
 ;

823 
	`ry

tPam
.
pNCdName
 , 
sTemp
 ) ;

826 
	`rtf

sKey
 , "%s%02d" , 
sIP
 , 
byNo
 ) ;

827 
	`memt

sTemp
 , 0 , ( sTemp ) ) ;

828 if!
	`GBusProfeSg

ofe
 , 
sSe
 , 
sKey
 , 
sTemp
 , 
sizebuff
 ) )

829  
FALSE
 ;

831 
	`ry

tPam
.
sIp
 , 
sTemp
 ) ;

834 
	`rtf

sKey
 , "%s%02d" , 
sRouIp
 , 
byNo
 ) ;

835 
	`memt

sTemp
 , 0 , ( sTemp ) ) ;

836 if!
	`GBusProfeSg

ofe
 , 
sSe
 , 
sKey
 , 
sTemp
 , 
sizebuff
 ) )

838 
	`tf
 ( "%n'fd\n", 
sKey
 );

839 
	`memt

tPam
.
sRouIp
, 0 , (etParam.sRouteIp ) );

843 
	`ry

tPam
.
sRouIp
 , 
sTemp
 ) ;

845 
m_busMag
.
	`SNCdPam
&
tPam
 ) ;

848 if!
	`GBusProfeSg

ofe
 , 
sSysDNS
 , 
sSysDNS_Key
 , 
sTemp_Dns
 , 
sizebuff_Dns
 ) )

850  
FALSE
 ;

854 
	`ry

m_busMag
.
m_sysDns
 , 
sTemp_Dns
 ) ;

857 
m_busMag
.
	`EbNCdPam
( ) ;

858  
TRUE
 ;

859 
	}
}

861 
BOOL
 
	$InComThad
( )

863 
size
 = 
m_busMag
.
m_sbus
.
	`size
() ;

864 if
size
 == 0 )

865  
FALSE
 ;

868  
i
 = 0 ; i < 
size
 ; i++ )

870 
PBUSMANAGER
 
pBus
 = 
m_busMag
.
m_sbus
[ 
i
 ] ;

871 
THREADPARA
 
ThadPa
 ;

874 if!
pBus
->
m_Proc
 || !pBus->
m_pMhod
 || !pBus->
m_Pt
 )

878 if!
	`OnPt

pBus
 ) )

880 
	`LogPromText
"OP܈%d Faed ! \" , 
pBus
->
m_Pt
->
m_uThePt
 );

881 
	`LogPromText
"pBus->hThad = %d \n" , 
pBus
->
hThad
 );

886 
	`LogPromText
"OP܈%d Sucs! \" , 
pBus
->
m_Pt
->
m_uThePt
 );

889 
ThadPa
.
hThad
 = 
	`had_
(&ThadPa.
ThadID
, 
NULL
, 
ThadProc
, (*)
pBus
);

890 if(
ThadPa
.
ThadID
<0)

892 
	`OutPromText
((*)" ****CreateThread Fail!****");

894 
pBus
->
hThad
 = 
ThadPa
.hThread ;

895 
pBus
->
ThadID
 = 
ThadPa
.ThreadID ;

899 
	`SnSvOnLe
( ) ;

901  
TRUE
 ;

902 
	}
}

904 
	$SnSvOnLe
( )

906 
size
 = 
m_busMag
.
	`GClSize
() ;

907 if
size
 == 0 )

910 
THREADPARA
 
ThadPa
 ;

911 
ThadPa
.
hThad
 = 
	`had_
(&ThadPa.
ThadID
, 
NULL
, 
ThadSnSev
 , (*)
m_busMag
.
	`GSSvVe
() );

912 if(
ThadPa
.
ThadID
<0)

914 
	`OutPromText
((*)" ****ScanServerOnLine____CreateThread Fail!****");

918 
	}
}

920 * 
	$ThadSnSev
(*
pPrObj
 )

922 
ve
<
CBaPt
*> *
pVeSn
 = ( ve<CBaP܈*>* )
pPrObj
 ;

923 if
pVeSn
 =
NULL
 )

924  
NULL
 ;

926 
size
 = 
pVeSn
->
	`size
() ;

927 if!
size
 )

928  
NULL
 ;

930  
g_bARun
 )

932 
ve
<
CBaPt
 *>::

 
ibeg
 = 
pVeSn
->
	`beg
() ;

933 
ve
<
CBaPt
 *>::

 
nd
 = 
pVeSn
->
	`d
();

935  ; 
ibeg
 !
nd
 ; ibegin++ )

939 if*
ibeg
 )->
	`IsPtVid
() )

942 *
ibeg
 )->
	`CloPt
() ;

943 *
ibeg
 )->
	`OnPt
() ;

946 
	`Ap
( 1000 ) ;

948 
	`tf
( "Scan Clienthread hasxited!\n" ) ;

949  
NULL
 ;

950 
	}
}

952 
BOOL
 
	$OnPt
cڡ 
PBUSMANAGER
 
pBus
 )

954 if
pBus
 =
NULL
 )

955  
FALSE
 ;

957 
CBaPt
 * 
pBaPt
 = 
pBus
->
m_Pt
 ;

958 if
pBaPt
 =
NULL
 )

959  
FALSE
 ;

961 
szBuf
[96];

962 if!
pBaPt
->
	`OnPt

szBuf
 ) )

964 
	`LogPromText

szBuf
 ) ;

965  
FALSE
 ;

968  
TRUE
 ;

969 
	}
}

971 
BOOL
 
	$GProcName

BYTE
 
byTy
 , * 
sProc
 )

973  
byTy
 )

975 
MODBUS_RTU
:

976 
	`ry

sProc
 , "ModBus" ) ;

979  
FALSE
 ;

982  
TRUE
 ;

983 
	}
}

985 
BOOL
 
	$CeBusLe

INITBUS
 & 
bus
 )

987 
size
 = 
bus
.
m_busDa
.
	`size
() ;

989 if
size
 == 0 )

991 
	`tf
( "CreateBusLine In ReadProtPara Failed . \n " );

992  
FALSE
 ;

994 
WORD
 
wGhDevCou
 = 0 ;

996  
i
 = 0 ; i < 
size
 ; i++ )

998 
sComTy
[ 100 ] ;

999 
UINT
 
nPt
 = 0 ;

1000 
	`memt

sComTy
 , 0 , ( sComType ) ) ;

1001 
BYTE
 
byComTy
 = 0 ;

1002 
CBaPt
 * 
pPt
 = 
NULL
 ;

1003 
CProc
 * 
pProc
 = 
NULL
 ;

1004 
WORD
 
wIv
 = 0 ;

1005 
PBUSDATA
 
pBusDa
 = 
bus
.
m_busDa
[ 
i
 ] ;

1007 if
	`rcmp

pBusDa
->
m_BusSg
 , 
PASUE
 ) =0 ) &&BusDa->
m_BusTy
 =
COM_PAUSE
 )

1009 
m_busMag
.
	`AddPauBus
() ;

1013 
CMhod
 * 
pMhod
 = 
w
 
CPublicMhod
 ;

1014 
pMhod
->
m_pRdbObj
 = 
g_pRTDBObj
;

1015 
pMhod
->
m_pBusMag
 = &
m_busMag
;

1017 
byComTy
 = 
CBaPt
::
	`GCommArib

pBusDa
->
m_BusSg
 , 
sComTy
 , 
nPt
 ) ;

1018 
pPt
 = 
	`InCom

byComTy
 ) ;

1019 
pProc
 = 
	`InProc

pBusDa
->
m_ProcDPh
, 
pMhod
 ) ;

1020 if
NULL
 =
pProc
 )

1022  
FALSE
;

1024 
wIv
 = 
pBusDa
->
m_BusIv
 ;

1026 if
nPt
 == 0 )

1028 
	`tf
"O%E OK . \n" , 
pBusDa
->
m_BusSg
 ) ;

1031 if
pProc
 =
NULL
 )

1033 
	`tf
"C%Faed OK . \" , 
pBusDa
->
m_ProcDPh
 ) ;

1038 if
byComTy
 =
SOCKETTCP
 )

1041 
NETWORKPARAM
 
tPam
 ;

1042 
	`ry

tPam
.
pNCdName
 , 
pBusDa
->
m_NCdName
 ) ;

1043 if!
m_busMag
.
	`GNCdPam

tPam
.
pNCdName
 , &netParam ) )

1045 
	`tf
"GNPam EܣNCdNam%s\n" , 
pBusDa
->
m_NCdName
 ) ;

1046  
FALSE
 ;

1049 
	`ry

sComTy
 , 
tPam
.
sIp
 ) ;

1052 
pPt
->
m_uThePt
 = 
nPt
 ;

1053 
	`rtf
(
pPt
->
m_szArib
, "%s", 
sComTy
 );

1056 
	`SSlPtMode

byComTy
 , 
nPt
 ) ;

1059 
pMhod
->
m_pPt
 = 
pPt
 ;

1062 if
pProc
->
	`In

i
 ) )

1063 
m_busMag
.
	`AddBus

pProc
 , 
pPt
 , 
wIv
 , 
i
 + 1 , 
pMhod
, 
pBusDa
->
m_szPrtNCd
,BusDa->
m_szPrtRemeIp
,BusDa->
m_dwPrtSPtNum
 ) ;

1065 
wGhDevCou
 +
pMhod
->
	`GSgGhDevCou

i
 ) ;

1069 
	`InDevS

wGhDevCou
 ) ;

1070  
TRUE
 ;

1071 
	}
}

1073 
BOOL
 
	$InDevS

WORD
 
wDevCou
 )

1076 
size
 = 
m_busMag
.
m_sbus
.
	`size
() ;

1077  
i
 = 0 ; i < 
size
 ; i++ )

1079 
PBUSMANAGER
 
pBusMag
 = 
m_busMag
.
m_sbus
[ 
i
 ] ;

1080 if
pBusMag
->
m_pMhod
 )

1081 
pBusMag
->
m_pMhod
->
	`SGhDevCou

wDevCou
 ) ;

1083 
CProc
 *
pExPro
 = 
pBusMag
->
m_Proc
 ;

1084 if
pExPro
 =
NULL
 )

1088 
devSize
 =
pExPro
->
m_modu
.
	`size
() ;

1089  
m
 = 0 ; m < 
devSize
 ; m++ )

1091 
CProc
 * 
pProc
 = 
pExPro
->
m_modu
[ 
m
 ] ;

1092 
pProc
->
	`InDevS
( ) ;

1096  
TRUE
 ;

1097 
	}
};

1100 
BOOL
 
	$SSlPtMode

BYTE
 
byComTy
 , 
DWORD
 
nPt
 )

1102  
byComTy
 )

1104 
COMRS232
:

1106 if
nPt
 == 1 ||Port == 2 )

1107 
	`SSlCfigMode

nPt
 ) ;

1110 
COMRS422
:

1112 if
nPt
 == 8 ||Port == 4 )

1113 
	`SSlCfigMode

nPt
 ) ;

1117  
FALSE
 ;

1120  
TRUE
 ;

1121 
	}
}

1123 
CProc
 * 
	$InProc
* 
pDPh
 , 
CMhod
 *
pMhod
)

1125 
CProc
 * 
pProc
 = 
NULL
 ;

1126 
pProc
 = 
m_busMag
.
m_GProc
->
	`GProObj

pDPh
 , 
pMhod
 ) ;

1127  
pProc
 ;

1128 
	}
}

1130 
CBaPt
 * 
	$InCom

BYTE
 
byComTy
 )

1132 
CBaPt
 * 
pPt
 = 
NULL
 ;

1134  
byComTy
 )

1136 
COMRS232
:

1137 
COMRS422
:

1138 
COMRS485
:

1139 
pPt
 = 
w
 
CSlPt
 ;

1141 
SOCKETTCP
:

1142 
pPt
 = 
w
 
CTPtSv
 ;

1144 
TCP_CLIENT
:

1146 
pPt
 = 
w
 
CTCl
 ;

1147 
m_busMag
.
	`AddClPt

pPt
 ) ;

1150 
TCP_CLIENT_SHORT
:

1152 
pPt
 = 
w
 
CTClSht
 ;

1156  
NULL
 ;

1158  
pPt
 ;

1159 
	}
}

1161 
	$Ap

DWORD
 
dwMliSecd
 )

1163 
timev
 
tv
;

1164 
tv
.
tv_c
 = 0 ;

1165 
tv
.
tv_uc
 = 
dwMliSecd
 * 1000 ;

1166 
	`
(0, 
NULL
, NULL, NULL, &
tv
);

1167 
	}
}

1199 
	#RECV_INTE
 1

	)

1201 
BOOL
 
	$ProssRlDa

PBUSMANAGER
 
pbus
 , &
dex
 , 
size
 , 
PBUSMSG
 
pBusMsg
 )

1204 
BYTE
 
byRxEFmeNum
 = 0;

1205 cڡ 
BYTE
 
byMaxRxEFmeNum
 = 20;

1206 
chDebugBuf
[256];

1208 if
pbus
 =
NULL
 )

1209  
FALSE
 ;

1211 if!
pbus
->
m_Proc
 || !pbus->
m_pMhod
 || !pbus->
m_Pt
 )

1213 
	`Ap
( 100 ) ;

1214  
FALSE
 ;

1217 if
pbus
->
m_Proc
->
m_ProTy
 =
PROTOCO_TRANSPROT
 )

1219 if
pbus
->
m_Proc
->
m_TnsDay
 > 0)

1221 
BYTE
 
DDBBusNo
;

1222 
WORD
 
DDBAddr
;

1223 
CPublicMhod
::
	`GDDBDevBusAndAddr
(
DDBBusNo
,
DDBAddr
);

1224 if
DDBBusNo
 !
pbus
->
byBusNo
 )

1225 
	`Ap
(1000 * 
pbus
->
m_Proc
->
m_TnsDay
);

1226 
pbus
->
m_Proc
->
m_TnsDay
 = 0;

1230 
CProc
 * 
pProc
 = 
NULL
;

1231 
CBaPt
 * 
pPt
 = 
pbus
->
m_Pt
 ;

1232 if
dex
 >
size
 )

1233 
dex
 = 0 ;

1234 
pProc
 = 
pbus
->
m_Proc
->
m_modu
[ 
dex
++ ];

1235 if
pProc
 =
NULL
 )

1237 
	`up
(100*1000);

1238 
	`tf
( "pProtocol == NULL Failed \n" );

1239  
FALSE
 ;

1243 
BOOL
 
bDDB
 = 
FALSE
 ;

1244 if
CPublicMhod
::
	`IsHaveDDB
() &&

1245 
CPublicMhod
::
	`GDDBSyncS
(=
STATUS_SLAVE
 ) &&

1246 
pProc
->
m_ProTy
 =
PROTOCO_GATHER


1248 
bDDB
 = 
TRUE
 ;

1250 
BYTE
 
buf
[ 
MAX_BUFFER
 ];

1251 
	`memt

buf
, 0, 
MAX_BUFFER
 );

1252 
n
 = 0 ;

1253 if!
bDDB
 )

1255 if
pProc
->
	`GProcBuf

buf
 , 
n
 , 
pBusMsg
 ) )

1256 if
n
 > 0 )

1258 
wL
 = 
pPt
->
	`WrePt

buf
 , 
n
 ) ;

1259 if
wL
 > 0 )

1260 
	`OutBusDebug
(
pbus
->
byBusNo
, 
buf
, 
wL
, 0);

1262 
pbus
->
m_Tx
++ ;

1263 if
pbus
->
m_Tx
 > 0xFFFF )

1264 
pbus
->
m_Tx
 = 0 ;

1268 if
bDDB
 )

1269 
	`Ap
( 100 ) ;

1271 
	`Ap

pbus
->
wIv
 ) ;

1273 
n
 = 
buf
 ) ;

1274 
RdL
 = 
pPt
->
	`AsyRdDa

buf
 , 
n
 ) ;

1275 if
RdL
 <= 0 )

1277 
byRxEFmeNum
++;

1278 if
byRxEFmeNum
 >
byMaxRxEFmeNum
 )

1280 
byRxEFmeNum
 = 
byMaxRxEFmeNum
-3;

1281 
	`rtf

chDebugBuf
, "BusLine:%d Addr:%d State:" ,

1282 
pProc
->
m_byLeNo
+1,

1283 
pProc
->
m_wDevAddr
);

1284 
	`OutBusDebug
(
pbus
->
byBusNo
, (
BYTE
 *)
chDebugBuf
, 
	`
( chDebugBuf ), 2);

1287  
FALSE
 ;

1290 if!
bDDB
 )

1292 
	`OutBusDebug
(
pbus
->
byBusNo
, 
buf
, 
RdL
, 1);

1293 if
pProc
->
	`ProssProcBuf

buf
 , 
RdL
 ) )

1295 
pbus
->
m_Rx
++ ;

1296 if
pbus
->
m_Rx
 > 0xFFFF )

1297 
pbus
->
m_Rx
 = 0 ;

1299 
	`rtf

chDebugBuf
, "BusLine:%d Addr:%d State:ͨ" ,

1300 
pProc
->
m_byLeNo
+1,

1301 
pProc
->
m_wDevAddr
);

1304 
byRxEFmeNum
 = 0;

1305 
	`OutBusDebug
(
pbus
->
byBusNo
, (
BYTE
 *)
chDebugBuf
, 
	`
( chDebugBuf ), 2);

1309 
byRxEFmeNum
++;

1310 if
byRxEFmeNum
 >
byMaxRxEFmeNum
 )

1312 
byRxEFmeNum
 = 
byMaxRxEFmeNum
 - 3;

1313 
	`rtf

chDebugBuf
, "BusLine:%d Addr:%d State:" ,

1314 
pProc
->
m_byLeNo
+1,

1315 
pProc
->
m_wDevAddr
);

1316 
	`OutBusDebug
(
pbus
->
byBusNo
, (
BYTE
 *)
chDebugBuf
, 
	`
( chDebugBuf ), 2);

1321  
TRUE
 ;

1322 
	}
}

1324 
	$SdPackloss

PBUSMANAGER
 
pbus
 )

1326 if
pbus
 =
NULL
 )

1330 if
pbus
->
m_Proc
->
m_ProTy
 =
PROTOCO_TRANSPROT
 )

1333 
DWORD
 
dwLoss
 = 0 ;

1334 
dwLoss
 = 
pbus
->
m_Tx
 -bus->
m_Rx
 ;

1336 
WORD
 
wP
 = 
pbus
->
byBusNo
 + 52;

1337 
pbus
->
m_pMhod
->
	`SYcDa
2 , 
wP
 , 
dwLoss
 ) ;

1338 
	}
}

1340 
PBUSMANAGER
 
	$GBusMagPor

BYTE
 
byNo
 )

1342 
size
 = 
m_busMag
.
m_sbus
.
	`size
() ;

1343 if
byNo
 >
size
 )

1344  
NULL
 ;

1346 
PBUSMANAGER
 
pBus
 = 
m_busMag
.
m_sbus
[ 
byNo
 ] ;

1347 if!
pBus
->
m_Proc
 || !pBus->
m_pMhod
 || !pBus->
m_Pt
 )

1348  
NULL
 ;

1350  
pBus
 ;

1351 
	}
}

1353 
BOOL
 
	$ProssSclMsg

PBUSMSG
 
BusMsg
 , 
PBUSMANAGER
 
Bus
 , 
size
 )

1355 
PBUSMSG
 
pBusMsg
 = 
BusMsg
 ;

1356 
PBUSMANAGER
 
pBus
 = 
Bus
 ;

1358 if
pBusMsg
 =
NULL
 || 
pBus
 == NULL )

1360 
	`tf
("ProcessSpecialMsg failure\n");

1361  
FALSE
 ;

1364 if!
pBus
->
m_Proc
 || !pBus->
m_pMhod
 || !pBus->
m_Pt
 )

1366 
	`tf
("ProcessSpecialMsg failure\n");

1367  
FALSE
 ;

1370 
BOOL
 
bFg
 = 
FALSE
 ;

1371 
CProc
 *
pProc
 = 
pBus
->
m_Proc
 ;

1372 
BYTE
 
byMsgTy
 = 
pBusMsg
->byMsgType ;

1374  
byMsgTy
 )

1376 
BROADCASET_PROTO
:

1378 if
pProc
 )

1380 
BYTE
 
buf
[ 1024 ] ;

1381 
	`memt

buf
 , 0 , ( buf ) ) ;

1382 
n
 = 0 ;

1384 
bFg
 = 
pProc
->
	`BrdCa

buf
 , 
n
 ) ;

1385 if
n
 > 0 && 
bFg
 )

1386 
pBus
->
m_Pt
->
	`WrePt

buf
 , 
n
 ) ;

1390 
YK_PROTO
:

1392 
WORD
 
wDevAddr
 = 
pBusMsg
->
DInfo
.
wDevNo
 ;

1393 
iModuNo
 = 
pProc
->
	`GModuNo

wDevAddr
 ) ;

1395 if
iModuNo
 == -1 )

1397 
	`tf
("n'fdhAddr=%d\n", 
wDevAddr
);

1400 
	`ProssRlDa

pBus
 , 
iModuNo
 , 
size
 , 
pBusMsg
 ) ;

1403 
THREAD_EXIT
:

1404 
pBus
->
m_bThadRun
 = 
FALSE
;

1405 
	`tf
 ( "thad %decvx msg\n", 
pBus
->
m_Proc
->
m_byLeNo
 );

1408  
bFg
 ;

1409 
	}
}

1417 
	$SdBusThadExMsg
 ( )

1419 
size
 = 
m_busMag
.
m_sbus
.
	`size
() ;

1420 
PBUSMANAGER
 
pBusMag
 = 
NULL
;

1422  
i
=0; i<
size
; i++ )

1424 
pBusMag
 = 
	`GBusMagPor

i
 ) ;

1425 if
pBusMag
 =
NULL
 )

1428 
	`tf
 ( "ndhadx msg size=%d bus%dBusMag->hThad =%d sdmsg \n", 
size
, 
i
, 
pBusMag
->
hThad
 );

1429 if
pBusMag
->
hThad
 != -1 )

1431 
PBUSMSG
 
busMsg
 = 
w
 
BUSMSG
 ;

1432 
busMsg
->
byMsgTy
 = 
THREAD_EXIT
 ;

1434 
LMSG
 
msg
 ;

1435 
msg
.
pVoid
 = 
busMsg
 ;

1436 
pBusMag
->
	`SdMsg
&
msg
 );

1438 
	`tf
 ( "ndhadx msg size=%d bus%d sdmsg \n", 
size
, 
i
 );

1441 
pBusMag
 = 
NULL
;

1445 
	}
}

1453 
	$WaThadex
 ( )

1455 
nTicks
 = 0;

1456 
BOOL
 
bThadEx
 = 
FALSE
;

1457 
i
;

1458 
PBUSMANAGER
 
pBusMag
 = 
NULL
;

1460 
size
 = 
m_busMag
.
m_sbus
.
	`size
() ;

1461  
nTicks
 < 
THREAD_EXIT_TIME
)

1463  
i
=0; i<
size
; i++ )

1465 
pBusMag
 = 
	`GBusMagPor

i
 ) ;

1466 if
pBusMag
 =
NULL
 )

1469 if
pBusMag
->
m_bThadRun
 =
TRUE
 )

1471 
bThadEx
 = 
FALSE
;

1475 
pBusMag
 = 
NULL
;

1478 if
i
 >
size
 )

1480 
bThadEx
 = 
TRUE
;

1484 
	`Ap
(100);

1485 
nTicks
 ++;

1488 i!
bThadEx
 )

1490  
i
=0; i<
size
; i++ )

1492 
pBusMag
 = 
	`GBusMagPor

i
 ) ;

1493 if
pBusMag
 =
NULL
 )

1495 if
pBusMag
->
m_bThadRun
 =
TRUE
 )

1497 
	`tf
 ( "Thad %dكx wwexhthad fly\n",
i
);

1498 
	`had_nl
(
pBusMag
->
ThadID
);

1499 
	`had_jo

pBusMag
->
ThadID
, 
NULL
 );

1501 
pBusMag
 = 
NULL
;

1506 
	`tf
 ( "All Threadxit\n" );

1509 
	}
}

1511 * 
	$ThadProc
(*
pPrObj
)

1513 
PBUSMANAGER
 
pbus
 = ( PBUSMANAGER )
pPrObj
 ;

1514 
size
 = 
pbus
->
m_Proc
->
m_modu
.
	`size
() ;

1515 
dex
 = 0 ;

1516  
pbus
->
m_bThadRun
 )

1518 
LMSG
 
msgRecv
 ;

1519 if
pbus
->
	`RecvMsg
&
msgRecv
 ) )

1521 
PBUSMSG
 
busMsg
 = ( PBUSMSG )
msgRecv
.
pVoid
 ;

1522 if
busMsg
 =
NULL
 )

1525 
	`ProssSclMsg

busMsg
 , 
pbus
 , 
size
 ) ;

1527 if
busMsg
 !
NULL
 )

1529 
de
 
busMsg
 ;

1530 
busMsg
 = 
NULL
 ;

1535 
	`ProssRlDa

pbus
 , 
dex
 , 
size
 ) ;

1539 
	`tf
"Ex Thad P܈%d \n" , 
pbus
->
m_Proc
->
m_byLeNo
 );

1541 
	`had_ex
(0);

1542  
NULL
;

1543 
	}
}

1545 
	$OnTimeProc
()

1547 
nCou
 = 
m_busMag
.
m_sbus
.
	`size
();

1548 
nMoudSize
 = 0;

1549 
PBUSMANAGER
 
pBus
 ;

1550 
CProc
 *
pPrObj
 = 
NULL
;

1551 
CProc
 *
pMoud
;

1554 
i
 = 0; i < 
nCou
; i++)

1556 
pBus
 = 
m_busMag
.
m_sbus
[
i
];

1557 if!
pBus
->
m_Proc
 || !pBus->
m_pMhod
 || !pBus->
m_Pt
 )

1560 
pPrObj
 = 
pBus
->
m_Proc
;

1561 
nMoudSize
 = 
pPrObj
->
m_modu
.
	`size
();

1563 
k
 = 0; k < 
nMoudSize
; k++)

1565 
pMoud
 = 
pPrObj
->
m_modu
[
k
];

1566 
pMoud
->
	`TimProc
();

1570 
	}
}

1572 
	$ma
(
gc
, **
gv
)

1577 i
	`ady_rug
( "/mynand/config/Baylayer.lock" ) )

1579 
	`tf
 ( "the Program isunning \n" );

1583 
	`tf
 ( "the Program Begino Run\n" );

1585 
	`SiglHook
(
SIGKILL
, 
SignHdr
);

1586 
	`SiglHook
(
SIGTERM
, 
SignHdr
);

1588 
g_bARun
 = 
TRUE
;

1589 
	`SiglHook
(
SIGINT
, 
SignHdr
);

1590 
	`SiglHook
(
SIGQUIT
, 
SignHdr
);

1591 
	`SiglHook
(
SIGSTOP
, 
SignHdr
);

1594 
	`tf
("----------------Open RTDBase----------------\n");

1595 if
	`On_SHM_DBa
() < 0 )

1597 
	`ex
(-1);

1600 
	`ShowRTDBInfo
();

1603 if
	`InBusLe
( ) )

1604 
	`tf
( "InitBusLine OK.\n" );

1607 
	`tf
( "InitBusLine Failed. \n " );

1608 
	`ex
( 0 ) ;

1612  
g_bARun
 )

1614 
	`Ap
( 200 ) ;

1615 
	`OnTimeProc
();

1619 
	`SdBusThadExMsg
 ( );

1620 
	`WaThadex
 ( );

1621 
	`tf
( "Program End! \n\n\n" );

1624 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/main.h

1 #ide
MAIN_H_INCLUDED


2 
	#MAIN_H_INCLUDED


	)

4 
	~<dio.h
>

5 
	~<dlib.h
>

6 
	~<rg.h
>

7 
	~<y.h
>

8 
	~<f.h
>

9 
	~<unid.h
>

10 
	~<dg.h
>

11 
	~<sys/iol.h
>

12 
	~<sys/mm.h
>

13 
	~<sys/tys.h
>

14 
	~<sys/m.h
>

15 
	~<sys/.h
>

16 
	~<sys/time.h
>

17 
	~<o.h
>

18 
	~<sigl.h
>

21 
	~"../she/rdbFun.h
"

22 
	~"../she/CProc.h
"

23 
	~"../she/ofe.h
"

24 
	~"../she/TLi.h
"

25 
	~"../she/CTPtSv.h
"

26 
	~"../she/SlPt.h
"

27 
	~"../she/TCl.h
"

28 
	~"../she/TClSht.h
"

29 
	~"../she/Rtu.h
"

30 
	~"../libdb/rdbObj.h
"

31 
	~"GProc.h
"

32 
	~"cmsg.h
"

33 
	~"CBusDebug.h
"

35 
	~<ve
>

36 
	~"globDef.h
"

37 
	~"../she/glob.h
"

39 
usg
 
mea
 
	gd
 ;

41 
ass
 
	gCBusMg
 ;

42 
ass
 
	gCPublicMhod
;

45 
	#MAX_LINE
 22

	)

48 
	#BUS_PATH
 "/mynd/cfig/BusLe.i"

	)

51 
	sgBusDa


53 
gBusDa
( )

55 
memt

m_BusSg
 , 0 , ( m_BusString ) ) ;

56 
	mm_BusTy
 = 0 ;

57 
	mm_BusIv
 = 0 ;

62 
memt

m_szPrtNCd
, 0, ( m_szPrintNetCard ) );

63 
memt

m_szPrtRemeIp
, 0, ( m_szPrintRemoteIp ) );

65 
	mm_BusSg
[ 200 ] ;

66 
	mm_BusTy
 ;

67 
WORD
 
	mm_BusIv
 ;

71 
	mm_szIP
[24];

72 
	mm_NCdName
[ 30 ];

73 
	mm_ProcDPh
[ 200 ] ;

76 
	mm_szPrtNCd
[5];

77 
	mm_szPrtRemeIp
[16];

78 
DWORD
 
	mm_dwPrtSPtNum
;

79 }
	tBUSDATA
, *
	tPBUSDATA
;

82 
	sgBusInfo


84 
	mpublic
:

85 
gBusInfo
( )

88 ~
gBusInfo
()

90 
RemoveA
() ;

94 
BOOL
 
AddBusSg

PBUSDATA
 
pBusDa
 )

96 if
	mpBusDa
 =
NULL
 )

97  
FALSE
 ;

99 
	mm_busDa
.
push_back

pBusDa
 ) ;

101  
	mTRUE
 ;

104 
BOOL
 
RemoveA
( )

106 
	mnCou
 = 
m_busDa
.
size
();

107 if
	mnCou
 > 0 )

109 
	mnCou
--)

110 
de
 
	mm_busDa
[
nCou
];

112 
	mm_busDa
.
r
();

114  
	mTRUE
 ;

117 
	mpublic
:

118 
ve
<
PBUSDATA
> 
m_busDa
 ;

119 }
	tINITBUS
 , *
	tPINITBUS
 ;

121 
	sgBusMag


123 
CProc
 * 
	mm_Proc
 ;

124 
CBaPt
 * 
	mm_Pt
 ;

125 
CBusDebug
 
	mm_Debug
;

126 
CMhod
 * 
	mm_pMhod
 ;

127 
WORD
 
	mwIv
 ;

128 
CMsg
 
	mm_msg
 ;

129 
	mhThad
;

130 
had_t
 
	mThadID
 ;

131 
BOOL
 
	mm_bThadRun
;

132 
BYTE
 
	mbyBusNo
 ;

133 
DWORD
 
	mm_Tx
 , 
	mm_Rx
 ;

134 
gBusMag
( )

136 
	mm_bThadRun
 = 
TRUE
;

137 
	mm_Proc
 = 
NULL
 ;

138 
	mm_Pt
 = 
NULL
 ;

139 
	mhThad
 = -1 ;

140 
	mThadID
 = 0 ;

141 
	mbyBusNo
 = 0xFF;

142 
	mm_pMhod
 = 
NULL
 ;

143 
	mm_Tx
 = 0 ;

144 
	mm_Rx
 = 0 ;

146 ~
gBusMag
( )

148 if
	mhThad
 >=0 )

150 
had_jo

ThadID
 , 0 ) ;

151 
tf
( "Release Thread Resource! \n" );

155 
BOOL
 
SdMsg
* 
pVoid
 )

157  
	mm_msg
.
SdMsg

pVoid
 );

160 
BOOL
 
RecvMsg
* 
pVoid
 )

162  
	mm_msg
.
RecvMsg

pVoid
 ) ;

165 }
	tBUSMANAGER
, *
	tPBUSMANAGER
 ;

166 
	gve
< 
	tPBUSMANAGER
 > 
	tBUSARRAY
 ;

168 
	sgNWkPam


170 
	mpNCdName
[ 50 ] ;

171 
	msDNS
[ 50 ] ;

172 
	msGeWay
[ 50 ] ;

173 
	msSubNMask
[ 50 ] ;

174 
	msIp
[ 50 ] ;

175 
	msRouIp
[ 50 ] ;

177 
gNWkPam
( )

179 
memt

pNCdName
 , 0 , (NetCardName ) ) ;

180 
memt

sDNS
 , 0 , 
pNCdName
 ) ) ;

181 
memt

sGeWay
 , 0 , 
pNCdName
 ) ) ;

182 
memt

sSubNMask
 , 0 , 
pNCdName
 ) ) ;

183 
memt

sIp
 , 0 , 
pNCdName
 ) ) ;

184 
memt

sRouIp
 , 0 , ( sRouteIp ) ) ;

187 
BOOL
 
	mݔ
 <<
gNWkPam
 * 
	mpPam
 )

189 if
	mpPam
 =
NULL
 )

190  
FALSE
 ;

192 
ry

pNCdName
 , 
pPam
->pNetCardName ) ;

193 
ry

sDNS
 , 
pPam
->sDNS ) ;

194 
ry

sGeWay
 , 
pPam
->sGateWay ) ;

195 
ry

sSubNMask
 , 
pPam
->sSubNetMask ) ;

196 
ry

sIp
 , 
pPam
->sIp ) ;

197 
ry

sRouIp
 , 
pPam
->sRouteIp ) ;

199  
	mTRUE
 ;

202 }
	tNETWORKPARAM
 , *
	tPNETWORKPARAM
 ;

203 
	gve
< 
	tNETWORKPARAM
 > 
	tNETWORKPARAM_ARRAY
 ;

206 
	sgThadPa


208 
	mhThad
;

209 
had_t
 
	mThadID
 ;

210 }
	tTHREADPARA
 , *
	tPTHREADPARA
 ;

211 
	gve
< 
	tTHREADPARA
 > 
	tTHREADARRAY
 ;

214 
BOOL
 
InBusLe
( ) ;

215 
GBusProIv

CProfe
 &
Profe
 , * 
sSe
 , * 
sKey
 );

216 
BOOL
 
CeBusLe

INITBUS
 & 
bus
 ) ;

217 
CBaPt
 * 
InCom

BYTE
 
byComTy
 ) ;

218 
CProc
 * 
InProc
* 
pDPh
, 
CMhod
 *
pMhod
) ;

219 
BOOL
 
GProcName

BYTE
 
byTy
 , * 
sProc
 ) ;

220 
BOOL
 
InComThad
( ) ;

221 * 
ThadProc
(*
pPrObj
);

222 
BOOL
 
OnPt
cڡ 
PBUSMANAGER
 
pBus
 );

223 
Ap

DWORD
 
dwMliSecd
 );

224 
BOOL
 
AddPtOthPa

PBUSDATA
 
pBusDa
 , 
CProfe
 &
ofe
, * 
busSg
 , 
BYTE
 
byNo
) ;

225 
BOOL
 
AddNPa

PBUSDATA
 
pBusDa
 , 
CProfe
 &
ofe
 , 
BYTE
 
byNo
) ;

226 
BOOL
 
GBusProfeSg

CProfe
 &
Profe
 , * 
sSe
 , * 
sKey
 , * 
sTemp
 , &
size
 );

227 
PrtCfigMsg

BYTE
 
leNo
 ,
PBUSDATA
 
pBusDa
 );

228 
BOOL
 
SLolNPa

CProfe
 &
Profe
 ) ;

229 
BOOL
 
ProssRlDa

PBUSMANAGER
 
pbus
 , &
dex
 , 
size
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

230 
BOOL
 
ProssSclMsg

PBUSMSG
 
BusMsg
 , 
PBUSMANAGER
 
Bus
 , 
size
 ) ;

231 
SdPackloss

PBUSMANAGER
 
pbus
 ) ;

232 
BOOL
 
SSlPtMode

BYTE
 
byComTy
 , 
DWORD
 
nPt
 ) ;

233 
SnSvOnLe
( ) ;

234 * 
ThadSnSev
(*
pPrObj
 );

235 
BOOL
 
InDevS

WORD
 
wDevCou
 ) ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/CProtocol_Cdt.cpp

1 
	~"CProc_Cdt.h
"

2 
	~"cdt.h
"

4 cڡ 
	g_CDT_
 = 1;

69 
BYTE
 
	gCdtCRC
[16][16] = {

88 
	gCProc_Cdt
::
	$CProc_Cdt
()

91 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

92 
	}
}

94 
	gCProc_Cdt
::~
	$CProc_Cdt
()

97 
size
 = 
m_modu
.
	`size
() ;

98  
i
 = 0 ; i < 
size
 ; i++ )

100 
de
 
m_modu
[ 
i
 ] ;

102 
m_modu
.
	`r
() ;

103 
	`tf
( "Delete All CProtocol_Cdt OK . \n" );

104 
	}
}

106 
BOOL
 
	gCProc_Cdt
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

108  
FALSE
 ;

109 
	}
}

111 
BOOL
 
	gCProc_Cdt
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

113  
FALSE
 ;

114 
	}
}

116 
BOOL
 
	gCProc_Cdt
::
	$In

BYTE
 
byLeNo
 )

120 
m_byLeNo
 = 
byLeNo
 ;

122 
m_ProTy
 = 
PROTOCO_GATHER
 ;

123  
	`GDevDa
( ) ;

124 
	}
}

126 
BOOL
 
	gCProc_Cdt
::
	$GDevDa
( )

128 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

129 
	`rtf

m_sDevPh
 , "%s/Cdt/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

130 
CProfe
 
	`ofe

m_sDevPh
 ) ;

131  
	`ProssFeDa

ofe
 ) ;

132 
	}
}

134 
BOOL
 
	gCProc_Cdt
::
	$ProssFeDa

CProfe
 &
ofe
 )

136 
BOOL
 
bR
 = 
FALSE
;

137 if!
ofe
.
	`IsVid
() )

139 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

140  
FALSE
 ;

142 
sSe
[ 200 ] = "DEVNUM" ;

143 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

144 
WORD
 
wModu
 = 0 ;

145 
ro
=1 ;

146 
WORD
 
addr
 =3 ;

147 
sName
[ 50 ] = { 0 };

148 
eme
[ 200 ] = { 0 };

149 
iNum
 = 0 ;

150 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

151 if
iNum
 == 0 )

153 
	`tf
( "Get DEVNUM Failed ! \n " );

154  
FALSE
 ;

156  
i
 = 0 ; i < 
iNum
 ; i++ )

158 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

159 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

160 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

161 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

162 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

163 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

165 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

166 i!
bR
 )

168 
	`tf
 ( "CCdModu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

170  
FALSE
;

174  
TRUE
 ;

175 
	}
}

177 
BOOL
 
	gCProc_Cdt
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

179 
CProc_Cdt
 * 
pProc
 = 
NULL
 ;

180 
BOOL
 
bR
 = 
FALSE
;

181  
iModu
 )

183 
_CDT_
:

185 
pProc
 = 
w
 
Cdt0
 ;

186 
pProc
->
m_byLeNo
 = m_byLineNo ;

187 
pProc
->
m_wModuTy
 = 
iModu
 ;

188 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

189 
pProc
->
m_SlNo
 = 
iSlNo
 ;

191 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

192 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

193 
pProc
->
m_pMhod
 = m_pMethod ;

194 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

196 
bR
 = 
pProc
->
	`In

m_byLeNo
 ) ;

197 i!
bR
 )

199 
	`tf
 ( "Init Error \n");

200  
FALSE
;

202 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

207 
	`tf
( "Cdt don't containhis module Failed .\n" );

208  
FALSE
 ;

211 
m_modu
.
	`push_back

pProc
 ) ;

213  
TRUE
 ;

214 
	}
}

225 
BYTE
 
	gCProc_Cdt
::
	$GCrc
(
BYTE
 *
buf
)

227 
BYTE
 
mp
;

228 
BYTE
 
Hi
;

229 
BYTE
 
Lo
;

230 
mp
 = 
buf
[0];

231 
i
 = 0;

234 
Lo
 = 
mp
 & 0x0F;

235 
Hi
 = 
mp
 >> 4;

236 
mp
 = 
CdtCRC
[
Hi
][
Lo
] ^ 
buf
[++
i
];

237 }
i
 < 4);

238 
Lo
 = 
mp
 & 0x0F;

239 
Hi
 = 
mp
 >> 4;

240 
mp
 = 
CdtCRC
[
Hi
][
Lo
];

241 
mp
 ^= 0xFF;

242  
mp
;

243 
	}
}

245 
BOOL
 
	gCProc_Cdt
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

258   
TRUE
 ;

259 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/CProtocol_Cdt.h

1 #ide
CPROTOCOL_CDT_H


2 
	#CPROTOCOL_CDT_H


	)

4 
	~"../../she/CProc.h
"

5 
	~"../../she/CMhod.h
"

6 as
	cCProc_Cdt
 : 
public
 
CProc


8 
public
:

9 
CProc_Cdt
();

10 
	mvtu
 ~
CProc_Cdt
();

11 
vtu
 
BYTE
 
GCrc
(BYTE *);

12 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

13 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

14 
vtu
 
BOOL
 
In
(
BYTE
 
byLeNo
 );

15 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 );

16 
vtu
 
	$TimProc
(){ ; }

17 
eed
:

18 
BOOL
 
	`GDevDa
( );

19 
eed
:

20 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

21 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

22 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/cdt.cpp

11 
	~"cdt.h
"

13 
	~<mh.h
>

14 
	~<time.h
>

16 #ide
ERROR_CONST


17 cڡ 
	gERROR_CONST
 = 5;

19 #ide
COMSTATUS_ONLINE


20 cڡ 
	gCOMSTATUS_ONLINE
 = 1;

22 #ide
COMSTATUS_FAULT


23 cڡ 
	gCOMSTATUS_FAULT
 = 0;

25 
	#CONFILEPATH
 "/mynand/config/Cdt/template/"

26 cڡ 
UINT
 
YCSIGNBIT
 = 1 << 11;

27 cڡ 
UINT
 
YCOVERFLOW
 = 1 << 14;

28 cڡ 
UINT
 
YCINVALIDVAL
 = 1 << 15;

29 cڡ 
BYTE
 
YMINVALIDVAL
 = 1 << 7;

30 cڡ 
BYTE
 
YMISBINARY
 = 1 << 5;

31 

	)

33 
	gCdt0
::
	$Cdt0
()

35 
yc_da
.
	`r
();

36 
yc_c_da
.
	`r
();

37 
yc_g_da
.
	`r
();

38 
cdt_cf
.
	`r
();

39 
m_wETim
 = 
ERROR_CONST
 + 1;

40 
m_byPtStus
 = 
COMSTATUS_FAULT
;

41 
le
 = 0;

42 
lesum
 = 0;

43 
timeag
 = 0;

44 
byBusNo
 = 0;

45 
wDevNo
 = 0;

46 
wP
 = 0;

47 
byV
 = 0;

48 
	}
}

50 
	gCdt0
::~
	$Cdt0
()

52 
cdt_cf
.
	`r
();

53 
	}
}

56 
tm
 *
	gCdt0
::
	$GTime
()

58 
time_t
 
tim
;

59 
tim
 = 
	`time
(
NULL
);

60  
	`loime
(&
tim
);

61 
	}
}

64 
BOOL
 
	gCdt0
::
	$InYx
(
BYTE
 *
buf
)

66 if(
buf
[0] >= 0xF0)

67 if((
buf
[0] == buf[6]) && (buf[6] == buf[12]))

68 if((
buf
[1] == buf[7]) && (buf[7] == buf[13]))

69 if((
buf
[2] == buf[8]) && (buf[8] == buf[14]))

70 if((
buf
[3] == buf[9]) && (buf[9] == buf[15]))

71 if((
buf
[4] == buf[10]) && (buf[10] == buf[16]))

72 if((
buf
[5] == buf[11]) && (buf[11] == buf[17]))

73  
TRUE
;

74  
FALSE
;

75 
	}
}

79 
BOOL
 
	gCdt0
::
	$InYk
(
BYTE
 *
buf
)

81 if(
buf
[0] == 0xE1)

82 if((
buf
[0] == buf[6]) && (buf[6] == buf[12]))

83 if((
buf
[1] == buf[7]) && (buf[7] == buf[13]))

84 if((
buf
[2] == buf[8]) && (buf[8] == buf[14]))

85 if((
buf
[3] == buf[9]) && (buf[9] == buf[15]))

86 if((
buf
[4] == buf[10]) && (buf[10] == buf[16]))

87 if((
buf
[5] == buf[11]) && (buf[11] == buf[17]))

88  
TRUE
;

89  
FALSE
;

90 
	}
}

93 
BOOL
 
	gCdt0
::
	$GYkBuf
(
BYTE
 *
buf
, 
PBUSMSG
 
pBusMsg
)

95 
buf
[0] = buf[2] = buf[4] = 0xEB;

96 
buf
[1] = buf[3] = buf[5] = 0x90;

99 
buf
[6] = 0x71;

100 if(
pBusMsg
->
dwDaTy
 =
YK_SEL
){

101 
buf
[7] = 0x61;

102 
buf
[8] = 0x03;

103 
buf
[9] = 
cdt_cf
[
le
].
ddr
;

104 
buf
[10] = 
cdt_cf
[
le
].
daddr
;

105 
buf
[11] = 
	`GCrc
(buf + 6);

107 
buf
[24] = buf[18] = buf[12] = 0xE0;

109 if(
byV
){

110 
buf
[25] = buf[19] = buf[13] = buf[27] = buf[21] = buf[15] = 0xCC;

111 
buf
[26] = buf[20] = buf[14] = buf[28] = buf[22] = buf[16] = 
cdt_cf
[
le
].
swchd
;

112 
buf
[29] = buf[23] = buf[17] = 
	`GCrc
(buf + 12);

113 
yk_time_ag
 = 
	`time
(
NULL
);

114 
yk_l_ag
 = 0x01;

116 
buf
[25] = buf[19] = buf[13] = buf[27] = buf[21] = buf[15] = 0x33;

117 
buf
[26] = buf[20] = buf[14] = buf[28] = buf[22] = buf[16] = 
cdt_cf
[
le
].
swchd
;

118 
buf
[29] = buf[23] = buf[17] = 
	`GCrc
(buf + 12);

119 
yk_time_ag
 = 
	`time
(
NULL
);

120 
yk_l_ag
 = 0x02;

124 if((
pBusMsg
->
dwDaTy
 =
YK_EXCT
&& 
yk_l_ag
){

125 
buf
[9] = 
cdt_cf
[
le
].
ddr
;

126 
buf
[7] = 0xC2;

127 
buf
[8] = 0x03;

128 
buf
[10] = 
cdt_cf
[
le
].
daddr
;

129 
buf
[11] = 
	`GCrc
(buf + 6);

131 
i
=0; i<3; i++){

132 
buf
[12 + 
i
*6] = 0xE2;

133 
buf
[13 + 
i
*6] = buf[15 + i*6] = 0xAA;

134 
buf
[14 + 
i
*6] = buf[16 + i*6] = 
cdt_cf
[
le
].
swchd
;

135 
buf
[17 + 
i
*6] = 
	`GCrc
(buf + 12 + i*6);

137 
yk_l_ag
 = 0;

140 if((
pBusMsg
->
dwDaTy
 =
YK_CANCEL
&& 
yk_l_ag
){

141 
buf
[9] = 
cdt_cf
[
le
].
ddr
;

142 
buf
[7] = 0xB3;

143 
buf
[8] = 0x03;

144 
buf
[10] = 
cdt_cf
[
le
].
daddr
;

145 
buf
[11] = 
	`GCrc
(buf + 6);

147 
i
=0; i<3;i++){

148 
buf
[12 + 
i
*6] = 0xE3;

149 
buf
[13 + 
i
*6] = buf[15 + i*6] = 0x55;

150 
buf
[14 + 
i
*6] = buf[16 + i*6] = 
cdt_cf
[
le
].
swchd
;

151 
buf
[17 + 
i
*6] = 
	`GCrc
(buf + 12 + i*6);

153 
yk_l_ag
 = 0;

156  
FALSE
;

157  
TRUE
;

158 
	}
}

161 
	gCdt0
::
	$STime
(
BYTE
 *
buf
, &
n
)

163 
tm
 *
timebridge
;

164 
timebridge
 = 
	`GTime
();

166 
buf
[
n
++] = 0x71;

167 
buf
[
n
++] = 0x7A;

168 
buf
[
n
++] = 0x02;

169 
buf
[
n
++] = 
cdt_cf
[
le
].
ddr
;

170 
buf
[
n
++] = 
cdt_cf
[
le
].
daddr
;

171 
buf
[
n
++] = 
	`GCrc
(buf + 6);

173 
buf
[
n
++] = 0xEE;

174 
buf
[
n
++] = 0x00;

175 
buf
[
n
++] = 0x00;

176 
buf
[
n
++] = 
timebridge
->
tm_c
;

177 
buf
[
n
++] = 
timebridge
->
tm_m
;

178 
buf
[
n
++] = 
	`GCrc
(buf + 12);

180 
buf
[
n
++] = 0xEF;

181 
buf
[
n
++] = 
timebridge
->
tm_hour
;

182 
buf
[
n
++] = 
timebridge
->
tm_mday
;

183 
buf
[
n
++] = 
timebridge
->
tm_m
 + 1;

184 
buf
[
n
++] = 
timebridge
->
tm_yr
 - 100;

185 
buf
[
n
++] = 
	`GCrc
(buf + 18);

186 
	}
}

189 
BOOL
 
	gCdt0
::
	$GProcBuf
(
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
)

191 
time_t
 
cds
;

192 
cds
 = 
	`time
(
NULL
);

193 if(
pBusMsg
 !
NULL
){

195 
cdt_cf
[
le
].
ddr
 = (
pBusMsg
->
SrcInfo
).
wDevNo
;

196 
cdt_cf
[
le
].
daddr
 = (
pBusMsg
->
DInfo
).
wDevNo
;

197 
YK_DATA
 *
yk_da
;

198 
yk_da
 = (
YK_DATA
 *)
pBusMsg
->
pDa
;

199 
byBusNo
 = 
pBusMsg
->
SrcInfo
.byBusNo;

200 
wDevNo
 = 
pBusMsg
->
SrcInfo
.wDevNo;

201 
wP
 = 
yk_da
->wPnt;

202 
byV
 = 
yk_da
->byVal;

204 if(
pBusMsg
->
byMsgTy
 =
YK_PROTO
){

205 
cdt_cf
[
le
].
ddr
 = (
pBusMsg
->
SrcInfo
).
wDevNo
;

206 
cdt_cf
[
le
].
daddr
 = (
pBusMsg
->
DInfo
).
wDevNo
;

207 
YK_DATA
 *
yk_da
;

208 
yk_da
 = (
YK_DATA
 *)
pBusMsg
->
pDa
;

209 
byBusNo
 = 
pBusMsg
->
SrcInfo
.byBusNo;

210 
wDevNo
 = 
pBusMsg
->
SrcInfo
.wDevNo;

211 
wP
 = 
yk_da
->wPnt;

212 
byV
 = 
yk_da
->byVal;

214 if(
	`GYkBuf
(
buf
, 
pBusMsg
)){

215 
n
 = 30;

216  
TRUE
;

218 
m_wETim
++;

219  
FALSE
;

224 if((
cds
 - 
yk_time_ag
 >1200&& ((
yk_l_ag
 == 0x01) || (yk_sel_flag == 0x02))){

225 
pBusMsg
->
dwDaTy
 = 
YK_CANCEL
;

226 
	`GYkBuf
(
buf
, 
pBusMsg
);

227 
yk_time_ag
 = 
cds
;

228 
n
 = 30;

229  
TRUE
;

232 
buf
[
n
++] = 0xEB;

233 
buf
[
n
++] = 0x90;

234 
buf
[
n
++] = 0xEB;

235 
buf
[
n
++] = 0x90;

236 
buf
[
n
++] = 0xEB;

237 
buf
[
n
++] = 0x90;

239 if((
cds
 - 
timeag
 >= 1200)){

240 
	`STime
(
buf
, 
n
);

241 
timeag
 = 
cds
;

244 
m_wETim
++;

245  
TRUE
;

246 
	}
}

250 
	gCdt0
::
	$BRev
(
BYTE
 *
y
)

252 
BYTE
 
r
[8];

253 
i
 = 0; i < 8; i++)

254 
r
[
i
] = ((*
y
 >> i) & 0x01);

255 *
y
 = 0;

256 
i
 = 0; i < 8; i++)

257 *
y
 +(
r
[7 - 
i
] << i);

258 
	}
}

261 
	gCdt0
::
	$ByRev
(
UINT
 *
y
)

263 
BYTE
 *
p
;

264 
BYTE
 
mp
;

265 
p
=(
BYTE
 *)
y
;

266 
mp
 = 
p
[3];

267 
p
[3] =[0];

268 
p
[0] = 
mp
;

270 
mp
 = 
p
[1];

271 
p
[1] =[2];

272 
p
[2] = 
mp
;

274 
i
=0;

275 
i
++ < 4)

276 
	`BRev
(
p
++);

277 
	}
}

280 
	gCdt0
::
	$WdByRev
(
WORD
 *
y
)

282 
BYTE
 *
p
;

283 
BYTE
 
mp
;

284 
p
=(
BYTE
 *)
y
;

285 
mp
 = 
p
[1];

286 
p
[1] =[0];

287 
p
[0] = 
mp
;

289 
i
=0;

290 
i
++ < 2)

291 
	`BRev
(
p
++);

292 
	}
}

295 
	gCdt0
::
	$ResvYkDa
(
BYTE
 *
buf
)

309 if((
buf
[0] != 0xE1) || (buf[0] != buf[6]) || (buf[0] != buf[12])){

310 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
YK_ERROR
);

313 if((
buf
[2] !
cdt_cf
[
le
].
swchd
|| (buf[2] !buf[4]|| (buf[1] !buf[3]|| (buf[5] !
	`GCrc
(buf))){

314 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
YK_ERROR
);

317 if((
buf
[2] != buf[8]) || (buf[2] != buf[14]))

319 if((
buf
[1] != buf[7]) || (buf[1] != buf[13]))

321 if((
buf
[1] == 0xCC) || (buf[1] == 0x33))

322 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

324 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
YK_ERROR
);

325 
	}
}

328 
	gCdt0
::
	$ResvYcDa
(
BYTE
 *
buf
, cڡ BYTE &
fo_n
)

330 if((
buf
[0] > 0x7F) && (buf[0] < 0xF0) && (buf[0] != 0xE1))

332 if(
buf
[5] !
	`GCrc
(buf))

334 
UINT
 
vuemp
;

335 
vue
;

336 
m
 = 0;

337 cڡ 
func_ba
 = 0x00;

338 
WORD
 
func_
 = 0;

341 if((
fo_n
 >0x03&& 
	`InYx
(
buf
)){

342 
	`ResvYxDa
(
buf
, 1);

343 
	`ResvYcDa
(
buf
 + 18, 
fo_n
 - 3);

345 }if(
	`InYk
(
buf
&& (
fo_n
 >= 0x03)){

346 
	`ResvYkDa
(
buf
);

347 
	`ResvYcDa
(
buf
 + 18, 
fo_n
 - 3);

351 
m
 < 
fo_n
){

352 
func_
 = 
buf
[
m
 * 6] - 
func_ba
;

353 if(
cdt_cf
[
le
].
yc_func
[
func_
 / 32] & (
UINT
)
	`pow
(2, func_step % 32)){

354 
buf
[-5]){

356 if(
buf
[5 + 
m
 * 6] !
	`GCrc
(buf + m * 6))

358 
vuemp
 = 
buf
[1 + 6 * 
m
] | (buf[2 + 6 * m] << 8);

359 if(
vuemp
 & 
YCINVALIDVAL
)

360 
vue
 = 0;

361 if(
vuemp
 & 
YCOVERFLOW
)

362 
vue
 = 0;

363 if(
vuemp
 & 
YCSIGNBIT
)

364 
vue
 = -()(~((
vuemp
 & 0xFFF) - 1) & 0xFFF);

366 
vue
 = ()
vuemp
;

367 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
func_
 * 2, 
vue
);

368 
vuemp
 = 
buf
[3 + 6 * 
m
] | (buf[4 + 6 * m] << 8);

369 if(
vuemp
 & 
YCINVALIDVAL
)

370 
vue
 = 0;

371 if(
vuemp
 & 
YCOVERFLOW
)

372 
vue
 = 0;

373 if(
vuemp
 & 
YCSIGNBIT
)

374 
vue
 = -()(~((
vuemp
 & 0xFFF) - 1) & 0xFFF);

376 
vue
 = ()
vuemp
;

377 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
func_
 * 2 + 1, 
vue
);

380 if(
buf
[5 + 
m
 * 6] !
	`GCrc
(buf + m * 6))

382 
vuemp
 = 
buf
[1 + 6 * 
m
] | (buf[2 + 6 * m] << 8);

383 if(
vuemp
 & 
YCINVALIDVAL
)

384 
vue
 = 0;

385 if(
vuemp
 & 
YCOVERFLOW
)

386 
vue
 = 0;

387 if(
vuemp
 & 
YCSIGNBIT
)

388 
vue
 = -()(~((
vuemp
 & 0xFFF) - 1) & 0xFFF);

390 
vue
 = ()
vuemp
;

391 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
func_
 * 2, 
vue
);

392 
vuemp
 = 
buf
[3 + 6 * 
m
] | (buf[4 + 6 * m] << 8);

393 if(
vuemp
 & 
YCINVALIDVAL
)

394 
vue
 = 0;

395 if(
vuemp
 & 
YCOVERFLOW
)

396 
vue
 = 0;

397 if(
vuemp
 & 
YCSIGNBIT
)

398 
vue
 = -()(~((
vuemp
 & 0xFFF) - 1) & 0xFFF);

400 
vue
 = ()
vuemp
;

401 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
func_
 * 2 + 1, 
vue
);

404 if(
buf
[5 + 
m
 * 6] !
	`GCrc
(buf + m * 6))

406 
vue
 = 0;

407 
vuemp
 = 
buf
[1 + 6 * 
m
] | (buf[2 + 6 * m] << 8);

408 if(
vuemp
 & 
YCINVALIDVAL
)

409 
vue
 = 0;

410 if(
vuemp
 & 
YCOVERFLOW
)

411 
vue
 = 0;

412 if(
vuemp
 & 
YCSIGNBIT
)

413 
vue
 = -()(~((
vuemp
 & 0xFFF) - 1) & 0xFFF);

415 
vue
 = ()
vuemp
;

416 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
func_
 * 2, 
vue
);

417 
vuemp
 = 0;

418 
vuemp
 = 
buf
[3 + 6 * 
m
] | (buf[4 + 6 * m] << 8);

419 if(
vuemp
 & 
YCINVALIDVAL
)

420 
vue
 = 0;

421 if(
vuemp
 & 
YCOVERFLOW
)

422 
vue
 = 0;

423 if(
vuemp
 & 
YCSIGNBIT
)

424 
vue
 = -()(~((
vuemp
 & 0xFFF) - 1) & 0xFFF);

426 
vue
 = ()
vuemp
;

427 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
func_
 * 2 + 1, 
vue
);

432 
m
++;

434 
m
++;

436 
	}
}

439 
	gCdt0
::
	$ResvYxDa
(
BYTE
 *
buf
, cڡ BYTE &
fo_n
)

441 
UINT
 
vue
;

442 
UINT
 
i
 = 0;

443 cڡ 
func_ba
 = 0xF0;

444 
WORD
 
func_
;

446 
m
 = 0; m < 
fo_n
; m++){

447 
func_
 = 
buf
[6*
m
] - 
func_ba
;

448 if(
cdt_cf
[
le
].
yx_func
 & (
WORD
)
	`pow
(2, 
func_
)){

449 if(
buf
[6*
m
 + 5] !
	`GCrc
(buf + 6*m))

451 
vue
 = (
buf
[6*
m
 + 4] << 24) | (buf[6*m + 3] << 16) | (buf[6*m + 2] << 8) | buf[6*m + 1];

452 
i
 = 0;

453 
i
<=31){

454 if(
cdt_cf
[
le
].
yx_bm
 & (
UINT
)
	`pow
(2, 
i
)){

455 
m_pMhod
->
	`SYxDa
(
m_SlNo
, 
func_
 * 32 + 
i
, (
vue
 & (
UINT
)
	`pow
(2, i)) ? 1 : 0);

457 
i
++;

460 if((
fo_n
 >3&& 
	`InYx
(
buf
))

461 
m
 += 2;

463 
	}
}

466 
	gCdt0
::
	$ResvYmDa
(
BYTE
 *
buf
, cڡ BYTE &
fo_n
)

468 if(((
buf
[0] < 0xA0) || (buf[0] > 0xDF)) && (buf[0] < 0xF0) && (buf[0] != 0xE1))

470 
UINT
 
vue
;

471 
WORD
 
m
 = 0;

472 cڡ 
func_ba
 = 0xA0;

473 
WORD
 
func_
;

475 if(
	`InYx
(
buf
&& (
fo_n
 >= 0x03)){

476 
	`ResvYxDa
(
buf
, 1);

477 
	`ResvYmDa
(
buf
 + 18, 
fo_n
 - 3);

479 }if(
	`InYk
(
buf
&& (
fo_n
 >= 0x03)){

480 
	`ResvYkDa
(
buf
);

481 
	`ResvYmDa
(
buf
 + 18, 
fo_n
 - 3);

485 
m
 < 
fo_n
){

486 
func_
 = 
buf
[6 * 
m
] - 
func_ba
;

487 if(
cdt_cf
[
le
].
ym_func
[
func_
 / 32] & (
UINT
)
	`pow
(2, func_step % 32)){

488 if(
buf
[5 + 6 * 
m
] !
	`GCrc
(buf + 6 * m))

490 
vue
 = 
buf
[6*
m
 + 1] | (buf[6*m + 2] << 8) | (buf[6*m + 3] << 16) | (buf[6*m + 4] << 24);

491 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 
func_
, 
vue
);

493 
m
++;

495 
	}
}

498 
	gCdt0
::
	$ResvYmDaBCD
(
BYTE
 *
buf
, cڡ BYTE &
fo_n
)

500 if(((
buf
[0] < 0xA0) || (buf[0] > 0xDF)) && (buf[0] < 0xF0) && (buf[0] != 0xE1))

502 
UINT
 
vue
;

503 
WORD
 
m
 = 0;

504 cڡ 
func_ba
 = 0xA0;

505 
WORD
 
func_
;

507 if(
	`InYx
(
buf
&& (
fo_n
 >= 0x03)){

508 
	`ResvYxDa
(
buf
, 1);

509 
	`ResvYmDaBCD
(
buf
 + 18, 
fo_n
 - 3);

511 }if(
	`InYk
(
buf
&& (
fo_n
 >= 0x03)){

512 
	`ResvYkDa
(
buf
);

513 
	`ResvYmDaBCD
(
buf
 + 18, 
fo_n
 - 3);

517 
m
 < 
fo_n
){

518 
func_
 = 
buf
[6 * 
m
] - 
func_ba
;

519 if(
cdt_cf
[
le
].
ym_func
[
func_
 / 32] & (
UINT
)
	`pow
(2, func_step % 32)){

520 if(
buf
[5 + 6 * 
m
] !
	`GCrc
(buf + 6 * m))

522 
vue
 = (
buf
[4 + 6*
m
] & 0x10) * 10000000;

523 
vue
 = vu+ (
buf
[4 + 6*
m
] & 0x0F) * 1000000;

524 
vue
 = vu+ (
buf
[3 + 6*
m
] & 0xF0) * 100000;

525 
vue
 = vu+ (
buf
[3 + 6*
m
] & 0x0F) * 10000;

526 
vue
 = vu+ (
buf
[2 + 6*
m
] & 0xF0) * 1000;

527 
vue
 = vu+ (
buf
[2 + 6*
m
] & 0x0F) * 100;

528 
vue
 = vu+ (
buf
[1 + 6*
m
] & 0xF0) * 10;

529 
vue
 = vu+ (
buf
[1 + 6*
m
] & 0x0F);

530 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 
func_
, 
vue
);

532 
m
++;

534 
	}
}

537 
	gCdt0
::
	$ResvSDa
(
BYTE
 *
buf
, cڡ BYTE &
fo_n
)

539 if(
buf
[0] != 0x80)

541 if(
buf
[5] !
	`GCrc
(buf))

543 if(
buf
[11] !
	`GCrc
(buf + 6))

545 
WORD
 
d
 = 0;

546 
BYTE
 
m
 = 0;

548 
TIMEDATA
 
time_s
;

549 
WORD
 
same
;

550 
m
 < 
fo_n
){

551 if((
fo_n
 >0x03&& 
	`InYx
(
buf
&& buf[
m
 * 6] == 0xE1){

552 
	`ResvYkDa
(
buf
);

553 
m
 += 3;

556 
same
 = (
buf
[2 + 
m
 * 6] << 8) + buf[1 + m * 6];

557 
time_s
.
MiSec
 = 
same
;

558 
time_s
.
Secd
 = 
buf
[3 + 
m
 * 6];

559 
time_s
.
Mu
 = 
buf
[4 + 
m
 * 6];

560 
time_s
.
Hour
 = 
buf
[7 + 
m
 * 6];

561 
time_s
.
Day
 = 
buf
[8 + 
m
 * 6];

562 
time_s
.
Mth
 = 0;

563 
time_s
.
Yr
 = 0;

566 
m_pMhod
->
	`SYxDaWhTime
(
m_SlNo
, 
d
++, (
buf
[10 + 
m
*6] & (1 << 15)? 1 : 0, &
time_s
);

567 
m
 += 2;

569 
	}
}

572 
BOOL
 
	gCdt0
::
	$ProssProcBuf
(
BYTE
 *
buf
, 
n
)

575 if(
n
 == 0)

576  
FALSE
;

578 if(((
buf
[0] != buf[2]) || (buf[0] != buf[4])) && ((buf[1] != buf[3]) || (buf[3] != buf[5])))

579  
FALSE
;

580 if(
buf
[8] == 0){

581 
m_wETim
 = 0;

582  
FALSE
;

584 if(((
buf
[0] == 0xEB) && (buf[1] == 0x90)) || ((buf[0] == 0x09) && (buf[1] == 0xD7))){

585 if((
buf
[6] =0x71&& (buf[9] =
cdt_cf
[
le
].
ddr
&& (buf[10] =cdt_cf[le].
daddr
|| (buf[11] =
	`GCrc
(buf + 6))){

586 
buf
[7]){

589 
	`ResvYcDa
(
buf
 + 12, buf[8]);

593 
	`ResvYcDa
(
buf
 + 12, buf[8]);

597 
	`ResvYcDa
(
buf
 + 12, buf[8]);

601 if(
buf
[12] >= 0xF0)

602 
	`ResvYxDa
(
buf
 + 12, buf[8]);

603 if(
buf
[12] == 0xE1)

604 
	`ResvYkDa
(
buf
 + 12);

610 if(!(
buf
[16] & 
YMINVALIDVAL
)){

611 if(
buf
[16] & 
YMISBINARY
)

612 
	`ResvYmDaBCD
(
buf
 + 12, buf[8]);

614 
	`ResvYmDa
(
buf
 + 12, buf[8]);

619 
	`ResvSDa
(
buf
 + 12, buf[8]);

622  
FALSE
;

624 
m_wETim
 = 0;

625  
TRUE
;

628  
FALSE
;

629 
	}
}

632 
	gCdt0
::
	$DeuVCfig
(
CfigIm
 *
cfigle
)

634 
cfigle
->
ty
= 0x00;

635 
cfigle
->
yc_func
[0] = 0xFFFFFFFF;

636 
cfigle
->
yc_func
[1] = 0xFFFFFFFF;

637 
cfigle
->
yc_func
[2] = 0xFFFFFFFF;

638 
cfigle
->
yc_func
[3] = 0xFFFFFFFF;

639 
cfigle
->
yx_func
 = 0xFFFF;

640 
cfigle
->
yx_bm
 = 0xFFFFFFFF;

641 
cfigle
->
ym_func
[0] = 0xFFFFFFFF;

642 
cfigle
->
ym_func
[1] = 0xFFFFFFFF;

643 
cfigle
->
swchd
 = 0x00;

644 
cfigle
->
ddr
 = 0x01;

645 
cfigle
->
daddr
 = 0x01;

646 
	}
}

649 
	gCdt0
::
	$RdCf
(
BYTE
 *
fame
)

651 
FILE
 *
hFe
;

652 
szText
[256];

653 *
mp
;

654 
BYTE
 
i
 = 0;

655 
BYTE
 
cag
 = 0;

656 
CfigIm
 
cfigle
;

657 if((
hFe
 = 
	`fݒ
((cڡ *)
fame
, "r")=
NULL
)

660  
	`fgs
(
szText
, (szText), 
hFe
!
NULL
 )

662 
	`rim
(
szText
);

663 if
szText
[0]=='#' || szText[0]==';' )

665 
i
 = 0;

666 
cag
 = 0;

667 
	`memt
(&
cfigle
, 0, (configline));

669 
mp
 = 
	`ok
(
szText
,",");

670 if((
	`
(
mp
, 
NULL
, 16) >= 0x00) || (strtol(temp, NULL, 16) <= 0xA0))

671 
cfigle
.
ty
 = 
	`
(
mp
, 
NULL
, 16);

672 if(
mp
 =
NULL
)

674 (
mp
 = 
	`ok
(
NULL
, ",")))

676 ++
i
)

679 if((((
UINT
)
	`l
(
mp
, 
NULL
, 16) >= 0) && ((UINT)strtoll(temp, NULL, 16) <= 0xFFFFFFFF)))

680 
cfigle
.
yc_func
[0] = (
UINT
)
	`l
(
mp
, 
NULL
, 16);

682 
cag
 = 1;

685 if(((
UINT
)
	`l
(
mp
, 
NULL
, 16) >= 0 ) && ((UINT)strtoll(temp, NULL, 16) <= 0xFFFFFFFF))

686 
cfigle
.
yc_func
[1] = (
UINT
)
	`l
(
mp
, 
NULL
, 16);

688 
cag
 = 1;

691 if(((
UINT
)
	`l
(
mp
, 
NULL
, 16) >= 0) && ((UINT)strtoll(temp, NULL, 16) <= 0xFFFFFFFF))

692 
cfigle
.
yc_func
[2] = (
UINT
)
	`l
(
mp
, 
NULL
, 16);

694 
cag
 = 1;

697 if((
UINT
)
	`l
(
mp
, 
NULL
, 16) >= 0 && ((UINT)strtoll(temp, NULL, 16) <= 0xFFFFFFFF))

698 
cfigle
.
yc_func
[3] = (
UINT
)
	`l
(
mp
, 
NULL
, 16);

700 
cag
 = 1;

703 if(((
UINT
)
	`l
(
mp
, 
NULL
, 16>0&& ((UINT)
	`
(temp, NULL, 16) <= 0xFFFF))

704 
cfigle
.
yx_func
 = (
WORD
)
	`l
(
mp
, 
NULL
, 16);

706 
cag
 = 1;

709 if(((
UINT
)
	`l
(
mp
, 
NULL
, 16) >= 0) && ((UINT)strtoll(temp, NULL, 16) <= 0xFFFFFFFF))

710 
cfigle
.
yx_bm
 = (
UINT
)
	`l
(
mp
, 
NULL
, 16);

712 
cag
 = 1;

715 if(((
UINT
)
	`l
(
mp
, 
NULL
, 16) >= 0) && ((UINT)strtoll(temp, NULL, 16) <= 0xFFFFFFFF))

716 
cfigle
.
ym_func
[0] = (
UINT
)
	`l
(
mp
, 
NULL
, 16);

718 
cag
 = 1;

721 if(((
UINT
)
	`l
(
mp
, 
NULL
, 16) >= 0) && ((UINT)strtoll(temp, NULL, 16) <= 0xFFFFFFFF))

722 
cfigle
.
ym_func
[1] = (
UINT
)
	`l
(
mp
, 
NULL
, 16);

724 
cag
 = 1;

727 if((
UINT
)(
	`
(
mp
, 
NULL
, 16) >= 0) && ((UINT)strtol(temp, NULL, 16) <= 0xFF ))

728 
cfigle
.
swchd
 = (
BYTE
)
	`
(
mp
, 
NULL
, 16);

730 
cag
 = 1;

733 if(((
UINT
)
	`
(
mp
, 
NULL
, 16) >= 0) && ((UINT)strtol(temp, NULL, 16) <= 0xFF))

734 
cfigle
.
ddr
 = (
BYTE
)
	`
(
mp
, 
NULL
, 16);

736 
cag
 = 1;

739 if(((
UINT
)
	`
(
mp
, 
NULL
, 16) >= 0) && ((UINT)strtol(temp, NULL, 16) <= 0xFF))

740 
cfigle
.
daddr
 = (
BYTE
)
	`
(
mp
, 
NULL
, 16);

742 
cag
 = 1;

745 
cag
 = 1;

748 if
cag
 == 1 )

750 
cag
 = 1;

751 
	`tf
("cdt config filerror:\n");

756 if(
cag
 =1|| (
i
 < 11) )

758 
	`tf
("%lesum i%d %d\n\n",
fame
,
lesum
, 
i
+1);

759 
	`DeuVCfig
(&
cfigle
);

761 
i
=0; i<4; i++)

762 
	`ByRev
(
cfigle
.
yc_func
 + 
i
);

763 
	`WdByRev
(&(
cfigle
.
yx_func
));

764 
	`ByRev
(&(
cfigle
.
yx_bm
));

765 
	`ByRev
(
cfigle
.
ym_func
);

766 
	`ByRev
(
cfigle
.
ym_func
 + 1);

767 
cdt_cf
.
	`push_back

cfigle
 );

768 
lesum
++;

770 
u
 = 
	`fo
(
hFe
);

771 if
u
 )

772 
	`
("fclose");

773  
lesum
;

774 
	}
}

777 
BOOL
 
	gCdt0
::
	$In
(
BYTE
 
byLeNo
)

780 
BYTE
 
szFeName
[128] = {0};

781 
	`rtf
((*)
szFeName
, "%s%s", 
CONFILEPATH
, 
m_sTemePh
);

782 if(
	`RdCf
(
szFeName
) <= 0){

783 
	`tf
("C'fd %s\n", 
szFeName
);

784 
CfigIm
 
cڙem
;

785 
	`DeuVCfig
(&
cڙem
);

786 
cdt_cf
.
	`push_back
(
cڙem
);

788  
TRUE
;

789 
	}
}

792 
	gCdt0
::
	$TimProc
()

794 
m_byPtStus
 = (
m_wETim
 > 
ERROR_CONST
? 
COMSTATUS_FAULT
 : 
COMSTATUS_ONLINE
;

795 
	}
}

798 
BOOL
 
	gCdt0
::
	$GDevCommS
()

800  (
m_byPtStus
 =
COMSTATUS_ONLINE
? 
COM_DEV_NORMAL
 : 
COM_DEV_ABNORMAL
;

801 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/cdt.h

1 #ide
CDT_H


2 
	#CDT_H


	)

4 
	~"CProc_Cdt.h
"

5 
usg
 
mea
 
	gd
;

7 #ide
BYTE


8 
	tBYTE
;

10 #ide
UINT


11 
	tUINT
;

13 
	tULONG
;

16 
BYTE
 
	mty
;

17 
UINT
 
	myc_func
[4];

18 
WORD
 
	myx_func
;

19 
UINT
 
	myx_bm
;

20 
UINT
 
	mym_func
[2];

21 
BYTE
 
	mswchd
;

22 
BYTE
 
	mddr
;

23 
BYTE
 
	mdaddr
;

24 }
	tCfigIm
;

26 as
	cCdt0
 : 
public
 
CProc_Cdt
{

27 
public
:

28 
Cdt0
();

29 
	mvtu
 ~
Cdt0
();

30 
vtu
 
tm
 *
GTime
();

31 
vtu
 
BOOL
 
InYx
(
BYTE
 *);

32 
vtu
 
BOOL
 
InYk
(
BYTE
 *);

33 
vtu
 
BOOL
 
GYkBuf
(
BYTE
 *, 
PBUSMSG
);

34 
vtu
 
STime
(
BYTE
 *, &);

35 
vtu
 
BOOL
 
GProcBuf
(
BYTE
 *, &, 
PBUSMSG
);

36 
vtu
 
BRev
(
BYTE
 *);

37 
vtu
 
ByRev
(
UINT
 *);

38 
vtu
 
WdByRev
(
WORD
 *);

39 
vtu
 
ResvYkDa
(
BYTE
 *);

40 
vtu
 
ResvYcDa
(
BYTE
 *, const BYTE &);

41 
vtu
 
ResvYxDa
(
BYTE
 *, const BYTE &);

42 
vtu
 
ResvYmDa
(
BYTE
 *, const BYTE &);

43 
vtu
 
ResvYmDaBCD
(
BYTE
 *, const BYTE &);

44 
vtu
 
ResvSDa
(
BYTE
 *, const BYTE &);

45 
vtu
 
BOOL
 
ProssProcBuf
(
BYTE
 *, );

46 
vtu
 
DeuVCfig
(
CfigIm
 *);

47 
vtu
 
RdCf
(
BYTE
 *);

48 
vtu
 
BOOL
 
In
(
BYTE
);

49 
vtu
 
TimProc
();

50 
vtu
 
BOOL
 
GDevCommS
();

51 
	meed
:

52 
ve
<> 
yc_da
;

53 
	mve
<> 
	myc_c_da
;

54 
	mve
<> 
	myc_g_da
;

55 
BOOL
 
	myc_y
;

56 
BOOL
 
	myc_c_y
;

57 
BOOL
 
	myc_g_y
;

58 
	mve
<
	mCfigIm
> 
	mcdt_cf
;

59 
	mm_wETim
;

60 
	mm_byPtStus
;

62 
BYTE
 
	mle
;

63 
BYTE
 
	mlesum
;

64 
ULONG
 
	mtimeag
;

65 
ULONG
 
	myk_time_ag
;

66 
WORD
 
	mddr
;

67 
WORD
 
	mdaddr
;

68 
BYTE
 
	mbyBusNo
;

69 
BYTE
 
	mwDevNo
;

70 
BYTE
 
	mwP
;

71 
BYTE
 
	mbyV
;

72 
BYTE
 
	myk_l_ag
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_Cdt.h
"

6 
CProc
 *
CeProc
(
CMhod
 *
pMhod
);

9 
CProc
 *
	$CeProc
(
CMhod
 *
pMhod
)

11 
CProc
 *
pProc
 = 
NULL
;

12 
pProc
 = 
w
 
CProc_Cdt
;

13 if(
pProc
)

14 
pProc
->
m_pMhod
 = 
pMhod
;

15  
pProc
;

16 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/CProtocol_Cjt188.cpp

1 
	~"CProc_Cjt188.h
"

2 
	~"Cjt188_2004.h
"

4 
	#MODULE_CJT188_2004
 1

	)

6 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

9 
	gCProc_Cjt188
::
	$CProc_Cjt188
()

12 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

13 
	`memt

m_szPrtBuf
, 0, ( m_szPrintBuf ) );

14 
	`memt

m_bySveAddr
, 0xAA, ( m_bySlaveAddr ) );

15 
m_bySdPos
 = 0;

16 
m_byDaTy
 = 0;

17 
m_byMTy
 = 
CJT188_READDATA_DATATYPE
;

18 
m_byFENum
 = 4;

19 
m_byS
 = 0;

20 
	}
}

22 
	gCProc_Cjt188
::~
	$CProc_Cjt188
()

25 
size
 = 
m_modu
.
	`size
() ;

26  
i
 = 0 ; i < 
size
 ; i++ )

28 
de
 
m_modu
[ 
i
 ] ;

30 
m_modu
.
	`r
() ;

31 
m_CfgInfo
.
	`r
();

32 
	`tf
( "Delete All CProtocol_Cjt188 OK . \n" );

33 
	}
}

35 
BOOL
 
	gCProc_Cjt188
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

37  
FALSE
 ;

38 
	}
}

40 
BOOL
 
	gCProc_Cjt188
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

42  
FALSE
 ;

43 
	}
}

45 
BOOL
 
	gCProc_Cjt188
::
	$In

BYTE
 
byLeNo
 )

49 
m_byLeNo
 = 
byLeNo
 ;

51 
m_ProTy
 = 
PROTOCO_GATHER
 ;

53  
	`GDevDa
( ) ;

54 
	}
}

56 
BOOL
 
	gCProc_Cjt188
::
	$GDevDa
( )

58 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

59 
	`rtf

m_sDevPh
 , "%s/Cjt188/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

60 
CProfe
 
	`ofe

m_sDevPh
 ) ;

62  
	`ProssFeDa

ofe
 ) ;

63 
	}
}

65 
BOOL
 
	gCProc_Cjt188
::
	$ProssFeDa

CProfe
 &
ofe
 )

67 if!
ofe
.
	`IsVid
() )

69 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

70  
FALSE
 ;

73 
sSe
[ 200 ] = "DEVNUM" ;

74 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

76 
sName
[ 50 ] = { 0 };

77 
eme
[ 200 ] = { 0 };

78 
iNum
 = 0 ;

80 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

81 if
iNum
 == 0 )

83 
	`tf
( "Get DEVNUM Failed ! \n " );

84  
FALSE
 ;

87  
i
 = 0 ; i < 
iNum
 ; i++ )

89 
WORD
 
wModu
 = 0 ;

90 
ro
 = 0 ;

91 
WORD
 
addr
 = 0 ;

92 
BOOL
 
bR
 = 
FALSE
;

94 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

96 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

97 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

98 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

99 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

100 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

103 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

104 i!
bR
 )

106 
	`tf
 ( "CModBuModu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

108  
FALSE
;

112  
TRUE
 ;

113 
	}
}

115 
BOOL
 
	gCProc_Cjt188
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

117 
CProc_Cjt188
 * 
pProc
 = 
NULL
 ;

120  
iModu
 )

122 
MODULE_CJT188_2004
:

124 
pProc
 = 
w
 
CCjt188_2004
 ;

125 
pProc
->
m_byLeNo
 = m_byLineNo ;

126 
pProc
->
m_wModuTy
 = 
iModu
 ;

127 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

128 
pProc
->
m_SlNo
 = 
iSlNo
 ;

129 
	`ry

pProc
->
m_sDevName
 , 
sName
 ) ;

130 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

131 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

132 
pProc
->
m_pMhod
 = m_pMethod ;

133 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

135 if!
pProc
->
	`In

m_byLeNo
 ) )

137 
	`tf
" Add bu%d Add%d s%d!!!\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

138  
FALSE
;

141 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

147 
	`tf
( "Cjt188 don't containhis module Failed .\n" );

148  
FALSE
 ;

151 
m_modu
.
	`push_back

pProc
 ) ;

153  
TRUE
 ;

154 
	}
}

156 
BYTE
 
	gCProc_Cjt188
::
	$GCs
cڡ 
BYTE
 * 
pBuf
 , 
n
 )

158 
BYTE
 
byR
 = 0x00;

159 
i
;

161 if
pBuf
 =
NULL
 || 
n
 <= 0 )

162  
byR
;

164  
i
=0; i<
n
 ; i++ )

166 
byR
 +
pBuf
[
i
];

169  
byR
;

170 
	}
}

172 
BOOL
 
	gCProc_Cjt188
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

175 
dex
 = 0 ;

176 
buf
[ 
dex
++ ] = 0xFF ;

177 
buf
[ 
dex
++ ] = 0x02 ;

178 
buf
[ 
dex
++ ] = 0x03 ;

179 
buf
[ 
dex
++ ] = 0x04 ;

181 
WORD
 
wCRC
 = 
	`GCs

buf
, 
dex
 );

182 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

183 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

185 
n
 = 
dex
 ;

187 
	`tf
( "\n CProtocol_Cjt188 TestBroadCast \n " ) ;

188  
TRUE
 ;

189 
	}
}

200 
	gCProc_Cjt188
::
	$t
 ( cڡ *
szBuf
, 
n
 )

202 #ifde 
CJT188PRINT


203 
	`tf
"%s\n", 
szBuf
 );

206 #ifde 
CJT188DEBUG


207 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

209 
	}
}

221 
BOOL
 
	gCProc_Cjt188
::
	$WhhBufVue
 (cڡ 
BYTE
 *
buf
, &
n
, &
pos
 )

223 cڡ 
BYTE
 *
por
 = 
buf
;

224 
d
;

225 
BYTE
 
byCrc
;

226 
pos
 = 0;

228 if
buf
 =
NULL
 || 
n
 <= 0 )

230 
	`t
( "buf==NULL oren <=0" );

231  
FALSE
;

234  
n
 > 0 )

236 *
por
)

241 if*(
por
+1!
m_byMTy
 )

243 
	`rtf
(
m_szPrtBuf
,

245 *(
por
+1), 
m_byMTy
 );

246 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
m_szPrtBuf
, 
	`
(m_szPrintBuf), 2 );

247 
DEFAULT
;

251 if*
por
 + 9 ) & 0x80 ) == 0)

253 
	`t
( "Cjt188ecv λ Ϊ1" );

254 
DEFAULT
;

258 
d
=*(
por
+10);

259 if
d
+12>
n
 || datalen > 0x64 )

261 
	`rtf
(
m_szPrtBuf
,

263 
d
, 
n
 );

264 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
m_szPrtBuf
, 
	`
(m_szPrintBuf), 2 );

265 
DEFAULT
;

269 
byCrc
=
	`GCs
(
por
,
d
 + 11);

270 if(*(
por
+
d
+11)!=
byCrc


271 || *(
por
+
d
+12)!=0x16)

273 
	`rtf
(
m_szPrtBuf
,

275 
byCrc
, *(
por
+
d
+10), *(pointer+datalen+11));

276 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
m_szPrtBuf
, 
	`
(m_szPrintBuf), 2 );

277 
DEFAULT
;

281  
k
=0; k<7; k++)

283 if0x =
m_bySveAddr
[
k
] )

288 i*(
por
 + 2 + 
k
!
m_bySveAddr
[k] )

290 
	`rtf
(
m_szPrtBuf
,

291 "Cjt188ecvddr܁h%d by Gaddr=%dddr=%d ",
k
,

292 *(
por
 + 1 + 
k
), 
m_bySveAddr
[k] );

293 
	`t

m_szPrtBuf
 );

294 
DEFAULT
;

300 
n
 = 
d
 + 12;

301 
buf
 = bu+ 
pos
;

302  
TRUE
;

308 
DEFAULT
:

309 
n
--;

310 
por
++;

311 
pos
 ++;

314 
	`t
( "Cjt188 can't findhe correctecvbuf" );

315  
FALSE
;

316 
	}
}

328 
BOOL
 
	gCProc_Cjt188
::
	$RdCfgInfo
 ( )

330 
FILE
 *

 = 
NULL
;

331 
szLeBuf
[256];

332 
szFeName
[256] = "";

334 
	`tf
 ( "slaveaddr=%.2x %.2x %.2x %.2x %.2x %.2x %.2x\n",

335 
m_bySveAddr
[0], m_bySlaveAddr[1], m_bySlaveAddr[2],

336 
m_bySveAddr
[3], m_bySlaveAddr[4], m_bySlaveAddr[5],

337 
m_bySveAddr
[6]);

339 
	`rtf

szFeName
, "%s%s", 
CJT188PREFIXFILENAME
, 
m_sTemePh
);

340 

 = 
	`fݒ

szFeName
, "r" );

341 if

 =
NULL
 )

343 
	`rtf
(
m_szPrtBuf
, "Cjt188:RdCfgInffݒ %r!!!\n", 
szFeName
 );

344 
	`tf
 ( "%s", 
m_szPrtBuf
 );

345  
FALSE
;

349 
	`rtf
(
m_szPrtBuf
, "Cjt188:RdCfgInffݒ %Ok!!!\n", 
szFeName
 );

350 
	`tf
 ( "%s", 
m_szPrtBuf
 );

353  
	`fgs

szLeBuf
, (szLeBuf), 

 ) !
NULL
 )

355 
	`rim

szLeBuf
 );

356 if
szLeBuf
[0] == '#' || szLineBuf[0] == ';' )

361 i(
szLeBuf
[0]-'0') < 0 || (szLineBuf[0] - '0') > 9 )

377 if
	`cmp

szLeBuf
, "metertype=", 10 ) == 0 )

379 
num
;

380 
	`ssnf

szLeBuf
+10 ), "%2x", &
num
 );

381 
m_byMTy
 = (
BYTE
)
num
;

382 
	`tf
 ( "mty=%.2x\n", 
m_byMTy
 );

384 if
	`cmp

szLeBuf
, "fenum=", 6 ) == 0 )

386 
num
;

387 
	`ssnf

szLeBuf
+6, "%2d", (*)&
num
 );

388 
m_byFENum
 = (
BYTE
)
num
;

389 
	`tf
 ( "num=%.2d\n", 
m_byFENum
 );

397 
	`fo


 );

399  
TRUE
;

400 
	}
}

411 
BYTE
 
	gCProc_Cjt188
::
	$ChgeSdPos
 ( )

413 
InfoNum
 = 
m_CfgInfo
.
	`size
( );

414  
InfoNum
 > 0 )

416 
m_bySdPos
 = ( m_bySdPo+ 1 )% ( 
m_CfgInfo
.
	`size
() );

418 i
m_CfgInfo
[
m_bySdPos
].
byCye
 > 0 )

420  
m_bySdPos
;

425 
InfoNum
 --;

430 
	}
}

441 
BYTE
 
	gCProc_Cjt188
::
	$HexToBcd
 ( 
BYTE
 
c
 )

443  (
BYTE
)
c
>>4 ) * 10 + ( c & 0x0f ));

444 
	}
}

455 
BYTE
 
	gCProc_Cjt188
::
	$BcdToHex
 ( 
BYTE
 
c
 )

457  ( (
c
%10) + (c/10)*16);

458 
	}
}

471 
DWORD
 
	gCProc_Cjt188
::
	$oh
 ( *
szBuf
 , 
BYTE
 
n
, BYTE 
byFg
)

473 
BYTE
 
i
 = 0, 
j
;

474 
DWORD
 
mpvue
 = 0;

475 
DWORD
 
vue
 = 0;

478 if8 <
n
 )

480 
n
 = 8;

483 
i
=0;i<
n
;i++)

485 if1 =
byFg
 )

487 
j
 = 
i
;

489 if0 =
byFg
 )

491 
j
 = 
n
 - 
i
;

495 if(
szBuf
[
j
]>='A') && (szBuf[j]<='F') )

497 
mpvue
 = 
szBuf
[
j
]-'A'+10;

499 if(
szBuf
[
j
]>='a') && (szBuf[j]<='f') )

501 
mpvue
 = 
szBuf
[
j
]-'a'+10;

503 if(
szBuf
[
j
]>='0') && (szBuf[j]<='9') )

505 
mpvue
 = 
szBuf
[
j
]-'0';

508 
vue
 = vue*16+
mpvue
;

511  
vue
;

512 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/CProtocol_Cjt188.h

2 #ide
CPROTOCOL_CJT188_H


3 
	#CPROTOCOL_CJT188_H


	)

5 
	~"../../she/CProc.h
"

6 
	~"../../she/CMhod.h
"

7 
	~<time.h
>

8 
	~<sys/time.h
>

10 
usg
 
mea
 
	gd
;

12 
	#CJT188PREFIXFILENAME
 "/myp/cfig/Cjt188/me/"

	)

15 
	#CJT188DEBUG


	)

17 
	#CJT188_READDATA_DATATYPE
 1

	)

18 
	#CJT188_TIME_DATATYPE
 2

	)

21 
	#CJT188_MAX_BUF_LEN
 256

	)

22 
	#CJT188_MAX_RESEND_COUNT
 3

	)

23 
	#CJT188_MAX_RECV_ERR_COUNT
 3

	)

25 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

33 as
	cCjt188CfgInfo


35 
	mpublic
:

36 
	$Cjt188CfgInfo
 ()

38 
byDaTy
 = 0;

39 
byDI0
 = 0;

40 
byDI1
 = 0;

41 
byCye
 = 1;

44 
BYTE
 
byDaTy
;

45 
BYTE
 
byDI0
;

46 
BYTE
 
byDI1
;

47 
BYTE
 
byCye
;

48 
	}
};

51 as
	cCProc_Cjt188
 : 
public
 
CProc


53 
public
:

54 
CProc_Cjt188
();

55 
	mvtu
 ~
CProc_Cjt188
();

59 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

61 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

63 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

65 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 ) ;

67 
vtu
 
	$TimProc
(){ ; }

69 
public
:

70 
BYTE
 
m_bySdPos
;

71 
BYTE
 
m_byDaTy
;

72 
ve
 <
Cjt188CfgInfo
> 
m_CfgInfo
;

73 
m_szPrtBuf
[256];

74 
BYTE
 
m_bySveAddr
[7];

75 
BYTE
 
m_byMTy
;

76 
BYTE
 
m_byFENum
;

77 
BYTE
 
m_byS
;

79 
eed
:

81 
vtu
 
BYTE
 
	`GCs
cڡ BYTE * 
pBuf
 , 
n
 );

83 
vtu
 
BOOL
 
	`WhhBufVue
(cڡ 
BYTE
 *
buf
, &
n
, &
pos
 );

85 
vtu
 
BOOL
 
	`RdCfgInfo
( );

87 
vtu
 
BYTE
 
	`ChgeSdPos
( );

89 
eed
:

91 
	`t
cڡ *
szBuf
, 
n
=0 );

93 
eed
:

95 
BOOL
 
	`GDevDa
( ) ;

97 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

99 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

101 
DWORD
 
	`oh
 ( *
szBuf
, 
BYTE
 
n
, BYTE 
byFg
 );

103 
BYTE
 
	`HexToBcd
BYTE 
c
 );

105 
BYTE
 
	`BcdToHex
BYTE 
c
 );

107 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/Cjt188_2004.cpp

19 
	~<dio.h
>

20 
	~<as.h
>

21 
	~"Cjt188_2004.h
"

23 
	#CJT188_2004_SYNC_INTERVAL
 60*20

	)

32 
	gCCjt188_2004
::
	$CCjt188_2004
 ()

34 
	`InProcStus
( );

35 
	}
}

44 
	gCCjt188_2004
::~
	$CCjt188_2004
 ()

46 
	}
}

59 
BOOL
 
CCjt188_2004
::
	$ProssDaT1
 ( cڡ 
BYTE
 *
buf
, 
n
 )

61 
BYTE
 
byYxV
;

62 
WORD
 
wYcP
 = 0;

63 
WORD
 
wYxP
 = 0;

64 
i
 ;

65 cڡ 
BYTE
 *
por
 = 
buf
;

66 
por
 += 10;

69 if0x16 !*
por
 ) )

71 
	`t
( "ݳ쳣" );

72  
FALSE
;

75 
por
 += 4;

80  
i
=0; i<2; i++ )

82 
DWORD
 
dwYcV
;

83 
fYcV
;

84 
dwYcV
 = 
	`HexToBcd
*
por
 )

85 + 
	`HexToBcd
*(
por
 + 1) ) * 100

86 + 
	`HexToBcd
*(
por
 + 2) ) * 10000

87 + 
	`HexToBcd
*(
por
 + 3) ) * 1000000;

89 
fYcV
 = ()(
dwYcV
);

90 
	`rtf

m_szPrtBuf
, "%d yc%d upde%f",
m_SlNo
, 
wYcP
, 
fYcV
 );

91 
	`t

m_szPrtBuf
 );

93 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wYcP
, 
fYcV
 );

95 
wYcP
 ++;

96 
por
 += 5;

101 
por
 += 7;

106 if0 =*
por
 & 0x03 ) )

108 
byYxV
 = 0;

109 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

110 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
, 
wYxP
, 
byYxV
 );

111 
	`t

m_szPrtBuf
 );

113 if1 =(*
por
 & 0x03) )

115 
byYxV
 = 1;

116 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

117 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
, 
wYxP
, 
byYxV
 );

118 
	`t

m_szPrtBuf
 );

120 
wYxP
 ++;

122 if3 =*
por
 & 0x03 ) )

124 
byYxV
 = 0;

128 
byYxV
 = 1;

130 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

131 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
, 
wYxP
, 
byYxV
 );

132 
	`t

m_szPrtBuf
 );

133 
wYxP
 ++;

136  
i
=0; i<6; i++ )

138 
byYxV
 = ( *
por
 >> (2 + 
i
) ) & 0x01;

139 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

140 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
, 
wYxP
, 
byYxV
 );

141 
	`t

m_szPrtBuf
 );

142 
wYxP
 ++;

144 
por
++;

145  
i
=0; i<8; i++ )

147 
byYxV
 = ( *
por
 >> 
i
 ) & 0x01;

148 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

149 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
 ,
wYxP
, 
byYxV
 );

150 
	`t

m_szPrtBuf
 );

151 
wYxP
 ++;

154  
TRUE
;

155 
	}
}

167 
BOOL
 
	gCCjt188_2004
::
	$ProssDaT2
 ( cڡ 
BYTE
 *
buf
, 
n
 )

169 
DWORD
 
dwYcV
;

170 
fYcV
;

171 
BYTE
 
byYxV
;

172 
WORD
 
wYcP
 = 0;

173 
WORD
 
wYxP
 = 0;

174 
i
 ;

175 cڡ 
BYTE
 *
por
 = 
buf
;

176 
por
 += 10;

179 if0x2!*
por
 ) )

181 
	`t
( "ݳ쳣" );

182  
FALSE
;

185 
por
 += 4;

189  
i
=0; i<5; i++ )

191 
dwYcV
 = 
	`HexToBcd
*
por
 )

192 + 
	`HexToBcd
*(
por
 + 1) ) * 100

193 + 
	`HexToBcd
*(
por
 + 2) ) * 10000

194 + 
	`HexToBcd
*(
por
 + 3) ) * 1000000;

195 
fYcV
 = ()(
dwYcV
) ;

196 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wYcP
, 
fYcV
 );

197 
	`rtf

m_szPrtBuf
, "%d yc%d upde%f",
m_SlNo
, 
wYcP
, 
fYcV
 );

198 
	`t

m_szPrtBuf
 );

200 
wYcP
 ++;

201 
por
 += 5;

205  
i
=0; i<2; i++ )

207 
dwYcV
 = 
	`HexToBcd
*
por
 )

208 + 
	`HexToBcd
*(
por
 + 1) ) * 100

209 + 
	`HexToBcd
*(
por
 + 2) ) * 10000 ;

211 
fYcV
 = ()(
dwYcV
) / 100;

212 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wYcP
, 
fYcV
 );

213 
	`rtf

m_szPrtBuf
, "%d yc%d upde%f",
m_SlNo
, 
wYcP
, 
fYcV
 );

214 
	`t

m_szPrtBuf
 );

215 
wYcP
 ++;

216 
por
 += 3;

221 
dwYcV
 = 
	`HexToBcd
*
por
 )

222 + 
	`HexToBcd
*(
por
 + 1) ) * 100

223 + 
	`HexToBcd
*(
por
 + 2) ) * 10000 ;

225 
fYcV
 = ()(
dwYcV
);

226 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wYcP
, 
fYcV
 );

227 
	`rtf

m_szPrtBuf
, "%d yc%d upde%f",
m_SlNo
, 
wYcP
, 
fYcV
 );

228 
	`t

m_szPrtBuf
 );

229 
wYcP
 ++;

230 
por
 += 3;

234 
por
 += 7;

239 if0 =*
por
 & 0x03 ) )

241 
byYxV
 = 0;

242 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

243 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
, 
wYxP
, 
byYxV
 );

244 
	`t

m_szPrtBuf
 );

246 if1 =(*
por
 & 0x03) )

248 
byYxV
 = 1;

249 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

250 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
, 
wYxP
, 
byYxV
 );

251 
	`t

m_szPrtBuf
 );

253 
wYxP
 ++;

255 if3 =*
por
 & 0x03 ) )

257 
byYxV
 = 0;

261 
byYxV
 = 1;

263 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

264 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
, 
wYxP
, 
byYxV
 );

265 
	`t

m_szPrtBuf
 );

266 
wYxP
 ++;

269  
i
=0; i<6; i++ )

271 
byYxV
 = ( *
por
 >> (2 + 
i
) ) & 0x01;

272 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

273 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
,
wYxP
, 
byYxV
 );

274 
	`t

m_szPrtBuf
 );

275 
wYxP
 ++;

277 
por
++;

278  
i
=0; i<8; i++ )

280 
byYxV
 = ( *
por
 >> 
i
 ) & 0x01;

281 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wYxP
, 
byYxV
 );

282 
	`rtf

m_szPrtBuf
, "%d yx%d upde%d",
m_SlNo
, 
wYxP
, 
byYxV
 );

283 
	`t

m_szPrtBuf
 );

284 
wYxP
 ++;

287  
TRUE
;

288 
	}
}

300 
BOOL
 
	gCCjt188_2004
::
	$ProssDaT3
 ( cڡ 
BYTE
 *
buf
, 
n
 )

302 
	`ProssDaT1

buf
, 
n
 );

303  
TRUE
;

304 
	}
}

317 
BOOL
 
	gCCjt188_2004
::
	$ProssRdDa
 ( cڡ 
BYTE
 *
buf
, 
n
 )

319 cڡ 
BYTE
 *
por
 = 
buf
;

320 
por
 += 9;

323 if0x40 =0x40 & *
por
 ) )

325 
	`t
( "ͨѶ쳣" );

326  
FALSE
;

330 
por
 += 2;

333 if
m_CfgInfo
[
m_bySdPos
].
byDI0
 !*(
por
)

334 || 
m_CfgInfo
[
m_bySdPos
].
byDI1
 !*(
por
+1) )

336 
	`rtf

m_szPrtBuf
,

338 *
por
, *or+1), 
m_CfgInfo
[
m_bySdPos
].
byDI0
,m_CfgInfo[m_bySdPos].
byDI1
 );

339 
	`t

m_szPrtBuf
 );

340  
FALSE
;

342 
por
 += 2;

345 if
m_byS
 !*
por
 )

347 
	`rtf

m_szPrtBuf
,

349 *
por
, 
m_byS
 );

350 
	`t

m_szPrtBuf
 );

351  
FALSE
;

355 if
m_byMTy
 >= 0x10 && m_byMeterType <= 0x19 )

357 
	`t
( "ˮ " );

358  
	`ProssDaT1

buf
, 
n
 );

360 if
m_byMTy
 >= 0x20 && m_byMeterType <= 0x29 )

362 
	`t
( " " );

363  
	`ProssDaT2

buf
, 
n
 );

365 if
m_byMTy
 >= 0x30 && m_byMeterType <= 0x39 )

367 
	`t
( "ȼ " );

368  
	`ProssDaT3

buf
, 
n
 );

371  
FALSE
;

372 
	}
}

384 
BOOL
 
	gCCjt188_2004
::
	$ProssBuf
 ( cڡ 
BYTE
 *
buf
, 
n
 )

386  
m_byDaTy
 )

388 
CJT188_READDATA_DATATYPE
:

389 
	`t
( "ݴ" );

390  
	`ProssRdDa

buf
, 
n
 );

393 
CJT188_TIME_DATATYPE
:

394 
	`t
( "ʱ" );

398 
	`rtf

m_szPrtBuf
, "δҵ%d", 
m_byDaTy
 );

399 
	`t

m_szPrtBuf
 );

400  
FALSE
;

404  
TRUE
;

405 
	}
}

416 
BOOL
 
	gCCjt188_2004
::
	$IsTimeToSync
 ( )

418 
time_t
 
dTime
;

419 
time_t
 
curTime
;

422 if
m_bLkStus
 && 
m_bLkTimeSyn
 )

424 
dTime
 = 
	`time

NULL
 );

425 
m_bLkTimeSyn
 = 
FALSE
;

426  
TRUE
;

430 
curTime
 = 
	`time
(
NULL
);

431 if
	`difime

curTime
, 
dTime
 ) > 
CJT188_2004_SYNC_INTERVAL
 )

433 
dTime
 = 
curTime
;

434  
TRUE
;

437  
FALSE
;

438 
	}
}

451 
BOOL
 
	gCCjt188_2004
::
	$RequeRdDa
 ( 
BYTE
 *
buf
, &
n
 )

453 
n
 = 0;

454  
i
=0; i<
m_byFENum
; i++)

456 
buf
[
n
++] = 0xfe;

458 
buf
[
n
++] = 0x68;

459 
buf
[
n
++] = 
m_byMTy
;

461  
i
=0; i<7; i++)

463 
buf
[
n
++] = 
m_bySveAddr
[
i
];

465 
buf
[
n
++] = 0x01;

466 
buf
[
n
++] = 0x03;

468 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI0
;

469 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI1
;

470 
buf
[
n
++] = ( ++
m_byS
 ) % 0xff;

471 
buf
[
n
++] = 
	`GCs
bu+ 
m_byFENum
,en - m_byFENum );

472 
buf
[
n
++] = 0x16;

474  
TRUE
;

475 
	}
}

487 
BOOL
 
	gCCjt188_2004
::
	$TimeSync
 ( 
BYTE
 *
buf
, &
n
 )

489 
REALTIME
 
curTime
;

490 
n
 = 0;

491  
i
=0; i<
m_byFENum
; i++)

493 
buf
[
n
++] = 0xfe;

495 
buf
[
n
++] = 0x68;

496 
buf
[
n
++] = 
m_byMTy
;

498  
i
=0; i<7; i++)

500 
buf
[
n
++] = 
m_bySveAddr
[
i
];

502 
buf
[
n
++] = 0x04;

503 
buf
[
n
++] = 0x0a;

506 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI0
;

507 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI1
;

509 
buf
[
n
++] = ( ++
m_byS
 ) % 0xff;

511 
	`GCutTime
&
curTime
 );

512 
buf
[
n
++] = 
	`BcdToHex
(
BYTE
)
curTime
.
wSecd
 );

513 
buf
[
n
++] = 
	`BcdToHex
(
BYTE
)
curTime
.
wMu
 );

514 
buf
[
n
++] = 
	`BcdToHex
(
BYTE
)
curTime
.
wHour
);

515 
buf
[
n
++] = 
	`BcdToHex
(
BYTE
)
curTime
.
wDay
);

516 
buf
[
n
++] = 
	`BcdToHex
(
BYTE
)
curTime
.
wMth
 ) ;

517 
buf
[
n
++] = 
	`BcdToHex
(
BYTE
)(
curTime
.
wYr
%100));

518 
buf
[
n
++] = 
	`BcdToHex
(
BYTE
)(
curTime
.
wYr
/100));

520 
buf
[
n
++] = 
	`GCs
bu+ 
m_byFENum
,en - m_byFENum );

521 
buf
[
n
++] = 0x16;

523  
TRUE
;

524 
	}
}

536 
BOOL
 
	gCCjt188_2004
::
	$GSdBuf
 ( 
BYTE
 *
buf
, &
n
 )

538  
m_byDaTy
 )

540 
CJT188_READDATA_DATATYPE
:

541 
	`t
( "" );

542  
	`RequeRdDa

buf
, 
n
 );

545 
CJT188_TIME_DATATYPE
:

546 
	`t
( "ʱ" );

547  
	`TimeSync

buf
, 
n
 );

551 
	`rtf

m_szPrtBuf
, "Cjt188_2004 %dô", 
m_bySdPos
 );

552 
	`t

m_szPrtBuf
 );

553  
FALSE
;

556  
TRUE
;

557 
	}
}

568 
BOOL
 
	gCCjt188_2004
::
	$InProcStus
 ( )

570 
m_bLkStus
 = 
FALSE
;

571 
m_bySdPos
 = 0;

572 
m_byDaTy
 = 0;

573 
m_byRecvECou
 = 0;

574 
m_bIsReSd
 = 
FALSE
;

575 
m_byRendCou
 = 0;

576 
m_bIsSdg
 = 
FALSE
;

577 
m_bIsNdRend
 = 
TRUE
;

578 
m_bTimeSynFg
 = 
FALSE
;

579 
m_bLkTimeSyn
 = 
TRUE
;

580 
m_byS
 = 0;

583 
m_byReSdL
 = 0;

584 
	`memt

m_byReSdBuf
, 0, 
CJT188_MAX_BUF_LEN
 );

586  
TRUE
;

587 
	}
}

599 
	gCCjt188_2004
::
	$InSdCfgInfo
 ( )

601 
Cjt188CfgInfo
 
tCfgInfo
;

604 
tCfgInfo
.
byDaTy
 = 
CJT188_READDATA_DATATYPE
;

605 
tCfgInfo
.
byDI0
 = 0x1f;

606 
tCfgInfo
.
byDI1
 = 0x90;

607 
tCfgInfo
.
byCye
 = 1;

608 
m_CfgInfo
.
	`push_back

tCfgInfo
 );

611 
tCfgInfo
.
byDaTy
 = 
CJT188_TIME_DATATYPE
;

612 
tCfgInfo
.
byDI0
 = 0x15;

613 
tCfgInfo
.
byDI1
 = 0xA0;

614 
tCfgInfo
.
byCye
 = 0;

615 
m_CfgInfo
.
	`push_back

tCfgInfo
 );

616 
	}
}

628 
BOOL
 
	gCCjt188_2004
::
	$GDevNameToAddr
 ( )

630 
n
 = 
	`

m_sDevName
 );

631 if
n
 < 14)

633  
FALSE
;

636 
m_bySveAddr
[6] = 
	`oh

m_sDevName
 + 
n
 - 14, 2, 1 );

637 
m_bySveAddr
[5] = 
	`oh

m_sDevName
 + 
n
 - 12, 2, 1 );

638 
m_bySveAddr
[4] = 
	`oh

m_sDevName
 + 
n
 - 10, 2, 1 );

639 
m_bySveAddr
[3] = 
	`oh

m_sDevName
 + 
n
 - 8, 2, 1 );

640 
m_bySveAddr
[2] = 
	`oh

m_sDevName
 + 
n
 - 6, 2, 1 );

641 
m_bySveAddr
[1] = 
	`oh

m_sDevName
 + 
n
 - 4, 2, 1 );

642 
m_bySveAddr
[0] = 
	`oh

m_sDevName
 + 
n
 - 2, 2, 1 );

644  
TRUE
;

646 
	}
}

657 
	gCCjt188_2004
::
	$TimProc
 ( )

659 if! 
m_bLkStus
 )

666 i
m_bIsReSd
 && 
m_byRendCou
 >
CJT188_MAX_RESEND_COUNT
 )

668 
	`rtf

m_szPrtBuf
, "nd cou %d >%d InProcStus", 
m_byRendCou
, 
CJT188_MAX_RESEND_COUNT
 );

669 
	`t

m_szPrtBuf
 );

670 
	`InProcStus
( );

674 i
m_byRecvECou
 >
CJT188_MAX_RECV_ERR_COUNT
 )

676 
	`rtf

m_szPrtBuf
, "cv cou %d >%d InProcStus", 
m_byRecvECou
, 
CJT188_MAX_RECV_ERR_COUNT
 );

677 
	`t

m_szPrtBuf
 );

678 
	`InProcStus
( );

680 
	}
}

692 
BOOL
 
	gCCjt188_2004
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

694 
pos
 = 0;

695 
BOOL
 
bR
 = 
TRUE
;

697 
	`t
( "ProcessProtocolBuf" );

699 if!
	`WhhBufVue

buf
, 
n
 , 
pos
 ) )

702 
	`t
 ( "Cjt1886 WhetherBufValue buf Recvrr!!!\n" );

703 
m_byRecvECou
 ++;

704 
m_bIsReSd
 = 
TRUE
;

705  
FALSE
;

709 
bR
 = 
	`ProssBuf

buf
+
m_byFENum
, 
n
 );

710 if!
bR
 )

712 
	`t
( "ķδ" );

716 
m_byRecvECou
 = 0;

717 
m_bLkStus
 = 
TRUE
;

718 
m_bIsReSd
 = 
FALSE
;

719 
m_byRendCou
 = 0;

720 
m_bIsSdg
 = 
FALSE
;

723  
TRUE
;

724 
	}
}

736 
BOOL
 
	gCCjt188_2004
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

738 
BOOL
 
bR
 = 
TRUE
;

740 i
m_bIsReSd
 && 
m_bIsSdg
 )

742 
n
 = 
m_byReSdL
;

743 
	`memy

buf
, 
m_byReSdBuf
, 
n
 );

744 
m_byRendCou
 ++;

746 if
m_bLkStus
 && 
pBusMsg
 !
NULL
 )

748 
	`t
( "Ϣ" );

750  
FALSE
;

754 
	`t
( "GetSendBuf" );

756 
	`ChgeSdPos
( );

757 
m_byDaTy
 = 
m_CfgInfo
[
m_bySdPos
].
byDaTy
;

760 if
	`IsTimeToSync
() )

762 
i
;

763 
	`t
( "timeo sync" );

764 
m_byDaTy
 = 
CJT188_TIME_DATATYPE
;

765  
i
=0; i<()
m_CfgInfo
.
	`size
(); i++ )

767 if
CJT188_TIME_DATATYPE
 =
m_CfgInfo
[
i
].
byDaTy
 )

769 
m_bySdPos
 = 
i
;

774 
m_bIsNdRend
 = 
FALSE
;

778 
bR
 = 
	`GSdBuf

buf
, 
n
 );

780 i
bR
 && 
n
 > 0)

783 
m_byReSdL
 = 
n
;

784 
	`memy

m_byReSdBuf
, 
buf
, 
m_byReSdL
 );

785 
m_bIsReSd
 = 
TRUE
;

787 
m_bIsSdg
 = 
TRUE
;

789 if!
m_bIsNdRend
 )

791 
m_bIsSdg
 = 
FALSE
;

792 
m_bIsNdRend
 = 
TRUE
;

797  
bR
;

798 
	}
}

810 
BOOL
 
	gCCjt188_2004
::
	$In
 ( 
BYTE
 
byLeNo
 )

812 
	`as

byLeNo
 <= 22 );

814 if!
	`GDevNameToAddr
( ) )

816 
	`t
 ( "CCjt188_2004:Addr Err!!!\n" );

817  
FALSE
;

821 if!
	`RdCfgInfo
() )

823 
	`t
 ( "CCjt188_2004:ReadCfgInfo Err!!!\n" );

824  
FALSE
;

828 if!
	`InProcStus
() )

830 
	`t
 ( "CCjt188_2004:InitProtocolStatus Err\n" );

831  
FALSE
;

835 
	`InSdCfgInfo
( );

836 if
m_CfgInfo
.
	`emy
() )

838 
	`tf
 ( "CCjt188_2004:can't findhe InitSendCfgInfo\n" );

839  
FALSE
;

842 
	`t
( "Cjt188 Init OK" );

843  
TRUE
;

844 
	}
}

856 
BOOL
 
	gCCjt188_2004
::
	$GDevCommS
 ( )

858 i
m_bLkStus
 )

859  
COM_NORMAL
;

861  
COM_DEV_ABNORMAL
;

862 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/Cjt188_2004.h

21 #ide 
CJT188_2007_INC


22 
	#CJT188_2007_INC


	)

24 
	~"CProc_Cjt188.h
"

33 as
	cCCjt188_2004
 : 
public
 
CProc_Cjt188


35 
public
:

37 
CCjt188_2004
 ();

38 ~
CCjt188_2004
 ();

40 
vtu
 
TimProc
( );

42 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

44 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

46 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

48 
vtu
 
BOOL
 
GDevCommS
( ) ;

50 
	mpublic
:

54 
public
:

55 
eed
:

58 
vtu
 
BOOL
 
RequeRdDa

BYTE
 *
buf
, &
n
 );

60 
BOOL
 
ProssDaT1
 ( cڡ 
BYTE
 *
buf
, 
n
 );

62 
BOOL
 
ProssDaT2
 ( cڡ 
BYTE
 *
buf
, 
n
 );

64 
BOOL
 
ProssDaT3
 ( cڡ 
BYTE
 *
buf
, 
n
 );

66 
vtu
 
BOOL
 
ProssRdDa
cڡ 
BYTE
 *
buf
, 
n
 );

68 
vtu
 
BOOL
 
TimeSync

BYTE
 *
buf
, &
n
 );

70 
vtu
 
InSdCfgInfo
( );

72 
	mive
:

75 
BOOL
 
IsTimeToSync
( );

77 
BOOL
 
InProcStus
( );

79 
BOOL
 
GSdBuf

BYTE
 *
buf
, &
n
 );

81 
BOOL
 
ProssBuf
cڡ 
BYTE
 *
buf
, 
n
 );

83 
BOOL
 
GDevNameToAddr
( );

85 
	mive
:

86 
BOOL
 
m_bLkTimeSyn
;

87 
BOOL
 
	mm_bLkStus
;

88 
BOOL
 
	mm_bIsSdg
;

89 
BOOL
 
	mm_bIsReSd
;

90 
BOOL
 
	mm_bIsNdRend
;

91 
BOOL
 
	mm_bTimeSynFg
;

94 
BYTE
 
	mm_byRendCou
;

95 
BYTE
 
	mm_byReSdBuf
[
CJT188_MAX_BUF_LEN
];

96 
BYTE
 
	mm_byReSdL
;

98 
BYTE
 
	mm_byRecvECou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_Cjt188.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

10 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

12 
CProc
 * 
pProc
 = 
NULL
 ;

13 
pProc
 = 
w
 
CProc_Cjt188
 ;

14 if
pProc
 )

16 
pProc
->
m_pMhod
 = 
pMhod
 ;

17 
	`tf
( "CJ/T188 OK.\n " ) ;

20  
pProc
 ;

21 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/CProtocol_DDB.cpp

1 
	~"CProc_DDB.h
"

2 
	~"DDB.h
"

4 
	#MODULE_RTU
 1

	)

6 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

8 
	gCProc_DDB
::
	$CProc_DDB
()

11 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

13 
	}
}

15 
	gCProc_DDB
::~
	$CProc_DDB
()

18 
size
 = 
m_modu
.
	`size
() ;

19  
i
 = 0 ; i < 
size
 ; i++ )

21 
de
 
m_modu
[ 
i
 ] ;

23 
m_modu
.
	`r
() ;

24 
	`tf
( "Delete All CProtocol_DDB OK . \n" );

25 
	}
}

27 
BOOL
 
	gCProc_DDB
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

29  
FALSE
 ;

30 
	}
}

32 
BOOL
 
	gCProc_DDB
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

34  
FALSE
 ;

35 
	}
}

37 
BOOL
 
	gCProc_DDB
::
	$In

BYTE
 
byLeNo
 )

40 
m_byLeNo
 = 
byLeNo
 ;

42 
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

44  
	`GDevDa
( ) ;

45 
	}
}

47 
BOOL
 
	gCProc_DDB
::
	$GDevDa
( )

49 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

50 
	`rtf

m_sDevPh
 , "%s/DDB/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

51 
CProfe
 
	`ofe

m_sDevPh
 ) ;

53  
	`ProssFeDa

ofe
 ) ;

54 
	}
}

56 
BOOL
 
	gCProc_DDB
::
	$ProssFeDa

CProfe
 &
ofe
 )

58 
BOOL
 
bR
 = 
FALSE
;

59 if!
ofe
.
	`IsVid
() )

61 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

62  
FALSE
 ;

65 
sSe
[ 200 ] = "DEVNUM" ;

66 
sKey
[ 20 ][ 100 ]={ "module" , "addr" , "name" , "template" } ;

68 
WORD
 
wModu
 = 0 ;

69 
WORD
 
addr
 =3 ;

70 
sName
[ 50 ] = { 0 };

71 
eme
[ 200 ] = { 0 };

72 
iNum
 = 0 ;

74 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

75 if
iNum
 == 0 )

77 
	`tf
( "Get DEVNUM Failed ! \n " );

78  
FALSE
 ;

81  
i
 = 0 ; i < 
iNum
 ; i++ )

83 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

85 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

86 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

87 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 2 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

88 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

91 
bR
 = 
	`CeModu

wModu
 , 
addr
 , 
sName
 , 
eme
 ) ;

92 i!
bR
 )

94 
	`tf
 ( "CModBuModu=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
addr
, 
sName
, 
eme
 );

96  
FALSE
;

100  
TRUE
 ;

101 
	}
}

103 
BOOL
 
	gCProc_DDB
::
	$CeModu

iModu
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

105 
CProc_DDB
 * 
pProc
 = 
NULL
 ;

107  
iModu
 )

109 
MODULE_RTU
:

111 
pProc
 = 
w
 
CDDB
 ;

112 
pProc
->
m_byLeNo
 = m_byLineNo ;

113 
pProc
->
m_wModuTy
 = 
iModu
 ;

114 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

116 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

117 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

118 
pProc
->
m_pMhod
 = m_pMethod ;

119 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

121 if!
pProc
->
	`In

m_byLeNo
 ) )

122  
FALSE
 ;

123 
	`tf
" Add bu%d Add%d \n" , 
m_byLeNo
 , 
iAddr
 ) ;

128 
	`tf
( "ModBus don't containhis module Failed .\n" );

129  
FALSE
 ;

132 
m_modu
.
	`push_back

pProc
 ) ;

134  
TRUE
 ;

135 
	}
}

138 
BOOL
 
	gCProc_DDB
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

140  
TRUE
 ;

141 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/CProtocol_DDB.h

1 #ide
CPROTOCOL_DDB_H


2 
	#CPROTOCOL_DDB_H


	)

4 
	~"../../she/CProc.h
"

5 
	~"../../she/CMhod.h
"

6 
	~"../../libdb/rdbObj.h
"

7 
	~"../../she/rdbDef.h
"

8 
	~<time.h
>

9 
	~<sys/time.h
>

12 as
	cCProc_DDB
 : 
public
 
CProc


14 
public
:

15 
CProc_DDB
();

16 
	mvtu
 ~
CProc_DDB
();

17 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

18 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

19 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

20 
vtu
 
	$TimProc
(){ ; }

22 
eed
:

23 
BOOL
 
	`GDevDa
( ) ;

24 
eed
:

25 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

26 
BOOL
 
	`CeModu

iModu
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

27 
BOOL
 
	`BrdCa

BYTE
 * 
buf
 , &
n
 );

28 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/DDB.cpp

19 
	~<dio.h
>

20 
	~<unid.h
>

21 
	~"../../BayLay/CPublicMhod.h
"

22 
	~"DDB.h
"

25 
	#DDBDEBUG
 1

	)

26 
	#DDBPRINT
 1

	)

29 "C" 
SCutTime

REALTIME
 *
pRlTime
 );

30 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

31 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

39 
	gCDDB
::
	$CDDB
 ()

41 
m_byLolStus
 = 
STATUS_SLAVE
;

42 
m_byRemeStus
 = 
STATUS_MASTER
;

45 
m_bSwchS
 = 
FALSE
;

46 
m_bTimeProcCou
 = 0;

48 
m_byMacheId
 = 
IDENTITY_SINGLE
;

50 
m_wAYcNum
 = 0;

51 
m_wAYxNum
 = 0;

52 
m_wAYmNum
 = 0;

54 
m_pYcHdAddr
 = 0;

55 
m_pYxHdAddr
 = 0;

56 
m_pYmHdAddr
 = 0;

58 
m_iDayedSwchMu
 = 0;

59 
m_iDayedSynSecd
 = 0;

60 
m_tmLaSwchTime
 = 0;

61 
m_tmNowSwchTime
 = 0;

62 
m_byQuickSwchNum
 = 0;

64 
m_bRecvReڣSwch
 = 
FALSE
;

67 
	`InProcStus
( );

68 
	}
}

77 
	gCDDB
::~
	$CDDB
 ()

79 
	}
}

93 
BOOL
 
CDDB
::
	$GSSPosAndNum
 ( 
BYTE
 
byDaTy
, 
STNPARAM
 *
pS
, 
DWORD
 &
dwSPos
, 
WORD
 &
wCou
 )

95  
byDaTy
 )

98 
wCou
 = 
pS
->
wDigSum
;

99 
dwSPos
 = 
pS
->
dwDigPos
;

103 
wCou
 = 
pS
->
wAlogSum
;

104 
dwSPos
 = 
pS
->
dwAlogPos
;

108 
wCou
 = 
pS
->
wPulSum
;

109 
dwSPos
 = 
pS
->
dwPulPos
;

113  
FALSE
;

117  
TRUE
;

118 
	}
}

134 
BOOL
 
	gCDDB
::
	$GSlNoAndP
 (
BYTE
 
byDaTy
, 
WORD
 
wPos
, WORD &
wSlNo
, WORD &
wP
, 
STNPARAM
 *
pS
 )

136 
i
;

137 
WORD
 
wSNum
;

138 
WORD
 
wCou
;

139 
DWORD
 
dwSPos
;

142 
byDaTy
)

144 
DDB_YX_DATATYPE
:

146 if
wPos
 > 
MAX_DIGITAL_SUM
 || wPo> 
m_pMhod
->
m_pRdbObj
->
m_nDigSum
 )

148 
	`t
 ( (*)"DDB:GetSerialNoAndPnt yx wPos isoo big!!!" );

149  
FALSE
;

154 
DDB_YC_DATATYPE
:

156 if
wPos
 > 
MAX_ANALOG_SUM
 || wPo> 
m_pMhod
->
m_pRdbObj
->
m_nAlogSum
 )

158 
	`t
 ( (*)"DDB:GetSerialNoAndPnt yc wPos isoo big!!!" );

159  
FALSE
;

164 
DDB_YM_DATATYPE
:

166 if
wPos
 > 
MAX_PULSE_SUM
 || wPo> 
m_pMhod
->
m_pRdbObj
->
m_nPulSum
 )

168 
	`t
 ( (*)"DDB:GetSerialNoAndPnt ym wPos isoo big!!!" );

169  
FALSE
;

174  
FALSE
;

179 if
pS
 =
NULL
 )

181 
pS
 = &
m_pMhod
->
m_pRdbObj
->
m_pRTDBS
->
RTDBa
.
SUn
[0];

182 
wSNum
 = 
m_pMhod
->
m_pRdbObj
->
m_wSSum
;

184  
i
=0; i<
wSNum
; i++, 
pS
++)

186 i!
	`GSSPosAndNum

byDaTy
, 
pS
, 
dwSPos
, 
wCou
 ) )

188 
	`t
 ( (*)"DDB:GetSerialNoAndPnt get stn startposndumrror!!!" );

193 i
wPos
 >
dwSPos
 && wPo< ( 
wCou
 + dwStartPos ) )

195 
wSlNo
 = 
pS
->
wSNum
;

196 
wP
 = 
wPos
 - 
dwSPos
;

203 i!
	`GSSPosAndNum

byDaTy
, 
pS
, 
dwSPos
, 
wCou
 ) )

205 
	`t
 ( (*)"DDB:GetSerialNoAndPnt get stn startposndumrror!!!" );

208 if
wPos
 >
wCou
 + 
dwSPos
)

210 
pS
 ++;

213 
wSlNo
 = 
pS
->
wSNum
;

214 
wP
 = 
wPos
 - 
dwSPos
;

217  
TRUE
;

218 
	}
}

229 
BOOL
 
	gCDDB
::
	$SwchStus
 ( 
BOOL
 
bStus
 )

231 if
bStus
 )

234 if
m_byLolStus
 =
STATUS_MASTER
 )

236  
FALSE
;

240 
m_byLolStus
 = 
STATUS_MASTER
;

241 
m_byRemeStus
 = 
STATUS_SLAVE
;

243 
	`t
( (*)"Ϊ ԶΪ\n" );

254 if
m_byLolStus
 =
STATUS_SLAVE
 )

256  
FALSE
;

260 
m_byLolStus
 = 
STATUS_SLAVE
;

261 
m_byRemeStus
 = 
STATUS_MASTER
;

264 
m_bRecvReڣSwch
 = 
TRUE
;

266 
	`t
( (*)"Ϊӻ ԶΪ\n" );

276 
CPublicMhod
::
	`SDDBSyncS

m_byLolStus
 );

277  
TRUE
;

278 
	}
}

280 
BOOL
 
	gCDDB
::
	$DevSSwchStus
 ( 
BOOL
 
bStus
 )

282 
m_bTimeProcCou
 = 0;

284 
	`SwchStus

bStus
 );

286 
	`time
(&
m_tmNowSwchTime
);

287 
time_t
 
TimeDifn
 = 
	`abs
(
m_tmNowSwchTime
 - 
m_tmLaSwchTime
);

288 
	`tf
("%lu = %lu -%lu \n",
TimeDifn
,
m_tmNowSwchTime
,
m_tmLaSwchTime
);

289 if
TimeDifn
 < 
m_iDayedSynSecd
+10 || 
m_byQuickSwchNum
 == 0 )

291 
m_tmLaSwchTime
 = 
m_tmNowSwchTime
;

292 
m_byQuickSwchNum
++;

293 
	`tf
("m_byQuickSwchNum = %d\n",
m_byQuickSwchNum
);

294 if
m_byQuickSwchNum
 > 6)

296 
m_byQuickSwchNum
 = 6;

301 
m_tmNowSwchTime
 = 0;

302 
m_tmLaSwchTime
 = 0;

303 
m_byQuickSwchNum
 = 0;

306 
	`InProcStus
( );

314 
	`t
((*)"~~~~~~~~~~~~~~~~~~~~~~~~~~\n");

315  
TRUE
;

316 
	}
}

328 
WORD
 
	gCDDB
::
	$GDaNum
 ( 
BYTE
 
byDaTy
 )

330 
WORD
 
wDaSum
 = 0;

331  
byDaTy
 )

334 
wDaSum
 = 
m_pMhod
->
m_pRdbObj
->
m_nDigSum
;

338 
wDaSum
 = 
m_pMhod
->
m_pRdbObj
->
m_nAlogSum
;

342 
wDaSum
 = 
m_pMhod
->
m_pRdbObj
->
m_nPulSum
;

348  
wDaSum
;

349 
	}
}

361 
DWORD
 
	gCDDB
::
	$GDaHdAddr
 ( 
BYTE
 
byDaTy
 )

363 
DWORD
 
dwHdAddr
 = 0;

365  
byDaTy
 )

368 
dwHdAddr
 = (
DWORD
)&
m_pMhod
->
m_pRdbObj
->
m_pRTDBS
->
RTDBa
.
DigTab
[0] ;

372 
dwHdAddr
 = (
DWORD
)&
m_pMhod
->
m_pRdbObj
->
m_pRTDBS
->
RTDBa
.
AlogTab
[0] ;

376 
dwHdAddr
 = (
DWORD
)&
m_pMhod
->
m_pRdbObj
->
m_pRTDBS
->
RTDBa
.
PulTab
[0] ;

383  
dwHdAddr
;

384 
	}
}

395 
	gCDDB
::
	$GCommFme
 ( 
BYTE
 *
buf
, BYTE 
byFuncCode
 )

397 
BYTE
 
byFmeTy
;

399 
buf
[0]=0x68;

400 
buf
[1]=0x16;

402 
byFmeTy
 = 
byFuncCode
 & 0x0F;

404 i(
m_byMacheId
 =
IDENTITY_B
)

405 
byFmeTy
 |= 0x10;

407 if(
m_byLolStus
 =
STATUS_SLAVE
)

408 
byFmeTy
 |= 0x20;

410 
buf
[3] = 
byFmeTy
;

411 
	}
}

423 
WORD
 
	gCDDB
::
	$GCrc
 ( 
BYTE
 *
pBuf
, 
nL
 )

426 
WORD
 
Gpy
=0xA001;

427 
WORD
 
CRC
=0xFFFF;

428 
WORD
 
dex
;

429 
nL
--)

431 
CRC
=CRC^(
WORD
)*
pBuf
++;

432 
dex
=0;index<8;index++)

434 if((
CRC
 & 0x0001)==1)

435 
CRC
=(CRC>>1)^
Gpy
;

437 
CRC
=CRC>>1;

441  
CRC
;

442 
	}
}

454 
	gCDDB
::
	$t
 ( *
szBuf
 )

457 #ifde 
DDBDEBUG


458 
	`tf
 ( "%s", 
szBuf
 );

461 #ifde
DDBPRINT


462 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
szBuf
,
	`
(szBuf) , 2);

466 
	}
}

478 
BOOL
 
	gCDDB
::
	$YcDaDl
 ( 
BYTE
 *
buf
, 
n
 )

480 
WORD
 
wDaNum
;

481 
WORD
 
wDaPos
;

482 
DWORD
 
dwYcV
;

483 
STNPARAM
 *
pS
 = 
NULL
;

484 
BYTE
 *
por
 = 
buf
;

485 
WORD
 
wSlNo
, 
wP
;

487 
wDaNum
 = ( 
por
[5] << 8 ) |ointer[6];

488 
wDaPos
 = ( 
por
[7] << 8 ) |ointer[8];

490 
por
 += 9;

491  
wDaNum
 > 0 )

493 
	`memy
&
dwYcV
, 
por
, 4 );

495 i
	`GSlNoAndP
2, 
wDaPos
, 
wSlNo
, 
wP
, 
pS
 ) )

497 
m_pMhod
->
	`SYcDa

wSlNo
, 
wP
, ()
dwYcV
 );

500 
por
 += 4;

501 
wDaPos
++;

502 
wDaNum
--;

505 
m_wDaPos
 = 
wDaPos
;

506  
TRUE
;

507 
	}
}

518 
BOOL
 
	gCDDB
::
	$YxDaDl
 ( 
BYTE
 *
buf
, 
n
 )

520 
WORD
 
wDaNum
;

521 
WORD
 
wDaPos
;

522 
BYTE
 
byTmp
, 
i
;

523 
BYTE
 *
por
 = 
buf
;

524 
STNPARAM
 *
pS
 = 
NULL
;

525 
WORD
 
wSlNo
, 
wP
;

526 
BYTE
 
byYxV
;

528 
wDaNum
 = ( 
por
[5] << 8 ) |ointer[6];

529 
wDaPos
 = ( 
por
[7] << 8 ) |ointer[8];

531 
por
 += 9;

533  
wDaNum
 > 0 )

535 
byTmp
 = *
por
;

536 
i
=0; i<8; i++)

538 if
byTmp
 & ( 0x01 << 
i
 ) )

540 
byYxV
 = 1;

544 
byYxV
 = 0;

547 i
	`GSlNoAndP
 (1,
wDaPos
, 
wSlNo
, 
wP
, 
pS
 ) )

549 
m_pMhod
->
	`SYxDa

wSlNo
, 
wP
, 
byYxV
 );

552 
wDaNum
 -- ;

553 
wDaPos
 ++;

555 if
wDaNum
 == 0 )

559 
por
 ++;

562 
m_wDaPos
 = 
wDaPos
;

563  
TRUE
;

564 
	}
}

575 
BOOL
 
	gCDDB
::
	$YmDaDl
 ( 
BYTE
 *
buf
, 
n
 )

577 
WORD
 
wDaNum
;

578 
WORD
 
wDaPos
;

579 
DWORD
 
dwYmV
;

580 
BYTE
 *
por
 = 
buf
;

581 
WORD
 
wSlNo
, 
wP
;

582 
STNPARAM
 *
pS
 = 
NULL
;

584 
wDaNum
 = ( 
por
[5] << 8 ) |ointer[6];

585 
wDaPos
 = ( 
por
[7] << 8 ) |ointer[8];

587 
por
 += 9;

589  
wDaNum
 > 0 )

591 
	`memy
&
dwYmV
, 
por
, 4 );

593 i
	`GSlNoAndP
3, 
wDaPos
, 
wSlNo
, 
wP
, 
pS
 ) )

595 
m_pMhod
->
	`SYmDa

wSlNo
, 
wP
, 
dwYmV
 );

597 
por
 += 4;

598 
wDaPos
++;

599 
wDaNum
--;

602 
m_wDaPos
 = 
wDaPos
;

603  
TRUE
;

604 
	}
}

616 
BOOL
 
	gCDDB
::
	$TimeSyncDl
 ( 
BYTE
 *
buf
, 
n
 )

618 
REALTIME
 
CuTime
;

620 
CuTime
.
wYr
 = ( 
buf
[5] << 8 ) | buf[6];

621 
CuTime
.
wMth
 = 
buf
[7];

622 
CuTime
.
wDay
 = 
buf
[8];

623 
CuTime
.
wHour
 = 
buf
[9];

624 
CuTime
.
wMu
 = 
buf
[10];

625 
CuTime
.
wSecd
 = 
buf
[11];

626 
CuTime
.
wMliSec
 = ( 
buf
[12] << 8 ) | buf[13];

628 
	`SCutTime
&
CuTime
 );

629  
TRUE
;

630 
	}
}

640 
BOOL
 
	gCDDB
::
	$LkBusStusDl
(
BYTE
 *
buf
, 
n
)

642 
WORD
 
wDaNum
;

643 
WORD
 
wDaPos
;

644 
BYTE
 *
por
 = 
buf
;

647 
wDaNum
 = ( 
por
[5] << 8 ) |ointer[6];

648 
wDaPos
 = ( 
por
[7] << 8 ) |ointer[8];

650 
por
 += 8;

652  
wDaNum
 > 0 )

654 
por
 ++;

655 
i
 = 0; i < 8; i++)

657 
BOOL
 
bStus
 = ( *
por
 >> 
i
 ) & 0x01;

658 
CPublicMhod
::
	`SDDBBusLkStus
(
wDaPos
, 
bStus
);

661 
wDaPos
++;

662 
wDaNum
--;

663 if0 =
wDaNum
 )

670 
m_wDaPos
 = 
wDaPos
;

671  
TRUE
;

672 
	}
}

681 
BOOL
 
	gCDDB
::
	$LkSStusDl
(
BYTE
 *
buf
, 
n
)

683 
WORD
 
wDaNum
;

684 
WORD
 
wDaPos
;

685 
BYTE
 *
por
 = 
buf
;

688 
wDaNum
 = ( 
por
[5] << 8 ) |ointer[6];

689 
wDaPos
 = ( 
por
[7] << 8 ) |ointer[8];

691 
por
 += 8;

693  
wDaNum
 > 0 )

695 
por
 ++;

696 
i
 = 0; i < 8; i++)

698 
BOOL
 
bStus
 = ( *
por
 >> 
i
 ) & 0x01;

699 
CPublicMhod
::
	`SDDBSLkStus
(
wDaPos
, 
bStus
);

700 
	`tf
("dȡn%d stus=%d\n", 
wDaPos
, 
bStus
);

701 
wDaPos
++;

702 
wDaNum
--;

703 if0 =
wDaNum
 )

710 
m_wDaPos
 = 
wDaPos
;

711  
TRUE
;

713 
	}
}

725 
BOOL
 
	gCDDB
::
	$ProssRecvDaBuf
 ( 
BYTE
 *
buf
, 
n
 )

727 
BOOL
 
bR
 = 
FALSE
;

729  
buf
[4] )

731 
DDB_YC_DATATYPE
:

732 
bR
 = 
	`YcDaDl

buf
, 
n
 );

733 if
buf
[3] & 0x80 )

735 
	`t
( (*)"ycnd\n" );

736 
m_byDaTy
 = 
DDB_YM_DATATYPE
;

737 
m_wDaPos
 = 0;

741 
DDB_YX_DATATYPE
:

742 
bR
 = 
	`YxDaDl

buf
, 
n
 );

743 if
buf
[3] & 0x80 )

745 
	`t
( (*)"yxnd\n" );

746 
m_byDaTy
 = 
DDB_YC_DATATYPE
;

747 
m_wDaPos
 = 0;

751 
DDB_YM_DATATYPE
:

752 
bR
 = 
	`YmDaDl

buf
, 
n
 );

753 if
buf
[3] & 0x80 )

755 
	`t
( (*)"ymnd\n" );

756 
m_byDaTy
 = 
DDB_LINKBUSSTATUS_DATATYPE
;

757 
m_wDaPos
 = 0;

761 
DDB_TIME_DATATYPE
:

762 
bR
 = 
	`TimeSyncDl

buf
, 
n
 );

763 
	`t
( (*)"timesyncnd\n" );

764 
m_byDaTy
 = 
DDB_YX_DATATYPE
;

765 
m_wDaPos
 = 0;

769 
DDB_LINKBUSSTATUS_DATATYPE
:

771 
	`t
( (*)"bus begin\n" );

772 
	`LkBusStusDl

buf
,
n
);

773 if
buf
[3] & 0x80 )

775 
	`t
( (*)"busnd\n" );

776 
m_byDaTy
 = 
DDB_LINKSTNSTATUS_DATATYPE
;

777 
m_wDaPos
 = 0;

782 
DDB_LINKSTNSTATUS_DATATYPE
:

784 
	`LkSStusDl

buf
, 
n
 );

785 if
buf
[3] & 0x80 )

787 
	`t
( (*)"stnnd\n" );

788 
m_byDaTy
 = 
DDB_TIME_DATATYPE
;

789 
m_wDaPos
 = 0;

794 
DDB_YK_DATATYPE
:

795 
	`t
( (*)"yk \n" );

796 if
m_bIsYkg
 )

798 
m_bIsYkg
 = 
FALSE
;

799 
m_byDaTy
 = 
m_bySaveDaTy
;

804 
	`PackSdYkMsg
&
buf
[5] );

812  
bR
;

813 
	}
}

824 
BOOL
 
	gCDDB
::
	$ProssRequeSyn
 ( 
BYTE
 *
buf
, 
n
 )

826 
m_SdStus
 = 
RESPONSE_SYN
;

827  
TRUE
;

828 
	}
}

841 
BOOL
 
	gCDDB
::
	$ProssReڣSyn
 ( 
BYTE
 *
buf
, 
n
 )

848 
m_bRemeSyn
 = 
buf
[4];

850 if!
m_bSyn
 )

883 
	`t
 ( (*)( "״̬Ϊ %d\n" ));

884 if
m_byLolStus
 =
STATUS_SLAVE
 )

887 
m_SdStus
 = 
REQUEST_DATA
;

892 
m_SdStus
 = 
NONESTATUS
;

895 
m_byDaTy
 = 
DDB_YX_DATATYPE
;

898 
m_bSyn
 = 
TRUE
;

909 if
m_byLolStus
 =
STATUS_SLAVE
 )

912 
m_SdStus
 = 
REQUEST_DATA
;

917 
m_SdStus
 = 
RESPONSE_SYN
;

922 
m_byDaTy
 = 
DDB_YX_DATATYPE
;

926  
TRUE
;

927 
	}
}

939 
BOOL
 
	gCDDB
::
	$ProssRequeDa
 ( 
BYTE
 *
buf
, 
n
 )

941 
m_byDaTy
 = 
buf
[4];

942 
m_SdStus
 = 
RESPONSE_DATA
;

944 if
DDB_YK_DATATYPE
 =
m_byDaTy


945 && 
STATUS_MASTER
 =
m_byLolStus
 )

947 
	`t
( (*)"PackSendYkMsg\n" );

948 
	`PackSdYkMsg
&
buf
[5] );

950  
TRUE
;

951 
	}
}

963 
BOOL
 
	gCDDB
::
	$ProssReڣDa
 ( 
BYTE
 *
buf
, 
n
 )

966  
	`ProssRecvDaBuf

buf
, 
n
 );

967 
	}
}

979 
BOOL
 
	gCDDB
::
	$ProssRequeSwch
 ( 
BYTE
 *
buf
, 
n
 )

982 
	`DevSSwchStus
(1);

984 
m_SdStus
 = 
RESPONSE_SWITCH
;

986  
TRUE
;

987 
	}
}

999 
BOOL
 
	gCDDB
::
	$ProssReڣSwch
 ( 
BYTE
 *
buf
, 
n
 )

1001 
	`DevSSwchStus
(0);

1003 
m_SdStus
 = 
REQUEST_DATA
;

1005  
TRUE
;

1006 
	}
}

1018 
BOOL
 
	gCDDB
::
	$PackSdYkMsg
 ( 
BYTE
 *
buf
 )

1020 
m_YkStus
 = (
DDBYKSTATUS
)
buf
[0];

1022 
m_SaveDeYkDa
.
byDeBusNo
 = 
buf
[1];

1023 
m_SaveDeYkDa
.
wDeAddr
 = 
	`MAKEWORD

buf
[3], buf[2] );

1024 
m_SaveDeYkDa
.
wP
 = 
	`MAKEWORD

buf
[5] , buf[4]);

1025 
m_SaveDeYkDa
.
byV
 = 
buf
[6];

1027 if
STATUS_SLAVE
 =
m_byLolStus
 )

1029 
CPublicMhod
::
	`SDDBDevBusAndAddr

m_SaveDeYkDa
.
byDeBusNo
, m_SaveDeYkDa.
wDeAddr
 );

1032 
	`t
((*)"CDDB::PackSendYkMsg\n");

1033  
m_YkStus
 )

1035 
DDB_YK_SEL
:

1036 
	`t
((*)"CDDB::YkSel\n");

1037 
m_pMhod
->
	`SYkS

this
,

1038 
m_SaveDeYkDa
.
byDeBusNo
,

1039 
m_SaveDeYkDa
.
wDeAddr
,

1040 
m_SaveDeYkDa
.
wP
,

1041 
m_SaveDeYkDa
.
byV
);

1042 
m_YkStus
 = 
DDB_YK_SEL_CONFIRM
;

1045 
DDB_YK_EXE
:

1046 
	`t
((*)"CDDB::YkExe\n");

1047 
m_pMhod
->
	`SYkExe

this
,

1048 
m_SaveDeYkDa
.
byDeBusNo
,

1049 
m_SaveDeYkDa
.
wDeAddr
,

1050 
m_SaveDeYkDa
.
wP
,

1051 
m_SaveDeYkDa
.
byV
);

1052 
m_YkStus
 = 
DDB_YK_EXE_CONFIRM
;

1055 
DDB_YK_CANCEL
:

1056 
	`t
((*)"CDDB::YkCancel\n");

1057 
m_pMhod
->
	`SYkCl

this
,

1058 
m_SaveDeYkDa
.
byDeBusNo
,

1059 
m_SaveDeYkDa
.
wDeAddr
,

1060 
m_SaveDeYkDa
.
wP
,

1061 
m_SaveDeYkDa
.
byV
);

1062 
m_YkStus
 = 
DDB_YK_CANCEL_CONFIRM
;

1065 
DDB_YK_SEL_RTN
:

1066 
	`t
((*)"CDDB::YkSelRtn\n");

1067 
m_pMhod
->
	`SYkSR

this
,

1068 
m_bySaveSrcBusNo
,

1069 
m_wSaveSrcDevAddr
,

1070 
m_SaveDeYkDa
.
wP
,

1071 
m_SaveDeYkDa
.
byV
);

1072 
m_YkStus
 = 
DDB_YK_SEL_RTN_CONFIRM
;

1075 
DDB_YK_EXE_RTN
:

1076 
	`t
((*)"CDDB::YkExeRtn\n");

1077 
m_pMhod
->
	`SYkExeR

this
,

1078 
m_bySaveSrcBusNo
,

1079 
m_wSaveSrcDevAddr
,

1080 
m_SaveDeYkDa
.
wP
,

1081 
m_SaveDeYkDa
.
byV
);

1082 
m_YkStus
 = 
DDB_YK_EXE_RTN_CONFIRM
;

1085 
DDB_YK_CANCEL_RTN
:

1086 
	`t
((*)"CDDB::YkCancelRtn\n");

1087 
m_pMhod
->
	`SYkClR

this
,

1088 
m_bySaveSrcBusNo
,

1089 
m_wSaveSrcDevAddr
,

1090 
m_SaveDeYkDa
.
wP
,

1091 
m_SaveDeYkDa
.
byV
);

1092 
m_YkStus
 = 
DDB_YK_CANCEL_RTN_CONFIRM
;

1096 
	`t
((*)"CDDB::YkError\n");

1097 
	`InProcStus
( );

1101 if
DDB_YK_DATATYPE
 !
m_byDaTy
 )

1102 
m_bySaveDaTy
 = 
m_byDaTy
;

1103 
m_byDaTy
 = 
DDB_YK_DATATYPE
;

1105  
TRUE
;

1106 
	}
}

1117 
BOOL
 
	gCDDB
::
	$WhhBufVue
 (
BYTE
 *
buf
, &
n
, &
pos
 )

1119 
szBuf
[256];

1120 
BYTE
 *
por
 = 
buf
;

1121 
WORD
 
wCrc
;

1122 
BYTE
 
byHCrc
, 
byLCrc
;

1123 
BYTE
 
byDaL
;

1124 
pos
 = 0;

1126 if
buf
 =
NULL
 || 
n
 <= 0 )

1127  
FALSE
;

1129  
n
 > 0 )

1131 if0x68 =*
por
 && 0x16 == *(pointer+1))

1133 
byDaL
 = *(
por
+2);

1134 if(
byDaL
+5 > 
n
)

1136 
n
--;

1137 
por
++;

1138 
pos
 ++;

1139 
	`rtf
 (
szBuf
, "n=%d byDaL=%d\n", 
n
, 
byDaL
 );

1140 
	`t

szBuf
 );

1143 
wCrc
 = 
	`GCrc

por
+3, 
byDaL
);

1144 
byHCrc
 = (
wCrc
 >> 8) & 0xff;

1145 
byLCrc
 = 
wCrc
 & 0xff;

1146 i
byHCrc
 !*(
por
 + 3 + 
byDaL
|| 
byLCrc
 != *(ointer + 4 + byDataLen ))

1148 
n
--;

1149 
por
++;

1150 
pos
 ++;

1151 
	`t
 ( (*)"crcrr\n" );

1155  
TRUE
;

1159 
n
--;

1160 
por
++;

1161 
pos
 ++;

1165  
FALSE
;

1166 
	}
}

1179 
	gCDDB
::
	$JudgeStus
 ( )

1181 if
m_byRemeStus
 =
m_byLolStus
 )

1183 if
m_byMacheId
 =
IDENTITY_A
 )

1185 
	`SwchStus
( 1 );

1187 if
m_byMacheId
 =
IDENTITY_B
 )

1189 
	`SwchStus
( 0 );

1192 
	}
}

1204 
	gCDDB
::
	$JudgeStus
 ( 
BYTE
 
byRemeBy
 )

1206 if
byRemeBy
 >> 5 ) & 0x01 )

1208 
m_byRemeStus
 = 
STATUS_SLAVE
;

1212 
m_byRemeStus
 = 
STATUS_MASTER
;

1215 
	`JudgeStus
( );

1216 
	}
}

1227 
BOOL
 
	gCDDB
::
	$ProssRecvTyBuf
 ( 
BYTE
 *
buf
, 
n
 )

1230 
	`JudgeStus

buf
[3] );

1232  
buf
[3]&0x0f )

1234 
REQUEST_SYN
:

1235 
	`t
 ( (*)"DDB RECV REQUEST_SYN\n" );

1236 
	`ProssRequeSyn

buf
, 
n
 );

1239 
RESPONSE_SYN
:

1240 
	`t
 ( (*)"DDB RECV RESPONSE_SYN\n" );

1241 
	`ProssReڣSyn

buf
, 
n
 );

1244 
REQUEST_DATA
:

1246 if
buf
[4] =
DDB_YK_DATATYPE
 && 
m_bIsYkg
)

1248 
	`t
( (*)"yktn\n" );

1249 
m_bIsYkg
 = 
FALSE
;

1250 
m_byDaTy
 = 
m_bySaveDaTy
;

1254 
	`ProssRequeDa

buf
, 
n
 );

1258 
RESPONSE_DATA
:

1260 
	`ProssReڣDa

buf
, 
n
 );

1263 
REQUEST_SWITCH
:

1264 
	`ProssRequeSwch

buf
, 
n
 );

1267 
RESPONSE_SWITCH
:

1268 
	`ProssReڣSwch

buf
, 
n
 );

1274  
TRUE
;

1275 
	}
}

1289 
BOOL
 
	gCDDB
::
	$YcDaSd
 ( 
BYTE
 *
buf
, &
n
 )

1291 
WORD
 
wYcDaNum
 = 
m_wAYcNum
;

1292 
ANALOGITEM
 *
pYcDa
 = 
m_pYcHdAddr
;

1293 
WORD
 
wMaxBy
;

1294 
WORD
 
wLveYcNum
;

1295 
WORD
 
wSdNum
 = 0;

1297 
	`GCommFme
(
buf
, 
RESPONSE_DATA
);

1298 
buf
[4] = 
DDB_YC_DATATYPE
;

1299 
buf
[7] = (
m_wDaPos
 >> 8) & 0xff;

1300 
buf
[8] = 
m_wDaPos
 & 0xff;

1302 
pYcDa
 +
m_wDaPos
;

1303 
wMaxBy
 = 
DDB_MAX_BUF_LEN
 - 11;

1304 
wLveYcNum
 = 
wYcDaNum
 - 
m_wDaPos
;

1305 
n
 = 9;

1307 
wMaxBy
 >4 && 
wLveYcNum
 > 0)

1309 
	`memy
(
buf
+
n
, &(
pYcDa
->
dwRawV
), 4);

1310 
n
 += 4;

1311 
wMaxBy
 -= 4;

1313 
pYcDa
 ++;

1314 
wLveYcNum
 --;

1315 
wSdNum
 ++;

1318 
buf
[5] = (
wSdNum
 >> 8) & 0xff;

1319 
buf
[6] = 
wSdNum
 & 0xff;

1320 
buf
[2] = 
n
-3;

1322 
m_wDaPos
 +
wSdNum
;

1324 if
wLveYcNum
 == 0 )

1326 
buf
[3] |= 0x80;

1327 
m_wDaPos
 = 0;

1330  
TRUE
;

1331 
	}
}

1342 
BOOL
 
	gCDDB
::
	$YxDaSd
 ( 
BYTE
 *
buf
, &
n
 )

1344 
WORD
 
wYxDaNum
 = 
m_wAYxNum
;

1345 
DIGITALITEM
 *
pYxDa
 = 
m_pYxHdAddr
;

1346 
WORD
 
wMaxBy
;

1347 
WORD
 
wLveYxNum
;

1348 
BYTE
 
byTmp
, 
i
;

1349 
WORD
 
wSdNum
 = 0;

1351 
	`GCommFme
(
buf
, 
RESPONSE_DATA
);

1352 
buf
[4] = 
DDB_YX_DATATYPE
;

1353 
buf
[7] = (
m_wDaPos
 >> 8) & 0xff;

1354 
buf
[8] = 
m_wDaPos
 & 0xff;

1356 
pYxDa
 +
m_wDaPos
;

1357 
wMaxBy
 = 
DDB_MAX_BUF_LEN
 - 11;

1358 
wLveYxNum
 = 
wYxDaNum
 - 
m_wDaPos
;

1359 
n
 = 9;

1361 
wMaxBy
 > 0 && 
wLveYxNum
 > 0)

1363 
byTmp
 = 0x00;

1365  
i
=0; i<8; i++)

1367 i
pYxDa
->
wStus
 & 0x01 ) == 1 )

1369 
byTmp
 |(0x01 << 
i
);

1371 
pYxDa
++;

1372 
wLveYxNum
--;

1373 
wSdNum
++;

1374 if(
wLveYxNum
 == 0 )

1378 
buf
[
n
++] = 
byTmp
;

1379 
wMaxBy
 -- ;

1383 
buf
[5] = (
wSdNum
 >> 8) & 0xff;

1384 
buf
[6] = 
wSdNum
 & 0xff;

1385 
buf
[2] = 
n
-3;

1387 
m_wDaPos
 +
wSdNum
 ;

1389 if
wLveYxNum
 == 0 )

1391 
buf
[3] |= 0x80;

1392 
m_wDaPos
 = 0;

1395  
TRUE
;

1396 
	}
}

1407 
BOOL
 
	gCDDB
::
	$YmDaSd
 ( 
BYTE
 *
buf
, &
n
 )

1409 
WORD
 
wYmDaNum
 = 
m_wAYmNum
;

1410 
PULSEITEM
 *
pYmDa
 = 
m_pYmHdAddr
;

1411 
WORD
 
wMaxBy
;

1412 
WORD
 
wLveYmNum
;

1413 
WORD
 
wSdNum
 = 0;

1415 
	`GCommFme
(
buf
, 
RESPONSE_DATA
);

1416 
buf
[4] = 
DDB_YM_DATATYPE
;

1417 
buf
[7] = (
m_wDaPos
 >> 8) & 0xff;

1418 
buf
[8] = 
m_wDaPos
 & 0xff;

1420 
pYmDa
 +
m_wDaPos
;

1421 
wMaxBy
 = 
DDB_MAX_BUF_LEN
 - 11;

1422 
wLveYmNum
 = 
wYmDaNum
 - 
m_wDaPos
;

1423 
n
 = 9;

1425 
wMaxBy
 >4 && 
wLveYmNum
 > 0)

1427 
	`memy
(
buf
+
n
, &(
pYmDa
->
dwRawV
), 4);

1429 
n
 += 4;

1430 
wMaxBy
 -= 4;

1431 
pYmDa
 ++;

1432 
wLveYmNum
 --;

1433 
wSdNum
 ++;

1436 
m_wDaPos
 +
wSdNum
;

1438 
buf
[5] = (
wSdNum
 >> 8) & 0xff;

1439 
buf
[6] = 
wSdNum
 & 0xff;

1440 
buf
[2] = 
n
-3;

1442 i
wLveYmNum
 == 0 )

1444 
buf
[3] |= 0x80;

1445 
m_wDaPos
 = 0;

1447  
TRUE
;

1448 
	}
}

1460 
BOOL
 
	gCDDB
::
	$TimeSyncSd
 ( 
BYTE
 *
buf
, &
n
 )

1462 
REALTIME
 
CuTime
;

1464 
	`GCutTime
&
CuTime
 );

1465 
	`GCommFme

buf
, 
RESPONSE_DATA
 );

1467 
buf
[4] = 
DDB_TIME_DATATYPE
;

1468 
buf
[5] = ( 
CuTime
.
wYr
 >> 8) & 0xff;

1469 
buf
[6] = 
CuTime
.
wYr
 & 0xff;

1470 
buf
[7] = 
CuTime
.
wMth
;

1471 
buf
[8] = 
CuTime
.
wDay
;

1472 
buf
[9] = 
CuTime
.
wHour
;

1473 
buf
[10] = 
CuTime
.
wMu
;

1474 
buf
[11] = 
CuTime
.
wSecd
;

1475 
buf
[12] = ( 
CuTime
.
wMliSec
 >> 8) & 0xff;

1476 
buf
[13] = ( 
CuTime
.
wMliSec
 ) & 0xff;

1478 
n
 = 14;

1479 
buf
[2] = 
n
-3;

1481  
TRUE
;

1482 
	}
}

1493 
BOOL
 
	gCDDB
::
	$LkBusStusSd

BYTE
 *
buf
, &
n
 )

1495 
BYTE
 
byBusNum
 = 
m_pMhod
->
	`GToTBusNum
();

1496 
i
 = 0;

1497 
BYTE
 
byStus
 = 0xff;

1499 
	`GCommFme

buf
, 
RESPONSE_DATA
 );

1501 
buf
[4] = 
DDB_LINKBUSSTATUS_DATATYPE
;

1503 
buf
[5] = ( ( 
byBusNum
 ) >> 8) & 0xff;

1504 
buf
[6] = ( 
byBusNum
 ) & 0xff;

1507 
buf
[7] = (
m_wDaPos
 >> 8) & 0xff;

1508 
buf
[8] = 
m_wDaPos
 & 0xff;

1511 if
MAX_LINE
 < 
byBusNum
 || 0 == byBusNum)

1513  
FALSE
;

1516 
n
 = 9;

1517 
i
 = 0; i < 
byBusNum
; i++)

1520 
BOOL
 
bStus
 = 
m_pMhod
->
	`GCommS
(
i
);

1521 
CPublicMhod
::
	`SDDBBusLkStus
(
i
, 
bStus
);

1523 if
bStus
 )

1525 
byStus
 |
bStus
 << ( 
i
 % 8)) );

1529 
byStus
 &
bStus
 << ( 
i
 % 8)) | ( 0xff >> (8 - ( i % 8))));

1532 i0 =
i
+1 )%8 ) )

1534 
buf
[
n
++] = 
byStus
;

1535 
byStus
 = 0xff;

1539 if0 !
byBusNum
 % 8 ))

1541 
buf
[
n
++] = 
byStus
;

1544 if
i
 !
byBusNum
)

1546  
FALSE
;

1549 
buf
[2] = 
n
 - 3;

1550 
buf
[3] |= 0x80;

1551 
m_wDaPos
 = 0;

1553  
TRUE
;

1554 
	}
}

1564 
BOOL
 
	gCDDB
::
	$LkSStusSd
(
BYTE
 *
buf
, &
n
)

1566 
WORD
 
wSlNum
 = 
m_pMhod
->
m_pRdbObj
->
m_wSSum
;

1568 
BYTE
 
byStus
 = 0xff;

1569 
WORD
 
wMaxBy
;

1570 
WORD
 
wLveStusNum
;

1571 
WORD
 
wSdNum
 = 0;

1573 
	`GCommFme

buf
, 
RESPONSE_DATA
 );

1575 
buf
[4] = 
DDB_LINKSTNSTATUS_DATATYPE
;

1577 
buf
[7] = (
m_wDaPos
 >> 8) & 0xff;

1578 
buf
[8] = 
m_wDaPos
 & 0xff;

1580 
wMaxBy
 = 
DDB_MAX_BUF_LEN
 - 11;

1581 
wLveStusNum
 = ( 
wSlNum
 - 
m_wDaPos
 );

1582 
n
 = 9;

1584 
wMaxBy
 > 1 && 
wLveStusNum
 > 0)

1586 
BOOL
 
bStus
 = 
m_pMhod
->
	`GDevCommS

m_wDaPos
 );

1588 
CPublicMhod
::
	`SDDBSLkStus
(
m_wDaPos
, 
bStus
);

1589 if
bStus
 )

1591 
byStus
 |(
bStus
 << ( 
wSdNum
 % 8) );

1595 
byStus
 &
bStus
 << ( 
wSdNum
 % 8)) | ( 0xff >> ( 8 - (wSendNum % 8 ))));

1598 i0 =
wSdNum
+1 )%8 ) )

1600 
buf
[
n
++] = 
byStus
;

1601 
byStus
 = 0xff;

1602 
wMaxBy
 -= 1;

1605 
m_wDaPos
++;

1606 
wSdNum
 ++;

1607 
wLveStusNum
 --;

1610 if0 !
wSdNum
 % 8 ))

1612 
buf
[
n
++] = 
byStus
;

1615 
buf
[5] = (
wSdNum
 >> 8) & 0xff;

1616 
buf
[6] = 
wSdNum
 & 0xff;

1617 
buf
[2] = 
n
-3;

1619 i
wLveStusNum
 == 0 )

1621 
buf
[3] |= 0x80;

1622 
m_wDaPos
 = 0;

1625  
TRUE
;

1626 
	}
}

1640 
BOOL
 
	gCDDB
::
	$GSdDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

1642  
m_byDaTy
 )

1644 
DDB_YX_DATATYPE
:

1645 
	`YxDaSd

buf
, 
n
 );

1648 
DDB_YC_DATATYPE
:

1649 
	`YcDaSd

buf
, 
n
 );

1652 
DDB_YM_DATATYPE
:

1653 
	`YmDaSd

buf
, 
n
 );

1656 
DDB_LINKBUSSTATUS_DATATYPE
:

1658 
	`LkBusStusSd

buf
, 
n
);

1662 
DDB_LINKSTNSTATUS_DATATYPE
:

1664 
	`LkSStusSd

buf
, 
n
);

1668 
DDB_TIME_DATATYPE
:

1669 
	`TimeSyncSd

buf
, 
n
 );

1670 
m_byDaTy
 = 
DDB_YX_DATATYPE
;

1673 
DDB_YK_DATATYPE
:

1674 
	`t
( (*)"ResponseYkData" );

1675 
	`ReڣYkDa

buf
, 
n
 );

1684 
m_SdStus
 = 
NONESTATUS
;

1685  
TRUE
;

1686 
	}
}

1698 
BOOL
 
	gCDDB
::
	$RequeSyn
 ( 
BYTE
 *
buf
, &
n
 )

1701 
buf
[2] = 1;

1702 
	`GCommFme

buf
, 
REQUEST_SYN
 );

1704 
n
 = 4;

1706  
TRUE
;

1707 
	}
}

1719 
BOOL
 
	gCDDB
::
	$ReڣSyn
 ( 
BYTE
 *
buf
, &
n
 )

1721 
	`GCommFme

buf
, 
RESPONSE_SYN
 );

1724 if(
m_bSyn
)

1725 
buf
[4] = 1;

1727 
buf
[4] = 0;

1729 
buf
[2] = 2;

1730 
n
 = 5;

1732  
TRUE
;

1733 
	}
}

1745 
BOOL
 
	gCDDB
::
	$RequeDa
 ( 
BYTE
 *
buf
, &
n
 )

1747 
	`GCommFme

buf
, 
REQUEST_DATA
 );

1750 
buf
[4] = 
m_byDaTy
;

1753 
buf
[5] = (
m_wDaPos
 >> 8) & 0xff;

1754 
buf
[6] = (
m_wDaPos
) & 0xff;

1756 
buf
[2] = 4;

1757 
n
 = 7;

1759  
TRUE
;

1760 
	}
}

1772 
BOOL
 
	gCDDB
::
	$ReڣDa
 ( 
BYTE
 *
buf
, &
n
 )

1774  
	`GSdDaBuf
(
buf
, 
n
);

1775 
	}
}

1787 
BOOL
 
	gCDDB
::
	$RequeSwch
 ( 
BYTE
 *
buf
, &
n
 )

1789 
	`GCommFme

buf
, 
REQUEST_SWITCH
 );

1790 
buf
[2] = 1;

1791 
n
 = 4;

1794 
m_SdStus
 = 
NONESTATUS
;

1796  
TRUE
;

1797 
	}
}

1809 
BOOL
 
	gCDDB
::
	$ReڣSwch
 ( 
BYTE
 *
buf
, &
n
 )

1811 
	`GCommFme

buf
, 
RESPONSE_SWITCH
 );

1812 
buf
[2] = 1;

1813 
n
 = 4;

1814 
m_SdStus
 = 
NONESTATUS
;

1816  
TRUE
;

1817 
	}
}

1829 
BOOL
 
	gCDDB
::
	$RequeYkDa
 ( 
BYTE
 *
buf
, &
n
 )

1832 
	`GCommFme

buf
, 
m_SdStus
 );

1835 
buf
[4] = 
m_byDaTy
;

1838 
buf
[5] = 
m_YkStus
;

1840 if
STATUS_MASTER
 =
m_byLolStus
 )

1843 
buf
[6] = 
m_bySaveSrcBusNo
;

1846 
buf
[7] = 
	`HIBYTE

m_wSaveSrcDevAddr
 );

1847 
buf
[8] = 
	`LOBYTE
(
m_wSaveSrcDevAddr
 );

1852 
buf
[6] = 
m_SaveDeYkDa
.
byDeBusNo
;

1855 
buf
[7] = 
	`HIBYTE
(
m_SaveDeYkDa
.
wDeAddr
);

1856 
buf
[8] = 
	`LOBYTE
(
m_SaveDeYkDa
.
wDeAddr
);

1860 
buf
[9] = 
	`HIBYTE
(
m_SaveDeYkDa
.
wP
);

1861 
buf
[10] = 
	`LOBYTE
(
m_SaveDeYkDa
.
wP
);

1864 
buf
[11] = 
m_SaveDeYkDa
.
byV
;

1867 
buf
[2] = 9;

1869 
n
 = 12;

1871 
m_bIsYkg
 = 
FALSE
;

1872  
TRUE
;

1873 
	}
}

1884 
BOOL
 
	gCDDB
::
	$ReڣYkDa
 ( 
BYTE
 *
buf
, &
n
 )

1886 
	`GCommFme
(
buf
, 
m_SdStus
);

1888 
buf
[4] = 
m_byDaTy
;

1891 
buf
[5] = 
m_YkStus
;

1894 
buf
[2] = 3;

1895 
n
 = 6;

1898  
m_YkStus
 )

1900 
DDB_YK_SEL_CONFIRM
:

1901 
m_YkStus
 = 
DDB_YK_SEL_RTN
;

1904 
DDB_YK_EXE_CONFIRM
:

1905 
m_YkStus
 = 
DDB_YK_EXE_RTN
;

1908 
DDB_YK_SEL
:

1909 
m_YkStus
 = 
DDB_YK_EXE
;

1916 
m_byDaTy
 = 
m_bySaveDaTy
;

1917  
TRUE
;

1918 
	}
}

1930 
BOOL
 
	gCDDB
::
	$ErgodicDevS
()

1932 
BYTE
 
eBusNo
,
eDevNo
;

1933 
BYTE
 
eBusNum
 = 
m_pMhod
->
	`GToTBusNum
();

1934  
eBusNo
=0;BusNo<
eBusNum
;BusNo++ )

1936 
BYTE
 
ProcTy
 = 
m_pMhod
->
	`GBusLeProcTy

eBusNo
 );

1937 if
ProcTy
 =
PROTOCO_GATHER
 )

1939 
BYTE
 
eDevNum
 = 
m_pMhod
->
	`GDevNum

eBusNo
 );

1940 
BYTE
 
eAbnmDevnum
 = 0;

1941  
eDevNo
=0;DevNo<
eDevNum
;DevNo++ )

1943 
WORD
 
eDevaddr
 = 
m_pMhod
->
	`GAddrByLeNoAndModuNo
 ( 
eBusNo
 , 
eDevNo
 );

1945 if
FALSE
 =
m_pMhod
->
	`GDevCommS

eBusNo
, 
eDevaddr
 ) )

1951 
eAbnmDevnum
++;

1955 if
eAbnmDevnum
 =
eDevNum
 )

1957  
FALSE
;

1961  
TRUE
;

1962 
	}
}

1973 
BOOL
 
	gCDDB
::
	$AddSdCrc
 ( 
BYTE
 *
buf
, &
n
 )

1975 
WORD
 
wCrc
;

1976 i
buf
[2] !
n
 -3 )

1977  
FALSE
;

1979 
wCrc
 = 
	`GCrc
(
buf
+3, buf[2]);

1980 
buf
[
n
++] = ( 
wCrc
 >> 8 ) & 0xff;

1981 
buf
[
n
++] = (
wCrc
) &0xff;

1983  
TRUE
;

1984 
	}
}

1995 
BOOL
 
	gCDDB
::
	$GSdTyBuf
 ( 
BYTE
 *
buf
, &
n
 )

1997 
BOOL
 
bR
 = 
FALSE
;

1998 
	`memt

buf
, 0, 
n
 );

2000 if
m_bSwchS
 =
TRUE
 && 
m_byLolStus
 =
STATUS_MASTER
 )

2002 
m_SdStus
 = 
REQUEST_SWITCH
;

2003 
m_bSwchS
 = 
FALSE
;

2007  
m_SdStus
 )

2009 
REQUEST_SYN
:

2010 
	`t
 ( (*)"DDB SEND REQUEST_SYN\n" );

2011 
bR
 = 
	`RequeSyn
(
buf
, 
n
);

2014 
RESPONSE_SYN
:

2015 
	`t
 ( (*)"DDB SEND RESPONSE_SYN\n" );

2016 
bR
 = 
	`ReڣSyn
(
buf
, 
n
);

2019 
REQUEST_DATA
:

2021 if
m_bIsYkg
 )

2023 if
DDB_YK_DATATYPE
 !
m_byDaTy
 )

2024 
m_bySaveDaTy
 = 
m_byDaTy
;

2025 
m_byDaTy
 = 
DDB_YK_DATATYPE
;

2026 
	`t
( (*)"RequestYkData\n" );

2027 
bR
 = 
	`RequeYkDa

buf
, 
n
 );

2029 if
DDB_YK_DATATYPE
 =
m_byDaTy
 )

2031 
bR
 = 
	`ReڣYkDa

buf
, 
n
 );

2035 
bR
 = 
	`RequeDa
(
buf
,
n
);

2039 
RESPONSE_DATA
:

2041 if
m_bIsYkg
 )

2043 if
DDB_YK_DATATYPE
 !
m_byDaTy
 )

2044 
m_bySaveDaTy
 = 
m_byDaTy
;

2045 
m_byDaTy
 = 
DDB_YK_DATATYPE
;

2046 
	`t
( (*)"ResponseYkData\n" );

2047 
bR
 = 
	`RequeYkDa

buf
, 
n
 );

2051 
bR
 = 
	`ReڣDa
(
buf
,
n
);

2055 
REQUEST_SWITCH
:

2056 
	`t
 ( (*)"DDB SEND REQUEST_SWITCH\n" );

2057 
bR
 = 
	`RequeSwch
(
buf
,
n
);

2060 
RESPONSE_SWITCH
:

2061 
	`t
 ( (*)"DDB SEND RESPONSE_SWITCH\n" );

2062 
bR
 = 
	`ReڣSwch
(
buf
, 
n
);

2065 
NONESTATUS
:

2066 
bR
 = 
TRUE
;

2067 
n
 = 0;

2071 
szBuf
[256];

2072 
n
 = 0;

2073 
	`rtf
 ( 
szBuf
, "DDB:GProcBun'fd m_SdStu%d\n", 
m_SdStus
 );

2074 
	`t

szBuf
 );

2078 if
bR
 )

2080 if
n
 > 0 )

2081 
	`AddSdCrc
(
buf
, 
n
);

2085 if
m_SdStus
 !
NONESTATUS
 )

2087 
szBuf
[256];

2088 
	`rtf
 (
szBuf
, "g mesgr!!!n=%d %.2x %.2x %.2x %.2x %.2x %.2x", 
n
,
buf
[0], buf[1], buf[2],buf[3],buf[4],buf[5] );

2089 
	`t

szBuf
 );

2093 
	`t
 ( (*)"m_SendStatus = NONESTATUS" );

2097 if
m_SdStus
 =
NONESTATUS
 )

2099 
bR
 = 
TRUE
;

2102  
bR
;

2103 
	}
}

2116 
BOOL
 
	gCDDB
::
	$ProssBusMsg
 ( 
PBUSMSG
 
pBusMsg
, 
BYTE
 *
buf
, &
n
 )

2118  
pBusMsg
->
byMsgTy
 )

2120 
YK_PROTO
:

2122 
	`t
( (*)"Recv YkMsg\n" );

2123 
	`ProssYK

pBusMsg
 ) ;

2128 
	`tf
 ( "DDB:ProssBusMsg c'fd msgty = %d\n", 
pBusMsg
->
byMsgTy
 );

2129  
FALSE
;

2133  
TRUE
;

2134 
	}
}

2145 
BOOL
 
	gCDDB
::
	$ProssYK

PBUSMSG
 
pBusMsg
 )

2147 if!
	`JudgeYkMsg

pBusMsg
 ) )

2149 
	`t
( (*)"CDDB::JudgeYkMsgrror\n" );

2150  
FALSE
;

2153 
	`SaveYkMsgInfo

pBusMsg
 );

2154 
	`SYkDaStus

pBusMsg
 );

2155 
	`t
( (*)"CDDB::ProcwssYk Ok\n" );

2157  
FALSE
 ;

2158 
	}
}

2170 
BOOL
 
	gCDDB
::
	$JudgeYkMsg
 ( 
PBUSMSG
 
pBusMsg
 )

2172 
DWORD
 
dwYkTy
 = 
pBusMsg
->
dwDaTy
 ;

2174 if
STATUS_MASTER
 =
m_byLolStus
 )

2176 if
YK_SEL_RTN
 !
dwYkTy


2177 && 
YK_EXCT_RTN
 !
dwYkTy


2178 && 
YK_CANCEL_RTN
 !
dwYkTy


2179 && 
YK_ERROR
 !
dwYkTy
)

2181 
	`tf
 ( (*)"CDDB:JudgeYkMsg ykmsg yktyperror\n" );

2182  
FALSE
;

2186 if
YK_SEL_RTN
 =
dwYkTy
)

2188 if
DDB_YK_SEL_RTN
 !
m_YkStus
 )

2190  
FALSE
;

2195 if
YK_EXCT_RTN
 =
dwYkTy
 )

2197 if
DDB_YK_EXE_RTN
 !
m_YkStus
 )

2199  
FALSE
;

2202  
TRUE
;

2204 if
STATUS_SLAVE
 =
m_byLolStus
 )

2206 if
YK_SEL
 !
dwYkTy


2207 && 
YK_EXCT
 !
dwYkTy


2208 && 
YK_CANCEL
 !
dwYkTy
)

2210 
	`tf
 ( (*)"CDDB:JudgeYkMsg ykmsg yktyperror\n" );

2211  
FALSE
;

2222  
TRUE
;

2225 
	`tf
 ( "DDB::JudgeYkMsgot DDB\n" );

2227  
FALSE
;

2228 
	}
}

2240 
	gCDDB
::
	$SaveYkMsgInfo
 ( 
PBUSMSG
 
pBusMsg
 )

2242 
PDDBYK_DATA
 
pYkDa
 = ( PDDBYK_DATA )
pBusMsg
->
pDa
 ;

2244 
m_bySaveSrcBusNo
 = 
pBusMsg
->
SrcInfo
.
byBusNo
;

2245 
m_wSaveSrcDevAddr
 = 
pBusMsg
->
SrcInfo
.
wDevNo
;

2247 if
STATUS_MASTER
 =
m_byLolStus
 )

2249 
	`t
 ( (*)"SaveYkMsgInfo masterot save\n" );

2255 
	`memy
&
m_SaveDeYkDa
, 
pYkDa
, 
DDBYK_DATA
 ) );

2256 
	}
}

2268 
	gCDDB
::
	$SYkDaStus
 ( 
PBUSMSG
 
pBusMsg
 )

2273 
m_bIsYkg
 = 
TRUE
;

2275 
DWORD
 
dwYkTy
 = 
pBusMsg
->
dwDaTy
 ;

2277  
dwYkTy
 )

2279 
YK_SEL
:

2280 
m_YkStus
 = 
DDB_YK_SEL
;

2283 
YK_EXCT
:

2284 
m_YkStus
 = 
DDB_YK_EXE
;

2287 
YK_CANCEL
:

2288 
m_YkStus
 = 
DDB_YK_CANCEL
;

2291 
YK_SEL_RTN
:

2292 
m_YkStus
 = 
DDB_YK_SEL_RTN
;

2295 
YK_EXCT_RTN
:

2296 
m_YkStus
 = 
DDB_YK_EXE_RTN
;

2299 
YK_CANCEL_RTN
:

2300 
m_YkStus
 = 
DDB_YK_CANCEL_RTN
;

2303 
YK_ERROR
:

2304 
m_YkStus
 = 
DDB_YK_ERROR
;

2308 
	`t
( (*)"DDB:SetYkDataStatusone dwYkType" );

2309 
m_YkStus
 = 
DDB_YK_NONE_STATUS
;

2313 
	}
}

2332 
BOOL
 
	gCDDB
::
	$RdCfgInfo
 ( )

2335 
szMacheBuf
[256];

2336 
szFame
[256] = "";

2338 
	`rtf

szFame
, "%s%s", 
DDBPREFIXFILENAME
, 
m_sTemePh
 );

2339 
CProfe
 
	`ofe

szFame
 ) ;

2340 if!
ofe
.
	`IsVid
() )

2342 
	`tf
"CDDB:RdCfgInfOf%Faed ! \" , 
ofe
.
m_szFeName
 );

2343  
FALSE
 ;

2346 
sSe
[ 200 ] = "DDB" ;

2347 
sKey
[ 20 ][ 100 ]={ "machineid" , "localip" , "renoteip" , "port",\

2351 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 0 ] , (*)"NULL" , 
szMacheBuf
 , ( szMachineBuf ) ) ;

2352 i
szMacheBuf
[0] == 'A' )

2354 
m_byMacheId
 = 
IDENTITY_A
;

2356 if
szMacheBuf
[0] == 'B' )

2358 
m_byMacheId
 = 
IDENTITY_B
;

2362 
m_byMacheId
 = 
IDENTITY_SINGLE
; ;

2363 
	`tf
 ( "CDDB:ReadCfgInfo Read m_byMachineIdrr !!! \n" );

2364  
FALSE
;

2367 
m_iDayedSwchMu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 4 ] , 0 ) ;

2368 if
m_iDayedSwchMu
 < 10 )

2370 
m_iDayedSwchMu
 = 10;

2372 if
m_iDayedSwchMu
 > 120 )

2374 
m_iDayedSwchMu
 = 120 ;

2377 
m_iDayedSynSecd
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 5 ] , 0 ) ;

2378 if
m_iDayedSynSecd
 < 10 )

2380 
m_iDayedSynSecd
 = 10;

2382 if
m_iDayedSynSecd
 > 120 )

2384 
m_iDayedSynSecd
 = 120 ;

2387 
	`tf
 ( "DayedSynSecd=%dDayedSwchMu=%dm\n", 
m_iDayedSynSecd
, 
m_iDayedSwchMu
 );

2408 
	`tf
"lolid=%d\n", 
m_byMacheId
 );

2409  
TRUE
;

2410 
	}
}

2422 
BOOL
 
	gCDDB
::
	$InProcStus
 ( )

2424 i
m_byMacheId
 =
IDENTITY_SINGLE
 )

2425  
FALSE
;

2427 
m_bSyn
 = 
TRUE
;

2428 
m_bRemeSyn
 = 
TRUE
;

2431 
m_byDaTy
 = 
DDB_YX_DATATYPE
;

2432 
m_bLkStus
 = 
FALSE
;

2433 
m_SdStus
 = 
REQUEST_SYN
;

2434 
m_dwLkTimeOut
 = 0;

2435 
m_byRecvECou
 = 0;

2436 
m_bIsReSd
 = 
FALSE
;

2437 
m_byRendCou
 = 0;

2438 
m_bIsSdg
 = 
FALSE
;

2439 
m_bSwchS
 = 
FALSE
;

2441 
m_wDaPos
 = 0;

2444 
	`memt
(
m_byReSdBuf
, 0 , 
DDB_MAX_BUF_LEN
);

2445 
m_wReSdL
 = 0;

2453  
TRUE
;

2454 
	}
}

2466 
	gCDDB
::
	$InProcDa
 ( 
BOOL
 
bStus
 )

2469 
m_wAYcNum
 = 
	`GDaNum
( 2 );

2470 
m_wAYxNum
 = 
	`GDaNum
( 1 );

2471 
m_wAYmNum
 = 
	`GDaNum
( 3 );

2474 
m_pYcHdAddr
 = ( 
ANALOGITEM
 * )
	`GDaHdAddr
( 2 );

2475 
m_pYxHdAddr
 = ( 
DIGITALITEM
 * )
	`GDaHdAddr
( 1 );

2476 
m_pYmHdAddr
 = ( 
PULSEITEM
 * )
	`GDaHdAddr
( 3 );

2478 
	`SwchStus

bStus
 );

2482 
	}
}

2495 
	gCDDB
::
	$TimProc
 ( )

2499 i
m_bSyn
 )

2501 
	`JudgeStus
( );

2540 if
m_byQuickSwchNum
 < 6 )

2542 if
m_byLolStus
 =
STATUS_MASTER
 )

2544 if
m_bTimeProcCou
 == 255)

2546 
m_bTimeProcCou
 = 11;

2550 
m_bTimeProcCou
++;

2553 if
m_bTimeProcCou
 >= 10)

2555 if
FALSE
 =
	`ErgodicDevS
() )

2557 
m_bSwchS
 = 
TRUE
;

2568 
time_t
 
TempNowTime
,
TempTimeDifn
;

2569 
	`time
(&
TempNowTime
);

2570 
TempTimeDifn
 = 
	`abs

TempNowTime
 - 
m_tmLaSwchTime
 );

2571 if
TempTimeDifn
 > 
m_iDayedSwchMu
*60 )

2573 
m_byQuickSwchNum
 = 0;

2578 if
m_byRecvECou
 > 
DDB_MAX_ERROR_COUNT
 )

2580 
szBuf
[256];

2581 
	`rtf
 ( 
szBuf
, "DDB Recv > %d ·\n", 
DDB_MAX_ERROR_COUNT
 );

2582 
	`t

szBuf
 );

2583 
	`InProcStus
( );

2585 i
m_byLolStus
 =
STATUS_MASTER
 )

2587 
	`t
 ( (*)"Ϊ ȴ \n" );

2588 
m_SdStus
 = 
NONESTATUS
;

2592 
	`t
 ( (*)"Ϊӻ  \n" );

2593 
m_SdStus
 = 
REQUEST_SYN
;

2598 if
m_byRendCou
 >
DDB_MAX_RESEND_COUNT
 )

2600 
szBuf
[256];

2601 
	`rtf
 (
szBuf
, "DDB ReSd > %d", 
DDB_MAX_RESEND_COUNT
 );

2602 
	`t

szBuf
 );

2604 
	`InProcStus
( );

2606 i
m_byLolStus
 =
STATUS_MASTER
 )

2629 
	`SwchStus
( 1 );

2635 
	}
}

2647 
BOOL
 
	gCDDB
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

2649 
pos
=0;

2650 
BOOL
 
bR
 = 
FALSE
;

2651 if!
	`WhhBufVue

buf
, 
n
, 
pos
 ) )

2653 
	`t
 ( (*)"CDDB:ProcessProtocolBuf buf Recvrr!!!\n" );

2654 
m_byRecvECou
 ++;

2655 
m_bIsReSd
 = 
TRUE
;

2656 
	`up
(100 * 1000);

2657  
FALSE
;

2660 
bR
 = 
	`ProssRecvTyBuf
&
buf
[
pos
], 
n
 );

2661 if!
bR
 )

2663 
	`t
 ( (*)"DDB ProcessRecvrr\n" );

2664 
m_byRecvECou
 ++;

2665 
m_bIsReSd
 = 
TRUE
;

2669 
m_byRecvECou
 = 0;

2672 
m_bIsReSd
 = 
FALSE
;

2673 
m_byRendCou
 = 0;

2674 
m_bIsSdg
 = 
FALSE
;

2677  
bR
;

2678 
	}
}

2690 
BOOL
 
	gCDDB
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

2692 
BOOL
 
bR
 = 
TRUE
;

2695 if
m_bRecvReڣSwch
 =
TRUE
 )

2697 
	`p
(
m_iDayedSynSecd
);

2699 
m_bRecvReڣSwch
 = 
FALSE
;

2701 i
m_bIsReSd
 || 
m_bIsSdg
 ) && (
m_wReSdL
 > 0) )

2703 if
m_SdStus
 =
REQUEST_SYN
 || m_SdStu=
RESPONSE_SYN
 )

2705 
	`up
( 200 * 1000 );

2709 
	`up
( 20 * 1000 );

2711 
	`t
 ( (*)"DDB Get Resend Buf\n" );

2712 
n
 = 
m_wReSdL
;

2713 
	`memy

buf
, 
m_byReSdBuf
, 
n
 );

2714 
m_byRendCou
 ++;

2717 if
pBusMsg
 !
NULL
 )

2719 if!
	`ProssBusMsg

pBusMsg
, 
buf
, 
n
 ) )

2720  
FALSE
;

2724 
bR
 = 
	`GSdTyBuf

buf
, 
n
 );

2726 if
bR
 )

2728 
m_byRendCou
 = 0;

2730 i
n
 > 
DDB_MAX_BUF_LEN
 )

2732 
szBuf
[256];

2733 
	`rtf
 (
szBuf
, "n=%d itobig f %d", 
n
, 
DDB_MAX_BUF_LEN
 );

2734 
	`t

szBuf
 );

2735  
FALSE
;

2738 
m_wReSdL
 = 
n
;

2739 
	`memy

m_byReSdBuf
, 
buf
, 
m_wReSdL
 );

2740 
m_bIsSdg
 = 
TRUE
;

2744  
bR
;

2745 
	}
}

2757 
BOOL
 
	gCDDB
::
	$In
 ( 
BYTE
 
byLeNo
 )

2759 i
CPublicMhod
::
	`IsHaveDDB
() )

2760  
FALSE
;

2763 if!
	`RdCfgInfo
() )

2766  
FALSE
;

2770 if!
	`InProcStus
( ) )

2772 
	`tf
 ( "CDDB:InitProtocolStatus Err\n" );

2773  
FALSE
;

2776 
	`InProcDa
( 0 );

2778 
	`tf
 ( "DDB Init Success\n" );

2780 
CPublicMhod
::
	`SDDBProc
();

2781 
CPublicMhod
::
	`SDDBBusAndAddr

m_byLeNo
 , 
m_wDevAddr
 ) ;

2782  
TRUE
;

2783 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/DDB.h

22 #ide 
__DDB_H__


23 
	#__DDB_H__


	)

25 
	~"../../she/tydef.h
"

26 
	~"../../she/CProc.h
"

27 
	~"CProc_DDB.h
"

30 
	#DDBPREFIXFILENAME
 "/mynd/cfig/DDB/me/"

	)

32 
	#DDB_YX_DATATYPE
 1

	)

33 
	#DDB_YC_DATATYPE
 2

	)

34 
	#DDB_YM_DATATYPE
 3

	)

35 
	#DDB_YK_DATATYPE
 4

	)

36 
	#DDB_TIME_DATATYPE
 5

	)

37 
	#DDB_LINKBUSSTATUS_DATATYPE
 6

	)

38 
	#DDB_LINKSTNSTATUS_DATATYPE
 7

	)

41 
	#DDB_MAX_BUF_LEN
 256

	)

44 
	#IDENTITY_A
 0

	)

45 
	#IDENTITY_B
 1

	)

46 
	#IDENTITY_SINGLE
 2

	)

50 
	#DDB_LINK_TIMEOUT
 30*1000

51 
	#DDB_MAX_ERROR_COUNT
 10

	)

52 
	#DDB_MAX_RESEND_COUNT
 10

	)

57 
	e_DDBSENDSTATUS


59 
	mREQUEST_SYN
,

60 
	mRESPONSE_SYN
,

61 
	mREQUEST_DATA
,

62 
	mRESPONSE_DATA
,

63 
	mREQUEST_SWITCH
,

64 
	mRESPONSE_SWITCH
,

65 
	mNONESTATUS
,

67 }
	tDDBSENDSTATUS
;

74 
	e_DDBYKSTATUS


76 
	mDDB_YK_NONE_STATUS
,

77 
	mDDB_YK_SEL
,

78 
	mDDB_YK_SEL_CONFIRM
,

79 
	mDDB_YK_EXE
,

80 
	mDDB_YK_EXE_CONFIRM
,

81 
	mDDB_YK_CANCEL
,

82 
	mDDB_YK_CANCEL_CONFIRM
,

83 
	mDDB_YK_SEL_RTN
,

84 
	mDDB_YK_SEL_RTN_CONFIRM
,

85 
	mDDB_YK_EXE_RTN
,

86 
	mDDB_YK_EXE_RTN_CONFIRM
,

87 
	mDDB_YK_CANCEL_RTN
,

88 
	mDDB_YK_CANCEL_RTN_CONFIRM
,

89 
	mDDB_YK_ERROR


90 }
	tDDBYKSTATUS
;

92 
	e_DDBLINKSTATUS


94 
	mDDB_BUS_LINK_STATUE
,

95 
	mDDB_STN_LINK_STATUS


97 }
	tDDBLINKSTATUS
;

105 as
	cCDDB
 : 
public
 
CProc_DDB


107 
public
:

109 
CDDB
 ();

110 ~
CDDB
 ();

114 
vtu
 
TimProc
();

116 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

118 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

120 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

124 
	meed
:

127 
ive
:

131 
m_byMacheId
;

137 
BOOL
 
	mm_bSyn
;

138 
BOOL
 
	mm_bRemeSyn
;

139 
BOOL
 
	mm_byLolStus
;

140 
BOOL
 
	mm_byRemeStus
;

141 
BOOL
 
	mm_bLkStus
;

142 
BOOL
 
	mm_bIsReSd
;

143 
BOOL
 
	mm_bIsSdg
;

145 
BOOL
 
	mm_bSwchS
;

146 
BYTE
 
	mm_bTimeProcCou
;

148 
DWORD
 
	mm_dwLkTimeOut
;

150 
BYTE
 
	mm_byRecvECou
;

151 
BYTE
 
	mm_byReSdBuf
[
DDB_MAX_BUF_LEN
];

152 
BYTE
 
	mm_byRendCou
;

153 
WORD
 
	mm_wReSdL
;

154 
WORD
 
	mm_wDaPos
;

156 
DDBSENDSTATUS
 
	mm_SdStus
;

157 
BYTE
 
	mm_byDaTy
;

160 
DDBYKSTATUS
 
	mm_YkStus
;

161 
BYTE
 
	mm_bySaveDaTy
;

162 
BYTE
 
	mm_bySaveSrcBusNo
;

163 
WORD
 
	mm_wSaveSrcDevAddr
;

164 
DDBYK_DATA
 
	mm_SaveDeYkDa
;

165 
BOOL
 
	mm_bIsYkg
;

171 
WORD
 
	mm_wAYcNum
;

172 
WORD
 
	mm_wAYxNum
;

173 
WORD
 
	mm_wAYmNum
;

176 
ANALOGITEM
 *
	mm_pYcHdAddr
;

177 
DIGITALITEM
 *
	mm_pYxHdAddr
;

178 
PULSEITEM
 *
	mm_pYmHdAddr
;

180 
time_t
 
	mm_tmLaSwchTime
;

181 
time_t
 
	mm_tmNowSwchTime
;

182 
BYTE
 
	mm_byQuickSwchNum
;

183 
	mm_iDayedSynSecd
;

184 
	mm_iDayedSwchMu
;

185 
BOOL
 
	mm_bRecvReڣSwch
;

191 
BOOL
 
GSSPosAndNum
(
BYTE
 
byDaTy
, 
STNPARAM
 *
pS
, 
DWORD
 &
dwSPos
, 
WORD
 &
wCou
 );

193 
BOOL
 
GSlNoAndP
(
BYTE
 
byDaTy
, 
WORD
 
wPos
, WORD &
wSlNo
, WORD &
wP
, 
STNPARAM
 *
pS
 );

195 
BOOL
 
SwchStus
BOOL 
bStus
 );

197 
BOOL
 
DevSSwchStus
BOOL 
bStus
 );

199 
WORD
 
GDaNum
 ( 
BYTE
 
byDaTy
 );

201 
DWORD
 
GDaHdAddr
 ( 
BYTE
 
byDaTy
 );

203 
GCommFme
 ( 
BYTE
 *
buf
, BYTE 
byFuncCode
 );

205 
WORD
 
GCrc
 ( 
BYTE
 *
pBuf
, 
nL
 );

207 
t
* 
szBuf
 );

208 
BOOL
 
JudgeYkMsg
 ( 
PBUSMSG
 
pBusMsg
 );

209 
SaveYkMsgInfo
 ( 
PBUSMSG
 
pBusMsg
 );

210 
SYkDaStus
 ( 
PBUSMSG
 
pBusMsg
 );

213 
BOOL
 
RdCfgInfo
();

215 
BOOL
 
InProcStus
( );

217 
InProcDa
 ( 
BOOL
 
bStus
 );

220 
BOOL
 
ProssBusMsg
(
PBUSMSG
 
pBusMsg
, 
BYTE
 *
buf
, &
n
);

223 
BOOL
 
GSdTyBuf

BYTE
 *
buf
, &
n
 );

225 
BOOL
 
AddSdCrc
(
BYTE
 *
buf
, &
n
);

227 
BOOL
 
RequeSyn

BYTE
 *
buf
, &
n
 );

229 
BOOL
 
ReڣSyn

BYTE
 *
buf
, &
n
 );

231 
BOOL
 
RequeDa

BYTE
 *
buf
, &
n
 );

233 
BOOL
 
ReڣDa

BYTE
 *
buf
, &
n
 );

235 
BOOL
 
RequeSwch

BYTE
 *
buf
, &
n
 );

237 
BOOL
 
ReڣSwch

BYTE
 *
buf
, &
n
 );

239 
BOOL
 
RequeYkDa
 ( 
BYTE
 *
buf
, &
n
 );

241 
BOOL
 
ReڣYkDa
 ( 
BYTE
 *
buf
, &
n
 );

244 
BOOL
 
GSdDaBuf

BYTE
 *
buf
, &
n
 );

246 
BOOL
 
YcDaSd

BYTE
 *
buf
, &
n
 );

248 
BOOL
 
YxDaSd

BYTE
 *
buf
, &
n
 );

250 
BOOL
 
YmDaSd

BYTE
 *
buf
, &
n
 );

252 
BOOL
 
TimeSyncSd

BYTE
 *
buf
, &
n
 );

254 
BOOL
 
LkBusStusSd

BYTE
 *
buf
, &
n
 );

255 
BOOL
 
LkSStusSd

BYTE
 *
buf
, &
n
 );

258 
JudgeStus
 ( 
BYTE
 
byRemeBy
 );

260 
JudgeStus
 ( );

265 
BOOL
 
WhhBufVue

BYTE
 *
buf
, &
n
, &
pos
 );

267 
BOOL
 
ProssRecvTyBuf

BYTE
 *
buf
, 
n
 );

269 
BOOL
 
ProssRequeSyn

BYTE
 *
buf
, 
n
 );

271 
BOOL
 
ProssReڣSyn

BYTE
 *
buf
, 
n
 );

273 
BOOL
 
ProssRequeDa

BYTE
 *
buf
, 
n
 );

275 
BOOL
 
ProssReڣDa

BYTE
 *
buf
, 
n
 );

277 
BOOL
 
ProssRequeSwch

BYTE
 *
buf
, 
n
 );

279 
BOOL
 
ProssReڣSwch

BYTE
 *
buf
, 
n
 );

281 
BOOL
 
PackSdYkMsg
 ( 
BYTE
 *
buf
 );

284 
BOOL
 
ProssRecvDaBuf
(
BYTE
 *
buf
, 
n
);

286 
BOOL
 
YcDaDl

BYTE
 *
buf
, 
n
 );

288 
BOOL
 
YxDaDl

BYTE
 *
buf
, 
n
 );

290 
BOOL
 
YmDaDl

BYTE
 *
buf
, 
n
 );

292 
BOOL
 
TimeSyncDl

BYTE
 *
buf
, 
n
 );

294 
BOOL
 
LkBusStusDl

BYTE
 *
buf
, 
n
 );

295 
BOOL
 
LkSStusDl

BYTE
 *
buf
, 
n
 );

298 
BOOL
 
ErgodicDevS
();

300 
BOOL
 
ProssYK

PBUSMSG
 
pBusMsg
 ) ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_DDB.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

12 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

14 
CProc
 * 
pProc
 = 
NULL
 ;

15 
pProc
 = 
w
 
CProc_DDB
 ;

16 if
pProc
 )

18 
pProc
->
m_pMhod
 = 
pMhod
 ;

19 
	`tf
( "DDB DLL OK.\n " ) ;

22  
pProc
 ;

23 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDTWithTime.cpp

21 
	~"CDTWhTime.h
"

22 
	~<dio.h
>

23 
	~<dt.h
>

31 
	gCDTWhTime
::
	$CDTWhTime
 ()

33 
	`memt

m_fYcBuf
, 0, ( m_fYcBuf ) );

34 
	`memt

m_byYxBuf
, 0, ( m_byYxBuf ) );

35 
	`memt

m_dwYmBuf
, 0, ( m_dwYmBuf ) );

38 
m_wADaIv
 = 15;

39 
m_LolHbtTime
 = 60 * 1000;

42 
m_dwFeYcBegPos
 = 0;

43 
m_dwFeYxBegPos
 = 0;

44 
m_dwFeYmBegPos
 = 0;

47 
	`memt

m_szPhD
, 0, ( m_szPathDir ) );

48 
	`memt

m_szReFeName
 , 0, ( m_szRecentFileName ) );

51 
	`InProcS
( );

52 
	`tf
 ( "CDTWithTime construtor\n" );

55 
	}
}

66 
	gCDTWhTime
::~
	$CDTWhTime
 ()

68 
	`tf
 ( "CDTWithTime destrutor\n" );

70 
	}
}

82 
	gCDTWhTime
::
	$TimProc
 ( )

85 
	`RdChgDa
();

88 
	`TimeToProc
( );

91 
	`ProcEProc
( );

92 
	}
}

104 
BOOL
 
	gCDTWhTime
::
	$ProssProcBuf
 ( 
BYTE
 *
pBuf
, 
n
 )

106 
pos
 =0;

108 if!
	`WhhBufVid

pBuf
, 
n
, 
pos
 ) )

110 
	`t
( ( * )"CDTWithTime can't findightecv buf" );

111 
	`SS

DATATRANS_RESEND_STATE
 );

112  
FALSE
;

116 if!
	`ProssRecvBuf
&
pBuf
[
pos
], 
n
 ) )

118  
FALSE
;

122 
	`SRecvPam
( );

123  
TRUE
;

124 
	}
}

137 
BOOL
 
	gCDTWhTime
::
	$GProcBuf
 ( 
BYTE
 *
buf
,

138 &
n
,

139 
PBUSMSG
 
pBusMsg
)

141 
BOOL
 
bR
 = 
FALSE
;

144 if
NULL
 =
buf
 )

146 
	`t
( ( * )" CDTWithTime GetProtocolBuf buf = NULL" );

147  
FALSE
;

152 
bR
 = 
	`GSdBuf

buf
, 
n
 );

155 
	`SSdPam

bR
 );

157  
bR
;

158 
	}
}

170 
BOOL
 
	gCDTWhTime
::
	$In
 ( 
BYTE
 
byLeNo
 )

173 if!
	`RdCfgInfo
( ) )

175  
FALSE
;

179 
	`InProc
( );

181 
	`rtf
 ( 
m_szPhD
, "%sBus%.2dlog/", 
DATATRANSSPREFIXFILENAME
, 
m_byLeNo
 + 1);

182 
m_DFe
.
	`CeD

m_szPhD
 );

184 
	`CloLk
( );

186 
	`tf
 ( "CDTWithTime Init Ok\n" );

187  
TRUE
;

188 
	}
}

201 
	gCDTWhTime
::
	$TimeToProc
 ( )

203 if
	`TimeToWreFe
( ) )

205 
	`SS

DATATRANS_WRITEFILE_STATE
 );

206 
	`t
( (*)"CDTWithTime TimeToWriteFile" );

207 if
	`SaveDaToFe
&
m_SaveFeTime
 ) )

210 
	`UntS

DATATRANS_WRITEFILE_STATE
 );

214 if
	`TimeToA
( ) )

216 
	`t
( (*)"CDTWithTimeimetoall" );

217 
DWORD
 
dwA
 = 
DATATRANS_YC_STATE
 | 
DATATRANS_YX_STATE
 | 
DATATRANS_YM_STATE
 ;

218 
	`SS

dwA
 );

219 
	`OnLk
( );

229 
	}
}

241 
BOOL
 
	gCDTWhTime
::
	$TimeToA
 ( )

243 if
	`IsHaveS

DATATRANS_WRITEFILE_STATE
 ) )

245  
FALSE
;

248 if0 !
	`

m_szRdFe
 ) )

250  
FALSE
;

253 *
pRdFe
 = 
m_DFe
.
	`GDFe

m_szPhD
 ) ;

254 if
NULL
 !
pRdFe
 )

256 
	`rtf

m_szRdFe
, "%s%s", 
m_szPhD
, 
pRdFe
 );

257  
TRUE
;

260  
FALSE
;

261 
	}
}

273 
BOOL
 
	gCDTWhTime
::
	$TimeToWreFe
 ( )

275 
time_t
 
nowTime
;

276 
tm
 *
pRecdTime
;

278 
nowTime
 = 
	`time

NULL
 );

279 
pRecdTime
 = 
	`loime
&
nowTime
 );

280 
tm
 *
pTm
 = 
pRecdTime
;

282 
	`DeOldeFe
( );

284 if
m_wADaIv
 >= 60 )

286 
DWORD
 
tmp
 = 
m_wADaIv
 % 60;

287 
DWORD
 
tmpTime
 = 60 / 
tmp
;

289 if0 =
pRecdTime
->
tm_m
 % 
tmp
 ) )

291 if
m_LolAddHour
 >
m_LolSumTime
 )

293 
m_LolAddHour
 =0;

294 
m_LolAddTime
 = 0;

295 
	`memy
&
m_SaveFeTime
 , 
pRecdTime
, 
tm
 ));

297 
szTmpTimeBuf
[64] ;

298 
	`rtf

szTmpTimeBuf
, "%.4d%.2d%.2d%.2d%.2d.log",

299 
pTm
->
tm_yr
 + 1900,

300 
pTm
->
tm_m
,

301 
pTm
->
tm_mday
,

302 
pTm
->
tm_hour
,

303 
pTm
->
tm_m
);

305 if0 !
	`rcmp

szTmpTimeBuf
, 
m_szReFeName
 ) ) )

307  
TRUE
;

313 
m_LolAddTime
 ++;

314 if
m_LolAddTime
 >
tmpTime
 )

316 
m_LolAddHour
 ++;

323 if0 =
pRecdTime
->
tm_m
 % 
m_wADaIv
 ) )

325 
	`memy
&
m_SaveFeTime
 , 
pRecdTime
, 
tm
 ));

326 
szTmpTimeBuf
[64] ;

327 
	`rtf

szTmpTimeBuf
, "%.4d%.2d%.2d%.2d%.2d.log",

328 
pTm
->
tm_yr
 + 1900,

329 
pTm
->
tm_m
,

330 
pTm
->
tm_mday
,

331 
pTm
->
tm_hour
,

332 
pTm
->
tm_m
);

334 if0 !
	`rcmp

szTmpTimeBuf
, 
m_szReFeName
 ) ) )

336  
TRUE
;

341  
FALSE
;

342 
	}
}

353 
BOOL
 
	gCDTWhTime
::
	$TimeToHbt
 ( )

355 
m_LolHbtAddTime
 += 200;

356 if
m_LolHbtAddTime
 >
m_LolHbtTime
 )

359 if
m_ProcS
 )

361  
FALSE
;

365 
m_LolHbtAddTime
 = 0;

366  
TRUE
;

369  
FALSE
;

370 
	}
}

382 
BOOL
 
	gCDTWhTime
::
	$SaveDaToFe
 ( 
tm
 *
pTm
 )

384 
szTmpTimeBuf
[64] ;

385 
	`rtf

szTmpTimeBuf
, "%.4d%.2d%.2d%.2d%.2d.log",

386 
pTm
->
tm_yr
 + 1900,

387 
pTm
->
tm_m
,

388 
pTm
->
tm_mday
,

389 
pTm
->
tm_hour
,

390 
pTm
->
tm_m
);

391 if0 =
	`rcmp

szTmpTimeBuf
, 
m_szReFeName
 ) ) )

393  
FALSE
;

398 if
	`WreDaToFe
(
szTmpTimeBuf
) )

400 
	`t
( (*)"write ok" );

401 
	`ry

m_szReFeName
, 
szTmpTimeBuf
 );

402  
TRUE
;

405  
FALSE
;

406 
	}
}

417 
	gCDTWhTime
::
	$DeOldeFe
 ( )

419 
DWORD
 
dwDSize
 = 
m_DFe
.
	`GDSize
(*)
DATATRANSSPREFIXFILENAME
 );

420 if
dwDSize
 >
CDTWITHTIME_MAX_SAVE_SIZE
)

422 
m_DFe
.
	`DeOldeFe

m_szPhD
 );

424 
	}
}

436 
BOOL
 
	gCDTWhTime
::
	$WreDaToFe
 ( *
pszFeName
 )

438 
szFe
[128];

439 
BYTE
 
szBuf
[1024];

440 
n
;

442 
	`rtf

szFe
, "%s%s", 
m_szPhD
, 
pszFeName
 );

444 if
m_DFe
.
	`IsFe
 ( 
szFe
 ) )

446  
FALSE
;

449 
DWORD
 
dwS
 = 
DATATRANS_WRITEFILE_YC_STATE


450 | 
DATATRANS_WRITEFILE_YX_STATE


451 | 
DATATRANS_WRITEFILE_YM_STATE


452 | 
DATATRANS_WRITEFILE_HEAD_STATE
;

453 
	`SS

dwS
 );

455 
	`t
( (*)"begino write buf" );

457  
	`PackFeDaBuf

szBuf
, 
n
 ) )

459 if!
m_DFe
.
	`WreToFe

szFe
, 
szBuf
, 
n
 ) )

461 
m_DFe
.
	`DeFe

szFe
 );

462  
FALSE
;

467  
TRUE
;

468 
	}
}

481 
BOOL
 
	gCDTWhTime
::
	$PackFeDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

483 if
	`IsHaveS

DATATRANS_WRITEFILE_HEAD_STATE
 ) )

485 
	`t
( (*) "write head file" );

486  
	`PackFeHdBuf

buf
, 
n
 );

489 if
	`IsHaveS

DATATRANS_WRITEFILE_YX_STATE
 ) )

491 
	`t
( (*) "write yx file" );

492  
	`PackFeYxBuf

buf
, 
n
 );

495 if
	`IsHaveS

DATATRANS_WRITEFILE_YC_STATE
 ) )

497 
	`t
( (*) "write yc file" );

498  
	`PackFeYcBuf

buf
, 
n
 );

501 if
	`IsHaveS

DATATRANS_WRITEFILE_YM_STATE
 ) )

503 
	`t
( (*) "write ym file" );

504  
	`PackFeYmBuf

buf
, 
n
 );

507  
FALSE
;

508 
	}
}

520 
BOOL
 
	gCDTWhTime
::
	$PackFeHdBuf
 ( 
BYTE
 *
buf
, &
n
 )

522 
n
 = 0;

524 
buf
[
n
++] = 0x68;

526 
buf
[
n
++] = 
	`HIBYTE

m_wDevAddr
 );

527 
buf
[
n
++] = 
	`LOBYTE

m_wDevAddr
 );

529 
buf
[
n
++] = 0;

531 
buf
[
n
++] = 
	`HIBYTE

m_SaveFeTime
.
tm_yr
 + 1900 );

532 
buf
[
n
++] = 
	`LOBYTE

m_SaveFeTime
.
tm_yr
 +1900 );

533 
buf
[
n
++] = ( 
BYTE
 )
m_SaveFeTime
.
tm_m
;

534 
buf
[
n
++] = ( 
BYTE
 )
m_SaveFeTime
.
tm_mday
;

535 
buf
[
n
++] = ( 
BYTE
 )
m_SaveFeTime
.
tm_hour
;

536 
buf
[
n
++] = ( 
BYTE
 )
m_SaveFeTime
.
tm_m
;

538 
	`UntS

DATATRANS_WRITEFILE_HEAD_STATE
 );

540  
TRUE
;

541 
	}
}

553 
BOOL
 
	gCDTWhTime
::
	$PackFeYcBuf
 ( 
BYTE
 *
buf
, &
n
 )

555 
BYTE
 
byCou
 = 0;

556 
n
 = 0;

558  
i
=
m_wFeDaPos
; i<
m_wAISum
; i++ )

560 
fV
 = 
m_fYcBuf
[
i
];

561 
BYTE
 
szTmp
[4];

563 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YC_TRANSTOSERIALNO
 , 
i
 ) ;

564 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

566 
buf
[
n
++] = (
BYTE
)
bDevS
;

569 
	`memy

szTmp
, &
fV
, 4 );

570 
buf
[
n
++] = 
szTmp
[3];

571 
buf
[
n
++] = 
szTmp
[2];

572 
buf
[
n
++] = 
szTmp
[1];

573 
buf
[
n
++] = 
szTmp
[0];

576 
byCou
 ++;

577 if
byCou
 >= 200 )

584 
m_wFeDaPos
 +
byCou
;

586 if
m_wFeDaPos
 >
m_wAISum
 )

588 
	`UntS

DATATRANS_WRITEFILE_YC_STATE
 );

589 
m_wFeDaPos
 = 0;

592  
TRUE
;

593 
	}
}

605 
BOOL
 
	gCDTWhTime
::
	$PackFeYxBuf
 ( 
BYTE
 *
buf
, &
n
 )

607 
BYTE
 
byCou
 = 0;

608 
n
 = 0;

610  
i
=
m_wFeDaPos
; i<
m_wDISum
; i += 4 )

613  
j
=0; j<4; j++)

615 if
i
 + 
j
 >
m_wDISum
 )

619 
WORD
 
wV
 = 
m_byYxBuf
[
i
+
j
];

621 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YX_TRANSTOSERIALNO
 , 
i
+
j
 ) ;

622 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

625 
BYTE
 
byV
 = ( 
wV
 & 0x01 );

626 
buf
[
n
++] = 
bDevS
 ;

627 
buf
[
n
++] = 
byV
 ;

628 
byCou
 ++;

632 if
byCou
 >= 250 )

638 
m_wFeDaPos
 +
byCou
;

640 if
m_wFeDaPos
 >
m_wDISum
 )

642 
	`UntS

DATATRANS_WRITEFILE_YX_STATE
 );

643 
m_wFeDaPos
 = 0;

645  
TRUE
;

646 
	}
}

658 
BOOL
 
	gCDTWhTime
::
	$PackFeYmBuf
 ( 
BYTE
 *
buf
, &
n
 )

660 
BYTE
 
byCou
 = 0;

661 
n
 = 0;

663 
m_pMhod
->
	`RdAYmDa
(&
m_dwYmBuf
[0]);

665  
i
=
m_wFeDaPos
; i<
m_wPISum
; i++ )

667 
szTmp
[4];

668 
DWORD
 
dwV
 = 
m_dwYmBuf
[
i
];

670 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

DD_TRANSTOSERIALNO
 , 
i
 ) ;

671 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

673 
buf
[
n
++] = (
BYTE
)
bDevS
;

675 
fV
 = ( )
dwV
;

676 
	`memy

szTmp
, &
fV
, 4 );

677 
buf
[
n
++] = 
szTmp
[3];

678 
buf
[
n
++] = 
szTmp
[2];

679 
buf
[
n
++] = 
szTmp
[1];

680 
buf
[
n
++] = 
szTmp
[0];

688 
byCou
 ++;

689 if
byCou
 >= 200 )

696 
m_wFeDaPos
 +
byCou
;

697 if
m_wFeDaPos
 >
m_wPISum
 )

699 
	`UntS

DATATRANS_WRITEFILE_YM_STATE
 );

700 
m_wFeDaPos
 = 0;

703  
TRUE
;

704 
	}
}

715 
	gCDTWhTime
::
	$ProcEProc
 ( )

717 
m_byTimCou
 ++;

719 if
m_byTimCou
 > 20 )

721 
m_byTimCou
 = 0;

722 if! 
	`IsHaveS
(
DATATRANS_LINK_STATE
) )

723 
	`t
( "CDTWithTime isuninglease wait" );

726 if
m_bySdCou
 > 
DATATRANS_MAX_SEND_COUNT
 )

728 
	`rtf

m_szPrtBuf
, "ndcou=%d > %d inroc",
m_bySdCou
, 
DATATRANS_MAX_SEND_COUNT
 );

729 
	`t
(
m_szPrtBuf
 );

730 
	`InProcS
( );

732 
	}
}

745 
BOOL
 
	gCDTWhTime
::
	$ProssRecvBuf
 ( 
BYTE
 *
pBuf
, 
n
 )

747 if!
m_bSdg
 )

749  
FALSE
;

752  
pBuf
[1] )

755 if!
	`IsHaveS

DATATRANS_YC_STATE
 ) && !IsHaveS
DATATRANS_YM_STATE
 ) )

757  
FALSE
;

759 if
	`IsHaveS

DATATRANS_YC_OVER_STATE
 ) )

761 
	`UntS

DATATRANS_YC_OVER_STATE
 );

762 
	`UntS

DATATRANS_YC_STATE
 );

765 if
	`IsHaveS

DATATRANS_YM_OVER_STATE
 ) )

767 
	`UntS

DATATRANS_YM_OVER_STATE
 );

768 
	`UntS

DATATRANS_YM_STATE
 );

769 
szBuf
[128];

770 if
m_DFe
.
	`IsFe

m_szRdFe
 ) )

772 
	`t
( (*)"CDTWithTime delete file" );

773 
m_DFe
.
	`DeFe

m_szRdFe
 );

774 
	`memt

m_szRdFe
, 0, ( m_szReadFile ) );

776 
	`t

szBuf
 );

779 
	`t
( (*)"CDTWithTimeocessecv yc/ym" );

783 if!
	`IsHaveS

DATATRANS_YX_STATE
 )

784 && !
	`IsHaveS

DATATRANS_CHANGE_YX_STATE
 ) )

786  
FALSE
;

789 if
	`IsHaveS

DATATRANS_CHANGE_YX_STATE
 ) )

791 
	`t
( (*)"CDTWithTimeocessecv changeyx" );

792 
	`UntS

DATATRANS_CHANGE_YX_STATE
 );

795 if
	`IsHaveS

DATATRANS_YX_OVER_STATE
 ) )

797 
	`UntS

DATATRANS_YX_OVER_STATE
 );

798 
	`UntS

DATATRANS_YX_STATE
 );

800 
	`t
( (*)"CDTWithTimeocessecv yx" );

804 if!
	`IsHaveS
 ( 
DATATRANS_CHANGE_YX_STATE
 ) )

806  
FALSE
;

809 
	`t
( (*)"CDTWithTimeocessecv changeyx" );

810 
	`UntS

DATATRANS_CHANGE_YX_STATE
 );

826 
	`t
( (*)"CDTWithTime can'tocessecv buf" );

827  
FALSE
;

831  
TRUE
;

832 
	}
}

844 
	gCDTWhTime
::
	$SRecvPam
 ( )

846 
m_bSdg
 = 
FALSE
;

847 
m_bySdCou
 = 0;

848 
	`UntS

DATATRANS_RESEND_STATE
 );

849 
	}
}

864 
BOOL
 
	gCDTWhTime
::
	$GSdBuf
 ( 
BYTE
 *
buf
, &
n
 )

866 
BOOL
 
bR
 = 
TRUE
;

868 if!
	`GProcS
( ) )

870  
FALSE
;

874 
bR
 = 
	`GSdTyBuf

buf
, 
n
 );

877 
	`SaveRendBuf

buf
, 
n
, 
bR
 );

879  
bR
;

880 
	}
}

892 
BOOL
 
	gCDTWhTime
::
	$GProcS
 ( )

895 if
	`IsRend
( ) )

898 
	`SS

DATATRANS_RESEND_STATE
 );

899 
	`OnLk
( );

900  
TRUE
;

904 if
	`IsHaveChgeYX
( ) )

913 if
	`IsHaveA
( ) )

915 
	`t
( (*)"CDTWithTimelldata" );

916 
	`OnLk
( );

917  
TRUE
;

921 if
	`IsHaveH
( ) )

928 
	`CloLk
( );

929  
FALSE
;

930 
	}
}

941 
BOOL
 
	gCDTWhTime
::
	$IsRend
 ( ) const

943  
	`IsHaveS

DATATRANS_RESEND_STATE
 );

944 
	}
}

955 
BOOL
 
	gCDTWhTime
::
	$IsHaveChgeYX
 ( ) const

957 i
m_dwDIEQueue
.
	`size
( ) > 0 )

959  
TRUE
;

962  
FALSE
;

963 
	}
}

974 
BOOL
 
	gCDTWhTime
::
	$IsHaveA
 ( ) const

976 
DWORD
 
dwA
 = 
DATATRANS_YC_STATE
 | 
DATATRANS_YX_STATE
 | 
DATATRANS_YM_STATE


977 | 
DATATRANS_YC_OVER_STATE
 | 
DATATRANS_YX_OVER_STATE
 | 
DATATRANS_YM_OVER_STATE
;

978 if
dwA
 & 
m_ProcS
 )

980  
TRUE
;

983  
FALSE
;

984 
	}
}

996 
BOOL
 
	gCDTWhTime
::
	$IsHaveH
 ( ) const

998  
	`IsHaveS

DATATRANS_HEARTBEAT_STATE
 );

999 
	}
}

1012 
BOOL
 
	gCDTWhTime
::
	$GSdTyBuf
 ( 
BYTE
 *
buf
, &
n
)

1015 if
	`IsHaveS

DATATRANS_RESEND_STATE
 ) )

1017 
	`GRendBuf

buf
, 
n
 );

1018  
TRUE
;

1022 if
	`IsHaveS

DATATRANS_CHANGE_YX_STATE
 ) )

1028 if
	`GADaBuf

buf
, 
n
 ) )

1030  
TRUE
;

1034 if
	`IsHaveH
( ) )

1039  
FALSE
;

1040 
	}
}

1052 
BOOL
 
	gCDTWhTime
::
	$GChgeYXBuf
 ( 
BYTE
 *
buf
, &
n
 )

1055 
BOOL
 
bR
 = 
	`PackChgeYXBuf

buf
, 
n
 );

1058 
	`t
( (*)"CDTWithTime get changeyx" );

1060  
bR
;

1061 
	}
}

1074 
BOOL
 
	gCDTWhTime
::
	$PackChgeYXBuf
 ( 
BYTE
 *
buf
, &
n
 )

1076 
WORD
 
wSlNo
;

1077 
WORD
 
wP
;

1078 
WORD
 
wV
;

1079 
BOOL
 
bDevS
;

1081 
tm
 
tmSu
;

1082 
WORD
 
wMiSecd
;

1083 
WORD
 
wTime
;

1086 if!
	`GSOEInfo

wSlNo
, &
wP
, &
wV
, &
tmSu
, &
wMiSecd
 ) )

1088  
FALSE
;

1091 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 );

1095 
n
 = 0;

1097 
buf
[
n
++] = 0x68;

1099 
buf
[
n
++] = 
	`HIBYTE

m_wDevAddr
 );

1100 
buf
[
n
++] = 
	`LOBYTE

m_wDevAddr
 );

1102 
buf
[
n
++] = 0xF4;

1103 
buf
[
n
++] = 
	`HIBYTE

tmSu
.
tm_yr
 + 1900 );

1104 
buf
[
n
++] = 
	`LOBYTE

tmSu
.
tm_yr
 + 1900 );

1105 
buf
[
n
++] = ( 
BYTE
 )
tmSu
.
tm_m
;

1106 
buf
[
n
++] = ( 
BYTE
 )
tmSu
.
tm_mday
;

1107 
buf
[
n
++] = ( 
BYTE
 )
tmSu
.
tm_hour
;

1108 
buf
[
n
++] = ( 
BYTE
 )
tmSu
.
tm_m
;

1109 
wTime
 = 
tmSu
.
tm_c
 * 1000 + 
wMiSecd
;

1110 
buf
[
n
++] = 
	`HIBYTE

wTime
 ) ;

1111 
buf
[
n
++] = 
	`LOBYTE

wTime
 ) ;

1113 
buf
[
n
++] = 
	`HIBYTE

wP
 + 
m_wAISum
 );

1114 
buf
[
n
++] = 
	`LOBYTE

wP
 + 
m_wAISum
 );

1116 
buf
[
n
++] = 0x01;

1118 
buf
[
n
++] = (
BYTE
)
bDevS
 );

1119 
buf
[
n
++] = ( 
BYTE
 )
wV
 & 0x01 );

1121  
TRUE
;

1122 
	}
}

1134 
BOOL
 
	gCDTWhTime
::
	$GADaBuf
 ( 
BYTE
 *
buf
, &
n
 )

1136 
	`t
( (*)"CDTWithTimelldata get" );

1138 if
	`IsHaveS

DATATRANS_YC_STATE
 ) )

1140 
	`t
( (*)"CDTWithTime get yc" );

1141  
	`GYCDaBuf

buf
, 
n
 );

1145 if
	`IsHaveS

DATATRANS_YX_STATE
 ) )

1152 i
	`IsHaveS

DATATRANS_YM_STATE
 ) )

1154 
	`t
( (*)"CDTWithTime get ym" );

1155  
	`GYMDaBuf

buf
, 
n
 );

1158  
FALSE
;

1159 
	}
}

1171 
BOOL
 
	gCDTWhTime
::
	$GYCDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

1174 
BOOL
 
bR
 = 
	`PackYCBuf

buf
, 
n
 );

1176 if
m_wADaPos
 >
m_wAISum
 )

1179 
	`SS
 ( 
DATATRANS_YC_OVER_STATE
 );

1180 
m_wADaPos
 = 0;

1182  
bR
;

1183 
	}
}

1195 
BOOL
 
	gCDTWhTime
::
	$PackYCBuf
 ( 
BYTE
 *
buf
, &
n
 )

1197 
BYTE
 
byCou
 = 0;

1198 
BYTE
 
byRdNum
;

1199 
n
 = 0;

1200 if
m_wADaPos
 >
m_wAISum
 )

1202  
FALSE
;

1205 if!
	`PackHdBuf

buf
, 
n
, 0xF0, 
ESD_DATATRANS_YC_DATATYPE
 ) )

1207  
FALSE
;

1210 if
m_wADaPos
 + 45 <
m_wAISum
 )

1212 
byCou
 = 45;

1216 
byCou
 = 
m_wAISum
 - 
m_wADaPos
;

1219 
byRdNum
 = 
m_DFe
.
	`RdFromFe

m_szRdFe
,

1220 &
buf
[
n
],

1221 
byCou
 * 5 ,

1222 
m_wADaPos
*5 + 
m_dwFeYcBegPos
);

1224 if
byRdNum
 !
byCou
 * 5 ))

1226  
FALSE
;

1229 
n
 +
byRdNum
;

1231 
buf
[12] = 
byCou
;

1233 
m_wADaPos
 +
byCou
;

1234  
TRUE
;

1235 
	}
}

1246 
BOOL
 
	gCDTWhTime
::
	$GYXDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

1249 
BOOL
 
bR
 = 
	`PackYXBuf

buf
, 
n
 );

1251 if
m_wADaPos
 >
m_wDISum
 )

1254 
	`SS
 ( 
DATATRANS_YX_OVER_STATE
 );

1255 
m_wADaPos
 = 0;

1257  
bR
;

1258 
	}
}

1269 
BOOL
 
	gCDTWhTime
::
	$PackYXBuf
 ( 
BYTE
 *
buf
, &
n
 )

1271 
BYTE
 
byCou
 = 0;

1272 
BYTE
 
byRdNum
;

1273 
n
 = 0;

1274 if
m_wADaPos
 >
m_wDISum
 )

1276  
FALSE
;

1279 if!
	`PackHdBuf

buf
, 
n
, 0xF2, 
ESD_DATATRANS_YX_DATATYPE
 ) )

1281  
FALSE
;

1284 if
m_wADaPos
 + 120 <
m_wDISum
 )

1286 
byCou
 = 120;

1290 
byCou
 = 
m_wDISum
 - 
m_wADaPos
;

1293 
byRdNum
 = 
m_DFe
.
	`RdFromFe

m_szRdFe
,

1294 &
buf
[
n
],

1295 
byCou
 * 2 ,

1296 
m_wADaPos
*2 + 
m_dwFeYxBegPos
);

1298 if
byRdNum
 !
byCou
 * 2 ))

1300  
FALSE
;

1304 
n
 +
byRdNum
;

1305 
buf
[12] = 
byCou
;

1307 
m_wADaPos
 +
byCou
;

1308  
TRUE
;

1309 
	}
}

1320 
BOOL
 
	gCDTWhTime
::
	$GYMDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

1323 
BOOL
 
bR
 = 
	`PackYMBuf

buf
, 
n
 );

1325 if
m_wADaPos
 >
m_wPISum
 )

1327 
	`t
( (*) "ymnd");

1329 
	`SS
 ( 
DATATRANS_YM_OVER_STATE
 );

1330 
m_wADaPos
 = 0;

1332  
bR
;

1333 
	}
}

1344 
BOOL
 
	gCDTWhTime
::
	$PackYMBuf
 ( 
BYTE
 *
buf
, &
n
 )

1346 
BYTE
 
byCou
 = 0;

1347 
BYTE
 
byRdNum
;

1348 
n
 = 0;

1349 if
m_wADaPos
 >
m_wPISum
 )

1351  
FALSE
;

1354 if!
	`PackHdBuf

buf
, 
n
, 0xF0, 
ESD_DATATRANS_YM_DATATYPE
 ) )

1356  
FALSE
;

1359 if
m_wADaPos
 + 45 <
m_wPISum
 )

1361 
byCou
 = 45;

1365 
byCou
 = 
m_wPISum
 - 
m_wADaPos
;

1368 
byRdNum
 = 
m_DFe
.
	`RdFromFe

m_szRdFe
,

1369 &
buf
[
n
],

1370 
byCou
 * 5 ,

1371 
m_wADaPos
*5 + 
m_dwFeYmBegPos
);

1373 if
byRdNum
 !
byCou
 * 5 ))

1375  
FALSE
;

1379 
n
 +
byRdNum
;

1380 
buf
[12] = 
byCou
;

1382 
m_wADaPos
 +
byCou
;

1383  
TRUE
;

1384 
	}
}

1395 
BOOL
 
	gCDTWhTime
::
	$PackHdBuf
 ( 
BYTE
 *
buf
, &
n
, BYTE 
byFuncCode
, BYTE 
byTy
 )

1397 
n
 = 0;

1398 
n
 = 
m_DFe
.
	`RdFromFe

m_szRdFe
, 
buf
, 10, 0 );

1399 if10 !
n
 )

1401  
FALSE
;

1404 
buf
[3] = 
byFuncCode
;

1407 if
ESD_DATATRANS_YM_DATATYPE
 =
byTy
)

1409 
buf
[
n
++] = 
	`HIBYTE

m_wADaPos
 + 
DATATRANS_MAX_YC_NUM
);

1410 
buf
[
n
++] = 
	`LOBYTE

m_wADaPos
 + 
DATATRANS_MAX_YC_NUM
);

1414 
buf
[
n
++] = 
	`HIBYTE

m_wADaPos
 );

1415 
buf
[
n
++] = 
	`LOBYTE

m_wADaPos
 );

1418 
buf
[
n
++] = 0x00;

1420  
TRUE
;

1421 
	}
}

1433 
BOOL
 
	gCDTWhTime
::
	$GHBuf
 ( 
BYTE
 *
buf
, &
n
 )

1435 
n
 = 0;

1436 
buf
[
n
++] = 0x68;

1437 
buf
[
n
++] = 0xF6;

1439  
TRUE
;

1440 
	}
}

1453 
	gCDTWhTime
::
	$GRendBuf
 ( 
BYTE
 *
buf
, &
n
 )

1455 
n
 = 
m_iRendL
;

1456 
	`memy

buf
, 
m_byRendBuf
, 
n
 );

1458 
m_byRendCou
 ++;

1459 
	}
}

1473 
	gCDTWhTime
::
	$SaveRendBuf
 ( 
BYTE
 *
buf
, 
n
, 
BOOL
 
byVid
 )

1475 if
byVid
 )

1477 
m_iRendL
 = 
n
;

1478 
	`memy

m_byRendBuf
, 
buf
, 
m_iRendL
 );

1480 
	}
}

1491 
	gCDTWhTime
::
	$SSdPam
 ( 
BOOL
 
bIsSdVid
 )

1493 if
bIsSdVid
 )

1495 
m_bSdg
 = 
TRUE
;

1496 
m_bySdCou
 ++;

1497 
	`SS

DATATRANS_RESEND_STATE
 );

1499 
	}
}

1512 
BOOL
 
	gCDTWhTime
::
	$RdCfgInfo
 ( )

1514 
szPh
[256] = "";

1515 
	`rtf

szPh
, "%s%s" ,
DATATRANSSPREFIXFILENAME
, 
m_sTemePh
 );

1516 
	`t

szPh
 );

1519 
	`RdCfgMInfo
 ( 
szPh
 );

1523 if!
	`RdCfgOthInfo

szPh
 ) )

1528 
	`t
( (*)"CDTWithTime ReadCfgInfo OK" );

1529  
TRUE
;

1530 
	}
}

1542 
	gCDTWhTime
::
	$RdCfgMInfo
 ( *
szPh
 )

1545 
	`RdMCfig

szPh
 );

1546 
	}
}

1557 
BOOL
 
	gCDTWhTime
::
	$RdCfgOthInfo
 ( *
szPh
 )

1559 
FILE
 *

 = 
NULL
;

1560 
szLeBuf
[256];

1561 
iLeNum
 = 0;

1562 
iOthInfoNum
 = 0;

1563 
iOthInfoANum
 = 2;

1565 

 = 
	`fݒ

szPh
 , "r");

1566 i
NULL
 =

 )

1568 
	`tf
 ( "ݒ f%r!!!\n", 
szPh
 );

1569  
FALSE
;

1572  
NULL
 !
	`fgs
(
szLeBuf
, (szLeBuf), 

)

1573 && 30 > 
iLeNum
 )

1575 
iLeNum
 ++;

1576 if0 =
	`cmp
 ( 
szLeBuf
, "SENDINTERVAL=", 13 ) )

1578 
WORD
 
wCfgV
 = (WORD)
	`oi
&
szLeBuf
[13] ) );

1580 if0 !
wCfgV
 % 60 ) )

1582 
	`tf
 ( "CDTWhTimwCfgV in mu%d\n", 
wCfgV
 );

1586 
wCfgV
 = wCfgVal / 60;

1588 if
wCfgV
 > 1 )

1590 if
wCfgV
 >= 60 )

1592 
m_LolSumTime
 = 
wCfgV
 / 60;

1593 
wCfgV
 = wCfgVal % 60;

1596 if0 =60 % 
wCfgV
 ) )

1598 
m_wADaIv
 =
m_LolSumTime
 * 60 + 
wCfgV
;

1599 
iOthInfoNum
 ++;

1604 
	`tf
 ( "CDTWhTimSENDINTERVAL/3600=%d ir!!!هigh deu iud\n", 
wCfgV
 );

1605 
m_wADaIv
 = 15;

1610 
	`tf
 ( "CDTWhTimSENDINTERVAL=%d!!! deu iud\n", 
wCfgV
 );

1611 
m_wADaIv
 = 15;

1614 
iOthInfoNum
 ++;

1616 if0 ==
	`cmp

szLeBuf
, "HEARTTIME=", 10 ) )

1618 
WORD
 
wCfgV
 = (WORD)
	`oi
&
szLeBuf
[10] ) );

1619 if
wCfgV
 >= 1 )

1621 
m_LolHbtTime
 = 
wCfgV
 * 1000;

1625 
	`tf
 ( "CDTWhTimHEARTTIME=%d!!! deu iud\n", 
wCfgV
 );

1626 
m_LolHbtTime
 = 60 * 1000;

1629 
iOthInfoNum
 ++;

1632 if
iOthInfoANum
 <
iOthInfoNum
 )

1634 
	`tf
 ( "CDTWhTimldrv=%dm, hrv=%lums\n", 
m_wADaIv
, 
m_LolHbtTime
 );

1639 
	`fo


 );

1640  
TRUE
;

1641 
	}
}

1652 
	gCDTWhTime
::
	$InProc
 ( )

1655 
	`InProcS
( );

1658 
	`InProcTnsTab
( );

1661 
	`InProcDa
( );

1663 
	`t
( (*)"CDTWithTime InitProtocol OK" );

1664 
	}
}

1676 
	gCDTWhTime
::
	$InProcS
 ( )

1680 if
	`IsHaveS

DATATRANS_LINK_STATE
 ) )

1682 
	`CloLk
( );

1684 
m_ProcS
 = 0;

1686 
m_byRendCou
 = 0;

1687 
m_iRendL
 = 0;

1688 
	`memt

m_byRendBuf
, 0, ( m_byResendBuf ) );

1690 
m_wADaPos
 = 0;

1692 
m_bSdg
=
FALSE
;;

1693 
m_bySdCou
 = 0;

1696 
m_LolAddTime
 = 0;

1697 
m_LolHbtAddTime
 = 0;

1698 
m_byTimCou
 = 0;

1699 
m_LolAddHour
 =0;

1702 
	`memt
&
m_SaveFeTime
 , 0, 
tm
 ) );

1703 
m_wFeDaPos
 = 0;

1704 
	`memt

m_szRdFe
, 0, ( m_szReadFile ) );

1706 
	`t
( (*)"CDTWithTime InitProtocolState" );

1708 
	}
}

1720 
	gCDTWhTime
::
	$InProcTnsTab
 ( )

1723 
	`CeTnsTab
();

1724 
	}
}

1735 
	gCDTWhTime
::
	$InProcDa
 ( )

1738 
m_pMhod
->
	`RdAYcDa
(&
m_fYcBuf
[0]);

1739 
m_pMhod
->
	`RdAYmDa
(&
m_dwYmBuf
[0]);

1740 
m_pMhod
->
	`RdAYxDa
&
m_byYxBuf
[ 0 ] ) ;

1742 
m_dwFeYxBegPos
 = 10;

1743 
m_dwFeYcBegPos
 = 10 + 
m_wDISum
 * 2;

1744 
m_dwFeYmBegPos
 = 10 + 
m_wDISum
 * 2 +
m_wAISum
 * 5;

1745 
	}
}

1748 
	gCDTWhTime
::
	$GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
)

1750 
WORD
 
wVue
 = 0 ;

1751 
byTy
)

1754 if(
wP
>=
DATATRANS_MAX_YC_NUM
)  -2;

1755 
	`memy
(
v
, &
m_fYcBuf
[
wP
], (
WORD
));

1759 if(
wP
>=
DATATRANS_MAX_YX_NUM
)

1762 if
m_byYxBuf
[ 
wP
 ] ==0 )

1763 
wVue
 = 0;

1765 
wVue
 = 1;

1767 
	`memy
(
v
, &
wVue
, (
WORD
));

1771 if(
wP
>=
DATATRANS_MAX_YM_NUM
)  -2;

1772 
	`memy
(
v
, &
m_dwYmBuf
[
wP
], (
DWORD
));

1778 
	}
}

1780 
BOOL
 
	gCDTWhTime
::
	$WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
fV
)

1782 if(
m_pwAITns
==
NULL
 
FALSE
;

1783 
WORD
 
wNum
 = 
m_pwAITns
[
wP
];

1784 if(
wNum
>
m_wAISum
 
FALSE
;

1785 if(
wNum
<
DATATRANS_MAX_YC_NUM
)

1787 
fDt
 = 
fV
 - 
m_fYcBuf
[
wNum
];

1788 if(
	`abs
(()
fDt
)>=
m_wDdV
)

1790 
m_fYcBuf
[
wNum
] = 
fV
;

1793 
	`AddAlogEvt

wSlNo
 , 
wNum
, 
fV
);

1797  
TRUE
 ;

1798 
	}
}

1800 
BOOL
 
	gCDTWhTime
::
	$WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
)

1802 if(
m_pwDITns
==
NULL
 
FALSE
;

1803 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

1804 if(
wNum
>
m_wDISum
 
FALSE
;

1805 if
wNum
<
DATATRANS_MAX_YX_NUM
)

1807 if
m_byYxBuf
[ 
wNum
 ] !
wV
 )

1809 
m_byYxBuf
[ 
wNum
 ] = 
wV
 ;

1812 
	`AddDigEvt

wSlNo
 , 
wNum
, 
wV
);

1816  
TRUE
 ;

1817 
	}
}

1818 
BOOL
 
	gCDTWhTime
::
	$WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
)

1820 if(
m_pwPITns
==
NULL
 
FALSE
;

1821 
WORD
 
wNum
 = 
m_pwPITns
[
wP
];

1822 if(
wNum
>
m_wPISum
 
FALSE
;

1823 if(
wNum
<
DATATRANS_MAX_YM_NUM
)

1825 
m_dwYmBuf
[
wNum
] = 
dwV
;

1827  
TRUE
 ;

1828 
	}
}

1830 
BOOL
 
	gCDTWhTime
::
	$WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

1832 if(
m_pwDITns
==
NULL
 
FALSE
;

1833 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

1834 if(
wNum
>=
m_wDISum
 
FALSE
;

1835 if(
wNum
<
DATATRANS_MAX_YX_NUM
)

1837 
	`AddSOEInfo
(
wSlNo
 , 
wNum
, 
wV
, 
lTime
, 
wMiSecd
);

1839  
TRUE
 ;

1840 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDTWithTime.h

22 #ide 
CDTWITHTIME_INC


23 
	#CDTWITHTIME_INC


	)

26 
	~"CProc_DaTns.h
"

27 
	~"CDFe.h
"

32 
	#CDTWITHTIME_MAX_SAVE_SIZE
 30 * 1024 * 1024

	)

47 as
	cCDTWhTime
 : 
public
 
CProc_DaTns


49 
public
:

51 
CDTWhTime
 ();

52 
	mvtu
 ~
CDTWhTime
 ();

56 
vtu
 
TimProc
( );

58 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

60 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

62 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
pBuf
 , 
n
 ) ;

64 
vtu
 
GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
);

65 
vtu
 
BOOL
 
WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
fV
) ;

66 
vtu
 
BOOL
 
WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
) ;

67 
vtu
 
BOOL
 
WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
) ;

68 
vtu
 
BOOL
 
WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
) ;

70 
	meed
:

73 
ive
:

75 
ProcEProc
 ( );

77 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
pBuf
, 
n
 );

79 
SRecvPam
 ( );

81 
BOOL
 
GSdBuf
 ( 
BYTE
 *
buf
, &
n
 );

83 
BOOL
 
GProcS
 ( );

85 
BOOL
 
	$IsRend
 ( ) const;

87 
BOOL
 
	$IsHaveChgeYX
 ( ) const;

89 
BOOL
 
	$IsHaveA
 ( ) const;

91 
BOOL
 
	$IsHaveH
 ( ) const;

93 
	`TimeToProc
( );

95 
BOOL
 
	`TimeToA
 ( );

97 
BOOL
 
	`TimeToWreFe
 ( );

99 
BOOL
 
	`TimeToHbt
 ( );

101 
BOOL
 
	`GSdTyBuf
 ( 
BYTE
 *
buf
, &
n
);

103 
BOOL
 
	`GChgeYXBuf
 ( 
BYTE
 *
buf
, &
n
 );

105 
BOOL
 
	`PackChgeYXBuf
 ( 
BYTE
 *
buf
, &
n
 );

107 
BOOL
 
	`GADaBuf
 ( 
BYTE
 *
buf
, &
n
 );

109 
BOOL
 
	`GYCDaBuf
 ( 
BYTE
 *
buf
, &
n
 );

111 
BOOL
 
	`PackYCBuf
 ( 
BYTE
 *
buf
, &
n
 );

113 
BOOL
 
	`GYXDaBuf
 ( 
BYTE
 *
buf
, &
n
 );

115 
BOOL
 
	`PackYXBuf
 ( 
BYTE
 *
buf
, &
n
 );

117 
BOOL
 
	`GYMDaBuf
 ( 
BYTE
 *
buf
, &
n
 );

119 
BOOL
 
	`PackYMBuf
 ( 
BYTE
 *
buf
, &
n
 );

121 
BOOL
 
	`PackHdBuf
 ( 
BYTE
 *
buf
, &
n
, BYTE 
byFuncCode
,BYTE 
byTy
 );

123 
BOOL
 
	`GHBuf
 ( 
BYTE
 *
buf
, &
n
 );

125 
	`GRendBuf
 ( 
BYTE
 *
buf
, &
n
 );

127 
	`SaveRendBuf
 ( 
BYTE
 *
buf
, 
n
, 
BOOL
 
byVid
 );

129 
	`SSdPam
 ( 
BOOL
 
bIsSdVid
 );

131 
BOOL
 
	`SaveDaToFe
 ( 
tm
 *
pTm
 );

133 
BOOL
 
	`WreDaToFe
 ( *
pszFeName
 );

135 
	`DeOldeFe
( );

137 
BOOL
 
	`PackFeDaBuf
 ( 
BYTE
 *
buf
, &
n
 );

139 
BOOL
 
	`PackFeHdBuf
 ( 
BYTE
 *
buf
, &
n
 );

141 
BOOL
 
	`PackFeYcBuf
 ( 
BYTE
 *
buf
, &
n
 );

143 
BOOL
 
	`PackFeYxBuf
 ( 
BYTE
 *
buf
, &
n
 );

145 
BOOL
 
	`PackFeYmBuf
 ( 
BYTE
 *
buf
, &
n
 );

155 
BOOL
 
	`RdCfgInfo
 ( );

157 
	`RdCfgMInfo
 ( *
szPh
 );

159 
BOOL
 
	`RdCfgOthInfo
 ( *
szPh
 );

161 
	`InProc
 ( );

163 
	`InProcS
 ( );

165 
	`InProcTnsTab
 ( );

167 
	`InProcDa
 ( );

170 
m_fYcBuf
[
DATATRANS_MAX_YC_NUM
];

171 
DWORD
 
m_dwYmBuf
[
DATATRANS_MAX_YM_NUM
];

172 
BYTE
 
m_byYxBuf
[
DATATRANS_MAX_YX_NUM
] ;

174 
WORD
 
m_wADaIv
;

177 
BYTE
 
m_byRendCou
;

178 
m_iRendL
;

179 
BYTE
 
m_byRendBuf
[
DATATRANS_MAX_BUF_LEN
];

182 
WORD
 
m_wADaPos
;

185 
BOOL
 
m_bSdg
;

186 
BYTE
 
m_bySdCou
;

189 
DWORD
 
m_LolAddTime
;

190 
DWORD
 
m_LolSumTime
;

191 
DWORD
 
m_LolAddHour
;

192 
DWORD
 
m_LolHbtTime
;

193 
DWORD
 
m_LolHbtAddTime
;

196 
CDFe
 
m_DFe
;

197 
m_szPhD
[128];

198 
m_szReFeName
[64];

199 
tm
 
m_SaveFeTime
;

200 
WORD
 
m_wFeDaPos
;

201 
m_szRdFe
[128];

202 
DWORD
 
m_dwFeYcBegPos
;

203 
DWORD
 
m_dwFeYxBegPos
;

204 
DWORD
 
m_dwFeYmBegPos
;

206 
BYTE
 
m_byTimCou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDataTrans.cpp

21 
	~"CDaTns.h
"

22 
	~<dio.h
>

30 
	gCDaTns
::
	$CDaTns
 ()

32 
	`memt

m_fYcBuf
, 0, ( m_fYcBuf ) );

33 
	`memt

m_byYxBuf
, 0, ( m_byYxBuf ) );

34 
	`memt

m_dwYmBuf
, 0, ( m_dwYmBuf ) );

37 
m_wADaIv
 = 15;

38 
m_LolHbtTime
 = 60 * 1000;

41 
	`InProcS
( );

42 
	`tf
 ( "CDataTrans construtor\n" );

45 
	}
}

56 
	gCDaTns
::~
	$CDaTns
 ()

58 
	`tf
 ( "CDataTrans destrutor\n" );

60 
	}
}

72 
	gCDaTns
::
	$TimProc
 ( )

75 
	`RdChgDa
();

78 
	`TimeToProc
( );

81 
	`ProcEProc
( );

82 
	}
}

94 
BOOL
 
	gCDaTns
::
	$ProssProcBuf
 ( 
BYTE
 *
pBuf
, 
n
 )

96 
pos
 =0;

98 if!
	`WhhBufVid

pBuf
, 
n
, 
pos
 ) )

100 
	`t
( ( * )"CDataTrans can't findightecv buf" );

101 
	`SS

DATATRANS_RESEND_STATE
 );

102  
FALSE
;

106 if!
	`ProssRecvBuf
&
pBuf
[
pos
], 
n
 ) )

108  
FALSE
;

112 
	`SRecvPam
( );

113  
TRUE
;

114 
	}
}

127 
BOOL
 
	gCDaTns
::
	$GProcBuf
 ( 
BYTE
 *
buf
,

128 &
n
,

129 
PBUSMSG
 
pBusMsg
)

131 
BOOL
 
bR
 = 
FALSE
;

134 if
NULL
 =
buf
 )

136 
	`t
( ( * )" CDataTrans GetProtocolBuf buf = NULL" );

137  
FALSE
;

139 
	`memt

buf
, 0, 256 );

143 
bR
 = 
	`GSdBuf

buf
, 
n
 );

146 
	`SSdPam

bR
 );

148  
bR
;

149 
	}
}

161 
BOOL
 
	gCDaTns
::
	$In
 ( 
BYTE
 
byLeNo
 )

164 if!
	`RdCfgInfo
( ) )

166  
FALSE
;

170 
	`InProc
( );

173 
	`UntS

DATATRANS_LINK_STATE
 );

174  
TRUE
;

175 
	}
}

188 
	gCDaTns
::
	$TimeToProc
 ( )

191 if
	`TimeToA
( ) )

193 
	`t
( (*)"CDataTransimetoall" );

194 
DWORD
 
dwA
 = 
DATATRANS_YC_STATE
 | 
DATATRANS_YX_STATE
 | 
DATATRANS_YM_STATE
 ;

195 
	`SS

dwA
 );

197 
	`SS

DATATRANS_LINK_STATE
 );

200 if
	`TimeToHbt
( ) )

202 
	`t
( (*)"CDataTransimetoheart" );

203 
	`SS

DATATRANS_HEARTBEAT_STATE
 );

205 
	`SS

DATATRANS_LINK_STATE
 );

208 
	}
}

220 
BOOL
 
	gCDaTns
::
	$TimeToA
 ( )

222 
m_LolAddTime
 += 200;

223 if
m_LolAddTime
 >
m_LolSumTime
 )

226 if
m_ProcS
 )

228  
FALSE
;

232 
m_LolHbtAddTime
 = 0;

234 
m_LolAddTime
 = 0;

235  
TRUE
;

238  
FALSE
;

239 
	}
}

250 
BOOL
 
	gCDaTns
::
	$TimeToHbt
 ( )

252 
m_LolHbtAddTime
 += 200;

253 if
m_LolHbtAddTime
 >
m_LolHbtTime
 )

256 if
m_ProcS
 )

258  
FALSE
;

262 
m_LolHbtAddTime
 = 0;

263  
TRUE
;

266  
FALSE
;

267 
	}
}

279 
	gCDaTns
::
	$ProcEProc
 ( )

281 
m_byTimCou
 ++;

283 if
m_byTimCou
 > 20 )

285 
m_byTimCou
 = 0;

286 if! 
	`IsHaveS
(
DATATRANS_LINK_STATE
) )

287 
	`t
( "CDataTrans isuninglease wait" );

290 if
m_bySdCou
 > 
DATATRANS_MAX_SEND_COUNT
 )

292 
	`rtf

m_szPrtBuf
, "ndcou=%d > %d inroc",
m_bySdCou
, 
DATATRANS_MAX_SEND_COUNT
 );

293 
	`t
(
m_szPrtBuf
 );

294 
	`InProcS
( );

296 
	}
}

309 
BOOL
 
	gCDaTns
::
	$ProssRecvBuf
 ( 
BYTE
 *
pBuf
, 
n
 )

311 if!
m_bSdg
 )

313  
FALSE
;

316  
pBuf
[1] )

319 if!
	`IsHaveS

DATATRANS_YC_STATE
 ) )

321  
FALSE
;

323 if
	`IsHaveS

DATATRANS_YC_OVER_STATE
 ) )

325 
	`UntS

DATATRANS_YC_OVER_STATE
 );

326 
	`UntS

DATATRANS_YC_STATE
 );

328 
	`t
( (*)"CDataTransocessecv yc" );

332 if!
	`IsHaveS

DATATRANS_YX_STATE
 )

333 && !
	`IsHaveS

DATATRANS_CHANGE_YX_STATE
 ) )

335  
FALSE
;

338 if
	`IsHaveS

DATATRANS_CHANGE_YX_STATE
 ) )

340 
	`t
( (*)"CDataTransocessecv changeyx" );

341 
	`UntS

DATATRANS_CHANGE_YX_STATE
 );

344 if
	`IsHaveS

DATATRANS_YX_OVER_STATE
 ) )

346 
	`UntS

DATATRANS_YX_OVER_STATE
 );

347 
	`UntS

DATATRANS_YX_STATE
 );

349 
	`t
( (*)"CDataTransocessecv yx" );

353 if!
	`IsHaveS

DATATRANS_YM_STATE
 ) )

355  
FALSE
;

357 if
	`IsHaveS

DATATRANS_YM_OVER_STATE
 ) )

359 
	`UntS

DATATRANS_YM_OVER_STATE
 );

360 
	`UntS

DATATRANS_YM_STATE
 );

362 
	`t
( (*)"CDataTransocessecv ym" );

366 if!
	`IsHaveH
( ) )

368  
FALSE
;

371 
	`UntS

DATATRANS_HEARTBEAT_STATE
 );

372 
	`t
( (*)"CDataTransocessecv heart" );

378  
FALSE
;

382  
TRUE
;

383 
	}
}

395 
	gCDaTns
::
	$SRecvPam
 ( )

397 
m_bSdg
 = 
FALSE
;

398 
m_bySdCou
 = 0;

399 
	`UntS

DATATRANS_RESEND_STATE
 );

400 
	}
}

415 
BOOL
 
	gCDaTns
::
	$GSdBuf
 ( 
BYTE
 *
buf
, &
n
 )

417 
BOOL
 
bR
 = 
TRUE
;

419 if!
	`GProcS
( ) )

421  
FALSE
;

425 
bR
 = 
	`GSdTyBuf

buf
, 
n
 );

428 
	`SaveRendBuf

buf
, 
n
, 
bR
 );

430  
bR
;

431 
	}
}

443 
BOOL
 
	gCDaTns
::
	$GProcS
 ( )

446 if
	`IsRend
( ) )

449 
	`SS

DATATRANS_RESEND_STATE
 );

451 
	`SS

DATATRANS_LINK_STATE
 );

452  
TRUE
;

456 if
	`IsHaveChgeYX
( ) )

458 
	`t
( (*)"CDataTrans changeyx" );

459 
	`SS

DATATRANS_CHANGE_YX_STATE
 );

461 
	`SS

DATATRANS_LINK_STATE
 );

462  
TRUE
;

466 if
	`IsHaveA
( ) )

468 
	`t
( (*)"CDataTranslldata" );

470 
	`SS

DATATRANS_LINK_STATE
 );

471  
TRUE
;

475 if
	`IsHaveH
( ) )

477 
	`t
( (*)"CDataTrans heart" );

479 
	`SS

DATATRANS_LINK_STATE
 );

480  
TRUE
;

484 
	`UntS

DATATRANS_LINK_STATE
 );

485  
FALSE
;

486 
	}
}

497 
BOOL
 
	gCDaTns
::
	$IsRend
 ( ) const

499  
	`IsHaveS

DATATRANS_RESEND_STATE
 );

500 
	}
}

511 
BOOL
 
	gCDaTns
::
	$IsHaveChgeYX
 ( ) const

513 i
m_dwDIEQueue
.
	`size
( ) > 0 )

515  
TRUE
;

518  
FALSE
;

519 
	}
}

530 
BOOL
 
	gCDaTns
::
	$IsHaveA
 ( ) const

532 
DWORD
 
dwA
 = 
DATATRANS_YC_STATE
 | 
DATATRANS_YX_STATE
 | 
DATATRANS_YM_STATE


533 | 
DATATRANS_YC_OVER_STATE
 | 
DATATRANS_YX_OVER_STATE
 | 
DATATRANS_YM_OVER_STATE
;

534 if
dwA
 & 
m_ProcS
 )

536  
TRUE
;

539  
FALSE
;

540 
	}
}

552 
BOOL
 
	gCDaTns
::
	$IsHaveH
 ( ) const

554  
	`IsHaveS

DATATRANS_HEARTBEAT_STATE
 );

555 
	}
}

568 
BOOL
 
	gCDaTns
::
	$GSdTyBuf
 ( 
BYTE
 *
buf
, &
n
)

571 if
	`IsHaveS

DATATRANS_RESEND_STATE
 ) )

573 
	`GRendBuf

buf
, 
n
 );

574  
TRUE
;

578 if
	`IsHaveS

DATATRANS_CHANGE_YX_STATE
 ) )

580  
	`GChgeYXBuf

buf
, 
n
 );

584 if
	`GADaBuf

buf
, 
n
 ) )

586  
TRUE
;

590 if
	`IsHaveH
( ) )

592  
	`GHBuf

buf
, 
n
 );

595  
FALSE
;

596 
	}
}

608 
BOOL
 
	gCDaTns
::
	$GChgeYXBuf
 ( 
BYTE
 *
buf
, &
n
 )

611 
BOOL
 
bR
 = 
	`PackChgeYXBuf

buf
, 
n
 );

614 
	`t
( (*)"CDataTrans get changeyx" );

616  
bR
;

617 
	}
}

630 
BOOL
 
	gCDaTns
::
	$PackChgeYXBuf
 ( 
BYTE
 *
buf
, &
n
 )

632 
WORD
 
wSlNo
;

633 
WORD
 
wP
;

634 
WORD
 
wV
;

635 
BOOL
 
bDevS
;

636 
BYTE
 
byV
;

639 if!
	`GDigEvt

wSlNo
, 
wP
, 
wV
 ) )

641  
FALSE
;

644 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 );

646 
byV
 = ( 
bDevS
 << 1 ) | ( 
wV
 & 0x01 );

648 
n
 = 0;

650 
buf
[
n
++] = 0x68;

652 
buf
[
n
++] = 
	`HIBYTE

m_wDevAddr
 );

653 
buf
[
n
++] = 
	`LOBYTE

m_wDevAddr
 );

655 
buf
[
n
++] = 0xF2;

657 
buf
[
n
++] = 
	`HIBYTE

wP
 );

658 
buf
[
n
++] = 
	`LOBYTE

wP
 );

660 
buf
[
n
++] = 0x01;

662 
buf
[
n
++] = 
byV
;

664  
TRUE
;

665 
	}
}

677 
BOOL
 
	gCDaTns
::
	$GADaBuf
 ( 
BYTE
 *
buf
, &
n
 )

680 if
	`IsHaveS

DATATRANS_YC_STATE
 ) )

682 
	`t
( (*)"CDataTrans get yc" );

683  
	`GYCDaBuf

buf
, 
n
 );

687 if
	`IsHaveS

DATATRANS_YX_STATE
 ) )

689 
	`t
( (*)"CDataTrans get yx" );

690  
	`GYXDaBuf

buf
, 
n
 );

694 i
	`IsHaveS

DATATRANS_YM_STATE
 ) )

696 
	`t
( (*)"CDataTrans get ym" );

697  
	`GYMDaBuf

buf
, 
n
 );

700  
FALSE
;

701 
	}
}

713 
BOOL
 
	gCDaTns
::
	$GYCDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

716 
BOOL
 
bR
 = 
	`PackYCBuf

buf
, 
n
 );

718 if
m_wADaPos
 >
m_wAISum
 )

721 
	`SS
 ( 
DATATRANS_YC_OVER_STATE
 );

722 
m_wADaPos
 = 0;

724  
bR
;

725 
	}
}

737 
BOOL
 
	gCDaTns
::
	$PackYCBuf
 ( 
BYTE
 *
buf
, &
n
 )

739 
BYTE
 
byCou
 = 0;

740 
n
 = 0;

742 
buf
[
n
++] = 0x68;

744 
buf
[
n
++] = 
	`HIBYTE

m_wDevAddr
 );

745 
buf
[
n
++] = 
	`LOBYTE

m_wDevAddr
 );

747 
buf
[
n
++] = 0xF0;

749 
buf
[
n
++] = 
	`HIBYTE

m_wADaPos
 );

750 
buf
[
n
++] = 
	`LOBYTE

m_wADaPos
 );

752 
buf
[
n
++] = 0x00;

754  
i
=
m_wADaPos
; i<
m_wAISum
; i++ )

756 
fV
 = 
m_fYcBuf
[
i
];

757 
BYTE
 
szTmp
[4];

759 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YC_TRANSTOSERIALNO
 , 
i
 ) ;

760 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

762 
buf
[
n
++] = (
BYTE
)
bDevS
;

765 
	`memy

szTmp
, &
fV
, 4 );

766 
buf
[
n
++] = 
szTmp
[3];

767 
buf
[
n
++] = 
szTmp
[2];

768 
buf
[
n
++] = 
szTmp
[1];

769 
buf
[
n
++] = 
szTmp
[0];

776 
byCou
 ++;

777 if
byCou
 >= 45 )

784 
buf
[6] = 
byCou
;

785 
m_wADaPos
 +
byCou
;

787  
TRUE
;

788 
	}
}

799 
BOOL
 
	gCDaTns
::
	$GYXDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

802 
BOOL
 
bR
 = 
	`PackYXBuf

buf
, 
n
 );

804 if
m_wADaPos
 >
m_wDISum
 )

807 
	`SS
 ( 
DATATRANS_YX_OVER_STATE
 );

808 
m_wADaPos
 = 0;

810  
bR
;

811 
	}
}

822 
BOOL
 
	gCDaTns
::
	$PackYXBuf
 ( 
BYTE
 *
buf
, &
n
 )

824 
BYTE
 
byCou
 = 0;

825 
n
 = 0;

827 
buf
[
n
++] = 0x68;

829 
buf
[
n
++] = 
	`HIBYTE

m_wDevAddr
 );

830 
buf
[
n
++] = 
	`LOBYTE

m_wDevAddr
 );

832 
buf
[
n
++] = 0xF2;

834 
buf
[
n
++] = 
	`HIBYTE

m_wADaPos
 );

835 
buf
[
n
++] = 
	`LOBYTE

m_wADaPos
 );

837 
buf
[
n
++] = 0x00;

839  
i
=
m_wADaPos
; i<
m_wDISum
; i += 4 )

842  
j
=0; j<4; j++)

844 if
i
 + 
j
 >
m_wDISum
 )

848 
WORD
 
wV
 = 
m_byYxBuf
[
i
+
j
];

850 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YX_TRANSTOSERIALNO
 , 
i
+
j
 ) ;

851 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

854 
BYTE
 
byV
 = ( 
bDevS
 << 1 ) | ( 
wV
 & 0x01 );

855 
buf
[
n
] = ( buf[n] | ( 
byV
 << ( 2 * 
j
 ) ) ) ;

863 
n
 ++;

865 
byCou
 += 4;

866 if
byCou
 >= 240 )

873 
buf
[6] = 
byCou
;

874 
m_wADaPos
 +
byCou
;

875  
TRUE
;

876 
	}
}

887 
BOOL
 
	gCDaTns
::
	$GYMDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

890 
BOOL
 
bR
 = 
	`PackYMBuf

buf
, 
n
 );

892 if
m_wADaPos
 >
m_wPISum
 )

895 
	`SS
 ( 
DATATRANS_YM_OVER_STATE
 );

896 
m_wADaPos
 = 0;

898  
bR
;

899 
	}
}

910 
BOOL
 
	gCDaTns
::
	$PackYMBuf
 ( 
BYTE
 *
buf
, &
n
 )

912 
BYTE
 
byCou
 = 0;

913 
n
 = 0;

915 
m_pMhod
->
	`RdAYmDa
(&
m_dwYmBuf
[0]);

917 
buf
[
n
++] = 0x68;

919 
buf
[
n
++] = 
	`HIBYTE

m_wDevAddr
 );

920 
buf
[
n
++] = 
	`LOBYTE

m_wDevAddr
 );

922 
buf
[
n
++] = 0xF4;

924 
buf
[
n
++] = 
	`HIBYTE

m_wADaPos
 );

925 
buf
[
n
++] = 
	`LOBYTE

m_wADaPos
 );

927 
buf
[
n
++] = 0x00;

929  
i
=
m_wADaPos
; i<
m_wPISum
; i++ )

931 
szTmp
[4];

932 
DWORD
 
dwV
 = 
m_dwYmBuf
[
i
];

934 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

DD_TRANSTOSERIALNO
 , 
i
 ) ;

935 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

937 
buf
[
n
++] = (
BYTE
)
bDevS
;

938 
fV
 = ()
dwV
;

940 
	`memy

szTmp
, &
fV
, 4 );

941 
buf
[
n
++] = 
szTmp
[3];

942 
buf
[
n
++] = 
szTmp
[2];

943 
buf
[
n
++] = 
szTmp
[1];

944 
buf
[
n
++] = 
szTmp
[0];

947 
byCou
 ++;

948 if
byCou
 >= 45 )

955 
buf
[6] = 
byCou
;

956 
m_wADaPos
 +
byCou
;

957  
TRUE
;

958 
	}
}

970 
BOOL
 
	gCDaTns
::
	$GHBuf
 ( 
BYTE
 *
buf
, &
n
 )

972 
n
 = 0;

973 
buf
[
n
++] = 0x68;

974 
buf
[
n
++] = 0xF6;

976  
TRUE
;

977 
	}
}

990 
	gCDaTns
::
	$GRendBuf
 ( 
BYTE
 *
buf
, &
n
 )

992 
n
 = 
m_iRendL
;

993 
	`memy

buf
, 
m_byRendBuf
, 
n
 );

995 
m_byRendCou
 ++;

996 
	}
}

1010 
	gCDaTns
::
	$SaveRendBuf
 ( 
BYTE
 *
buf
, 
n
, 
BOOL
 
byVid
 )

1012 if
byVid
 )

1014 
m_iRendL
 = 
n
;

1015 
	`memy

m_byRendBuf
, 
buf
, 
m_iRendL
 );

1017 
	}
}

1028 
	gCDaTns
::
	$SSdPam
 ( 
BOOL
 
bIsSdVid
 )

1030 if
bIsSdVid
 )

1032 
m_bSdg
 = 
TRUE
;

1033 
m_bySdCou
 ++;

1034 
	`SS

DATATRANS_RESEND_STATE
 );

1036 
	}
}

1049 
BOOL
 
	gCDaTns
::
	$RdCfgInfo
 ( )

1051 
szPh
[256] = "";

1052 
	`rtf

szPh
, "%s%s" ,
DATATRANSSPREFIXFILENAME
, 
m_sTemePh
 );

1053 
	`t

szPh
 );

1056 
	`RdCfgMInfo
 ( 
szPh
 );

1060 if!
	`RdCfgOthInfo

szPh
 ) )

1065 
	`t
( (*)"CDataTrans ReadCfgInfo OK" );

1066  
TRUE
;

1067 
	}
}

1079 
	gCDaTns
::
	$RdCfgMInfo
 ( *
szPh
 )

1082 
	`RdMCfig

szPh
 );

1083 
	}
}

1094 
BOOL
 
	gCDaTns
::
	$RdCfgOthInfo
 ( *
szPh
 )

1096 
FILE
 *

 = 
NULL
;

1097 
szLeBuf
[256];

1098 
iLeNum
 = 0;

1099 
iOthInfoNum
 = 0;

1100 
iOthInfoANum
 = 2;

1102 

 = 
	`fݒ

szPh
 , "r");

1103 i
NULL
 =

 )

1105 
	`tf
 ( "ݒ f%r!!!\n", 
szPh
 );

1106  
FALSE
;

1109  
NULL
 !
	`fgs
(
szLeBuf
, (szLeBuf), 

)

1110 && 30 > 
iLeNum
 )

1112 
iLeNum
 ++;

1113 if0 =
	`cmp
 ( 
szLeBuf
, "SENDINTERVAL=", 13 ) )

1115 
WORD
 
wCfgV
 = (WORD)
	`oi
&
szLeBuf
[13] ) );

1116 if
wCfgV
 >= 1 )

1118 
m_wADaIv
 = 
wCfgV
;

1122 
	`tf
 ( "CDaTnSENDINTERVAL=%d!!! deu iud\n", 
wCfgV
 );

1123 
m_wADaIv
 = 15;

1126 
m_LolSumTime
 = 
m_wADaIv
 *1000 ;

1127 
iOthInfoNum
 ++;

1129 if0 ==
	`cmp

szLeBuf
, "HEARTTIME=", 10 ) )

1131 
WORD
 
wCfgV
 = (WORD)
	`oi
&
szLeBuf
[10] ) );

1132 if
wCfgV
 >= 1 )

1134 
m_LolHbtTime
 = 
wCfgV
 * 1000;

1138 
	`tf
 ( "CDaTnHEARTTIME=%d!!! deu iud\n", 
wCfgV
 );

1139 
m_LolHbtTime
 = 60 * 1000;

1142 
iOthInfoNum
 ++;

1145 if
iOthInfoANum
 <
iOthInfoNum
 )

1147 
	`tf
 ( "CDaTnldrv=%lums, hrv=%lums\n", 
m_LolSumTime
, 
m_LolHbtTime
 );

1152 
	`fo


 );

1153  
TRUE
;

1154 
	}
}

1165 
	gCDaTns
::
	$InProc
 ( )

1168 
	`InProcS
( );

1171 
	`InProcTnsTab
( );

1174 
	`InProcDa
( );

1176 
	`t
( (*)"CDataTrans InitProtocol OK" );

1177 
	}
}

1189 
	gCDaTns
::
	$InProcS
 ( )

1193 if
	`IsHaveS

DATATRANS_LINK_STATE
 ) )

1196 
	`UntS

DATATRANS_LINK_STATE
 );

1198 
m_ProcS
 = 0;

1200 
m_byRendCou
 = 0;

1201 
m_iRendL
 = 0;

1202 
	`memt

m_byRendBuf
, 0, ( m_byResendBuf ) );

1204 
m_wADaPos
 = 0;

1206 
m_bSdg
=
FALSE
;;

1207 
m_bySdCou
 = 0;

1210 
m_LolAddTime
 = 0;

1211 
m_LolHbtAddTime
 = 0;

1212 
m_byTimCou
 = 0;

1216 
	`t
( (*)"CDataTrans InitProtocolState" );

1218 
	}
}

1230 
	gCDaTns
::
	$InProcTnsTab
 ( )

1233 
	`CeTnsTab
();

1234 
	}
}

1245 
	gCDaTns
::
	$InProcDa
 ( )

1248 
m_pMhod
->
	`RdAYcDa
(&
m_fYcBuf
[0]);

1249 
m_pMhod
->
	`RdAYmDa
(&
m_dwYmBuf
[0]);

1250 
m_pMhod
->
	`RdAYxDa
&
m_byYxBuf
[ 0 ] ) ;

1251 
	}
}

1254 
	gCDaTns
::
	$GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
)

1256 
WORD
 
wVue
 = 0 ;

1257 
byTy
)

1260 if(
wP
>=
DATATRANS_MAX_YC_NUM
)  -2;

1261 
	`memy
(
v
, &
m_fYcBuf
[
wP
], (
WORD
));

1265 if(
wP
>=
DATATRANS_MAX_YX_NUM
)

1268 if
m_byYxBuf
[ 
wP
 ] ==0 )

1269 
wVue
 = 0;

1271 
wVue
 = 1;

1273 
	`memy
(
v
, &
wVue
, (
WORD
));

1277 if(
wP
>=
DATATRANS_MAX_YM_NUM
)  -2;

1278 
	`memy
(
v
, &
m_dwYmBuf
[
wP
], (
DWORD
));

1284 
	}
}

1286 
BOOL
 
	gCDaTns
::
	$WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
fV
)

1288 if(
m_pwAITns
==
NULL
 
FALSE
;

1289 
WORD
 
wNum
 = 
m_pwAITns
[
wP
];

1290 if(
wNum
>
m_wAISum
 
FALSE
;

1291 if(
wNum
<
DATATRANS_MAX_YC_NUM
)

1293 
fDt
 = 
fV
 - 
m_fYcBuf
[
wNum
];

1294 if(
	`abs
(()
fDt
)>=
m_wDdV
)

1296 
m_fYcBuf
[
wNum
] = 
fV
;

1299 
	`AddAlogEvt

wSlNo
 , 
wNum
, 
fV
);

1303  
TRUE
 ;

1304 
	}
}

1306 
BOOL
 
	gCDaTns
::
	$WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
)

1308 if(
m_pwDITns
==
NULL
 
FALSE
;

1309 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

1310 if(
wNum
>
m_wDISum
 
FALSE
;

1311 if
wNum
<
DATATRANS_MAX_YX_NUM
)

1313 if
m_byYxBuf
[ 
wNum
 ] !
wV
 )

1315 
m_byYxBuf
[ 
wNum
 ] = 
wV
 ;

1318 
	`AddDigEvt

wSlNo
 , 
wNum
, 
wV
);

1322  
TRUE
 ;

1323 
	}
}

1324 
BOOL
 
	gCDaTns
::
	$WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
)

1326 if(
m_pwPITns
==
NULL
 
FALSE
;

1327 
WORD
 
wNum
 = 
m_pwPITns
[
wP
];

1328 if(
wNum
>
m_wPISum
 
FALSE
;

1329 if(
wNum
<
DATATRANS_MAX_YM_NUM
)

1331 
m_dwYmBuf
[
wNum
] = 
dwV
;

1333  
TRUE
 ;

1334 
	}
}

1336 
BOOL
 
	gCDaTns
::
	$WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

1338 if(
m_pwDITns
==
NULL
 
FALSE
;

1339 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

1340 if(
wNum
>=
m_wDISum
 
FALSE
;

1341 if(
wNum
<
DATATRANS_MAX_YX_NUM
)

1343 
	`AddSOEInfo
(
wSlNo
 , 
wNum
, 
wV
, 
lTime
, 
wMiSecd
);

1345  
TRUE
 ;

1346 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDataTrans.h

22 #ide 
CDATATRANS_INC


23 
	#CDATATRANS_INC


	)

26 
	~"CProc_DaTns.h
"

43 as
	cCDaTns
 : 
public
 
CProc_DaTns


45 
public
:

47 
CDaTns
 ();

48 
	mvtu
 ~
CDaTns
 ();

52 
vtu
 
TimProc
( );

54 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

56 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

58 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
pBuf
 , 
n
 ) ;

60 
vtu
 
GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
);

61 
vtu
 
BOOL
 
WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
fV
) ;

62 
vtu
 
BOOL
 
WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
) ;

63 
vtu
 
BOOL
 
WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
) ;

64 
vtu
 
BOOL
 
WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
) ;

66 
	meed
:

69 
ive
:

71 
ProcEProc
 ( );

73 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
pBuf
, 
n
 );

75 
SRecvPam
 ( );

77 
BOOL
 
GSdBuf
 ( 
BYTE
 *
buf
, &
n
 );

79 
BOOL
 
GProcS
 ( );

81 
BOOL
 
	$IsRend
 ( ) const;

83 
BOOL
 
	$IsHaveChgeYX
 ( ) const;

85 
BOOL
 
	$IsHaveA
 ( ) const;

87 
BOOL
 
	$IsHaveH
 ( ) const;

89 
	`TimeToProc
( );

91 
BOOL
 
	`TimeToA
 ( );

93 
BOOL
 
	`TimeToHbt
 ( );

95 
BOOL
 
	`GSdTyBuf
 ( 
BYTE
 *
buf
, &
n
);

97 
BOOL
 
	`GChgeYXBuf
 ( 
BYTE
 *
buf
, &
n
 );

99 
BOOL
 
	`PackChgeYXBuf
 ( 
BYTE
 *
buf
, &
n
 );

101 
BOOL
 
	`GADaBuf
 ( 
BYTE
 *
buf
, &
n
 );

103 
BOOL
 
	`GYCDaBuf
 ( 
BYTE
 *
buf
, &
n
 );

105 
BOOL
 
	`PackYCBuf
 ( 
BYTE
 *
buf
, &
n
 );

107 
BOOL
 
	`GYXDaBuf
 ( 
BYTE
 *
buf
, &
n
 );

109 
BOOL
 
	`PackYXBuf
 ( 
BYTE
 *
buf
, &
n
 );

111 
BOOL
 
	`GYMDaBuf
 ( 
BYTE
 *
buf
, &
n
 );

113 
BOOL
 
	`PackYMBuf
 ( 
BYTE
 *
buf
, &
n
 );

115 
BOOL
 
	`GHBuf
 ( 
BYTE
 *
buf
, &
n
 );

117 
	`GRendBuf
 ( 
BYTE
 *
buf
, &
n
 );

119 
	`SaveRendBuf
 ( 
BYTE
 *
buf
, 
n
, 
BOOL
 
byVid
 );

121 
	`SSdPam
 ( 
BOOL
 
bIsSdVid
 );

123 
BOOL
 
	`RdCfgInfo
 ( );

125 
	`RdCfgMInfo
 ( *
szPh
 );

127 
BOOL
 
	`RdCfgOthInfo
 ( *
szPh
 );

129 
	`InProc
 ( );

131 
	`InProcS
 ( );

133 
	`InProcTnsTab
 ( );

135 
	`InProcDa
 ( );

138 
m_fYcBuf
[
DATATRANS_MAX_YC_NUM
];

139 
DWORD
 
m_dwYmBuf
[
DATATRANS_MAX_YM_NUM
];

140 
BYTE
 
m_byYxBuf
[
DATATRANS_MAX_YX_NUM
] ;

142 
WORD
 
m_wADaIv
;

145 
BYTE
 
m_byRendCou
;

146 
m_iRendL
;

147 
BYTE
 
m_byRendBuf
[
DATATRANS_MAX_BUF_LEN
];

150 
WORD
 
m_wADaPos
;

153 
BOOL
 
m_bSdg
;

154 
BYTE
 
m_bySdCou
;

157 
DWORD
 
m_LolAddTime
;

158 
DWORD
 
m_LolSumTime
;

159 
DWORD
 
m_LolHbtTime
;

160 
DWORD
 
m_LolHbtAddTime
;

162 
BYTE
 
m_byTimCou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDirFile.cpp

20 
	~"CDFe.h
"

21 
	~<dio.h
>

22 
	~<dlib.h
>

23 
	~<unid.h
>

24 
	~<dt.h
>

25 
	~<sys/.h
>

26 
	~<rg.h
>

27 
	~<w.h
>

28 
	~<sys/time.h
>

29 
	~<sys/sour.h
>

31 
DWORD
 
	gsdwDSize
;

41 
	$CDSize
 ( cڡ *
pszPh
,

42 cڡ 

 *
s
,

43 
tyag
)

45 
sdwDSize
 +
s
->
_size
;

47 
	}
}

57 
	gCDFe
::
	$CDFe
 ()

59 
im
 
r
;

60 
r
.
im_cur
 = 10240;

61 
r
.
im_max
 = 10240;

62 if
	`lim

RLIMIT_NOFILE
, &
r
 ) < 0 )

64 
	`tf
 ( "CDirFile setrlimitrror\n" );

67 
	`syem
( "ulimit -n 102400" );

69 
	`p
( 1 );

70 
	}
}

80 
	gCDFe
::~
	$CDFe
 ()

82 
	}
}

94 
BOOL
 
CDFe
::
	$CeD
 ( *
pszPh
 )

96 if
	`IsD

pszPh
 ) )

98 
	`tf
 ( "%iexi\n", 
pszPh
 );

99  
TRUE
;

103 if0 =
	`mkd

pszPh
, 0755 ) ) )

105 
	`tf
 ( "CeD %OK\n", 
pszPh
 );

106  
TRUE
;

109 
	`tf
 ( "CeD %E\n", 
pszPh
 );

110  
FALSE
;

111 
	}
}

123 
BOOL
 
	gCDFe
::
	$IsD
 ( *
pszPh
 )

125 if
NULL
 =
pszPh
 )

127  
FALSE
;

130 

 
buf
;

132 if(
	`l
(
pszPh
, &
buf
) ==0)

135  
	`S_ISDIR
(
buf
.
_mode
) != 0;

137  
FALSE
;

138 
	}
}

153 
DWORD
 
	gCDFe
::
	$WreToFe
 ( *
pszFeName
,

154 
BYTE
 *
pszBuf
,

155 
n
 )

157 
FILE
 *
pFe
 = 
NULL
;

158 
DWORD
 
dwFeL
;

161 
pFe
 = 
	`fݒ

pszFeName
, "ab+" );

162 if
NULL
 =
pFe
 )

164 
szBuf
[256];

165 
	`rtf

szBuf
, "WreToF%s:", 
pszFeName
 );

166 
	`

szBuf
 );

171 
dwFeL
 = 
	`fwre

pszBuf
, 1, 
n
, 
pFe
 );

173 
	`fo

pFe
 );

175  
dwFeL
;

176 
	}
}

191 
DWORD
 
	gCDFe
::
	$RdFromFe
 ( *
pszFeName
,

192 
BYTE
 *
pszBuf
,

193 
n
,

194 
DWORD
 
dwRdPos
)

196 
FILE
 *
pFe
 = 
NULL
;

197 
DWORD
 
dwFeL
=0;

200 
pFe
 = 
	`fݒ

pszFeName
, "rb" );

201 if
NULL
 =
pFe
 )

203 
szBuf
[256];

204 
	`rtf

szBuf
, "RdFromF%s:", 
pszFeName
 );

205 
	`

szBuf
 );

209 if-1 =
	`fek

pFe
, 
dwRdPos
, 
SEEK_SET
 ) )

211 
	`fo

pFe
 );

216 
dwFeL
 = 
	`d

pszBuf
, 1, 
n
, 
pFe
 );

218 
	`fo

pFe
 );

220  
dwFeL
;

221 
	}
}

233 
BOOL
 
	gCDFe
::
	$IsFe
 ( *
pszFeName
 )

235 
dt
 *
dp
;

236 
DIR
 *
dfd
;

237 
szPh
[128] = "";

238 
szFe
[64] = "";

240 if
NULL
 =
pszFeName
 )

242  
FALSE
;

245 *
pszFe
 = 
	`chr

pszFeName
, '/' );

246 if
NULL
 =
pszFe
 )

249 
	`ry

szPh
, "./" );

250 
	`ry

szFe
, 
pszFeName
 );

255 
	`ry

szFe
, 
pszFe
 + 1 );

257 
iPhL
 = 
	`

pszFeName
 ) - sn
pszFe
 ) + 1;

258 
	`y

szPh
, 
pszFeName
, 
iPhL
 );

261 
dfd
 = 
	`ݒd

szPh
 );

262 if
NULL
 =
dfd
 )

264 
szBuf
[256];

265 
	`rtf

szBuf
, "IsF%s:", 
pszFeName
 );

266 
	`

szBuf
 );

267  
FALSE
;

270 
dp
 = 
	`add
(
dfd
); 
NULL
!=dp; dp =eaddir(dfd))

273 if0 =
	`rcmp
(
dp
->
d_me
, 
szFe
) )

275 
	`od
(
dfd
);

276  
TRUE
;

280 
	`od
(
dfd
);

282  
FALSE
;

283 
	}
}

296 * 
	gCDFe
::
	$GLeDriFe
 ( *
pszPh
 )

298 
dt
 *
dp
 ;

299 
DIR
 *
dfd
;

300 *
pR
 = 
NULL
;

301 

 
buf
, 
Tmp
;

302 
szFeName
[128];

304 if!
	`IsD
(
pszPh
) )

306  
NULL
;

309 if(
dfd
 = 
	`ݒd
(
pszPh
)=
NULL
 )

311 
szBuf
[256];

312 
	`rtf

szBuf
, "GLeDriF%s:", 
pszPh
 );

313 
	`

szBuf
 );

314  
NULL
;

317 
dp
 = 
	`add
(
dfd
); 
NULL
!=dp; dp =eaddir(dfd))

319 if
NULL
 !
	`rr

dp
->
d_me
, ".log" ) )

321 
	`rtf

szFeName
, "%s/%s", 
pszPh
, 
dp
->
d_me
 );

323 if(
	`l
(
szFeName
, &
buf
) ==0)

325 if
NULL
 =
pR
 )

327 
pR
 = 
dp
->
d_me
;

328 
	`memy
&
Tmp
, &
buf
, 

 ) );

331 if
buf
.
_mtime
 >
Tmp
.st_mtime )

333 
pR
 = 
dp
->
d_me
;

334 
	`memy
&
Tmp
, &
buf
, 

 ) );

341 
	`od
(
dfd
);

342  
pR
;

343 
	}
}

356 * 
	gCDFe
::
	$GOldeDriFe
 ( *
pszPh
 )

358 
dt
 *
dp
 ;

359 
DIR
 *
dfd
;

360 *
pR
 = 
NULL
;

361 

 
buf
, 
Tmp
;

362 
szFeName
[128];

364 if!
	`IsD
(
pszPh
) )

366  
NULL
;

369 if(
dfd
 = 
	`ݒd
(
pszPh
)=
NULL
 )

371 
szBuf
[256];

372 
	`rtf

szBuf
, "GOldeDriF%s:", 
pszPh
 );

373 
	`

szBuf
 );

374  
NULL
;

377 
dp
 = 
	`add
(
dfd
); 
NULL
!=dp; dp =eaddir(dfd))

379 if
NULL
 !
	`rr

dp
->
d_me
, ".log" ) )

381 
	`rtf

szFeName
, "%s/%s", 
pszPh
, 
dp
->
d_me
 );

383 if(
	`l
(
szFeName
, &
buf
) ==0)

385 if
NULL
 =
pR
 )

387 
pR
 = 
dp
->
d_me
;

388 
	`memy
&
Tmp
, &
buf
, 

 ) );

391 if
buf
.
_mtime
 <
Tmp
.st_mtime )

393 
pR
 = 
dp
->
d_me
;

394 
	`memy
&
Tmp
, &
buf
, 

 ) );

400 
	`od
(
dfd
);

401  
pR
;

402 
	}
}

414 * 
	gCDFe
::
	$GDFe
 ( *
pPh
 )

416 
dt
 *
dp
;

417 
DIR
 *
dfd
;

419 if!
	`IsD
(
pPh
) )

421  
NULL
;

424 if(
dfd
 = 
	`ݒd
(
pPh
)=
NULL
 )

426 
szBuf
[256];

427 
	`rtf

szBuf
, "GDF%s:", 
pPh
 );

428 
	`

szBuf
 );

429  
NULL
;

432 
dp
 = 
	`add
(
dfd
); 
NULL
!=dp; dp =eaddir(dfd))

434 if
NULL
 !
	`rr

dp
->
d_me
, ".log" ) )

436 
	`od
(
dfd
);

437  
dp
->
d_me
;

441 
	`od
(
dfd
);

442  
NULL
;

443 
	}
}

456 
DWORD
 
	gCDFe
::
	$GDSize
 ( *
pszPh
 )

458 
sdwDSize
 = 0;

460 
iFg
 = 
	`w

pszPh
, &
CDSize
, 200 );

461 if0 =
iFg
 )

463  
sdwDSize
;

467 
	}
}

479 
BOOL
 
	gCDFe
::
	$DeFe
 ( *
pszFeName
 )

481 if!
	`IsFe

pszFeName
 ) )

483  
FALSE
;

486 
	`move

pszFeName
 );

488  
TRUE
;

489 
	}
}

501 
BOOL
 
	gCDFe
::
	$DeOldeFe
 ( *
pszPh
 )

503 *
pFe
;

504 
szFe
[128];

505 if!
	`IsD

pszPh
 ) )

507  
FALSE
;

510 
pFe
 = 
	`GOldeDriFe

pszPh
 );

511 if
NULL
 =
pFe
 )

513  
FALSE
;

516 
	`rtf

szFe
, "%s/%s", 
pszPh
, 
pFe
 );

517 
	`DeFe

szFe
 );

519  
FALSE
;

520 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDirFile.h

21 #ide 
CDIRFILE_INC


22 
	#CDIRFILE_INC


	)

24 
	~"../../she/tydef.h
"

32 as
	cCDFe


34 
	mpublic
:

36 
CDFe
 ();

37 ~
CDFe
 ();

40 
BOOL
 
CeD
*
pszPh
 );

42 
BOOL
 
IsD
*
pszPh
 );

44 
BOOL
 
IsFe
 ( *
pszFeName
 );

46 
DWORD
 
WreToFe
 ( *
pszFeName
, 
BYTE
 *
pszBuf
, 
n
);

48 
DWORD
 
RdFromFe
 ( *
pszFeName
, 
BYTE
 *
pszBuf
, 
n
 , DWORD 
dwRdPos
);

50 *
GDFe
*
pPh
 );

52 *
GLeDriFe
 ( *
pszPh
 );

54 *
GOldeDriFe
 ( *
pszPh
 );

56 
BOOL
 
DeFe
*
pszFeName
 );

58 
BOOL
 
DeOldeFe
*
pszPh
 );

60 
DWORD
 
GDSize
 ( *
pszPh
 );

63 
	meed
:

66 
ive
:

68 
DWORD
 
m_dwDSize
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CProtocol_DataTrans.cpp

22 
	~"CProc_DaTns.h
"

23 
	~"CDaTns.h
"

24 
	~"CDTWhTime.h
"

29 
	#MODULE_DATATRANS
 1

	)

30 
	#MODULE_DATATRANSWITHTIME
 2

	)

33 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

43 
	gCProc_DaTns
::
	$CProc_DaTns
 ()

45 
	`memt

m_sTemePh
, 0, ( m_sTemplatePath ) );

46 
	`memt

m_szPrtBuf
 , 0, (m_szPrintBuf) );

47 
	`memt

m_sMaAddr
, 0, ( m_sMasterAddr ) );

49 
m_ProcS
 = 0;

50 
	`tf
 ( "CProtocol_DataTrans constructor\n" );

51 
	}
}

61 
	gCProc_DaTns
::~
	$CProc_DaTns
 ()

64 
size
 = 
m_modu
.
	`size
() ;

65  
i
 = 0 ; i < 
size
 ; i++ )

67 
de
 
m_modu
[ 
i
 ] ;

69 
m_modu
.
	`r
() ;

71 
	`tf
( "Delete All CProtocol_DataTrans OK . \n" );

72 
	}
}

86 
BOOL
 
	gCProc_DaTns
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

88  
FALSE
;

89 
	}
}

101 
BOOL
 
	gCProc_DaTns
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

103  
FALSE
;

104 
	}
}

116 
BOOL
 
	gCProc_DaTns
::
	$In
 ( 
BYTE
 
byLeNo
 )

119 
m_byLeNo
 = 
byLeNo
;

121 
m_ProTy
 = 
PROTOCO_TRANSPROT
;

123  
	`GDevDa
( );

124 
	}
}

135 
BOOL
 
	gCProc_DaTns
::
	$GDevDa
 ( )

137 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

138 
	`rtf

m_sDevPh
 , "%s/DaTns/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

139 
CProfe
 
	`ofe

m_sDevPh
 ) ;

140 if!
ofe
.
	`IsVid
() )

142 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

143  
FALSE
 ;

146  
	`ProssFeDa

ofe
 );

147 
	}
}

159 
BOOL
 
	gCProc_DaTns
::
	$ProssFeDa
 ( 
CProfe
 &
ofe
 )

162 
sSe
[ 200 ] = "DEVNUM" ;

163 
sKey
[ 20 ][ 50 ]={ "module" , "addr" , "name" , "masteraddr" , "template" , "ycdead" , "ycProperty" , "timing"} ;

164 
sName
[ 50 ] = { 0 };

165 
eme
[ 200 ] = { 0 };

166 
iNum
 = 0 ;

167 
sMaAddr
[ 200 ] = { 0 } ;

169 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

170 if
iNum
 == 0 )

172 
	`tf
( "Get DEVNUM Failed ! \n " );

173  
FALSE
 ;

176 
BYTE
 
byIndex
 = 0 ;

177  
i
 = 0 ; i < 
iNum
 ; i++ )

179 
BOOL
 
bR
;

180 
iModu
 = 0 ;

181 
addr
 =0 ;

182 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

184 
iModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 
byIndex
++ ] , 0 ) ;

185 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 
byIndex
++ ] , 0 ) ;

187 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

188 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
sMaAddr
 , 
eme
 ) ) ;

189 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

192 
bR
 = 
	`CeModu

iModu
 ,

193 
sMaAddr
 ,

194 
addr
 ,

195 
sName
 ,

196 
eme
 ) ;

197 i!
bR
 )

199 
	`tf
 ( "CIEC101S Modu=%dddr=%d sName=%eme=%\
 \n", 
iModu
, 
addr
, 
sName
, 
eme
 );

201  
FALSE
;

205  
TRUE
 ;

206 
	}
}

221 
BOOL
 
	gCProc_DaTns
::
	$CeModu
 ( 
iModu
 ,

222 * 
sMaAddr
 ,

223 
iAddr
 ,

224 * 
sName
 ,

225 * 
ePh
 )

227 
CProc_DaTns
 * 
pProc
 = 
NULL
 ;

229  
iModu
 )

231 
MODULE_DATATRANS
:

233 
pProc
 = 
w
 
CDaTns
;

234 if!
	`InModu

pProc
 , 
iModu
 , 
sMaAddr
 , 
iAddr
 , 
sName
 , 
ePh
 ) )

235  
FALSE
 ;

238 
MODULE_DATATRANSWITHTIME
:

240 
pProc
 = 
w
 
CDTWhTime
;

241 if!
	`InModu

pProc
 , 
iModu
 , 
sMaAddr
 , 
iAddr
 , 
sName
 , 
ePh
 ) )

242  
FALSE
 ;

248 
	`tf
( "%s don't containhis module Failed .\n" , "IEC101S" );

249  
FALSE
 ;

253 
m_modu
.
	`push_back

pProc
 ) ;

254  
TRUE
 ;

255 
	}
}

272 
BOOL
 
	gCProc_DaTns
::
	$InModu
 ( 
CProc_DaTns
 * 
pProc
 ,

273 
iModu
 ,

274 * 
sMaAddr
 ,

275 
iAddr
 ,

276 * 
sName
 ,

277 * 
ePh
 )

279 if
pProc
 =
NULL
 )

280  
FALSE
 ;

282 
pProc
->
m_byLeNo
 = m_byLineNo ;

283 
pProc
->
m_wModuTy
 = 
iModu
 ;

284 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

285 
	`tf
("iddr=%d m_byLeNo=%d\n", 
iAddr
, 
m_byLeNo
);

286 
	`ry

pProc
->
m_sDevName
 , 
sName
 ) ;

287 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

288 
	`ry

pProc
->
m_sMaAddr
 , 
sMaAddr
 ) ;

289 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

290 
pProc
->
m_pMhod
 = m_pMethod ;

291 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

293 if!
pProc
->
	`In

m_byLeNo
 ) )

294  
FALSE
 ;

295 
	`tf
" Add bu%d Add%d ProcNam%\n" , 
m_byLeNo
 , 
iAddr
 , 
sName
 ) ;

297  
TRUE
 ;

298 
	}
}

310 
	#ESD_DATATRANS_PRINT
 1

	)

311 
	#ESD_DATATRANS_DEBUG
 1

	)

313 
	gCProc_DaTns
::
	$t
 ( cڡ *
szBuf
 )

315 #ifde 
ESD_DATATRANS_PRINT


316 
	`tf
 ( "%s\n" , 
szBuf
);

319 #ifde 
ESD_DATATRANS_DEBUG


320 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

322 
	}
}

333 
BOOL
 
	gCProc_DaTns
::
	$WhhBufVid
 ( cڡ 
BYTE
 *
buf
,

334 &
n
,

335 &
pos
 )

337 cڡ 
BYTE
 *
por
 = 
buf
;

338 
pos
 = 0;

340 i
buf
 =
NULL
 || 
n
 <= 0 )

342 
	`rtf

m_szPrtBuf
, "CProc_DaTnWhhBufVubuf==NULL o%d" , 
n
);

343 
	`t

m_szPrtBuf
 );

344  
FALSE
;

347  
n
 > 1 )

349 *
por
)

352  *
por
 + 1 ) )

358 
n
 = 2;

359  
TRUE
;

363 
	`rtf
 ( 
m_szPrtBuf
,

365 *(
por
 + 1) );

366 
	`t

m_szPrtBuf
 );

367 
DEFAULT
;

372 
DEFAULT
;

376 
DEFAULT
:

377 
n
--;

378 
por
++;

379 
pos
 ++;

383  
FALSE
;

384 
	}
}

397 
	gCProc_DaTns
::
	$SS
 ( 
DWORD
 
dwS
 )

399 
m_ProcS
 |
dwS
;

401 
	}
}

413 
	gCProc_DaTns
::
	$UntS
 ( 
DWORD
 
dwS
 )

415 
m_ProcS
 &~
dwS
;

416 
	}
}

428 
BOOL
 
	gCProc_DaTns
::
	$IsHaveS
 ( 
DWORD
 
dwS
 ) const

430 if(
m_ProcS
 & 
dwS
) )

432  
TRUE
;

435  
FALSE
;

436 
	}
}

448 
	gCProc_DaTns
::
	$OnLk
 ( )

450 if
	`IsHaveS

DATATRANS_LINK_STATE
 ) )

456 
m_pMhod
->
	`OnSock

m_byLeNo
 );

458 
	`t
( (*)"CProtocol_DataTrans openink" );

459 
	`SS

DATATRANS_LINK_STATE
 );

460 
	}
}

471 
	gCProc_DaTns
::
	$CloLk
 ( )

473 
m_pMhod
->
	`CloSock

m_byLeNo
 );

475 if
	`IsHaveS

DATATRANS_LINK_STATE
 ) )

478 
	`t
( (*)"CProtocol_DataTrans closeink" );

479 
	`UntS

DATATRANS_LINK_STATE
 );

482 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CProtocol_DataTrans.h

23 #ide 
CPROTOCOL_DATATRANS_INC


24 
	#CPROTOCOL_DATATRANS_INC


	)

28 
	~"../../she/CMhod.h
"

29 
	~"../../she/Rtu.h
"

32 
	#DATATRANSSPREFIXFILENAME
 "/mynd/cfig/DaTns/"

	)

37 
	#DATATRANS_MAX_YC_NUM
 4096

	)

38 
	#DATATRANS_MAX_YX_NUM
 8192

	)

39 
	#DATATRANS_MAX_YM_NUM
 1024

	)

40 
	#DATATRANS_MAX_BUF_LEN
 256

	)

41 
	#DATATRANS_MAX_SEND_COUNT
 3

	)

46 
	#DATATRANS_LINK_STATE
 0x00000001

	)

47 
	#DATATRANS_RESEND_STATE
 0x00000002

	)

48 
	#DATATRANS_YC_STATE
 0x00000004

	)

49 
	#DATATRANS_YC_OVER_STATE
 0x00000008

	)

50 
	#DATATRANS_YX_STATE
 0x00000010

	)

51 
	#DATATRANS_YX_OVER_STATE
 0x00000020

	)

52 
	#DATATRANS_YM_STATE
 0x00000040

	)

53 
	#DATATRANS_YM_OVER_STATE
 0x00000080

	)

54 
	#DATATRANS_CHANGE_YX_STATE
 0x00000100

	)

55 
	#DATATRANS_HEARTBEAT_STATE
 0x00000200

	)

56 
	#DATATRANS_WRITEFILE_STATE
 0x00000400

	)

57 
	#DATATRANS_WRITEFILE_OVER_STATE
 0x00000800

	)

58 
	#DATATRANS_WRITEFILE_HEAD_STATE
 0x00001000

	)

59 
	#DATATRANS_WRITEFILE_YC_STATE
 0x00002000

	)

60 
	#DATATRANS_WRITEFILE_YX_STATE
 0x00004000

	)

61 
	#DATATRANS_WRITEFILE_YM_STATE
 0x00008000

	)

67 
	mESD_DATATRANS_YC_DATATYPE
,

68 
	mESD_DATATRANS_YX_DATATYPE
,

69 
	mESD_DATATRANS_YM_DATATYPE


70 }
	tESD_DATATRANS_DATATYPE
;

80 as
	cCProc_DaTns
 : 
public
 
CRtuBa


82 
public
:

84 
CProc_DaTns
 ();

85 
	mvtu
 ~
CProc_DaTns
 ();

89 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

91 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

93 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

95 
vtu
 
	$TimProc
(){ ; }

97 
vtu
 
BOOL
 
	$BrdCa

BYTE
 * 
buf
 , &
n
 ){ 
FALSE
;
	}
}

99 
vtu
 
BOOL
 
WhhBufVid
cڡ 
BYTE
 *
buf
, &
n
, &
pos
 );

106 
	geed
:

109 
SS
 ( 
DWORD
 
dwS
 );

111 
UntS
 ( 
DWORD
 
dwS
 );

113 
BOOL
 
	$IsHaveS
 ( 
DWORD
 
dwS
 ) const;

115 
	`OnLk
 ( );

117 
	`CloLk
 ( );

120 
m_sMaAddr
[ 200 ] ;

121 
m_szPrtBuf
[256];

122 
	`t
cڡ *
szBuf
 );

123 
DWORD
 
m_ProcS
;

125 
ive
:

128 
BOOL
 
	`GDevDa
( ) ;

130 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

132 
BOOL
 
	`CeModu

iModu
 ,

133 * 
sMaAddr
 ,

134 
iAddr
 ,

135 * 
sName
 ,

136 * 
ePh
);

138 
BOOL
 
	`InModu

CProc_DaTns
 * 
pProc
 ,

139 
iModu
 ,

140 * 
sMaAddr
 ,

141 
iAddr
 ,

142 * 
sName
 ,

143 * 
ePh
 );

146 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_DaTns.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

10 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

12 
CProc
 * 
pProc
 = 
NULL
 ;

13 
pProc
 = 
w
 
CProc_DaTns
 ;

14 if
pProc
 )

16 
pProc
->
m_pMhod
 = 
pMhod
 ;

17 
	`tf
( "libDataTrans.so OK.\n " ) ;

20  
pProc
 ;

21 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/CProtocol_Dlt645.cpp

1 
	~"CProc_D645.h
"

2 
	~"D645_2007.h
"

3 
	~"D645_1997.h
"

6 
	#DLT645DEBUG
 1

	)

8 
	#MODULE_DLT645_2007
 1

	)

9 
	#MODULE_DLT645_1997
 2

	)

11 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

22 
BYTE
 
	$HexToBcd
 ( 
BYTE
 
c
 )

24 
c
 -= 0x33;

25  (
BYTE
)
c
>>4 ) * 10 + ( c & 0x0f ));

26 
	}
}

37 
DWORD
 
	gCProc_D645
::
	$oh
 ( *
szBuf
 )

39 
BYTE
 
i
 = 0;

40 
DWORD
 
mpvue
 = 0;

41 
DWORD
 
vue
 = 0;

42 
BYTE
 
n
 = 
	`
(
szBuf
);

44 
i
=0;i<
n
;i++)

46 if(
szBuf
[
i
]>='A') && (szBuf[i]<='F') )

48 
mpvue
 = 
szBuf
[
i
]-'A'+10;

50 if(
szBuf
[
i
]>='a') && (szBuf[i]<='f') )

52 
mpvue
 = 
szBuf
[
i
]-'a'+10;

54 if(
szBuf
[
i
]>='0') && (szBuf[i]<='9') )

56 
mpvue
 = 
szBuf
[
i
]-'0';

58 
vue
 = vue*16+
mpvue
;

60  
vue
;

61 
	}
}

74 
DWORD
 
	gCProc_D645
::
	$oh
 ( *
szBuf
 , 
BYTE
 
n
, BYTE 
byFg
)

76 
BYTE
 
i
 = 0, 
j
 = 0;

77 
DWORD
 
mpvue
 = 0;

78 
DWORD
 
vue
 = 0;

81 if8 <
n
 )

83 
n
 = 8;

86 
i
=0;i<
n
;i++)

88 if1 =
byFg
 )

90 
j
 = 
i
;

92 if0 =
byFg
 )

94 
j
 = 
n
 - 
i
;

98 if(
szBuf
[
j
]>='A') && (szBuf[j]<='F') )

100 
mpvue
 = 
szBuf
[
j
]-'A'+10;

102 if(
szBuf
[
j
]>='a') && (szBuf[j]<='f') )

104 
mpvue
 = 
szBuf
[
j
]-'a'+10;

106 if(
szBuf
[
j
]>='0') && (szBuf[j]<='9') )

108 
mpvue
 = 
szBuf
[
j
]-'0';

111 
vue
 = vue*16+
mpvue
;

114  
vue
;

115 
	}
}

118 
	gCProc_D645
::
	$CProc_D645
()

121 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

122 
	`memt

m_szPrtBuf
, 0, ( m_szPrintBuf ) );

123 
	`memt

m_bySveAddr
, 0, ( m_bySlaveAddr ) );

124 
m_bySdPos
 = 0;

125 
m_byDaTy
 = 0;

126 
	}
}

128 
	gCProc_D645
::~
	$CProc_D645
()

131 
size
 = 
m_modu
.
	`size
() ;

132  
i
 = 0 ; i < 
size
 ; i++ )

134 
de
 
m_modu
[ 
i
 ] ;

136 
m_modu
.
	`r
() ;

137 
m_CfgInfo
.
	`r
();

138 
	`tf
( "Delete All CProtocol_Dlt645 OK . \n" );

139 
	}
}

141 
BOOL
 
	gCProc_D645
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

143  
FALSE
 ;

144 
	}
}

146 
BOOL
 
	gCProc_D645
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

148  
FALSE
 ;

149 
	}
}

151 
BOOL
 
	gCProc_D645
::
	$In

BYTE
 
byLeNo
 )

155 
m_byLeNo
 = 
byLeNo
 ;

157 
m_ProTy
 = 
PROTOCO_GATHER
 ;

159  
	`GDevDa
( ) ;

160 
	}
}

162 
BOOL
 
	gCProc_D645
::
	$GDevDa
( )

164 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

165 
	`rtf

m_sDevPh
 , "%s/D645/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

166 
CProfe
 
	`ofe

m_sDevPh
 ) ;

168  
	`ProssFeDa

ofe
 ) ;

169 
	}
}

171 
BOOL
 
	gCProc_D645
::
	$ProssFeDa

CProfe
 &
ofe
 )

173 if!
ofe
.
	`IsVid
() )

175 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

176  
FALSE
 ;

179 
sSe
[ 200 ] = "DEVNUM" ;

180 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

182 
sName
[ 50 ] = { 0 };

183 
eme
[ 200 ] = { 0 };

184 
iNum
 = 0 ;

186 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

187 if
iNum
 == 0 )

189 
	`tf
( "Get DEVNUM Failed ! \n " );

190  
FALSE
 ;

193  
i
 = 0 ; i < 
iNum
 ; i++ )

195 
WORD
 
wModu
 = 0 ;

196 
ro
 = 0 ;

197 
WORD
 
addr
 = 0 ;

198 
BOOL
 
bR
 = 
FALSE
;

200 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

202 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

203 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

204 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

205 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

206 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

209 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

210 i!
bR
 )

212 
	`tf
 ( "CModBuModu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

214  
FALSE
;

218  
TRUE
 ;

219 
	}
}

221 
BOOL
 
	gCProc_D645
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

223 
CProc_D645
 * 
pProc
 = 
NULL
 ;

224 
BOOL
 
bR
 = 
FALSE
;

225  
iModu
 )

227 
MODULE_DLT645_2007
:

229 
pProc
 = 
w
 
CD645_2007
 ;

230 
pProc
->
m_byLeNo
 = m_byLineNo ;

231 
pProc
->
m_wModuTy
 = 
iModu
 ;

232 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

233 
pProc
->
m_SlNo
 = 
iSlNo
 ;

234 
	`ry

pProc
->
m_sDevName
 , 
sName
 ) ;

235 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

236 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

237 
pProc
->
m_pMhod
 = m_pMethod ;

238 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

240 
bR
 = 
pProc
->
	`In

m_byLeNo
 ) ;

241 i!
bR
 )

243 
	`tf
 ( "Init Error \n");

244  
FALSE
;

246 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

249 
MODULE_DLT645_1997
:

251 
pProc
 = 
w
 
CD645_1997
 ;

252 
pProc
->
m_byLeNo
 = m_byLineNo ;

253 
pProc
->
m_wModuTy
 = 
iModu
 ;

254 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

255 
pProc
->
m_SlNo
 = 
iSlNo
 ;

256 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

257 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

258 
pProc
->
m_pMhod
 = m_pMethod ;

259 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

261 
bR
 = 
pProc
->
	`In

m_byLeNo
 ) ;

262 i!
bR
 )

264 
	`tf
 ( "Init Error \n");

265  
FALSE
;

267 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

273 
	`tf
( "ModBus don't containhis module Failed .\n" );

274  
FALSE
 ;

277 
m_modu
.
	`push_back

pProc
 ) ;

279  
TRUE
 ;

280 
	}
}

282 
BYTE
 
	gCProc_D645
::
	$GCs
cڡ 
BYTE
 * 
pBuf
 , 
n
 )

284 
BYTE
 
byR
 = 0x00;

285 
i
;

287 if
pBuf
 =
NULL
 || 
n
 <= 0 )

288  
byR
;

290  
i
=0; i<
n
 ; i++ )

292 
byR
 +
pBuf
[
i
];

294  
byR
;

295 
	}
}

297 
BOOL
 
	gCProc_D645
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

300 
dex
 = 0 ;

301 
buf
[ 
dex
++ ] = 0xFF ;

302 
buf
[ 
dex
++ ] = 0x02 ;

303 
buf
[ 
dex
++ ] = 0x03 ;

304 
buf
[ 
dex
++ ] = 0x04 ;

306 
WORD
 
wCRC
 = 
	`GCs

buf
, 
dex
 );

307 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

308 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

310 
n
 = 
dex
 ;

312 
	`tf
( "\n CProtocol_Dlt645 TestBroadCast \n " ) ;

313  
TRUE
 ;

314 
	}
}

325 
	gCProc_D645
::
	$t
 ( cڡ *
szBuf
, 
n
 )

327 #ifde 
DLT645PRINT


328 
	`tf
"%s\n", 
szBuf
 );

331 #ifde 
DLT645DEBUG


332 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

334 
	}
}

346 
BOOL
 
	gCProc_D645
::
	$WhhBufVue
 (cڡ 
BYTE
 *
buf
, &
n
, &
pos
 )

348 cڡ 
BYTE
 *
por
 = 
buf
;

349 
d
;

350 
BYTE
 
byCrc
;

351 
pos
 = 0;

353 if
buf
 =
NULL
 || 
n
 <= 0 )

354  
FALSE
;

356  
n
 > 0 )

358 *
por
)

363 if*(
por
+7) != *pointer )

365 
DEFAULT
;

369 if*
por
 + 8 ) & 0x80 ) == 0)

371 
	`t
( "Dlt645ecv λ Ϊ1" );

372 
DEFAULT
;

376 
d
=*(
por
+9);

377 if
d
+11>
n
 || datalen > 200 )

379 
	`rtf
(
m_szPrtBuf
, "D645ecv d=%d=%d", 
d
, 
n
 );

380 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
m_szPrtBuf
, 
	`
(m_szPrintBuf), 2 );

381 
DEFAULT
;

385 
byCrc
=
	`GCs
(
por
,
d
 + 10);

386 if(*(
por
+
d
+10)!=
byCrc


387 || *(
por
+
d
+11)!=0x16)

389 
	`rtf
(
m_szPrtBuf
, "D645ecv cr GCrc=%d crc=%d oϡ by !0x16 =%x", 
byCrc
, *(
por
+
d
+10), *(pointer+datalen+11));

390 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
m_szPrtBuf
, 
	`
(m_szPrintBuf), 2 );

391 
DEFAULT
;

395  
k
=0; k<6; k++)

397 if
m_bySveAddr
[
k
] != 0 && m_bySlaveAddr[k] != 0xAA )

399 i*(
por
 + 1 + 
k
!
m_bySveAddr
[k] )

401 
	`rtf
(
m_szPrtBuf
, "D645ecvddr܁h%d by Gaddr=%dddr=%d ",
k
, *(
por
 + 1 + k), 
m_bySveAddr
[k] );

402 
	`t

m_szPrtBuf
 );

403 
DEFAULT
;

410 
n
 = 
d
 + 12;

411 
buf
 = bu+ 
pos
;

412 
	`tf
("pos=%d buf0=%.2x\n", 
pos
, 
buf
[0]);

413  
TRUE
;

419 
DEFAULT
:

420 
n
--;

421 
por
++;

422 
pos
 ++;

426  
FALSE
;

427 
	}
}

439 
BOOL
 
	gCProc_D645
::
	$RdCfgSveAddr
 ( *
szLeBuf
 )

441 *
p
 = 
szLeBuf
;

443 i
	`cmp

szLeBuf
, "slaveaddr=", 10 ) == 0 )

445 
p
 += 10;

446 
p
 = 
	`ok
(, "," );

447 if
p
 =
NULL
 )

449  
FALSE
;

453 
m_bySveAddr
[0] = 
	`oh
(
p
);

455  
k
=1; k<6; k++)

457 i
p
 = 
	`ok

NULL
, "," ) ) != NULL )

459 
iNum
 = 0;

460 
iNum
 = 
	`oh
(
p
);

461 if
iNum
 > 255 || iNum < 0 )

463 
	`rtf

m_szPrtBuf
, "D645:RdCfgInffe: %avddrby:%d ir!!! \n", 
m_sTemePh
, 
k
);

464 
	`t
 ( 
m_szPrtBuf
 );

467 
m_bySveAddr
[
k
] = 
	`oh
(
p
);

471 
	`tf
 ( "avddr=%x %x %x %x %x %x\n", 
m_bySveAddr
[0], m_bySlaveAddr[1], m_bySlaveAddr[2], m_bySlaveAddr[3], m_bySlaveAddr[4], m_bySlaveAddr[5] );

472  
TRUE
;

475  
FALSE
;

476 
	}
}

487 
BOOL
 
	gCProc_D645
::
	$RdCfgV
 ( *
szLeBuf
 )

489 *
p
 = 
NULL
;

490 
iNum
 = 0;

491 
i
 = 0;

492 
D645CfgInfo
 
tCfgInfo
;

494 
p
 = 
	`ok

szLeBuf
, "," );

495 if
p
 =
NULL
 )

497  
FALSE
;

501 
iNum
 = 
	`oi
(
p
);

502 if
iNum
 !
DLT645_YC_DATATYPE
 && iNum !
DLT645_YM_DATATYPE
 )

504 
	`rtf

m_szPrtBuf
, "D645:RdCfgInffe: %le:%zu by:%d ir!!! \n", 
m_sTemePh
, 
m_CfgInfo
.
	`size
(), 
i
);

505 
	`t
 ( 
m_szPrtBuf
 );

506  
FALSE
;

508 
tCfgInfo
.
byDaTy
 = 
	`oi

p
 );

511  ( 
p
 = 
	`ok

NULL
, "," ) ) )

513 ++
i
;

514 
iNum
 = 
	`oi
(
p
);

515 if
iNum
 > 255 || iNum < 0 )

517 
	`rtf

m_szPrtBuf
, "D645:RdCfgInffe: %le:%zu by:%d ir!!! \n", 
m_sTemePh
, 
m_CfgInfo
.
	`size
(), 
i
);

518 
	`t
 ( 
m_szPrtBuf
 );

521  
i
 )

524 
tCfgInfo
.
byDI0
 = 
	`oh

p
 );

528 
tCfgInfo
.
byDI1
 = 
	`oh

p
 );

532 
tCfgInfo
.
byDI2
 = 
	`oh

p
 );

536 
tCfgInfo
.
byDI3
 = 
	`oh

p
 );

540 
tCfgInfo
.
byDaNum
=
	`oi

p
 );

544 
tCfgInfo
.
bySIndex
 = 
	`oi

p
 );

548 
tCfgInfo
.
byDaFm
 = 
	`oi

p
 );

552 
tCfgInfo
.
byDaL
 = 
	`oi

p
);

556 
tCfgInfo
.
byFENum
 = 
	`oi

p
 );

560 
tCfgInfo
.
byCye
 = 
	`oi
(
p
);

568 
m_CfgInfo
.
	`push_back

tCfgInfo
 );

570  
TRUE
;

571 
	}
}

583 
BOOL
 
	gCProc_D645
::
	$RdCfgInfo
 ( )

585 
FILE
 *

 = 
NULL
;

586 
szLeBuf
[256];

587 
szFeName
[256] = "";

589 
	`rtf

szFeName
, "%s%s", 
DLT645PREFIXFILENAME
, 
m_sTemePh
);

590 

 = 
	`fݒ

szFeName
, "r" );

591 if

 =
NULL
 )

593 
	`rtf
(
m_szPrtBuf
, "D645:RdCfgInffݒ %r!!!\n", 
szFeName
 );

594 
	`tf
 ( "%s", 
m_szPrtBuf
 );

595  
FALSE
;

599 
	`rtf
(
m_szPrtBuf
, "D645:RdCfgInffݒ %Ok!!!\n", 
szFeName
 );

600 
	`tf
 ( "%s", 
m_szPrtBuf
 );

603  
	`fgs

szLeBuf
, (szLeBuf), 

 ) !
NULL
 )

605 
	`rim

szLeBuf
 );

606 if
szLeBuf
[0] == '#' || szLineBuf[0] == ';' )

611 i(
szLeBuf
[0]-'0') < 0 || (szLineBuf[0] - '0') > 9 )

613 if
	`RdCfgSveAddr

szLeBuf
 ) )

619 if
	`RdCfgV

szLeBuf
 ) )

624 
	`fo


 );

626 if(
m_CfgInfo
.
	`emy
())

628 
	`tf
 ( "d645:n'ad Cfgfom f%s\n", 
szFeName
 );

629  
FALSE
;

632  
TRUE
;

633 
	}
}

645 
BOOL
 
	gCProc_D645
::
	$CFmDa
 ( cڡ 
BYTE
 *
buf
, BYTE 
byDaFm
, BYTE 
byDaL
, 
DWORD
 &
dwDa
 )

647 
i
;

648 
BYTE
 
byDa
,
byTemp
;

650 i
byDaFm
 > 5 )

652 
	`rtf

m_szPrtBuf
, "D645 CFmDbyDaFm = %d\n", 
byDaFm
 );

653 
	`t

m_szPrtBuf
 );

654  
FALSE
;

657 
byDaFm
)

660 
i
=0;i<
byDaL
;i++)

662 
byDa
=*(
buf
+
i
)-0x33;

663 
byTemp
=(
byDa
>>4)*10+(byData&0x0F);

664 
dwDa
=dwDa*100+
byTemp
;

668 
i
=
byDaL
-1;i>=0;i--)

670 
byDa
=*(
buf
+
i
)-0x33;

671 
byTemp
=(
byDa
>>4)*10+(byData&0x0F);

672 
dwDa
=dwDa*100+
byTemp
;

677 if4 !
byDaL
 )

681 
dwDa
 = 
	`HexToBcd
(
buf
[3]) * 1000000 + HexToBcd(buf[2]) * 10000 + HexToBcd(buf[1]) * 100 + HexToBcd(buf[0]);

685 if4 !
byDaL
 )

689 
dwDa
 = 
	`HexToBcd
(
buf
[2]) * 1000000 + HexToBcd(buf[3]) * 10000 + HexToBcd(buf[0]) * 100 + HexToBcd(buf[1]);

693 if4 !
byDaL
 )

697 
dwDa
 = 
	`HexToBcd
(
buf
[1]) * 1000000 + HexToBcd(buf[0]) * 10000 + HexToBcd(buf[3]) * 100 + HexToBcd(buf[2]);

701 if4 !
byDaL
 )

705 
dwDa
 = 
	`HexToBcd
(
buf
[0]) * 1000000 + HexToBcd(buf[1]) * 10000 + HexToBcd(buf[2]) * 100 + HexToBcd(buf[3]);

713  
TRUE
;

714 
	}
}

726 
BYTE
 
	gCProc_D645
::
	$ChgeSdPos
 ( )

728 
InfoNum
 = 
m_CfgInfo
.
	`size
( );

729  
InfoNum
 > 0 )

731 
m_bySdPos
 = ( m_bySdPo+ 1 )% ( 
m_CfgInfo
.
	`size
() );

732 i
m_CfgInfo
[
m_bySdPos
].
byCye
 > 0 )

734  
m_bySdPos
;

738 
InfoNum
 --;

743 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/CProtocol_Dlt645.h

2 #ide
CPROTOCOL_D645_H


3 
	#CPROTOCOL_D645_H


	)

5 
	~"../../she/CProc.h
"

6 
	~"../../she/CMhod.h
"

7 
	~<time.h
>

8 
	~<sys/time.h
>

10 
usg
 
mea
 
	gd
;

12 
	#DLT645PREFIXFILENAME
 "/mynd/cfig/D645/me/"

	)

17 
	#DLT645_YC_DATATYPE
 2

	)

18 
	#DLT645_YM_DATATYPE
 4

	)

19 
	#DLT645_TIME_DATATYPE
 3

	)

22 
	#DLT645_MAX_BUF_LEN
 256

	)

23 
	#DLT645_MAX_RESEND_COUNT
 3

	)

24 
	#DLT645_MAX_RECV_ERR_COUNT
 3

	)

26 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

34 as
	cD645CfgInfo


36 
	mpublic
:

37 
	$D645CfgInfo
 ()

39 
byDaTy
 = 0;

40 
byDI0
 = 0;

41 
byDI1
 = 0;

42 
byDI2
 = 0;

43 
byDI3
 = 0;

44 
byDaNum
 = 0;

45 
bySIndex
 = 0;

46 
byDaFm
 = 0;

47 
byDaL
 = 0;

48 
byFENum
 = 0;

49 
byCye
 = 1;

52 
BYTE
 
byDaTy
;

53 
BYTE
 
byDI0
;

54 
BYTE
 
byDI1
;

55 
BYTE
 
byDI2
;

56 
BYTE
 
byDI3
;

57 
BYTE
 
byDaNum
;

58 
BYTE
 
bySIndex
;

59 
BYTE
 
byDaFm
;

60 
BYTE
 
byDaL
;

61 
BYTE
 
byFENum
;

62 
BYTE
 
byCye
;

63 
	}
};

66 as
	cCProc_D645
 : 
public
 
CProc


68 
public
:

69 
CProc_D645
();

70 
	mvtu
 ~
CProc_D645
();

71 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

72 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

73 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

75 
vtu
 
BYTE
 
GCs
cڡ BYTE * 
pBuf
 , 
n
 );

76 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 ) ;

77 
vtu
 
	$TimProc
(){ ; }

79 
vtu
 
BOOL
 
	`WhhBufVue
(cڡ 
BYTE
 *
buf
, &
n
, &
pos
 );

81 
vtu
 
BOOL
 
	`RdCfgInfo
( );

83 
vtu
 
BOOL
 
	`CFmDa
cڡ 
BYTE
 *
buf
, BYTE 
byDaFm
, BYTE 
byDaL
, 
DWORD
 &
dwDa
 );

84 
vtu
 
BYTE
 
	`ChgeSdPos
( );

86 
public
:

87 
BYTE
 
m_bySdPos
;

88 
BYTE
 
m_byDaTy
;

89 
ve
 <
D645CfgInfo
> 
m_CfgInfo
;

90 
m_szPrtBuf
[256];

91 
BYTE
 
m_bySveAddr
[6];

93 
eed
:

94 
BOOL
 
	`GDevDa
( ) ;

95 
	`t
cڡ *
szBuf
, 
n
=0 );

96 
eed
:

97 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

98 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

99 
DWORD
 
	`oh
 ( *
szBuf
 );

100 
DWORD
 
	`oh
 ( *
szBuf
 , 
BYTE
 
n
, BYTE 
byFg
);

104 
ive
:

108 
BOOL
 
	`RdCfgSveAddr
*
szLeBuf
 );

110 
BOOL
 
	`RdCfgV
*
szLeBuf
 );

111 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/Dlt645_1997.cpp

20 
	~"D645_1997.h
"

29 
	gCD645_1997
::
	$CD645_1997
 ()

31 
	`memt

m_bySveAddr
, 0xAA, ( m_bySlaveAddr ) );

32 
	}
}

42 
	gCD645_1997
::~
	$CD645_1997
 ()

44 
	}
}

56 
BOOL
 
CD645_1997
::
	$ProssYcDa
 ( cڡ 
BYTE
 *
buf
, 
n
 )

58 
BYTE
 
byDaNum
 = 0;

59 
BYTE
 
wP
 = 0;

60 
BYTE
 
byDaFm
 = 0;

61 
BYTE
 
byDaL
 = 0;

62 
DWORD
 
dwYcV
 = 0;

63 cڡ 
BYTE
 *
por
;

64 i
n
 < 14 )

65  
FALSE
;

67 i
buf
[8] != 0x81 )

68  
FALSE
;

70 
byDaNum
 = 
m_CfgInfo
[
m_bySdPos
].byDataNum;

71 
wP
 = (
WORD
)
m_CfgInfo
[
m_bySdPos
].
bySIndex
;

72 
byDaFm
 = 
m_CfgInfo
[
m_bySdPos
].byDataFormat;

73 
byDaL
 = 
m_CfgInfo
[
m_bySdPos
].byDataLen;

75 
por
 = 
buf
 + 12;

76  
byDaNum
 > 0 )

78 
fYcV
;

80 
	`CFmDa

por
, 
byDaFm
, 
byDaL
, 
dwYcV
);

81 
fYcV
 = ()
dwYcV
;

82 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
, 
fYcV
 );

84 
por
 +
byDaL
;

85 
wP
++;

86 
byDaNum
--;

88 
	`rtf

m_szPrtBuf
, "yt:%d vue:%f", 
wP
, 
fYcV
 );

89 
	`t

m_szPrtBuf
 );

92  
TRUE
;

93 
	}
}

104 
BOOL
 
	gCD645_1997
::
	$ProssYmDa
 ( cڡ 
BYTE
 *
buf
, 
n
 )

106 
BYTE
 
byDaNum
 = 0;

107 
BYTE
 
wP
 = 0;

108 
DWORD
 
dwYmV
 = 0;

109 
BYTE
 
byDaFm
 = 0;

110 
BYTE
 
byDaL
 = 0;

111 cڡ 
BYTE
 *
por
;

112 i
n
 < 14 )

113  
FALSE
;

115 i
buf
[8] != 0x81 )

116  
FALSE
;

118 
byDaNum
 = 
m_CfgInfo
[
m_bySdPos
].byDataNum;

119 
wP
 = (
WORD
)
m_CfgInfo
[
m_bySdPos
].
bySIndex
;

120 
byDaFm
 = 
m_CfgInfo
[
m_bySdPos
].byDataFormat;

121 
byDaL
 = 
m_CfgInfo
[
m_bySdPos
].byDataLen;

123 
por
 = 
buf
 + 12;

124  
byDaNum
 > 0 )

126 
	`CFmDa

por
, 
byDaFm
, 
byDaL
, 
dwYmV
 );

127 
m_pMhod
->
	`SYmDa

m_SlNo
, 
wP
, 
dwYmV
 );

129 
por
 +
byDaL
;

130 
wP
++;

131 
byDaNum
--;

133 
	`rtf

m_szPrtBuf
, "ym:%d vue:%lu", 
wP
, 
dwYmV
 );

134 
	`t

m_szPrtBuf
 );

137  
TRUE
;

138 
	}
}

150 
BOOL
 
	gCD645_1997
::
	$RequeRdDa
 ( 
BYTE
 *
buf
, &
n
 )

152 
n
 = 0;

153  
i
=0; i<
m_CfgInfo
[
m_bySdPos
].
byFENum
; i++)

155 
buf
[
n
++] = 0xfe;

157 
buf
[
n
++] = 0x68;

159  
i
=0; i<6; i++)

161 
buf
[
n
++] = 
m_bySveAddr
[
i
];

163 
buf
[
n
++] = 0x68;

164 
buf
[
n
++] = 0x01;

165 
buf
[
n
++] = 0x02;

167 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI0
 + 0x33;

168 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI1
 + 0x33;

169 
buf
[
n
++] = 
	`GCs
( buf, 12 );

170 
buf
[
n
++] = 0x16;

172  
TRUE
;

173 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/Dlt645_1997.h

21 #ide 
DLT645_1997_INC


22 
	#DLT645_1997_INC


	)

24 
	~"D645_2007.h
"

32 as
	cCD645_1997
 : 
public
 
CD645_2007


34 
public
:

36 
CD645_1997
 ();

37 ~
CD645_1997
 ();

41 
vtu
 
BOOL
 
RequeRdDa

BYTE
 *
buf
, &
n
 );

43 
vtu
 
BOOL
 
ProssYcDa
cڡ 
BYTE
 *
buf
, 
n
 );

45 
vtu
 
BOOL
 
ProssYmDa
cڡ 
BYTE
 *
buf
, 
n
 );

47 
	meed
:

50 
ive
:

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/Dlt645_2007.cpp

19 
	~<dio.h
>

20 
	~"D645_2007.h
"

30 
	gCD645_2007
::
	$CD645_2007
 ()

32 
	`InProcStus
( );

33 
	}
}

42 
	gCD645_2007
::~
	$CD645_2007
 ()

44 
	}
}

56 
BOOL
 
CD645_2007
::
	$ProssYcDa
 ( cڡ 
BYTE
 *
buf
, 
n
 )

58 
BYTE
 
byDaNum
 = 0;

59 
BYTE
 
wP
 = 0;

60 
BYTE
 
byDaFm
 = 0;

61 
BYTE
 
byDaL
 = 0;

62 
DWORD
 
dwYcV
 = 0;

63 cڡ 
BYTE
 *
por
;

64 i
n
 < 16 )

65  
FALSE
;

67 i
buf
[8] != 0x91 )

68  
FALSE
;

70 
byDaNum
 = 
m_CfgInfo
[
m_bySdPos
].byDataNum;

71 
wP
 = (
WORD
)
m_CfgInfo
[
m_bySdPos
].
bySIndex
;

72 
byDaFm
 = 
m_CfgInfo
[
m_bySdPos
].byDataFormat;

73 
byDaL
 = 
m_CfgInfo
[
m_bySdPos
].byDataLen;

75 
por
 = 
buf
 + 14;

76  
byDaNum
 > 0 )

78 
fYcV
;

80 
	`CFmDa

por
, 
byDaFm
, 
byDaL
, 
dwYcV
);

81 
fYcV
 = ()
dwYcV
;

82 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
, 
fYcV
 );

84 
por
 +
byDaL
;

85 
wP
++;

86 
byDaNum
--;

87 
	`rtf

m_szPrtBuf
, "yt:%d vue:%f", 
wP
, 
fYcV
 );

88 
	`t

m_szPrtBuf
 );

91  
TRUE
;

92 
	}
}

103 
BOOL
 
	gCD645_2007
::
	$ProssYmDa
 ( cڡ 
BYTE
 *
buf
, 
n
 )

105 
BYTE
 
byDaNum
 = 0;

106 
BYTE
 
wP
 = 0;

107 
DWORD
 
dwYmV
 = 0;

108 
BYTE
 
byDaFm
 = 0;

109 
BYTE
 
byDaL
 = 0;

110 cڡ 
BYTE
 *
por
;

111 i
n
 < 16 )

113 
	`t
((*)"len < 16");

114  
FALSE
;

117 i
buf
[8] != 0x91 )

119 
	`rtf

m_szPrtBuf
, "buf[8]=%.2x", 
buf
[8] );

120 
	`t
(
m_szPrtBuf
);

121  
FALSE
;

124 
byDaNum
 = 
m_CfgInfo
[
m_bySdPos
].byDataNum;

125 
wP
 = (
WORD
)
m_CfgInfo
[
m_bySdPos
].
bySIndex
;

126 
byDaFm
 = 
m_CfgInfo
[
m_bySdPos
].byDataFormat;

127 
byDaL
 = 
m_CfgInfo
[
m_bySdPos
].byDataLen;

129 
por
 = 
buf
 + 14;

130  
byDaNum
 > 0 )

132 
	`CFmDa

por
, 
byDaFm
, 
byDaL
, 
dwYmV
 );

133 
m_pMhod
->
	`SYmDa

m_SlNo
, 
wP
, 
dwYmV
 );

135 
por
 +
byDaL
;

136 
wP
++;

137 
byDaNum
--;

139 
	`rtf

m_szPrtBuf
, "ym:%d vue:%lu", 
wP
, 
dwYmV
 );

140 
	`t

m_szPrtBuf
 );

143  
TRUE
;

144 
	}
}

156 
BOOL
 
	gCD645_2007
::
	$ProssBuf
 ( cڡ 
BYTE
 *
buf
, 
n
 )

158  
m_byDaTy
 )

160 
DLT645_YC_DATATYPE
:

161 
	`t
( "ң" );

162 
	`ProssYcDa

buf
, 
n
 );

165 
DLT645_YM_DATATYPE
:

166 
	`t
( "ң" );

167 
	`ProssYmDa

buf
, 
n
 );

171 
	`rtf

m_szPrtBuf
, "δҵ%d", 
m_byDaTy
 );

172 
	`t

m_szPrtBuf
 );

173  
FALSE
;

176  
TRUE
;

177 
	}
}

188 
BOOL
 
	gCD645_2007
::
	$IsTimeToSync
 ( )

190 if
m_bLkStus
 && 
m_bLkTimeSyn
 )

192 
m_bLkTimeSyn
 = 
FALSE
;

193  
TRUE
;

196 
REALTIME
 
curTime
;

197 
	`GCutTime
&
curTime
 );

199 if12 =
curTime
.
wHour
 )

201 if1 > 
curTime
.
wMu
 && 10 > curTime.
wSecd
 )

203 if
m_bTimeSynFg
 )

204  
FALSE
;

206  
TRUE
;

210 
m_bTimeSynFg
 = 
FALSE
;

214  
FALSE
;

215 
	}
}

227 
BOOL
 
	gCD645_2007
::
	$RequeRdDa
 ( 
BYTE
 *
buf
, &
n
 )

229 
n
 = 0;

230  
i
=0; i<
m_CfgInfo
[
m_bySdPos
].
byFENum
; i++)

232 
buf
[
n
++] = 0xfe;

234 
buf
[
n
++] = 0x68;

236  
i
=0; i<6; i++)

238 
buf
[
n
++] = 
m_bySveAddr
[
i
];

240 
buf
[
n
++] = 0x68;

241 
buf
[
n
++] = 0x11;

242 
buf
[
n
++] = 0x04;

244 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI0
 + 0x33;

245 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI1
 + 0x33;

246 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI2
 + 0x33;

247 
buf
[
n
++] = 
m_CfgInfo
[
m_bySdPos
].
byDI3
 + 0x33;

248 
buf
[
n
++] = 
	`GCs
bu+ 
m_CfgInfo
[
m_bySdPos
].
byFENum
, 14 );

249 
buf
[
n
++] = 0x16;

251  
TRUE
;

252 
	}
}

263 
BOOL
 
	gCD645_2007
::
	$TimeSync
 ( 
BYTE
 *
buf
, &
n
 )

265 
REALTIME
 
curTime
;

266 
n
 = 0;

267  
i
=0; i<
m_CfgInfo
[
m_bySdPos
].
byFENum
; i++)

269 
buf
[
n
++] = 0xfe;

271 
buf
[
n
++] = 0x68;

273  
i
=0; i<6; i++)

275 
buf
[
n
++] = 0x99;

277 
buf
[
n
++] = 0x68;

278 
buf
[
n
++] = 0x08;

279 
buf
[
n
++] = 0x06;

281 
	`GCutTime
&
curTime
 );

283 
buf
[
n
++] = (
BYTE
)(
curTime
.
wSecd
 + 0x33);

284 
buf
[
n
++] = (
BYTE
)
curTime
.
wMu
 + 0x33;

285 
buf
[
n
++] = (
BYTE
)
curTime
.
wHour
 + 0x33;

286 
buf
[
n
++] = (
BYTE
)
curTime
.
wDay
 + 0x33;

287 
buf
[
n
++] = (
BYTE
)
curTime
.
wMth
 + 0x33;

288 
buf
[
n
++] = (
BYTE
)(
curTime
.
wYr
-2000)+ 0x33;

289 
buf
[
n
++] = 
	`GCs
( buf, 16 );

290 
buf
[
n
++] = 0x16;

292  
TRUE
;

293 
	}
}

305 
BOOL
 
	gCD645_2007
::
	$GSdBuf
 ( 
BYTE
 *
buf
, &
n
 )

307  
m_byDaTy
 )

309 
DLT645_YC_DATATYPE
:

311 
DLT645_YM_DATATYPE
:

312 
	`t
( "" );

313 
	`RequeRdDa

buf
, 
n
 );

316 
DLT645_TIME_DATATYPE
:

317 
	`t
( "ʱ" );

318 
	`TimeSync

buf
, 
n
 );

322 
	`rtf

m_szPrtBuf
, "D645_2007 %dô", 
m_bySdPos
 );

323 
	`t

m_szPrtBuf
 );

324  
FALSE
;

327  
TRUE
;

328 
	}
}

339 
BOOL
 
	gCD645_2007
::
	$InProcStus
 ( )

341 
m_bLkStus
 = 
FALSE
;

342 
m_bySdPos
 = 0;

343 
m_byDaTy
 = 0;

344 
m_byRecvECou
 = 0;

345 
m_bIsReSd
 = 
FALSE
;

346 
m_byRendCou
 = 0;

347 
m_bIsSdg
 = 
FALSE
;

348 
m_bIsNdRend
 = 
TRUE
;

349 
m_bTimeSynFg
 = 
FALSE
;

350 
m_bLkTimeSyn
 = 
TRUE
;

353 
m_byReSdL
 = 0;

354 
	`memt

m_byReSdBuf
, 0, 
DLT645_MAX_BUF_LEN
 );

356  
TRUE
;

357 
	}
}

369 
	gCD645_2007
::
	$TimProc
 ( )

374 i
m_bIsReSd
 && 
m_byRendCou
 > 
DLT645_MAX_RESEND_COUNT
 )

376 
	`rtf

m_szPrtBuf
, "nd cou %d > %d InProcStus", 
m_byRendCou
, 
DLT645_MAX_RESEND_COUNT
 );

377 
	`t

m_szPrtBuf
 );

378 
	`InProcStus
( );

382 i
m_byRecvECou
 > 
DLT645_MAX_RECV_ERR_COUNT
 )

384 
	`rtf

m_szPrtBuf
, "cv cou %d > %d InProcStus", 
m_byRecvECou
, 
DLT645_MAX_RECV_ERR_COUNT
 );

385 
	`t

m_szPrtBuf
 );

386 
	`InProcStus
( );

388 
	}
}

400 
BOOL
 
	gCD645_2007
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

402 
	`t
( "ProcessProtocolBuf" );

403 
pos
 = 0;

404 
BOOL
 
bR
 = 
TRUE
;

405 if!
	`WhhBufVue

buf
, 
n
 , 
pos
 ) )

408 
	`t
 ( "Dlt6456 WhetherBufValue buf Recvrr!!!\n" );

409 
m_byRecvECou
 ++;

410 
m_bIsReSd
 = 
TRUE
;

411  
FALSE
;

414 
bR
 = 
	`ProssBuf

buf
+
pos
, 
n
 );

415 if!
bR
 )

417 
	`t
( "ķδ" );

421 
m_byRecvECou
 = 0;

422 
m_bLkStus
 = 
TRUE
;

423 
m_bIsReSd
 = 
FALSE
;

424 
m_byRendCou
 = 0;

425 
m_bIsSdg
 = 
FALSE
;

428  
TRUE
;

429 
	}
}

441 
BOOL
 
	gCD645_2007
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

443 
BOOL
 
bR
 = 
TRUE
;

445 i
m_bLkStus
 && 
m_bIsReSd
 )

447 
n
 = 
m_byReSdL
;

448 
	`memy

buf
, 
m_byReSdBuf
, 
n
 );

449 
m_byRendCou
 ++;

451 if
m_bLkStus
 && 
pBusMsg
 !
NULL
 )

453 
	`t
( "Ϣ" );

455  
FALSE
;

459 
	`t
( "GetSendBuf" );

460 
	`ChgeSdPos
( );

461 
m_byDaTy
 = 
m_CfgInfo
[
m_bySdPos
].
byDaTy
;

462 if
	`IsTimeToSync
() )

464 
m_byDaTy
 = 
DLT645_TIME_DATATYPE
;

465 
m_bIsNdRend
 = 
FALSE
;

468 
bR
 = 
	`GSdBuf

buf
, 
n
 );

470 i
bR
 && 
n
 > 0)

472 
m_byReSdL
 = 
n
;

473 
	`memy

m_byReSdBuf
, 
buf
, 
m_byReSdL
 );

474 
m_bIsSdg
 = 
TRUE
;

475 if!
m_bIsNdRend
 )

477 
m_bIsSdg
 = 
FALSE
;

478 
m_bIsNdRend
 = 
TRUE
;

483  
bR
;

484 
	}
}

495 
BOOL
 
	gCD645_2007
::
	$GDevNameToAddr
 ( )

497 
n
 = 
	`

m_sDevName
 );

498 if
n
 < 12)

500  
FALSE
;

503 
m_bySveAddr
[0] = 
	`oh

m_sDevName
 + 
n
 - 2, 2, 1 );

504 
m_bySveAddr
[1] = 
	`oh

m_sDevName
 + 
n
 - 4, 2, 1 );

505 
m_bySveAddr
[2] = 
	`oh

m_sDevName
 + 
n
 - 6, 2, 1 );

506 
m_bySveAddr
[3] = 
	`oh

m_sDevName
 + 
n
 - 8, 2, 1 );

507 
m_bySveAddr
[4] = 
	`oh

m_sDevName
 + 
n
 - 10, 2, 1 );

508 
m_bySveAddr
[5] = 
	`oh

m_sDevName
 + 
n
 - 12, 2, 1 );

510  
TRUE
;

512 
	}
}

523 
BOOL
 
	gCD645_2007
::
	$In
 ( 
BYTE
 
byLeNo
 )

525 if
byLeNo
 > 22 )

526  
FALSE
;

534 if!
	`RdCfgInfo
() )

536 
	`t
 ( "CDlt645_2007:ReadCfgInfo Err!!!\n" );

537  
FALSE
;

540 if!
	`InProcStus
() )

542 
	`t
 ( "CDlt645_2007:InitProtocolStatus Err\n" );

543  
FALSE
;

546 
	`t
( "Dlt645 Init OK" );

547  
TRUE
;

548 
	}
}

560 
BOOL
 
	gCD645_2007
::
	$GDevCommS
 ( )

562 i
m_bLkStus
 )

563  
COM_NORMAL
;

565  
COM_DEV_ABNORMAL
;

566 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/Dlt645_2007.h

21 #ide 
DLT645_2007_INC


22 
	#DLT645_2007_INC


	)

24 
	~"CProc_D645.h
"

33 as
	cCD645_2007
 : 
public
 
CProc_D645


35 
public
:

37 
CD645_2007
 ();

38 ~
CD645_2007
 ();

40 
vtu
 
TimProc
( );

42 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

44 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

46 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

48 
vtu
 
BOOL
 
GDevCommS
( ) ;

50 
vtu
 
BOOL
 
RequeRdDa

BYTE
 *
buf
, &
n
 );

52 
vtu
 
BOOL
 
ProssYcDa
cڡ 
BYTE
 *
buf
, 
n
 );

54 
vtu
 
BOOL
 
ProssYmDa
cڡ 
BYTE
 *
buf
, 
n
 );

56 
vtu
 
BOOL
 
TimeSync

BYTE
 *
buf
, &
n
 );

58 
	mpublic
:

62 
public
:

63 
eed
:

65 
BOOL
 
GDevNameToAddr
( );

68 
	mive
:

71 
BOOL
 
IsTimeToSync
( );

73 
BOOL
 
InProcStus
( );

75 
BOOL
 
GSdBuf

BYTE
 *
buf
, &
n
 );

77 
BOOL
 
ProssBuf
cڡ 
BYTE
 *
buf
, 
n
 );

79 
	mive
:

80 
BOOL
 
m_bLkTimeSyn
;

81 
BOOL
 
	mm_bLkStus
;

82 
BOOL
 
	mm_bIsSdg
;

83 
BOOL
 
	mm_bIsReSd
;

84 
BOOL
 
	mm_bIsNdRend
;

85 
BOOL
 
	mm_bTimeSynFg
;

88 
BYTE
 
	mm_byRendCou
;

89 
BYTE
 
	mm_byReSdBuf
[
DLT645_MAX_BUF_LEN
];

90 
BYTE
 
	mm_byReSdL
;

92 
BYTE
 
	mm_byRecvECou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_D645.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

12 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

14 
CProc
 * 
pProc
 = 
NULL
 ;

15 
pProc
 = 
w
 
CProc_D645
 ;

16 if
pProc
 )

18 
pProc
->
m_pMhod
 = 
pMhod
 ;

19 
	`tf
( "Dlt645 DLL OK.\n " ) ;

22  
pProc
 ;

23 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/CProtocol_ESDCMMI.cpp

5 
	~"CProc_ESDCMMI.h
"

6 
	~"ESDCMMI.h
"

12 
BYTE
 
	gBB_BchTab
[256] = {

32 
	gCProc_ESDCMMI
::
	$CProc_ESDCMMI
()

34 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

35 
	}
}

37 
	gCProc_ESDCMMI
::~
	$CProc_ESDCMMI
()

39 
size
 = 
m_modu
.
	`size
() ;

40  
i
 = 0 ; i < 
size
 ; i++ )

42 
de
 
m_modu
[ 
i
 ] ;

44 
m_modu
.
	`r
() ;

45 
	`tf
( "Delete All CProtocol_ESDCMMI OK . \n" );

46 
	}
}

48 
BOOL
 
	gCProc_ESDCMMI
::
	$In

BYTE
 
byLeNo
 )

51 
m_byLeNo
 = 
byLeNo
 ;

53 
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

54  
	`GDevDa
( ) ;

55 
	}
}

57 
BOOL
 
	gCProc_ESDCMMI
::
	$GDevDa
( )

59 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

60 
	`rtf

m_sDevPh
 , "%s/ESDCMMI/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

61 
CProfe
 
	`ofe

m_sDevPh
 ) ;

62  
	`ProssFeDa

ofe
 ) ;

63 
	}
}

65 
BOOL
 
	gCProc_ESDCMMI
::
	$ProssFeDa

CProfe
 &
ofe
 )

67 
BOOL
 
bR
 = 
FALSE
;

68 if!
ofe
.
	`IsVid
() )

70 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

71  
FALSE
 ;

74 
sSe
[ 200 ] = "DEVNUM" ;

75 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

77 
WORD
 
wModu
 = 0 ;

78 
ro
=1 ;

79 
WORD
 
addr
 =3 ;

80 
sName
[ 50 ] = { 0 };

81 
eme
[ 200 ] = { 0 };

82 
iNum
 = 0 ;

84 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

85 if
iNum
 == 0 )

87 
	`tf
( "Get DEVNUM Failed ! \n " );

88  
FALSE
 ;

91  
i
 = 0 ; i < 
iNum
 ; i++ )

93 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

95 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

96 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

97 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

98 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

99 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

102 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

103 i!
bR
 )

105 
	`tf
 ( "Create ESDCMMI Module=%d serialno=%dddr=%d sName=%s stemplate=%s \

106 
E
 \
n
", wModule, serialno,ddr, sName, stemplate );

107  
FALSE
;

110  
TRUE
 ;

111 
	}
}

113 
BOOL
 
	gCProc_ESDCMMI
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

115 
CProc_ESDCMMI
 * 
pProc
 = 
NULL
 ;

117 
pProc
 = 
w
 
ESDCMMI
;

118 
pProc
->
m_byLeNo
 = m_byLineNo ;

119 
pProc
->
m_wModuTy
 = 
iModu
 ;

120 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

121 
pProc
->
m_SlNo
 = 
iSlNo
 ;

123 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

124 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

125 
pProc
->
m_pMhod
 = m_pMethod ;

126 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

129 if!
pProc
->
	`In

m_byLeNo
 ) )

130  
FALSE
 ;

131 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

134 
m_modu
.
	`push_back

pProc
 ) ;

136  
TRUE
 ;

137 
	}
}

140 
BYTE
 
	gCProc_ESDCMMI
::
	$ESDCMMI_GCRC
(
BYTE
 *
buf
, 
n
)

142 
BYTE
 
CRC
 = 0,
dex
=0;

143 
BYTE
 * 
pS
 = 
buf
;

145  
i
=0; i<
n
 ; i++ )

147 
dex
 = *
pS
 ^ 
CRC
;

148 
dex
 = index & 0xff;

149 
CRC
 = 
BB_BchTab
[
dex
] ;

150 
pS
++ ;

152 
CRC
 = ~ CRC ;

153  
CRC
;

154 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/CProtocol_ESDCMMI.h

5 #i!
defed
(
AFX_CPROTOCOL_ESDCMMI_H__DB4E4A83_510B_4232_A294_B1B4EE1AF4FD__INCLUDED_
)

6 
	#AFX_CPROTOCOL_ESDCMMI_H__DB4E4A83_510B_4232_A294_B1B4EE1AF4FD__INCLUDED_


	)

10 
	~"../../she/Rtu.h
"

11 
	~"../../she/CMhod.h
"

12 
	#ESDCMMIPREFIXFILENAME
 "/mynd/cfig/ESDCMMI/"

	)

14 as
	cCProc_ESDCMMI
 : 
public
 
CRtuBa


16 
public
:

17 
CProc_ESDCMMI
();

18 
	mvtu
 ~
CProc_ESDCMMI
();

19 
vtu
 
BYTE
 
ESDCMMI_GCRC
(BYTE *
buf
, 
n
);

20 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

22 
	meed
:

23 
BOOL
 
GDevDa
( ) ;

24 
	meed
:

25 
BOOL
 
ProssFeDa

CProfe
 &
ofe
 );

26 
BOOL
 
CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

28 
	mmt_sMaAddr
[ 24 ] ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/ESDCMMI.cpp

1 
	~"ESDCMMI.h
"

2 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

4 
	#ERROR_CONST
 5

	)

5 
	#COMSTATUS_ONLINE
 1

	)

6 
	#COMSTATUS_FAULT
 0

	)

8 
	#ERROR_FUN
 1

	)

9 
	#ERROR_REGISTER
 2

	)

10 
	#ERROR_DATA
 3

	)

11 
	#ERROR_CONFIG
 4

	)

13 
	#WORD_LENGTH
 7

	)

15 
	#YK_TIME_INTERVAL
 6

	)

16 
	#DZ_TIME_INTERVAL
 10

	)

18 
	#FRAMEBYTE_CONTROLBYTE
 0x71

	)

19 
	#FRAMEKIND_YC
 0x61

	)

20 
	#FRAMEKIND_YX
 0xF4

	)

21 
	#FRAMEKIND_YM
 0x85

	)

22 
	#FRAMEKIND_SOE
 0x26

	)

23 
	#FRAMEKIND_FAIL
 0x29

	)

25 
	#FRAMEKIND_DOWN_SETTIME
 0x7A

	)

26 
	#FRAMEKIND_DOWN_BECKONTIME
 0x4C

	)

27 
	#FRAMEKIND_DOWN_YKRESET
 0x61

	)

28 
	#FRAMEKIND_DOWN_YKEXECUTE
 0xC2

	)

29 
	#FRAMEKIND_DOWN_YKCANCEL
 0xB3

	)

30 
	#FRAMEKIND_DOWN_RESET
 0x3D

	)

31 
	#FRAMEKIND_DOWN_DZ
 0xA9

	)

33 
	#SEND_SOE_FRAME
 1

	)

34 
	#SEND_YX_FRAME
 2

	)

35 
	#SEND_YC_FRAME
 3

	)

36 
	#SEND_YM_FRAME
 4

	)

37 
	#SEND_FAIL_FRAME
 5

	)

39 
	#YK_PROTOCOL_CLOSE
 0XCC

	)

40 
	#YK_PROTOCOL_OPEN
 0X33

	)

41 
	#YK_PROTOCOL_ERR
 0XFF

	)

42 
	#YK_MODULE_CLOSE
 1

	)

43 
	#YK_MODULE_OPEN
 0

	)

44 
	#YK_PROTOCOL_EXECUTE
 0XAA

	)

45 
	#YK_PROTOCOL_CANCEL
 0X55

	)

46 
	#YK_TYPE_NORMAL
 0X3A

	)

47 
	#YK_TYPE_MUTIL
 0X35

	)

49 
	#YK_VALID
 1

	)

50 
	#YK_INVALID
 0

	)

51 
	#YK_PROCESS_SEND
 0

	)

52 
	#YK_PROCESS_RECEIVE
 1

	)

53 
	#YK_PROCESS_OVERTIME
 2

	)

54 
	#YK_PROCESS_SUCCESS
 3

	)

56 
	#YX_OPEN
 0

	)

57 
	#YX_CLOSE
 1

	)

60 
	#ESDCMMIPACKETLEN
 512

	)

62 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

63 "C" 
SCutTime

REALTIME
 *
pRlTime
 );

66 
	gESDCMMI
::
	$ESDCMMI
()

68 
FFg
 = 
TRUE
;

69 
m_wETim
 = 0;

70 
m_byPtStus
 = 0;

71 
curSdTy_nm
 = 
SEND_YX_FRAME
;

72 
m_bRTime
 = 
FALSE
;

73 
	`memt
(
mt_sMaAddr
, 0, (mt_sMasterAddr));

74 
	}
}

76 
	gESDCMMI
::~
	$ESDCMMI
()

79 
	}
}

81 
BOOL
 
ESDCMMI
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

83 if
buf
 =
NULL
 )

84  
FALSE
 ;

86 if
FFg
 )

88 
FFg
 = 
FALSE
;

89 
	`p
(10);

93 if
pBusMsg
 )

95 
	`DlBusMsgInfo

pBusMsg
 );

98 
BYTE
 
bySdTy
;

100 if(
m_iSOE_rd_p
 !
m_iSOE_wr_p
)

101 
bySdTy
 = 
SEND_SOE_FRAME
;

103 
bySdTy
 = 
curSdTy_nm
;

105 
bySdTy
)

107 
SEND_YX_FRAME
:

108 
	`ESDCMMI_asmbYxFme
(
buf
,
n
);

110 
SEND_YC_FRAME
:

111 
	`ESDCMMI_asmbYcFme
(
buf
,
n
);

113 
SEND_YM_FRAME
:

114 
	`ESDCMMI_asmbYmFme
(
buf
,
n
);

116 
SEND_SOE_FRAME
:

117 
	`ESDCMMI_asmbSFme
(
buf
,
n
);

119 
SEND_FAIL_FRAME
:

120 
	`ESDCMMI_asmbFaFme
(
buf
,
n
);

123 
	`ESDCMMI_asmbYxFme
(
buf
,
n
);

127 
m_wETim
++;

128 if
m_wETim
 > 
ERROR_CONST
 )

130 
m_wETim
 = 
ERROR_CONST
 + 1 ;

131 
m_byPtStus
 = 
COMSTATUS_FAULT
;

135 
m_byPtStus
 = 
COMSTATUS_ONLINE
;

138  
TRUE
;

140 
	}
}

142 
BOOL
 
	gESDCMMI
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

145 
BOOL
 
R
 = 
FALSE
;

146 if
n
 =0 || 
buf
 =
NULL
 )

147  
FALSE
 ;

150 
BYTE
 
ameKd
=0,
foWds
=0,
cmdTy
=0,
c
=0;

152 
WORD
 
i
=0;

153 
BYTE
 * 
por
 = 
NULL
,*
pDa
;

154 
BOOL
 
bInfoOk
;

157 
por
=
buf
;

159 if(
n
 < 
WORD_LENGTH
*2)

160  
FALSE
;

162 
n
>=
WORD_LENGTH
*2)

164 if(!
	`ESDCMMI_isSyncWd
(
por
))

166 
n
--;

167 
por
++;

172 
c
 = 
	`ESDCMMI_GCRC
(
por
+
WORD_LENGTH
, WORD_LENGTH-1);

173 if(
c
!=*(
por
+
WORD_LENGTH
*2-1))

175 
n
-=
WORD_LENGTH
*2;

176 
por
+=
WORD_LENGTH
*2;

182 
ameKd
*(
por
+
WORD_LENGTH
+1);

183 
foWds
*(
por
+
WORD_LENGTH
+2);

185 if
n
 < (
foWds
+2)*
WORD_LENGTH
)

188 
n
-=
WORD_LENGTH
*2;

189 
por
+=
WORD_LENGTH
*2;

192 
bInfoOk
 = 
TRUE
;

193 
pDa
=
por
;

194 
i
=0;i<
foWds
;i++)

196 
c
 = 
	`ESDCMMI_GCRC

por
, 
WORD_LENGTH
-1);

197 if(
c
 !*(
por
+
WORD_LENGTH
-1) )

199 
bInfoOk
 = 
FALSE
;

201 
n
 -
WORD_LENGTH
;

202 
por
 +
WORD_LENGTH
;

206 if(!
bInfoOk
)

212 
ameKd
)

214 
FRAMEKIND_DOWN_SETTIME
:

215 
R
 = 
	`ESDCMMI_tSubiTime
(
pDa
);

217 
FRAMEKIND_DOWN_BECKONTIME
:

218 
m_bRTime
 = 
TRUE
;

220 
FRAMEKIND_DOWN_YKRESET
:

221 
cmdTy
 = 
YK_SEL
;

222 
R
 = 
	`ESDCMMI_hdYkCmd
(
pDa
,
cmdTy
);

224 
FRAMEKIND_DOWN_YKEXECUTE
:

225 
cmdTy
 = 
YK_EXCT
;

226 
R
 = 
	`ESDCMMI_hdYkCmd
(
pDa
,
cmdTy
);

228 
FRAMEKIND_DOWN_YKCANCEL
:

229 
cmdTy
 = 
YK_CANCEL
;

230 
R
 = 
	`ESDCMMI_hdYkCmd
(
pDa
,
cmdTy
);

232 
FRAMEKIND_DOWN_RESET
:

235 
FRAMEKIND_DOWN_DZ
:

244 if
R
 =
TRUE
 )

246 
m_wETim
 = 0;

247  
TRUE
 ;

249  
FALSE
 ;

250 
	}
}

252 
BOOL
 
	gESDCMMI
::
	$In

BYTE
 
byLeNo
 )

254 
m_byLeNo
 = 
byLeNo
 ;

255 
m_byProID
 = 4;

256 
m_byEb
 = 1;

257 
m_wObjNum
 = 1;

258 
	`rtf

m_szObjName
, "%s", 
m_sDevName
 );

259 
	`rtf

m_ComCl1
, "%s", 
mt_sMaAddr
 );

260 
m_wRtuAddr
 = 
m_wDevAddr
 ;

261 
szFeName
[256] = "";

263 
	`rtf

szFeName
, "%s%s", 
ESDCMMIPREFIXFILENAME
, 
m_sTemePh
 );

265 
	`RdMCfig

szFeName
 );

268 
	`InRtuBa
() ;

272  
TRUE
 ;

273 
	}
}

275 
BOOL
 
	gESDCMMI
::
	$InRtuBa
( )

277 
UINT
 
uPt
;

278 
BOOL
 
bOk
 = 
FALSE
;

279 
szCl
[32];

283 
CBaPt
::
	`GCommArib
(
m_ComCl1
, 
szCl
, 
uPt
);

285 
m_wPtNum
 = (
WORD
)
uPt
 ;

288 
	`CeTnsTab
();

291 
m_pMhod
->
	`RdAYcDa
(&
m_fYCBuf
[0]);

292 
m_pMhod
->
	`RdAYmDa
(&
m_dwYMBuf
[0]);

293 
m_pMhod
->
	`RdAYxDa
&
m_byYXbuf
[ 0 ] ) ;

295 
m_bTaskRun
 = 
TRUE
;

296  
bOk
;

297 
	}
}

299 
BOOL
 
	gESDCMMI
::
	$DlBusMsgInfo

PBUSMSG
 
pBusMsg
 )

301 
YK_DATA
 *
pDa
 = (YK_DATA *)(
pBusMsg
->pData);

303  
pBusMsg
->
byMsgTy
 )

305 
YK_PROTO
:

306  
pBusMsg
->
dwDaTy
 )

308 
YK_SEL_RTN
:

309 if
pBusMsg
->
DaNum
 !1 ||BusMsg->
DaL
 !(
YK_DATA
) )

311 
	`tf
("ESDCMMI Yk DataNumrr\n");

314 if(
ESDCMMI_Yk_Da
.
m_byVid
 =
YK_VALID
&& (ESDCMMI_Yk_Da.
m_byYkCmd
 =
YK_SEL
) )

316 if(
ESDCMMI_Yk_Da
.
m_byLeNo
 =
pBusMsg
->
SrcInfo
.
byBusNo
)

317 && (
ESDCMMI_Yk_Da
.
m_byAddss
 =
pBusMsg
->
SrcInfo
.
wDevNo
)

318 && (
ESDCMMI_Yk_Da
.
m_byPotNo
 =
pDa
->
wP
)

319 && (
ESDCMMI_Yk_Da
.
m_byYkCmd
 =
YK_SEL
)

320 && (
ESDCMMI_Yk_Da
.
m_byStus
 =
YK_PROCESS_SEND
) )

322 if
pDa
->
byV
 !
ESDCMMI_Yk_Da
.
m_byYkAi
 )

324 
ESDCMMI_Yk_Da
.
m_byYkAi
 = 
YK_ERROR
;

326 
ESDCMMI_Yk_Da
.
m_byStus
 = 
YK_PROCESS_RECEIVE
;

327 
ESDCMMI_Yk_Da
.
m_byYkCmd
 = 
YK_SEL_RTN
;

340  
TRUE
;

341 
	}
}

350 
	gESDCMMI
::
	$ESDCMMI_addSyncWd
(
BYTE
 *
pBuf
)

352 
pBuf
[0] = 0xEB;

353 
pBuf
[1] = 0x90;

354 
pBuf
[2] = 0xEB;

355 
pBuf
[3] = 0x90;

356 
pBuf
[4] = 0xEB;

357 
pBuf
[5] = 0x90;

358 
pBuf
[6] = 0xFF;

359 
	}
}

369 
	gESDCMMI
::
	$ESDCMMI_addCڌWd
(
BYTE
 *
pBuf
,BYTE 
ameKd
,BYTE 
foWds
)

371 
pBuf
[0] = 
FRAMEBYTE_CONTROLBYTE
;

372 
pBuf
[1] = 
ameKd
;

373 
pBuf
[2] = 
foWds
;

374 
pBuf
[3] = 0x00;

375 
pBuf
[4] = 0x00;

376 
pBuf
[5] = 0x00;

377 
pBuf
[6] = 
	`ESDCMMI_GCRC
(pBuf,6);

380 
	}
}

383 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_asmbYxFme

BYTE
 * 
pBuf
 , &
n
 )

385 
BYTE
 *
pClWd
=
NULL
;

386 
WORD
 
wYxNum
,
wSdOrd
=0,
ndBys
=0,
iBys
=0;

387 
BYTE
 
byInfoWds
=0,
byTemp
;

388 
BYTE
 
funcCode
=0;

389 
BOOL
 
bChge
=
FALSE
;

390 
DWORD
 
dwYxDa
;

392 
	`ESDCMMI_addSyncWd
(
pBuf
);

393 
pBuf
 +
WORD_LENGTH
;

394 
ndBys
 = 
WORD_LENGTH
;

396 
pClWd
 = 
pBuf
;

397 
pBuf
 +
WORD_LENGTH
;

398 
ndBys
 +
WORD_LENGTH
;

400 
iBys
=
	`ESDCMMI_addPriWd
(
pBuf
,
ESDCMMIPACKETLEN
-
ndBys
);

401 
pBuf
+=
iBys
;

402 
ndBys
+=
iBys
;

403 
byInfoWds
+=(
iBys
/
WORD_LENGTH
);

405 
wYxNum
 = 
	`GPSum
(
YX_SUM
);

406 
wSdOrd
 = 
ESDCMMI_ndOrd
;

407 
funcCode
=(
BYTE
)(
wSdOrd
/32);

409 
ndBys
+
WORD_LENGTH
<=
ESDCMMIPACKETLEN
 && 
wSdOrd
<
wYxNum
)

411 if(
wSdOrd
<
wYxNum
-32)

412 
byTemp
=32;

414 
byTemp
=
wYxNum
-
wSdOrd
;

415 
	`ESDCMMI_geYxDWd
(
wSdOrd
,&
dwYxDa
,
byTemp
);

416 
wSdOrd
+=
byTemp
;

418 
pBuf
[0]=0x00;

419 
pBuf
[1]=
funcCode
;

420 
pBuf
[2]=
	`LOBYTE
(
	`LOWORD
(
dwYxDa
));

421 
pBuf
[3]=
	`HIBYTE
(
	`LOWORD
(
dwYxDa
));

422 
pBuf
[4]=
	`LOBYTE
(
	`HIWORD
(
dwYxDa
));

423 
pBuf
[5]=
	`HIBYTE
(
	`HIWORD
(
dwYxDa
));

424 
pBuf
[6]=
	`ESDCMMI_GCRC
(pBuf,6);

426 
pBuf
+=
WORD_LENGTH
;

427 
ndBys
+=
WORD_LENGTH
;

428 
byInfoWds
++;

430 if(
funcCode
>=0xFF || 
wSdOrd
>=
wYxNum
)

432 
curSdTy_i
 = 
SEND_YM_FRAME
;

433 
curSdTy_nm
 = 
SEND_YC_FRAME
;

434 
ESDCMMI_ndOrd
 = 0;

435 
bChge
=
TRUE
;

439 
funcCode
++;

442 if(!
bChge
)

443 
ESDCMMI_ndOrd
 = 
wSdOrd
;

445 
	`ESDCMMI_addCڌWd
(
pClWd
,
FRAMEKIND_YX
,
byInfoWds
);

447 if(!
wYxNum
)

449 
curSdTy_i
 = 
SEND_YM_FRAME
;

450 
curSdTy_nm
 = 
SEND_YC_FRAME
;

451 
ESDCMMI_ndOrd
 = 0;

453 
n
 = 
ndBys
;

454  
TRUE
;

455 
	}
}

457 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_asmbYcFme

BYTE
 * 
pBuf
 , &
n
 )

459 
BYTE
 *
pClWd
=
NULL
;

460 
WORD
 
wYcNum
,
wSdOrd
=0,
ndBys
=0,
iBys
=0;

461 
BYTE
 
byInfoWds
=0;

462 
fV
 = 0.0f;

463 
BOOL
 
bChge
=
FALSE
;

464 
BYTE
 
byBufr
[4];

466 
	`ESDCMMI_addSyncWd
(
pBuf
);

467 
pBuf
 +
WORD_LENGTH
;

468 
ndBys
 = 
WORD_LENGTH
;

470 
pClWd
 = 
pBuf
;

471 
pBuf
 +
WORD_LENGTH
;

472 
ndBys
 +
WORD_LENGTH
;

474 
iBys
=
	`ESDCMMI_addPriWd
(
pBuf
,
ESDCMMIPACKETLEN
-
ndBys
);

475 
ndBys
+=
iBys
;

476 
pBuf
+=
iBys
;

477 
byInfoWds
+=(
iBys
/
WORD_LENGTH
);

479 
wYcNum
 = 
	`GPSum
(
YC_SUM
);

480 
wSdOrd
 = 
ESDCMMI_ndOrd
;

482 
ndBys
+
WORD_LENGTH
<=
ESDCMMIPACKETLEN
 && 
wSdOrd
<
wYcNum
)

484 
pBuf
[0] = 
	`HIBYTE
(
wSdOrd
);

485 
pBuf
[1] = 
	`LOBYTE
(
wSdOrd
);

487 
fV
 = 
m_fYCBuf
[
wSdOrd
];

488 if
m_pAIMTab
[
wSdOrd
].
wS
>0 && m_pAIMTab[wSdOrd].
wPNum
>0 )

489 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
wSdOrd
].
wS
,m_pAIMTab[wSdOrd].
wPNum
,
m_fYCBuf
[wSendOrder]);

491 
	`memy
(&(
byBufr
[0]),&
fV
,4);

493 
pBuf
[2] = 
byBufr
[ 3 ] ;

494 
pBuf
[3] = 
byBufr
[ 2 ] ;

495 
pBuf
[4] = 
byBufr
[ 1 ] ;

496 
pBuf
[5] = 
byBufr
[ 0 ] ;

497 
pBuf
[6] = 
	`ESDCMMI_GCRC
(pBuf,6);

500 
wSdOrd
++;

501 
pBuf
+=
WORD_LENGTH
;

502 
ndBys
+=
WORD_LENGTH
;

503 
byInfoWds
++;

505 if(
wSdOrd
>0x7FF || wSdOrd>=
wYcNum
)

507 
curSdTy_nm
 = 
curSdTy_i
;

508 
ESDCMMI_ndOrd
 = 0;

509 
bChge
=
TRUE
;

513 if(!
bChge
)

514 
ESDCMMI_ndOrd
 = 
wSdOrd
;

516 
	`ESDCMMI_addCڌWd
(
pClWd
,
FRAMEKIND_YC
,
byInfoWds
);

518 if(!
wYcNum
)

520 
curSdTy_nm
 = 
curSdTy_i
;

521 
ESDCMMI_ndOrd
 = 0;

523 
n
 = 
ndBys
;

525  
TRUE
;

526 
	}
}

528 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_asmbYmFme

BYTE
 * 
pBuf
 , &
n
 )

530 
BYTE
 *
pClWd
=
NULL
;

531 
WORD
 
wYmNum
,
wSdOrd
=0,
ndBys
=0,
iBys
=0;

532 
BYTE
 
byInfoWds
=0;

533 
fV
 = 0.0f;

534 
BOOL
 
bChge
=
FALSE
;

535 
BYTE
 
byBufr
[4];

536 
BOOL
 
ag
 ;

538 
	`ESDCMMI_addSyncWd
(
pBuf
);

539 
pBuf
 +
WORD_LENGTH
;

540 
ndBys
 = 
WORD_LENGTH
;

542 
pClWd
 = 
pBuf
;

543 
pBuf
 +
WORD_LENGTH
;

544 
ndBys
 +
WORD_LENGTH
;

546 
iBys
=
	`ESDCMMI_addPriWd
(
pBuf
,
ESDCMMIPACKETLEN
-
ndBys
);

547 
ndBys
+=
iBys
;

548 
pBuf
+=
iBys
;

549 
byInfoWds
+=(
iBys
/
WORD_LENGTH
);

551 
wYmNum
 = 
	`GPSum
(
YM_SUM
);

552 
wSdOrd
 = 
ESDCMMI_ndOrd
;

555 
ndBys
+
WORD_LENGTH
<=
ESDCMMIPACKETLEN
 && 
wSdOrd
<
wYmNum
)

557 
pBuf
[0] = 
	`HIBYTE
(
wSdOrd
);

558 
pBuf
[1] = 
	`LOBYTE
(
wSdOrd
);

560 
fV
 = ( )
	`GPulDa
 ( 
m_pPIMTab
[
wSdOrd
].
wS
,m_pPIMTab[wSdOrd].
wPNum
 ,&
ag
 );

562 
	`memy
(&(
byBufr
[0]),&
fV
,4);

564 
pBuf
[2] = 
byBufr
[ 3 ] ;

565 
pBuf
[3] = 
byBufr
[ 2 ] ;

566 
pBuf
[4] = 
byBufr
[ 1 ] ;

567 
pBuf
[5] = 
byBufr
[ 0 ] ;

568 
pBuf
[6] = 
	`ESDCMMI_GCRC
(pBuf,6);

570 
wSdOrd
++;

571 
pBuf
+=
WORD_LENGTH
;

572 
ndBys
+=
WORD_LENGTH
;

573 
byInfoWds
++;

575 if(
wSdOrd
>0x3FF || wSdOrd>=
wYmNum
)

577 
curSdTy_i
 = 
SEND_FAIL_FRAME
;

578 
curSdTy_nm
 = 
SEND_YC_FRAME
;

579 
ESDCMMI_ndOrd
 = 0;

580 
bChge
=
TRUE
;

585 if(!
bChge
)

586 
ESDCMMI_ndOrd
 = 
wSdOrd
;

588 
	`ESDCMMI_addCڌWd
(
pClWd
,
FRAMEKIND_YM
,
byInfoWds
);

590 if(!
wYmNum
)

592 
curSdTy_i
 = 
SEND_FAIL_FRAME
;

593 
curSdTy_nm
 = 
SEND_YC_FRAME
;

594 
ESDCMMI_ndOrd
 = 0;

596 
n
 = 
ndBys
;

597  
TRUE
;

598 
	}
}

600 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_asmbSFme

BYTE
 * 
pBuf
 , &
n
 )

602 
BYTE
 *
pClWd
=
NULL
;

603 
WORD
 
ndBys
=0,
iBys
=0;

604 
WORD
 
wP
, 
wV
, 
wMiSecd
 , 
wSlNo
;

605 
tm
 
tmSu
;

606 
tV
;

607 
BYTE
 
byV
,
byV1
;

609 
	`ESDCMMI_addSyncWd
(
pBuf
);

610 
pBuf
 +
WORD_LENGTH
;

611 
ndBys
 = 
WORD_LENGTH
;

613 
pClWd
 = 
pBuf
;

614 
pBuf
 +
WORD_LENGTH
;

615 
ndBys
 +
WORD_LENGTH
;

617 
iBys
=
	`ESDCMMI_addPriWd
(
pBuf
,
ESDCMMIPACKETLEN
-
ndBys
);

618 
ndBys
+=
iBys
;

619 
pBuf
+=
iBys
;

621 (
ndBys
+
WORD_LENGTH
*2 <
ESDCMMIPACKETLEN
)&&(
m_iSOE_rd_p
 !
m_iSOE_wr_p
))

623 
	`GSOEInfo

wSlNo
 , &
wP
, &
wV
, &
tmSu
, &
wMiSecd
);

625 
pBuf
[0] = 0x00;

626 
pBuf
[1] = 0x80;

627 
tV
 = 
wMiSecd
;

628 
byV
 = 
tV
&0xFF;

629 
pBuf
[2] = 
byV
;

630 
tV
 = intV >> 8;

631 
byV
 = 
tV
&0x03;

632 
pBuf
[3]
byV
;

633 
tV
 = 
tmSu
.
tm_c
;

634 
byV
 = 
tV
&0x3F;

635 
pBuf
[4] = 
byV
;

636 
tV
 = 
tmSu
.
tm_m
;

637 
byV
 = 
tV
&0x3F;

638 
pBuf
[5] = 
byV
;

639 
pBuf
[6] = 
	`ESDCMMI_GCRC
(pBuf,6);

640 
pBuf
+=
WORD_LENGTH
;

643 
pBuf
[0] = 0x00;

644 
pBuf
[1] = 0x81;

645 
tV
 = 
tmSu
.
tm_hour
;

646 
byV
 = 
tV
&0x1F;

647 
pBuf
[2] = 
byV
;

648 
tV
 = 
tmSu
.
tm_mday
;

649 
byV
 = 
tV
&0x1F;

650 
pBuf
[3] = 
byV
;

651 
tV
 = 
wP
;

652 
byV
 = 
tV
&0xFF;

653 
pBuf
[4] = 
byV
;

654 
tV
 = intV >> 8;

655 
byV
 = 
tV
&0x0F;

656 
byV1
 = 
wV
;

657 i(
byV1
)

658 
byV
 |= 0x80;

660 
byV
 &= 0x7F;

661 
pBuf
[5] = 
byV
;

662 
pBuf
[6] = 
	`ESDCMMI_GCRC
(pBuf,6);

663 
ndBys
 +
WORD_LENGTH
*2;

664 
pBuf
+=
WORD_LENGTH
;

667 if(
ndBys
>
WORD_LENGTH
*2)

668 
	`ESDCMMI_addCڌWd
(
pClWd
,
FRAMEKIND_SOE
,
ndBys
/
WORD_LENGTH
-2);

670 
ndBys
=0;

672 
n
 = 
ndBys
;

673  
TRUE
;

674 
	}
}

676 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_asmbFaFme

BYTE
 * 
pBuf
 , &
n
 )

678 
BYTE
 *
pClWd
=
NULL
;

679 
WORD
 
wSdOrd
=0,
ndBys
=0,
iBys
=0;

680 
BYTE
 
byInfoWds
=0;

681 
BOOL
 
bChge
=
FALSE
;

682 
BYTE
 
byLe
,
bySve
;

683 
BYTE
 
ByLeDevNum
 = 0;

684 
BOOL
 
n
;

686 
	`ESDCMMI_addSyncWd
(
pBuf
);

687 
pBuf
 +
WORD_LENGTH
;

688 
ndBys
 = 
WORD_LENGTH
;

690 
pClWd
 = 
pBuf
;

691 
pBuf
 +
WORD_LENGTH
;

692 
ndBys
 +
WORD_LENGTH
;

694 
iBys
=
	`ESDCMMI_addPriWd
(
pBuf
,
ESDCMMIPACKETLEN
-
ndBys
);

695 
ndBys
+=
iBys
;

696 
pBuf
+=
iBys
;

697 
byInfoWds
+=(
iBys
/
WORD_LENGTH
);

699 
wSdOrd
=
ESDCMMI_ndOrd
;

700 
byLe
=
	`HIBYTE
(
wSdOrd
);

701 
bySve
=
	`LOBYTE
(
wSdOrd
);

703 
byLe
<=
m_pMhod
->
	`GToTBusNum
( ))

705 
BYTE
 
ProcTy
 = 
m_pMhod
->
	`GBusLeProcTy

byLe
 );

707 if
ProcTy
 !
PROTOCO_GATHER
 && ProcTy !
PROTOCO_TRANSPROT
 )

708 
byLe
 = 
m_pMhod
->
	`GToTBusNum
( );

709 if(
byLe
==
m_pMhod
->
	`GToTBusNum
( ))

711 
curSdTy_i
 = 
SEND_YX_FRAME
;

712 
curSdTy_nm
 = 
SEND_YC_FRAME
;

713 
ESDCMMI_ndOrd
 = 0;

714 
bChge
=
TRUE
;

718 if
ProcTy
 !
PROTOCO_GATHER
 && ProcTy !
PROTOCO_TRANSPROT
 ){

719 if(
byLe
 == 22){

720 
curSdTy_i
 = 
SEND_YX_FRAME
;

721 
curSdTy_nm
 = 
SEND_YC_FRAME
;

722 
ESDCMMI_ndOrd
 = 0;

723 
bChge
=
TRUE
;

726 
byLe
++;

730 if(
ndBys
+
WORD_LENGTH
*3>
ESDCMMIPACKETLEN
)

733 
ByLeDevNum
=
m_pMhod
->
	`GDevNum
(
byLe
);

735 if(
ByLeDevNum
==0)

737 
byLe
++;

738 
bySve
=0;

742 
n
 = 
	`ESDCMMI_InFa
(
byLe
, 
bySve
, 
pBuf
);

743 if
n
 )

745 
pBuf
+=
WORD_LENGTH
*3;

746 
ndBys
+=
WORD_LENGTH
*3;

747 
byInfoWds
+=3;

749 if(
bySve
==0)

750 
bySve
=1;

751 if(
bySve
>=
ByLeDevNum
)

753 
byLe
++;

754 
bySve
=0;

757 
bySve
++;

760 if(!
bChge
)

762 
wSdOrd
=
	`MAKEWORD
(
bySve
, 
byLe
);

763 
ESDCMMI_ndOrd
 = 0;

765 
	`ESDCMMI_addCڌWd
(
pClWd
,
FRAMEKIND_FAIL
,
byInfoWds
);

766 
n
 = 
ndBys
;

767  
TRUE
;

768 
	}
}

777 
WORD
 
	gESDCMMI
::
	$ESDCMMI_addPriWd

BYTE
 *
pBuf
 , 
WORD
 
nBy
 )

779 
WORD
 
bys
=0;

780 
n
;

781 
WORD
 
wP
, 
wV
, 
wSlNo
;

783 (
bys
+
WORD_LENGTH
*3<
nBy
)

785 if(!
	`GDigEvt

wSlNo
 , 
wP
, 
wV
))

787 if(!
	`ESDCMMI_YxChp

wP
 , 
pBuf
 ))

789 
pBuf
 +
WORD_LENGTH
*3;

790 
bys
 +
WORD_LENGTH
*3;

794 if((
ESDCMMI_Yk_Da
.
m_byYkCmd
 =
YK_SEL_RTN
)&&(ESDCMMI_Yk_Da.
m_byVid
 =
YK_VALID
)&&(
WORD_LENGTH
*3 <=(
nBy
-
bys
)))

796 
chDebugBuf
[100]="";

797 
	`rtf
(
chDebugBuf
 , "%s","insert YK_SEL_RTN\n");

799 
n
=
	`ESDCMMI_asmbYkRevi
(
pBuf
);

800 i(
n
>0)

802 
pBuf
 +
n
;

803 
bys
 +
n
;

806 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
chDebugBuf
, 
	`
( chDebugBuf ), 2);

809 i((
m_bRTime
 =
TRUE
)&&(
bys
+
WORD_LENGTH
*2 <
nBy
))

811 
	`ESDCMMI_asmSubRTime
(
pBuf
);

812 
pBuf
 +
WORD_LENGTH
*2;

813 
bys
 +
WORD_LENGTH
*2;

814 
m_bRTime
 = 
FALSE
;

817  
bys
;

818 
	}
}

833 
	gESDCMMI
::
	$ESDCMMI_InWd
(
BYTE
 *
pBuf
,BYTE 
func_high
,BYTE 
func_low
,BYTE 
modu_aiNo
,BYTE 
byLeNo
,BYTE 
modu_addr
,BYTE 
modu_ykNo
)

835 
pBuf
[0] = 
func_high
;

836 
pBuf
[1] = 
func_low
;

837 
pBuf
[2] = 
modu_aiNo
;

838 
pBuf
[3] = 
byLeNo
;

839 
pBuf
[4] = 
modu_addr
;

840 
pBuf
[5] = 
modu_ykNo
;

841 
pBuf
[6] =
	`ESDCMMI_GCRC
(pBuf,6);

844 
	}
}

856 
BYTE
 
	gESDCMMI
::
	$ESDCMMI_asmbYkRevi
(
BYTE
* 
pBuf
)

858 
BYTE
 
bys
=0;

859 
time_t
 
time0
,
time1
;

860 
BYTE
 *
pBuf0
=
pBuf
;

861 
tSec
=0;

862 
BYTE
 
oc_ykAi
,
modu_ykNo
,
modu_addrNo
,
yk_leNo
;

864 if(
ESDCMMI_Yk_Da
.
m_byYkCmd
 =
YK_SEL_RTN
)

866 
modu_ykNo
 = 
ESDCMMI_Yk_Da
.
m_byPotNo
;

867 
yk_leNo
=
ESDCMMI_Yk_Da
.
m_byLeNo
;

868 
modu_addrNo
=
ESDCMMI_Yk_Da
.
m_byAddss
;

869 if(
ESDCMMI_Yk_Da
.
m_byYkAi
==
YK_ERROR
)

871 
ESDCMMI_Yk_Da
.
m_byVid
=
YK_INVALID
;

872 
	`ESDCMMI_InWd
(
pBuf0
,0xE1,
YK_TYPE_NORMAL
,
YK_PROTOCOL_ERR
,
yk_leNo
,
modu_addrNo
,
modu_ykNo
);

873 
pBuf0
 +
WORD_LENGTH
;

874 
	`memy
(
pBuf0
,pBuf0-
WORD_LENGTH
,WORD_LENGTH);

875 
pBuf0
 +
WORD_LENGTH
;

876 
	`memy
(
pBuf0
,pBuf0-
WORD_LENGTH
,WORD_LENGTH);

877 
bys
+=
WORD_LENGTH
*3;

879  
bys
;

882 
oc_ykAi
 = 
ESDCMMI_Yk_Da
.
m_byYkAi
?
YK_PROTOCOL_CLOSE
:
YK_PROTOCOL_OPEN
;

884 if(
ESDCMMI_Yk_Da
.
m_byVid
 =
YK_VALID
)

886 if(
ESDCMMI_Yk_Da
.
m_byStus
 =
YK_PROCESS_RECEIVE
)

888 
ESDCMMI_Yk_Da
.
m_byVid
=
YK_INVALID
;

889 
ESDCMMI_Yk_Da
.
m_byStus
=
YK_PROCESS_SUCCESS
;

890 
	`ESDCMMI_InWd
(
pBuf0
,0xE1,
YK_TYPE_NORMAL
,
oc_ykAi
,
yk_leNo
,
modu_addrNo
,
modu_ykNo
);

891 
pBuf0
 +
WORD_LENGTH
;

892 
	`memy
(
pBuf0
,pBuf0-
WORD_LENGTH
,WORD_LENGTH);

893 
pBuf0
 +
WORD_LENGTH
;

894 
	`memy
(
pBuf0
,pBuf0-
WORD_LENGTH
,WORD_LENGTH);

895 
bys
+=
WORD_LENGTH
*3;

897  
bys
;

899 
time1
 = 
	`time
(
NULL
);

900 
time0
 = 
ESDCMMI_Yk_Da
.
m_tm
;

901 
tSec
 = ()
	`difime
(
time1
,
time0
);

903 if(
tSec
 > 
YK_TIME_INTERVAL
)

905 
ESDCMMI_Yk_Da
.
m_byVid
=
YK_INVALID
;

906 
ESDCMMI_Yk_Da
.
m_byStus
=
YK_PROCESS_OVERTIME
;

907 
	`ESDCMMI_InWd
(
pBuf0
,0xE1,
YK_TYPE_NORMAL
,
YK_PROTOCOL_ERR
,
yk_leNo
,
modu_addrNo
,
modu_ykNo
);

908 
pBuf0
 +
WORD_LENGTH
;

909 
	`memy
(
pBuf0
,pBuf0-
WORD_LENGTH
,WORD_LENGTH);

910 
pBuf0
 +
WORD_LENGTH
;

911 
	`memy
(
pBuf0
,pBuf0-
WORD_LENGTH
,WORD_LENGTH);

912 
bys
+=
WORD_LENGTH
*3;

914  
bys
;

919  
bys
;

920 
	}
}

929 
	gESDCMMI
::
	$ESDCMMI_asmSubRTime
(
BYTE
* 
pBuf
)

931 
BYTE
 *
pHd
;

932 
REALTIME
 
tm1
;

933 
tV
;

934 
BYTE
 
byV
;

936 
	`GCutTime
(&
tm1
);

937 
pHd
=
pBuf
;

939 
pBuf
[0] = 0x00;

940 
pBuf
[1] = 0x84;

941 
tV
 = 
tm1
.
wMliSec
;

942 
byV
 = 
tV
&0xFF;

943 
pBuf
[2] = 
byV
;

944 
tV
 = intV >> 8;

945 
byV
 = 
tV
&0x03;

946 
pBuf
[3] = 
byV
;

947 
tV
 = 
tm1
.
wSecd
;

948 
byV
 = 
tV
&0x3F;

949 
pBuf
[4] = 
byV
;

950 
tV
 = 
tm1
.
wMu
;

951 
byV
 = 
tV
&0x3F;

952 
pBuf
[5] = 
byV
;

953 
pBuf
[6] = 
	`ESDCMMI_GCRC
(
pHd
,6);

955 
pBuf
 +
WORD_LENGTH
;

956 
pHd
 +
WORD_LENGTH
;

958 
pBuf
[0] = 0x00;

959 
pBuf
[1] = 0x85;

960 
tV
 =
tm1
.
wHour
;

961 
byV
 = 
tV
&0xFF;

962 
pBuf
[2] = 
byV
;

963 
tV
 = 
tm1
.
wDay
;

964 
byV
 = 
tV
&0xFF;

965 
pBuf
[3] = 
byV
;

966 
tV
 = 
tm1
.
wMth
;

967 
byV
 = 
tV
&0xFF;

968 
pBuf
[4] = 
byV
;

969 
tV
 = 
tm1
.
wYr
%100;

970 
byV
 = 
tV
&0xFF;

971 
pBuf
[5] = 
byV
;

972 
pBuf
[6] = 
	`ESDCMMI_GCRC
(
pHd
,6);

973 
	}
}

983 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_GYxWdFromYxChP
(
WORD
 
YxOrd
,
BYTE
* 
pBuf
)

985 
BYTE
 
cou
=0;

986 
WORD
 
funcCode
 = 0,
maxYxOrd
=0,
yxLoWd
=0,
yxHiWd
=0;

987 
WORD
 
baYxOrd
=0;

988 
DWORD
 
yxDWd
=0;

990 
maxYxOrd
=
	`GPSum
(
YX_SUM
)-1;

991 if(
YxOrd
>
maxYxOrd
)

992  
FALSE
;

994 
funcCode
 = (
YxOrd
)/32;

995 if(
funcCode
>0xFF)

996  
FALSE
;

998 
baYxOrd
=
funcCode
*32;

999 if((
maxYxOrd
-
baYxOrd
+1)>=32)

1000 
cou
=32;

1002 
cou
=
maxYxOrd
-
baYxOrd
+1;

1004 
pBuf
[0] = 
	`HIBYTE
(
funcCode
);

1005 
pBuf
[0]|=0x80;

1006 
pBuf
[1]=
	`LOBYTE
(
funcCode
);

1008 
	`ESDCMMI_geYxDWd
(
baYxOrd
,&
yxDWd
,
cou
);

1009 
yxLoWd
=
	`LOWORD
(
yxDWd
);

1010 
yxHiWd
=
	`HIWORD
(
yxDWd
);

1011 
pBuf
[2] = 
	`LOBYTE
(
yxLoWd
);

1012 
pBuf
[3] = 
	`HIBYTE
(
yxLoWd
);

1013 
pBuf
[4] = 
	`LOBYTE
(
yxHiWd
);

1014 
pBuf
[5] = 
	`HIBYTE
(
yxHiWd
);

1015 
pBuf
[6] = 
	`ESDCMMI_GCRC
(pBuf,6);

1017  
TRUE
;

1019 
	}
}

1028 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_YxChp
(
WORD
 
YxChp
,
BYTE
* 
pBuf
)

1030 
BYTE
 
yxWd
[
WORD_LENGTH
];

1032 if(!
	`ESDCMMI_GYxWdFromYxChP
(
YxChp
,
yxWd
))

1033  
FALSE
;

1035 
	`memy
(
pBuf
,
yxWd
,
WORD_LENGTH
);

1036 
pBuf
 +
WORD_LENGTH
;

1037 
	`memy
(
pBuf
,
yxWd
,
WORD_LENGTH
);

1038 
pBuf
 +
WORD_LENGTH
;

1039 
	`memy
(
pBuf
,
yxWd
,
WORD_LENGTH
);

1041  
TRUE
;

1042 
	}
}

1053 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_geYxDWd
(
WORD
 
wSdOrd
,
DWORD
 * 
pYxDWd
,
BYTE
 
YxNum
)

1055 
DWORD
 
dwYxWd
=0;

1056 
BYTE
 
i
;

1058 *
pYxDWd
=0;

1059 
i
 = 0; i < 
YxNum
; i++)

1061 if(
m_byYXbuf
[
wSdOrd
]==
YX_CLOSE
)

1062 
dwYxWd
|=1<<
i
;

1064 
wSdOrd
++;

1067 *
pYxDWd
=
dwYxWd
;

1068  
TRUE
;

1069 
	}
}

1072 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_InFa
(
BYTE
 
byLeNo
,BYTE 
ModuNoAddO
,BYTE *
pBuf
)

1074 
REALTIME
 
pRlTime
;

1075 
BYTE
 
byTy
,
byS
;

1076 
WORD
 
bySveAddr
;

1078 
	`GCutTime
(&
pRlTime
);

1080 
pBuf
[0]=0x00;

1081 
pBuf
[1]=0x80;

1082 
pBuf
[2]=
	`LOBYTE
(
pRlTime
.
wMliSec
);

1083 
pBuf
[3]=
	`HIBYTE
(
pRlTime
.
wMliSec
);

1084 
pBuf
[4]=
pRlTime
.
wSecd
;

1085 
pBuf
[5]=
pRlTime
.
wMu
;

1086 
pBuf
[6]=
	`ESDCMMI_GCRC
Buf, 
WORD_LENGTH
-1);

1087 
pBuf
+=
WORD_LENGTH
;

1089 
pBuf
[0]=0x00;

1090 
pBuf
[1]=0x81;

1091 
pBuf
[2]=
pRlTime
.
wHour
;

1092 
pBuf
[3]=
pRlTime
.
wDay
;

1093 
pBuf
[4]=
pRlTime
.
wMth
;

1094 
pBuf
[5]=
pRlTime
.
wYr
%100;

1095 
pBuf
[6]=
	`ESDCMMI_GCRC
Buf, 
WORD_LENGTH
-1);

1096 
pBuf
+=
WORD_LENGTH
;

1098 
byTy
=(
ModuNoAddO
==0);

1099 if(
byTy
)

1101 
byTy
=1;

1102 
byS
=(
m_pMhod
->
	`GCommS
(
byLeNo
)!=
COM_DEV_NORMAL
);

1103 
bySveAddr
 = 0;

1107 
byTy
=2;

1108 
bySveAddr
 = 
m_pMhod
->
	`GAddrByLeNoAndModuNo

byLeNo
, 
ModuNoAddO
-1 );

1109 if0 !
bySveAddr
 )

1110 
byS
=(
m_pMhod
->
	`GDevCommS
(
byLeNo
, 
bySveAddr
)!=
COM_DEV_NORMAL
);

1112  
FALSE
;

1115 
pBuf
[0]=0x00;

1116 
pBuf
[1]=0x82;

1117 
pBuf
[2]=
byLeNo
+1;

1118 
pBuf
[3]=
bySveAddr
 & 0xFF;

1119 
pBuf
[4]=
byS
;

1120 
pBuf
[5]=
byTy
;

1121 
pBuf
[6]=
	`ESDCMMI_GCRC
Buf, 
WORD_LENGTH
-1);

1122  
TRUE
;

1123 
	}
}

1131 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_isSyncWd

BYTE
 * 
pWd
 )

1133  (0xEB==
pWd
[0] && 0x90==pWord[1] && 0xEB==pWord[2] && 0x90==pWord[3] && 0xEB==pWord[4] && 0x90==pWord[5] && 0xFF==pWord[6]);

1134 
	}
}

1143 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_tSubiTime
(
BYTE
* 
pBuf
)

1145 
BYTE
 * 
por
=
NULL
;

1146 
WORD
 
mc
=0;

1147 
BYTE
 
c
=0;

1148 
BYTE
 
m
=0;

1149 
BYTE
 
hour
=0;

1150 
BYTE
 
day
=0;

1151 
BYTE
 
mth
=0;

1152 
BYTE
 
yr
=0;

1153 
REALTIME
 
tm1
;

1155 
por
=
pBuf
;

1157 if((
por
[0]!=0)||(pointer[1]!=0xEE))

1158  
FALSE
;

1159 
mc
 = 
por
[3];

1160 
mc
 = msec << 8;

1161 
mc
 |(
WORD
)
por
[2];

1162 
c
 = 
por
[4];

1163 
m
 = 
por
[5];

1164 
por
+=
WORD_LENGTH
;

1167 if((
por
[0]!=0)||(pointer[1]!=0xEF))

1168  
FALSE
;

1169 
hour
 = 
por
[2];

1170 
day
 = 
por
[3];

1171 
mth
 = 
por
[4];

1172 
yr
 = 
por
[5];

1174 
tm1
.
wMliSec
 = 
mc
;

1175 
tm1
.
wSecd
 = 
c
;

1176 
tm1
.
wMu
 = 
m
;

1177 
tm1
.
wHour
 = 
hour
;

1178 
tm1
.
wDay
 = 
day
;

1179 
tm1
.
wMth
 = 
mth
;

1180 
tm1
.
wYr
 = 
yr
+2000;

1182  
	`SCutTime
(&
tm1
);

1183 
	}
}

1192 
BOOL
 
	gESDCMMI
::
	$ESDCMMI_hdYkCmd
(
BYTE
* 
pBuf
,BYTE 
cmdTy
)

1194 
time_t
 
time0
,
time1
;

1195 
tSec
=0;

1196 
BYTE
 
modu_ai
=0;

1197 
BYTE
 
func_hign
=
pBuf
[0];

1198 
BYTE
 
func_low
=
pBuf
[1];

1199 
BYTE
 
oc_ai
=
pBuf
[2];

1200 
BYTE
 
le_no
=
pBuf
[3];

1201 
BYTE
 
addr_no
=
pBuf
[4];

1202 
BYTE
 
_no
=
pBuf
[5];

1205 
time0
 = 
ESDCMMI_Yk_Da
.
m_tm
;

1206 
time1
 = 
	`time
(
NULL
);

1207 
tSec
 = ()
	`difime
(
time1
,
time0
);

1208 if(
	`abs
(
tSec
> 
YK_TIME_INTERVAL
)

1210 
ESDCMMI_Yk_Da
.
m_byVid
=
YK_INVALID
;

1211 
ESDCMMI_Yk_Da
.
m_byStus
=
YK_PROCESS_OVERTIME
;

1213 if
ESDCMMI_Yk_Da
.
m_byVid
 =
YK_VALID
 )

1215 
	`tf
("YK_VALID\n");

1216  
FALSE
;

1218 if((
YK_SEL
==
cmdTy
&&
func_hign
!=0XE0)||(
YK_EXCT
==cmdTy&&func_hign!=0XE2)||(
YK_CANCEL
==cmdType&&func_hign!=0XE3))

1219  
FALSE
;

1221 
func_low
)

1223 
YK_TYPE_NORMAL
:

1225 
YK_TYPE_MUTIL
:

1226  
FALSE
;

1228  
FALSE
;

1231 
oc_ai
)

1233 
YK_PROTOCOL_CLOSE
:

1234 
modu_ai
=
YK_MODULE_CLOSE
;

1236 
YK_PROTOCOL_OPEN
:

1237 
modu_ai
=
YK_MODULE_OPEN
;

1239 
YK_PROTOCOL_EXECUTE
:

1240 
YK_PROTOCOL_CANCEL
:

1241 
modu_ai
=
ESDCMMI_Yk_Da
.
m_byYkAi
;

1244  
FALSE
;

1247  
cmdTy
 )

1249 
YK_SEL
:

1250 
m_pMhod
->
	`SYkS
(
this
, 
le_no
, 
addr_no
, 
_no
, 
modu_ai
);

1252 
YK_EXCT
:

1253 
m_pMhod
->
	`SYkExe
(
this
, 
le_no
, 
addr_no
, 
_no
, 
modu_ai
);

1255 
YK_CANCEL
:

1256 
m_pMhod
->
	`SYkCl
(
this
, 
le_no
, 
addr_no
, 
_no
, 
modu_ai
);

1258  
FALSE
;

1260 
ESDCMMI_Yk_Da
.
m_byLeNo
 = 
le_no
;

1261 
ESDCMMI_Yk_Da
.
m_byAddss
 = 
addr_no
;

1262 
ESDCMMI_Yk_Da
.
m_byPotNo
 = 
_no
;

1263 
ESDCMMI_Yk_Da
.
m_byYkCmd
 = 
cmdTy
;

1264 
ESDCMMI_Yk_Da
.
m_byYkAi
 = 
modu_ai
;

1265 
ESDCMMI_Yk_Da
.
m_tm
 = 
	`time
(
NULL
);

1266 
ESDCMMI_Yk_Da
.
m_byVid
 = 
YK_VALID
;

1267 
ESDCMMI_Yk_Da
.
m_byStus
 = 
YK_PROCESS_SEND
;

1269 if(
YK_SEL
!=
cmdTy
)

1271 
ESDCMMI_Yk_Da
.
m_byVid
=
YK_INVALID
;

1274  
TRUE
;

1275 
	}
}

1279 
BOOL
 
	gESDCMMI
::
	$WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
wV
)

1281 if(
m_pwAITns
==
NULL
 
FALSE
;

1282 
WORD
 
wNum
 = 
m_pwAITns
[
wP
];

1283 if(
wNum
>
m_wAISum
 
FALSE
;

1284 if(
wNum
<
ESDCMMIMAX_AI_LEN
)

1286 
nDt
 = 
wV
 - 
m_fYCBuf
[
wNum
];

1287 if(
	`abs
(()
nDt
)>=
m_wDdV
)

1289 
m_fYCBuf
[
wNum
] = 
wV
;

1290 
	`AddAlogEvt

wSlNo
 , 
wNum
 , 
wV
 );

1293  
TRUE
 ;

1294 
	}
}

1296 
BOOL
 
	gESDCMMI
::
	$WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
)

1298 if(
m_pwDITns
==
NULL
 
FALSE
;

1299 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

1300 if(
wNum
>
m_wDISum
 
FALSE
;

1301 if
wNum
<
ESDCMMIMAX_DI_LEN
)

1303 if
m_byYXbuf
[ 
wNum
 ] !
wV
 )

1305 
m_byYXbuf
[ 
wNum
 ] = 
wV
 ;

1307 
	`AddDigEvt

wSlNo
 , 
wNum
 , 
wV
 );

1310  
TRUE
 ;

1311 
	}
}

1312 
BOOL
 
	gESDCMMI
::
	$WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
)

1314 if(
m_pwPITns
==
NULL
 
FALSE
;

1315 
WORD
 
wNum
 = 
m_pwPITns
[
wP
];

1316 if(
wNum
>
m_wPISum
 
FALSE
;

1317 if(
wNum
<
ESDCMMIMAX_PI_LEN
)

1319 
m_dwYMBuf
[
wNum
] = 
dwV
;

1321  
TRUE
 ;

1322 
	}
}

1324 
BOOL
 
	gESDCMMI
::
	$WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

1326 if(
m_pwDITns
==
NULL
 
FALSE
;

1327 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

1328 if(
wNum
>=
m_wDISum
 
FALSE
;

1329 if(
wNum
<
ESDCMMIMAX_DI_LEN
)

1331 
	`AddSOEInfo
(
wSlNo
 , 
wNum
, 
wV
, 
lTime
, 
wMiSecd
);

1333  
TRUE
 ;

1334 
	}
}

1336 
	gESDCMMI
::
	$TimProc
()

1339 
	`RdChgDa
();

1341 
	}
}

1343 
BOOL
 
	gESDCMMI
::
	$GDevCommS
( )

1345 if(
m_byPtStus
 =
COMSTATUS_ONLINE
)

1347  
COM_DEV_NORMAL
 ;

1351  
COM_DEV_ABNORMAL
 ;

1353 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/ESDCMMI.h

1 #i!
defed
(
ESDCMMI_
)

2 
	#ESDCMMI_


	)

7 
	~"CProc_ESDCMMI.h
"

9 
	#ESDCMMIMAX_AI_LEN
 (9216)

	)

10 
	#ESDCMMIMAX_PI_LEN
 (9216)

	)

11 
	#ESDCMMIMAX_DI_LEN
 (9216)

	)

13 
	#ESDCMMIMAX_MSG_LEN
 (1024)

	)

15 
	sSTRUCT_YK_DATA


17 
BYTE
 
	mm_byLeNo
;

18 
BYTE
 
	mm_byAddss
;

19 
BYTE
 
	mm_byPotNo
;

20 
BYTE
 
	mm_byVid
;

21 
time_t
 
	mm_tm
;

22 
BYTE
 
	mm_byYkCmd
;

23 
BYTE
 
	mm_byYkAi
;

24 
BYTE
 
	mm_byStus
;

25 }
	tESDCMMI_YK_STRUCT
;

29 as
	cESDCMMI
 : 
public
 
CProc_ESDCMMI


31 
public
:

32 
ESDCMMI
();

33 
	mvtu
 ~
ESDCMMI
();

35 
BOOL
 
	mFFg
;

36 
BYTE
 
	mbySdTy
;

38 
	mm_fYCBuf
[
ESDCMMIMAX_AI_LEN
];

39 
DWORD
 
	mm_dwYMBuf
[
ESDCMMIMAX_PI_LEN
];

40 
BYTE
 
	mm_byYXbuf
[
ESDCMMIMAX_DI_LEN
 ] ;

42 
	mm_wETim
;

43 
	mm_byPtStus
;

45 
BOOL
 
	mm_bRTime
;

46 
BYTE
 
	mcurSdTy_nm
;

47 
BYTE
 
	mcurSdTy_i
;

48 
WORD
 
	mESDCMMI_ndOrd
;

49 
ESDCMMI_YK_STRUCT
 
	mESDCMMI_Yk_Da
;

51 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

52 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

53 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

54 
vtu
 
BOOL
 
InRtuBa
();

55 
vtu
 
BOOL
 
WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
wV
) ;

56 
vtu
 
BOOL
 
WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
) ;

57 
vtu
 
BOOL
 
WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
) ;

58 
vtu
 
BOOL
 
WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
) ;

62 
vtu
 
BOOL
 
GDevCommS
( ) ;

63 
vtu
 
TimProc
() ;

65 
	mive
:

66 
ESDCMMI_addSyncWd

BYTE
 *
pBuf
 );

67 
ESDCMMI_addCڌWd
(
BYTE
 *
pBuf
,BYTE 
ameKd
,BYTE 
foWds
);

68 
BOOL
 
ESDCMMI_asmbYxFme

BYTE
 * 
pBuf
 , &
n
 );

69 
BOOL
 
ESDCMMI_asmbYcFme

BYTE
 * 
pBuf
 , &
n
 );

70 
BOOL
 
ESDCMMI_asmbYmFme

BYTE
 * 
pBuf
 , &
n
 );

71 
BOOL
 
ESDCMMI_asmbSFme

BYTE
 * 
pBuf
 , &
n
 );

72 
BOOL
 
ESDCMMI_asmbFaFme

BYTE
 * 
pBuf
 , &
n
 );

73 
WORD
 
ESDCMMI_addPriWd

BYTE
 *
pBuf
 , WORD 
nBy
 );

74 
ESDCMMI_InWd
(
BYTE
 *
pBuf
,BYTE 
func_high
,BYTE 
func_low
,BYTE 
modu_aiNo
,BYTE 
byLeNo
,BYTE 
modu_addr
,BYTE 
modu_ykNo
);

75 
BYTE
 
ESDCMMI_asmbYkRevi
(BYTE* 
pBuf
);

76 
ESDCMMI_asmSubRTime
(
BYTE
* 
pBuf
);

77 
BOOL
 
ESDCMMI_GYxWdFromYxChP
(
WORD
 
YxOrd
,
BYTE
* 
pBuf
);

78 
BOOL
 
ESDCMMI_geYxDWd
(
WORD
 
wSdOrd
,
DWORD
 * 
pYxDWd
,
BYTE
 
YxNum
);

79 
BOOL
 
ESDCMMI_YxChp
(
WORD
 
YxChp
,
BYTE
* 
pBuf
);

80 
BOOL
 
ESDCMMI_InFa
(
BYTE
 
byLeNo
,BYTE 
ModuNoAddO
,BYTE *
pBuf
);

81 
BOOL
 
ESDCMMI_isSyncWd

BYTE
 * 
pWd
 );

82 
BOOL
 
ESDCMMI_tSubiTime
(
BYTE
* 
pBuf
);

83 
BOOL
 
ESDCMMI_hdYkCmd
(
BYTE
* 
pBuf
,BYTE 
cmdTy
);

85 
BOOL
 
DlBusMsgInfo

PBUSMSG
 
pBusMsg
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/main.cpp

1 
	~<dio.h
>

2 
	~"CProc_ESDCMMI.h
"

6 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

11 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

13 
CProc
 * 
pProc
 = 
NULL
 ;

14 
pProc
 = 
w
 
CProc_ESDCMMI
 ;

15 if
pProc
 )

17 
pProc
->
m_pMhod
 = 
pMhod
 ;

18 
	`tf
( "ESDCMMI DLL OK.\n " ) ;

21  
pProc
 ;

22 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/CProtocol_IEC101S.cpp

1 
	~"CProc_IEC101S.h
"

2 
	~"../../she/CProc.h
"

3 
	~"IEC101S_2002.h
"

4 
	~"IEC101S_1997.h
"

5 
	~"rg.h
"

6 
	~<as.h
>

9 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

11 
	gCProc_IEC101S
::
	$CProc_IEC101S
()

13 
	`memt

m_sMaAddr
, 0, ( m_sMasterAddr ) );

14 
	`memt

m_szPrtBuf
, 0, ( m_szPrintBuf ) );

16 
	}
}

18 
	gCProc_IEC101S
::~
	$CProc_IEC101S
()

21 
	}
}

23 
BOOL
 
CProc_IEC101S
::
	$In

BYTE
 
byLeNo
 )

25 
m_byLeNo
 = 
byLeNo
 ;

26 
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

29  
	`GDevDa
( ) ;

30 
	}
}

32 
BOOL
 
	gCProc_IEC101S
::
	$GDevDa
( )

34 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

35 
	`rtf

m_sDevPh
 , "%s/IEC101Sve/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

36 
CProfe
 
	`ofe

m_sDevPh
 ) ;

38  
	`ProssFeDa

ofe
 ) ;

39 
	}
}

41 
BOOL
 
	gCProc_IEC101S
::
	$ProssFeDa

CProfe
 &
ofe
 )

43 if!
ofe
.
	`IsVid
() )

45 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

46  
FALSE
 ;

49 
sSe
[ 200 ] = "DEVNUM" ;

50 
sKey
[ 20 ][ 50 ]={ "module" , "addr" , "name" , "masteraddr" , "template" , "ycdead" , "ycProperty" , "timing"} ;

53 
sName
[ 50 ] = { 0 };

54 
eme
[ 200 ] = { 0 };

55 
iNum
 = 0 ;

56 
sMaAddr
[ 200 ] = { 0 } ;

58 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

59 if
iNum
 == 0 )

61 
	`tf
( "Get DEVNUM Failed ! \n " );

62  
FALSE
 ;

65 
BYTE
 
byIndex
 = 0 ;

66  
i
 = 0 ; i < 
iNum
 ; i++ )

68 
BOOL
 
bR
;

69 
WORD
 
wModu
 = 0 ;

70 
WORD
 
addr
 =0 ;

71 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

73 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 
byIndex
++ ] , 0 ) ;

74 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 
byIndex
++ ] , 0 ) ;

76 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

77 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
sMaAddr
 , 
eme
 ) ) ;

78 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

81 
bR
 = 
	`CeModu

wModu
 ,
sMaAddr
 , 
addr
 , 
sName
 , 
eme
 ) ;

82 i!
bR
 )

84 
	`tf
 ( "CIEC101S Modu=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
addr
, 
sName
, 
eme
 );

86  
FALSE
;

90  
TRUE
 ;

91 
	}
}

93 
BOOL
 
	gCProc_IEC101S
::
	$CeModu

iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

95 
CProc_IEC101S
 * 
pProc
 = 
NULL
 ;

97  
iModu
 )

99 
MODULE_IEC101S_2002
:

101 
pProc
 = 
w
 
CIEC101S_2002
;

102 if!
	`InIEC101S_Modu

pProc
 , 
iModu
 , 
sMaAddr
 , 
iAddr
 , 
sName
 , 
ePh
 ) )

103  
FALSE
 ;

106 
MODULE_IEC101S_1997
:

108 
pProc
 = 
w
 
CIEC101S_1997
;

109 if!
	`InIEC101S_Modu

pProc
 , 
iModu
 , 
sMaAddr
 , 
iAddr
 , 
sName
 , 
ePh
 ) )

110  
FALSE
 ;

115 
	`tf
( "%s don't containhis module Failed .\n" , "IEC101S" );

116  
FALSE
 ;

120 
m_modu
.
	`push_back

pProc
 ) ;

121  
TRUE
 ;

122 
	}
}

124 
BOOL
 
	gCProc_IEC101S
::
	$InIEC101S_Modu

CProc_IEC101S
 * 
pProc
 , 
iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

126 if
pProc
 =
NULL
 )

127  
FALSE
 ;

129 
pProc
->
m_byLeNo
 = m_byLineNo ;

130 
pProc
->
m_wModuTy
 = 
iModu
 ;

131 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

132 
	`tf
("iddr=%d m_byLeNo=%d\n", 
iAddr
, 
m_byLeNo
);

133 
	`ry

pProc
->
m_sDevName
 , 
sName
 ) ;

134 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

135 
	`ry

pProc
->
m_sMaAddr
 , 
sMaAddr
 ) ;

136 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

137 
pProc
->
m_pMhod
 = m_pMethod ;

138 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

140 if!
pProc
->
	`In

m_byLeNo
 ) )

141  
FALSE
 ;

142 
	`tf
" Add bu%d Add%d ProcNam%\n" , 
m_byLeNo
 , 
iAddr
 , 
sName
 ) ;

144  
TRUE
 ;

145 
	}
}

157 
	gCProc_IEC101S
::
	$t
 ( cڡ *
szBuf
, 
n
 )

159 #ifde 
IEC101S_PRINT


160 
	`tf
 ( "%s\n" , 
szBuf
);

164 #ifde 
IEC101S_DEBUG


165 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

167 
	}
}

180 
BYTE
 
	gCProc_IEC101S
::
	$GCs
 ( cڡ 
BYTE
 *
pBuf
, 
n
 )

182 
BYTE
 
byR
 = 0x00;

183 
	`as

pBuf
 !
NULL
 );

184 
	`as

n
 > 0 );

186  
i
=0; i<
n
 ; i++ )

188 
byR
 +
pBuf
[
i
];

191  
byR
;

192 
	}
}

203 
BOOL
 
	gCProc_IEC101S
::
	$ProssJudgeFg
 ( 
BYTE
 
c
 )

206 if
c
 & 0x10 )

208 
BOOL
 
bFcb
 = ( 
c
 & 0x20 ) >> 5;

212 i
bFcb
 !
m_bFcb
)

214 
m_SdStus
 = 
RESEND
;

215  
FALSE
;

219 
m_bFcb
 ^= 1;

223  
TRUE
;

224 
	}
}

237 
BOOL
 
	gCProc_IEC101S
::
	$WhhBufVid
 ( cڡ 
BYTE
 *
buf
, &
n
 )

239 cڡ 
BYTE
 *
por
 = 
buf
;

240 
d
;

241 
BYTE
 
byCs
;

242 
pos
 = 0;

244 i
buf
 =
NULL
 || 
n
 <= 0 )

246 
	`rtf

m_szPrtBuf
, "IEC101S WhhBufVubuf==NULL o%d" , 
n
);

247 
	`t

m_szPrtBuf
 );

248  
FALSE
;

251  
n
 > 0 )

253 *
por
)

258 if(*(
por
+3) != *pointer)

259 || (*(
por
+1) != *(pointer+2)))

261 
DEFAULT
;

265 
d
=*(
por
+1);

266 if
d
+6>
n
 )

268 
	`rtf
(
m_szPrtBuf
, "IEC101Secv d=%d=%d", 
d
, 
n
 );

269 
	`t

m_szPrtBuf
 );

270 
DEFAULT
;

274 
byCs
=
	`GCs
(
por
+4,
d
);

275 if(*(
por
+
d
+4)!=
byCs


276 || *(
por
+
d
+5)!=0x16)

278 
	`rtf
(
m_szPrtBuf
, "IEC101Secv cr GCs=%d cs=%d oϡ by !0x16 =%x", 
byCs
, *(
por
+
d
+4), *(pointer+datalen+5));

279 
	`t

m_szPrtBuf
 );

280 
DEFAULT
;

284 i*(
por
 + 5!
m_wDevAddr
 && *(pointer + 5) != 0xff )

286 
	`rtf
(
m_szPrtBuf
, "IEC101Secvddr Gaddr=%dddr=%d ", *(
por
 + 5), 
m_wDevAddr
 );

287 
	`t

m_szPrtBuf
 );

288 
DEFAULT
;

292 i0 =(*(
por
 + 4) & 0x40) )

294 
	`rtf
(
m_szPrtBuf
, "IEC101Secv PRM = %d ", *(
por
 + 4) & 0x40 );

295 
	`t

m_szPrtBuf
 );

296 
DEFAULT
;

300 
n
 = 
d
 + 6;

301 
buf
 = bu+ 
pos
;

302  
TRUE
;

308 
byCs
=
	`GCs
(
por
+1,2);

309 if*(
por
+3)!=
byCs
 || *(pointer+4)!=0x16 )

311 
	`rtf
(
m_szPrtBuf
, "IEC101Secv cr GCs=%d cs=%d oϡ by !0x16 =%x", 
byCs
, *(
por
+
d
+3), *(pointer+datalen+4));

312 
	`t

m_szPrtBuf
 );

313 
DEFAULT
;

317 i*(
por
+2!
m_wDevAddr
 )

319 
	`rtf
(
m_szPrtBuf
, "IEC101Secvddr Gaddr=%dddr=%d ", *(
por
+2), 
m_wDevAddr
 );

320 
	`t

m_szPrtBuf
 );

321 
DEFAULT
;

324 
buf
 = bu+ 
pos
;

325 
n
 = 5;

326  
TRUE
;

331 
DEFAULT
;

335 
DEFAULT
:

336 
n
--;

337 
por
++;

338 
pos
 ++;

342  
FALSE
;

343 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/CProtocol_IEC101S.h

1 #ide
CPROTOCOL_IEC101S_H


2 
	#CPROTOCOL_IEC101S_H


	)

4 
	~"../../she/Rtu.h
"

5 
	~"../../she/CMhod.h
"

6 
	~"../../she/tydef.h
"

11 
	#IEC101S_DEBUG


	)

13 
	#IEC101SPREFIXFILENAME
 "/mynd/cfig/IEC101Sve/"

	)

14 
	#MODULE_IEC101S_2002
 1

15 
	#MODULE_IEC101S_1997
 2

16 

	)

18 
	#IEC101S_TOTAL_CALL
 0x00000001

	)

19 
	#IEC101S_TOTAL_YX
 0x00000002

	)

20 
	#IEC101S_TOTAL_YC
 0x00000004

	)

21 
	#IEC101S_TOTAL_YM
 0x00000008

	)

22 
	#IEC101S_CALL_YM
 0x00000010

	)

23 
	#IEC101S_TIME_SYNC
 0x00000020

	)

24 
	#IEC101S_YK_SEL
 0x00000040

	)

25 
	#IEC101S_YK_EXE
 0x00000080

	)

26 
	#IEC101S_YK_CANCEL
 0x00000100

	)

27 
	#IEC101S_TOTAL_CALL_END
 0x00000200

	)

28 
	#IEC101S_CALL_YM_END
 0x00000400

	)

29 
	#IEC101S_TIME_SYNC_END
 0x00000800

	)

30 
	#IEC101S_SPECIAL_DATA
 0x00001000

	)

31 
	#IEC101S_CHANGE_YX
 0x00002000

	)

32 
	#IEC101S_CHANGE_YC
 0x00004000

	)

33 
	#IEC101S_SOE_YX
 0x00008000

	)

51 
	e_IEC101SSENDSTATUS


54 
	mNULL_STATUS
,

55 
	mRESEND
,

56 
	mLEVEL1_DATA
,

57 
	mLEVEL2_DATA
,

58 
	mTOTAL_CALL
,

59 
	mTIME_SYNC
,

60 
	mCALL_YM
,

61 
	mYK_RTN_DATA
,

62 
	mLINK_STATUS
,

63 
	mRECOGNITION
,

64 
	mDENY_RECOGNITION
,

65 
	mUSER_DATA
,

66 
	mNONE_USER_DATA
,

106 }
	tIEC101SSENDSTATUS
;

108 as
	cCProc_IEC101S
 : 
public
 
CRtuBa


110 
public
:

111 
CProc_IEC101S
();

112 
	mvtu
 ~
CProc_IEC101S
();

113 
BOOL
 
GDevDa
( );

114 
BOOL
 
ProssFeDa

CProfe
 &
ofe
 );

115 
BOOL
 
CeModu

iModu
 ,* 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

116 
BOOL
 
InIEC101S_Modu

CProc_IEC101S
 * 
pProc
 , 
iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 );

117 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

119 
vtu
 
BYTE
 
GCs
cڡ BYTE *
pBuf
, 
n
 );

121 
vtu
 
BOOL
 
WhhBufVid
cڡ 
BYTE
 *
buf
, &
n
 );

123 
vtu
 
BOOL
 
ProssJudgeFg

BYTE
 
c
 );

126 
	meed
:

127 
m_sMaAddr
[ 200 ] ;

128 
t
cڡ *
szBuf
, 
n
=0 );

130 
	mpublic
:

131 
m_szPrtBuf
[256];

132 
BOOL
 
	mm_bFcb
;

133 
IEC101SSENDSTATUS
 
	mm_SdStus
;

135 
DWORD
 
	mm_dwSdFg
;

136 
	mive
:

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/IEC101S_1997.cpp

20 
	~"IEC101S_1997.h
"

30 
	gCIEC101S_1997
::
	$CIEC101S_1997
 ()

33 
m_wYxSAddr
 = 0x001;

34 
m_wYcSAddr
 = 0x701;

35 
m_wYkSAddr
 = 0xb01;

36 
m_wYmSAddr
 = 0xc01;

37 
m_wComSAddr
 = 50000;

40 
m_byCL
 = 1;

41 
m_byAddrL
 = 1;

42 
m_byInfoAddrL
 = 2;

45 
m_byTٮClYx
 = 1;

46 
m_byTٮClYc
 = 11;

47 
m_byTٮClYm
 = 15;

49 
m_byChgeYx
 = 1;

50 
m_bySYx
 = 30;

51 
m_byChgeYc
 = 11;

52 
m_byYkTy
 = 
IEC101S_2002_YKSINGLE_TYPE
;

53 
	}
}

62 
	gCIEC101S_1997
::~
	$CIEC101S_1997
 ()

64 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/IEC101S_1997.h

21 #ide 
IEC101S_1997_INC


22 
	#IEC101S_1997_INC


	)

25 
	~"IEC101S_2002.h
"

33 as
	cCIEC101S_1997
 : 
public
 
CIEC101S_2002


35 
public
:

37 
CIEC101S_1997
 ();

38 ~
CIEC101S_1997
 ();

41 
	meed
:

44 
ive
:

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/IEC101S_2002.cpp

21 
	~"IEC101S_2002.h
"

22 
	~<as.h
>

23 
	~"../../she/glob.h
"

26 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

27 "C" 
SCutTime

REALTIME
 *
pRlTime
 );

29 
	s_CP56TIME2A


31 
BYTE
 
	mbyLoMis
;

32 
BYTE
 
	mbyHiMis
;

33 
BYTE
 
	mbyM
;

34 
BYTE
 
	mbyHour
;

35 
BYTE
 
	mbyDay
;

36 
BYTE
 
	mbyM
;

37 
BYTE
 
	mbyYr
;

38 }
	tCP56TIME2A
;

46 
	gCIEC101S_2002
::
	$CIEC101S_2002
 ()

49 
m_wYxSAddr
 = 0x0001;

50 
m_wYcSAddr
 = 0x4001;

51 
m_wYkSAddr
 = 0x6001;

52 
m_wYmSAddr
 = 0x6401;

53 
m_wComSAddr
 = 50000;

56 
m_byCL
 = 1;

57 
m_byAddrL
 = 1;

58 
m_byInfoAddrL
 = 2;

61 
m_byTٮClYx
 = 1;

62 
m_byTٮClYc
 = 11;

63 
m_byTٮClYm
 = 15;

65 
m_byChgeYx
 = 1;

66 
m_bySYx
 = 30;

67 
m_byChgeYc
 = 11;

68 
m_byYkTy
 = 
IEC101S_2002_YKSINGLE_TYPE
;

71 
	`memt

m_fYcBuf
, 0, ( m_fYcBuf ) );

72 
	`memt

m_byYxBuf
, 0, ( m_byYxBuf ) );

73 
	`memt

m_dwYmBuf
, 0, ( m_dwYmBuf ) );

76 
	`InProcS
( );

77 
	}
}

86 
	gCIEC101S_2002
::~
	$CIEC101S_2002
 ()

88 
	}
}

91 
	$GCp56Time2a

CP56TIME2A
 *
pCp56Time
 )

93 
REALTIME
 
curTime
;

94 
WORD
 
wMliSec
;

96 
	`GCutTime
&
curTime
 );

97 
wMliSec
 = 
curTime
.
wSecd
*1000 + curTime.wMilliSec;

98 
pCp56Time
->
byLoMis
 = 
	`LOBYTE

wMliSec
 );

99 
pCp56Time
->
byHiMis
 = 
	`HIBYTE

wMliSec
 );

100 
pCp56Time
->
byM
 = (
BYTE
)
curTime
.
wMu
;

101 
pCp56Time
->
byHour
 = (
BYTE
)
curTime
.
wHour
;

102 
pCp56Time
->
byDay
 = 
	`LOBYTE
(
curTime
.
wDay
 + ( curTime.
wDayOfWk
 << 5 ));

103 
pCp56Time
->
byM
 = (
BYTE
)
curTime
.
wMth
;

104 
pCp56Time
->
byYr
 = 
curTime
.
wYr
-2000;

105 
	}
}

107 
CP56TIME2A
 
	$GTmToCp56Time2a

tm
 
t
, 
WORD
 
wMiSec
 )

109 
WORD
 
wMliSec
;

110 
CP56TIME2A
 

;

112 
wMliSec
 = 
t
.
tm_c
*1000 + 
wMiSec
;

113 

.
byLoMis
 = 
	`LOBYTE

wMliSec
 );

114 

.
byHiMis
 = 
	`HIBYTE

wMliSec
 );

115 

.
byM
 = (
BYTE
)
t
.
tm_m
;

116 

.
byHour
 = (
BYTE
)
t
.
tm_hour
;

117 

.
byDay
 = 
	`LOBYTE
(
t
.
tm_mday
 + (.
tm_wday
 << 5 ));

118 

.
byM
 = (
BYTE
)
t
.
tm_m
;

119 

.
byYr
 = 
t
.
tm_yr
-100;

121  

;

122 
	}
}

137 
	gCIEC101S_2002
::
	$GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
)

139 
WORD
 
wVue
 = 0 ;

140 
byTy
)

143 if(
wP
>=
IEC101S_2002_MAX_YC_NUM
)  -2;

144 
	`memy
(
v
, &
m_fYcBuf
[
wP
], (
WORD
));

148 if(
wP
>=
IEC101S_2002_MAX_YX_NUM
)

151 if
m_byYxBuf
[ 
wP
 ] ==0 )

152 
wVue
 = 0;

154 
wVue
 = 1;

156 
	`memy
(
v
, &
wVue
, (
WORD
));

160 if(
wP
>=
IEC101S_2002_MAX_YM_NUM
)  -2;

161 
	`memy
(
v
, &
m_dwYmBuf
[
wP
], (
DWORD
));

167 
	}
}

169 
BOOL
 
	gCIEC101S_2002
::
	$WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
fV
)

171 if(
m_pwAITns
==
NULL
 
FALSE
;

172 
WORD
 
wNum
 = 
m_pwAITns
[
wP
];

173 if(
wNum
>
m_wAISum
 
FALSE
;

174 if(
wNum
<
IEC101S_2002_MAX_YC_NUM
)

176 
fDt
 = 
fV
 - 
m_fYcBuf
[
wNum
];

177 if(
	`abs
(()
fDt
)>=
m_wDdV
)

179 
m_fYcBuf
[
wNum
] = 
fV
;

180 if(
m_bDaIn
)

182 
	`AddAlogEvt

wSlNo
 , 
wNum
, 
fV
);

186  
TRUE
 ;

187 
	}
}

189 
BOOL
 
	gCIEC101S_2002
::
	$WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
)

191 if(
m_pwDITns
==
NULL
 
FALSE
;

192 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

193 if(
wNum
>
m_wDISum
 
FALSE
;

194 if
wNum
<
IEC101S_2002_MAX_YX_NUM
)

196 if
m_byYxBuf
[ 
wNum
 ] !
wV
 )

198 
m_byYxBuf
[ 
wNum
 ] = 
wV
 ;

199 if(
m_bDaIn
)

201 
	`AddDigEvt

wSlNo
 , 
wNum
, 
wV
);

205  
TRUE
 ;

206 
	}
}

207 
BOOL
 
	gCIEC101S_2002
::
	$WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
)

209 if(
m_pwPITns
==
NULL
 
FALSE
;

210 
WORD
 
wNum
 = 
m_pwPITns
[
wP
];

211 if(
wNum
>
m_wPISum
 
FALSE
;

212 if(
wNum
<
IEC101S_2002_MAX_YM_NUM
)

214 
m_dwYmBuf
[
wNum
] = 
dwV
;

216  
TRUE
 ;

217 
	}
}

219 
BOOL
 
	gCIEC101S_2002
::
	$WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

221 if(
m_pwDITns
==
NULL
 
FALSE
;

222 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

223 if(
wNum
>=
m_wDISum
 
FALSE
;

224 if(
wNum
<
IEC101S_2002_MAX_YX_NUM
)

226 
	`AddSOEInfo
(
wSlNo
 , 
wNum
, 
wV
, 
lTime
, 
wMiSecd
);

228  
TRUE
 ;

229 
	}
}

243 
	gCIEC101S_2002
::
	$SRecvPam
 ( )

245 
m_bSdg
 = 
FALSE
;

246 
m_bReSdg
 = 
FALSE
;

248 
m_bySdCou
 = 0;

249 
m_byRecvCou
 ++;

250 
m_byRendCou
 = 0;

252 
m_bLkStus
 = 
TRUE
;

253 
	}
}

265 
BOOL
 
	gCIEC101S_2002
::
	$ProssCB
 ( 
BYTE
 
c
 )

267  
c
 & 0x0f )

270 
m_SdStus
 = 
RECOGNITION
;

271 
	`InProcS
( );

272 
m_dwSdFg
 |
IEC101S_SPECIAL_DATA
;

273 
	`t
( "/ȷ֡ Զ·λ" );

277 
	`t
( "/ȷ֡ û̸λ" );

281 
	`t
( "/ȷ֡ ƽ⴫䱣" );

285 
	`t
( "/ȷ֡ û" );

286 
m_SdStus
 = 
USER_DATA
;

290 
	`t
( "/޻ش֡ û" );

291 
m_SdStus
 = 
NONE_USER_DATA
;

295 
	`t
( "/Ӧ ҪλӦ" );

299 
	`t
( "/Ӧ ·״̬" );

300 
m_SdStus
 = 
LINK_STATUS
;

301 
m_dwSdFg
 |
IEC101S_SPECIAL_DATA
;

305 
	`t
( "/Ӧ һ" );

306 
m_SdStus
 = 
LEVEL1_DATA
;

310 
	`t
( "/Ӧ " );

311 
m_SdStus
 = 
LEVEL2_DATA
;

315 
	`t
( "ΪЭ̵Ӧñ" );

316  
FALSE
;

320  
TRUE
;

321 
	}
}

332 
	gCIEC101S_2002
::
	$SYkPam
 ( 
BYTE
 
byTy
, BYTE 
byC
, 
WORD
 
wS
, WORD 
wP
, BYTE 
byStus
 )

334 
m_byYKAsduTy
 = 
byTy
;

335 
m_byYkC
 = 
byC
;

336 
m_wYkS
 = 
wS
;

337 
m_wYkP
 = 
wP
;

338 
m_byYkStus
 = 
byStus
;

339 
	}
}

350 
BOOL
 
	gCIEC101S_2002
::
	$IsYkPamTrue
 ( 
BYTE
 
byTy
, BYTE 
byC
, 
WORD
 
wS
, WORD 
wP
, BYTE 
byStus
 ) const

352 
BYTE
 
byTmp
;

353 if0x2d =
byTy
 )

355 
byTmp
 = 
IEC101S_2002_YKSINGLE_TYPE
;

357 if0x2=
byTy
 )

359 
byTmp
 = 
IEC101S_2002_YKDOUBLE_TYPE
;

363 
	`tf
 ( "IEC101S yky=%x ir!!!\n", 
byTy
 );

364  
FALSE
;

367 if
byTmp
 !
m_byYKAsduTy


368 || 
byC
 !
m_byYkC


369 || 
wS
 !
m_wYkS


370 || 
wP
 !
m_wYkP


371 || 
byStus
 !
m_byYkStus
)

373  
TRUE
;

377 
	`tf
 ( "IEC101S YKype=%x %x cot=%x %x stn=%d %dnt=%d %d status=%d %d\n" ,

378 
byTy
, 
m_byYkTy
, 
byC
, 
m_byYkC
, 
wS
, 
m_wYkS
, 
wP
, 
m_wYkP
 , 
byStus
, 
m_byYkStus
);

380  
FALSE
;

382 
	}
}

394 
BOOL
 
	gCIEC101S_2002
::
	$ProssYkBuf
 ( cڡ 
BYTE
 *
buf
, 
n
 )

396 cڡ 
BYTE
 *
por
 = &
buf
[8];

399 
BYTE
 
byC
 = *
por
++;

400 if2 =
m_byCL
 )

402 
por
++;

406 
WORD
 
wAddr
 = *
por
++;

407 i2 =
m_byAddrL
 )

409 
por
 ++;

411 if
wAddr
 !
m_wDevAddr
 )

413 
	`tf
 ( "IEC101S ַȷ\n" );

414  
FALSE
;

417 
WORD
 
wInfoAddr
 = 
	`MAKEWORD
*
por
, *(ointer + 1 ) );

418 
por
 += 2;

419 if3 =
m_byInfoAddrL
 )

421 
por
 ++;

429 
WORD
 
wNum
 = 
wInfoAddr
 - 
m_wYkSAddr
;

430 i
wNum
 > 
m_wDOSum
 )

432 
	`tf
 ( "IEC101S λòȷ\n" );

433  
FALSE
;

435 
WORD
 
byS
 = 
m_pDOMTab
[
wNum
].
wS
 - 1;

436 
WORD
 
wP
 = 
m_pDOMTab
[
wNum
].
wPNum
 - 1;

439 
BYTE
 
bySdco
 = *
por
;

440 
BYTE
 
byStus
 = 0xff;

441 if
IEC101S_2002_YKSINGLE_TYPE
 =
m_byYkTy
 )

443 
byStus
 = ( 
bySdco
 & 0x01 );

445 if
IEC101S_2002_YKDOUBLE_TYPE
 =
m_byYkTy
 )

447 
byStus
 = ( 
bySdco
 & 0x03 ) -1;

449 if(0 !
byStus
 && 1 != byStatus)

451 
	`tf
 ( "IEC101S ״̬ȷ\n" );

452  
FALSE
;

456 if0x06 =
byC
 )

458 if0 !(0x80 & 
bySdco
 ) )

460 
BYTE
 
byBusNo
;

461 
WORD
 
wDevAddr
;

462 
	`tf
 ( "IEC101S ңѡ\n" );

463 if
m_pMhod
->
	`GBusLeAndAddr

byS
, 
byBusNo
, 
wDevAddr
 ) )

465 
m_dwSdFg
 = 
IEC101S_YK_SEL
;

466 
	`SYkPam

buf
[6], 
byC
, 
byS
, 
wP
, 
byStus
 );

467 
m_pMhod
->
	`SYkS
(
this
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byStus
);

472 i
	`IsYkPamTrue

buf
[6], 
byC
, 
byS
, 
wP
, 
byStus
 ) )

474 
BYTE
 
byBusNo
;

475 
WORD
 
wDevAddr
;

476 
	`tf
 ( "IEC101S ңִ\n" );

477 if
m_pMhod
->
	`GBusLeAndAddr

byS
, 
byBusNo
, 
wDevAddr
 ) )

479 
m_dwSdFg
 = 
IEC101S_YK_EXE
;

480 
m_pMhod
->
	`SYkExe
(
this
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byStus
);

485 if0x08 =
byC
 )

487 
BYTE
 
byBusNo
;

488 
WORD
 
wDevAddr
;

489 if
m_pMhod
->
	`GBusLeAndAddr

byS
, 
byBusNo
, 
wDevAddr
 ) )

491 
m_dwSdFg
 = 
IEC101S_YK_CANCEL
;

492 
	`SYkPam

buf
[6], 
byC
, 
byS
, 
wP
, 
byStus
 );

493 
m_pMhod
->
	`SYkCl
(
this
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byStus
);

497  
TRUE
;

498 
	}
}

510 
BOOL
 
	gCIEC101S_2002
::
	$ProssTٮClBuf
 ( cڡ 
BYTE
 *
buf
, 
n
 )

512 cڡ 
BYTE
 *
por
 = &
buf
[6];

513 
por
 ++;

515 
BYTE
 
byVsq
 = *
por
++;

516 if1 !
byVsq
 )

518 
	`rtf

m_szPrtBuf
, "IEC101Sٮ VSQ=%d", 
byVsq
 );

519 
	`t

m_szPrtBuf
 );

520  
FALSE
;

524 
BYTE
 
byC
 = *
por
++;

525 if2 =
m_byCL
 )

527 
por
++;

529 if6 !
byC
 )

531 
	`rtf

m_szPrtBuf
, "IEC101Sٮ COT=%d", 
byC
 );

532 
	`t

m_szPrtBuf
 );

533  
FALSE
;

537 
WORD
 
wAddr
 = *
por
++;

538 i2 =
m_byAddrL
 )

540 
por
 ++;

542 if
wAddr
 !
m_wDevAddr
 )

544 
	`rtf

m_szPrtBuf
, "IEC101Sٮ ADDR=%d", 
wAddr
 );

545 
	`t

m_szPrtBuf
 );

546  
FALSE
;

550 
WORD
 
wInfoAddr
 = 
	`MAKEWORD
*
por
, *(ointer + 1 ) );

551 
por
 += 2;

552 if3 =
m_byInfoAddrL
 )

554 
por
 ++;

556 if0 !
wInfoAddr
 )

558 
	`rtf

m_szPrtBuf
, "IEC101Sٮ INFOADDR=%d", 
wInfoAddr
 );

559 
	`t

m_szPrtBuf
 );

560  
FALSE
;

564 
BYTE
 
byQoi
 = *
por
++;

565 if0x14 !
byQoi
 )

567 
	`rtf

m_szPrtBuf
, "IEC101Sٮ QOI=%d", 
byQoi
 );

568 
	`t

m_szPrtBuf
 );

569  
FALSE
;

571  
TRUE
;

572 
	}
}

583 
BOOL
 
	gCIEC101S_2002
::
	$ProssYMClBuf
 ( cڡ 
BYTE
 *
buf
, 
n
 )

585 cڡ 
BYTE
 *
por
 = &
buf
[6];

586 
por
 ++;

588 
BYTE
 
byVsq
 = *
por
++;

589 if1 !
byVsq
 )

591 
	`rtf

m_szPrtBuf
, "IEC101S ym VSQ=%d", 
byVsq
 );

592 
	`t

m_szPrtBuf
 );

593  
FALSE
;

597 
BYTE
 
byC
 = *
por
++;

598 if2 =
m_byCL
 )

600 
por
++;

602 if6 !
byC
 )

604 
	`rtf

m_szPrtBuf
, "IEC101S ym COT=%d", 
byC
 );

605 
	`t

m_szPrtBuf
 );

606  
FALSE
;

610 
WORD
 
wAddr
 = *
por
++;

611 i2 =
m_byAddrL
 )

613 
por
 ++;

615 if
wAddr
 !
m_wDevAddr
 )

617 
	`rtf

m_szPrtBuf
, "IEC101S ym ADDR=%d", 
wAddr
 );

618 
	`t

m_szPrtBuf
 );

619  
FALSE
;

623 
WORD
 
wInfoAddr
 = 
	`MAKEWORD
*
por
, *(ointer + 1 ) );

624 
por
 += 2;

625 if3 =
m_byInfoAddrL
 )

627 
por
 ++;

629 if0 !
wInfoAddr
 )

631 
	`rtf

m_szPrtBuf
, "IEC101S ym INFOADDR=%d", 
wInfoAddr
 );

632 
	`t

m_szPrtBuf
 );

633  
FALSE
;

637 
BYTE
 
byQoi
 = *
por
++;

638 if0x14 !
byQoi
 )

640 
	`rtf

m_szPrtBuf
, "IEC101S ym QOI=%d", 
byQoi
 );

641 
	`t

m_szPrtBuf
 );

642  
FALSE
;

644  
TRUE
;

645 
	}
}

656 
BOOL
 
	gCIEC101S_2002
::
	$ProssTimeSyncBuf
 ( cڡ 
BYTE
 *
buf
, 
n
 )

658 cڡ 
BYTE
 *
por
 = &
buf
[6];

659 
por
 ++;

661 
BYTE
 
byVsq
 = *
por
++;

662 if1 !
byVsq
 )

664 
	`rtf

m_szPrtBuf
, "IEC101SimesynVSQ=%d", 
byVsq
 );

665 
	`t

m_szPrtBuf
 );

666  
FALSE
;

670 
BYTE
 
byC
 = *
por
++;

671 if2 =
m_byCL
 )

673 
por
++;

675 if6 !
byC
 )

677 
	`rtf

m_szPrtBuf
, "IEC101SimesynCOT=%d", 
byC
 );

678 
	`t

m_szPrtBuf
 );

679  
FALSE
;

683 
WORD
 
wAddr
 = *
por
++;

684 i2 =
m_byAddrL
 )

686 
por
 ++;

688 if
wAddr
 !
m_wDevAddr
 && wAddr != 0xff)

690 
	`rtf

m_szPrtBuf
, "IEC101SimesynADDR=%d", 
wAddr
 );

691 
	`t

m_szPrtBuf
 );

692  
FALSE
;

696 
WORD
 
wInfoAddr
 = 
	`MAKEWORD
*
por
, *(ointer + 1 ) );

697 
por
 += 2;

698 if3 =
m_byInfoAddrL
 )

700 
por
 ++;

702 if0 !
wInfoAddr
 )

704 
	`rtf

m_szPrtBuf
, "IEC101SimesynINFOADDR=%d", 
wInfoAddr
 );

705 
	`t

m_szPrtBuf
 );

706  
FALSE
;

710 
REALTIME
 
curTime
;

711 
WORD
 
wMiSecd
 = 
	`MAKEWORD
*(
por
), *(pointer + 1) );

712 
por
 += 2;

713 
curTime
.
wMliSec
 = 
wMiSecd
 % 1000;

714 
curTime
.
wSecd
 = 
wMiSecd
 / 1000;

715 
curTime
.
wMu
 = (*
por
++) & 0x3f;

716 
curTime
.
wHour
 = (*
por
++) & 0x1f;

717 
curTime
.
wDay
 = (*
por
++) & 0x1f;

718 
curTime
.
wMth
 = (*
por
++) & 0x0f;

719 
curTime
.
wYr
 = ( (*
por
++) + 2000 );

721 if
curTime
.
wSecd
 < 60

722 && 
curTime
.
wMu
 < 60

723 && 
curTime
.
wHour
 < 24

724 && 
curTime
.
wDay
 <= 31

725 && 
curTime
.
wMth
 <= 12

726 && 
curTime
.
wYr
 < 2030)

728 
	`SCutTime
&
curTime
 );

732 
	`rtf

m_szPrtBuf
, "IEC101imesync SetCurrentTimerr!!!time=%d-%d-%d %d:%d:%d",

733 
curTime
.
wYr
, curTime.
wMth
, curTime.
wDay
, curTime.
wHour
, curTime.
wMu
,curTime.
wSecd
);

734 
	`t

m_szPrtBuf
 );

736  
TRUE
;

737 
	}
}

749 
BOOL
 
	gCIEC101S_2002
::
	$ProssHd68Buf
 ( cڡ 
BYTE
 *
pBuf
, 
n
 )

752 i!
	`ProssJudgeFg

pBuf
[4] & 0xf0 ) )

754 
	`t
( "ProcessJudgeFlag" );

755  
FALSE
;

759 i!
	`ProssCB

pBuf
[4] & 0x0f ) )

761 
	`t
( "ProcessCtlBit" );

762  
FALSE
;

765  
pBuf
[6] )

768 
	`t
( "ң" );

769 
m_byYkTy
 = 
IEC101S_2002_YKSINGLE_TYPE
;

770 
	`ProssYkBuf

pBuf
, 
n
 );

774 
	`t
( "˫ң" );

775 
m_byYkTy
 = 
IEC101S_2002_YKDOUBLE_TYPE
;

776 
	`ProssYkBuf

pBuf
, 
n
 );

780 
	`t
( "" );

784 
	`t
( "趨ֵ һֵ" );

788 
	`t
( "趨ֵ Ȼֵ" );

792 
	`t
( "趨ֵ ̸" );

796 
	`t
( "ٻ" );

797 i
	`ProssTٮClBuf

pBuf
, 
n
 ) )

799 
m_dwSdFg
 |(
IEC101S_TOTAL_CALL
 | 
IEC101S_TOTAL_YX
 | 
IEC101S_TOTAL_YC
| 
IEC101S_TOTAL_CALL_END
);

800 
m_dwSdFg
 |
IEC101S_SPECIAL_DATA
;

804 
	`t
( "ٻ" );

810 
	`t
( "ٻ" );

811 i
	`ProssYMClBuf

pBuf
, 
n
 ) )

813 
m_dwSdFg
 |
IEC101S_CALL_YM
 | 
IEC101S_TOTAL_YM
 | 
IEC101S_CALL_YM_END
;

814 
m_dwSdFg
 |
IEC101S_SPECIAL_DATA
;

818 
	`t
( "ٻ" );

823 
	`t
( "" );

827 
	`t
( "ʱͬ" );

828 if
	`ProssTimeSyncBuf

pBuf
, 
n
 ) )

830 
m_SdStus
 = 
TIME_SYNC
;

831 
m_dwSdFg
 |
IEC101S_TIME_SYNC
 ;

832 
m_dwSdFg
 |
IEC101S_SPECIAL_DATA
;

836 
	`t
( "ʱ" );

841 
	`t
( "" );

845 
	`t
( "λ" );

849 
	`t
( "ʱ" );

856  
TRUE
;

857 
	}
}

869 
BOOL
 
	gCIEC101S_2002
::
	$ProssHd10Buf
 ( cڡ 
BYTE
 *
pBuf
, 
n
 )

872 i!
	`ProssJudgeFg

pBuf
[1] & 0xf0 ) )

874 
	`t
( "IEC101S:ProcessJudgeFlagrr" );

875  
FALSE
;

879 i!
	`ProssCB

pBuf
[1] & 0x0f ) )

881 
	`t
( "IEC101S:ProcessCtlBitrr" );

882  
FALSE
;

885  
TRUE
;

886 
	}
}

897 
BOOL
 
	gCIEC101S_2002
::
	$ProssRecvBuf
 ( cڡ 
BYTE
 *
pBuf
, 
n
 )

899 i
pBuf
[0] == 0x10 )

901  
	`ProssHd10Buf

pBuf
, 
n
 );

903 if
pBuf
[0] == 0x68 )

905  
	`ProssHd68Buf

pBuf
, 
n
 );

909 
	`t
( "ProcessRecvBufrr" );

912  
FALSE
;

913 
	}
}

927 
BOOL
 
	gCIEC101S_2002
::
	$IsYkRBusMsgVid
 ( 
PBUSMSG
 
pBusMsg
, 
DWORD
 
dwYkTy
 )

929 
	`as
 ( 
pBusMsg
 !
NULL
 );

932 if1 !
pBusMsg
->
DaNum


933 || 
pBusMsg
->
DaL
 !(
YK_DATA
))

935 
	`tf
 ( "IEC101S Yk Msgrr\n" );

936  
FALSE
;

940 if
m_dwSdFg
 & 
IEC101S_YK_SEL
 ) == 0

941 && (
m_dwSdFg
 & 
IEC101S_YK_EXE
) == 0

942 && (
m_dwSdFg
 & 
IEC101S_YK_CANCEL
) == 0)

944 
	`tf
 ( "IEC101S None Yk Status\n" );

945 
	`SYkPam
( 0, 0, 0, 0, 0 );

946  
FALSE
;

950 
YK_DATA
 *
pDa
 = (YK_DATA *)
pBusMsg
->pData;

951 if!
	`IsYkPamTrue

m_byYKAsduTy
, 
m_byYkC
, 
pBusMsg
->
SrcInfo
.
wDevNo
, 
pDa
->
wP
,Da->
byV
 ) )

953 
	`tf
 ( "IEC101S MsgData isrr\n" );

954  
FALSE
;

957 if!
m_dwSdFg
 & 
dwYkTy
 ) )

959 
	`tf
 ( "IEC101S None Yk Status\n" );

960 
	`SYkPam
( 0, 0, 0, 0, 0 );

961  
FALSE
;

964  
TRUE
;

965 
	}
}

977 
BOOL
 
	gCIEC101S_2002
::
	$DlBusMsg
 ( 
PBUSMSG
 
pBusMsg
 )

979  
pBusMsg
->
byMsgTy
 )

981 
YK_PROTO
:

983  
pBusMsg
->
dwDaTy
 )

985 
YK_SEL_RTN
:

986 if
	`IsYkRBusMsgVid

pBusMsg
, 
IEC101S_YK_SEL
 ) )

988 
	`tf
 ( "IEC101S YK_SEL_RTN\n" );

989 
m_SdStus
 = 
YK_RTN_DATA
;

993 
YK_EXCT_RTN
:

994 if
	`IsYkRBusMsgVid

pBusMsg
, 
IEC101S_YK_EXE
 ) )

996 
	`tf
 ( "IEC101S YK_EXCT_RTN\n" );

997 
m_SdStus
 = 
YK_RTN_DATA
;

1001 
YK_CANCEL_RTN
:

1002 if
	`IsYkRBusMsgVid

pBusMsg
, 
IEC101S_YK_CANCEL
 ) )

1004 
	`tf
 ( "IEC101S YK_CANCEL_RTN\n" );

1005 
m_SdStus
 = 
YK_RTN_DATA
;

1010 
	`t
( "IEC101S:DealBusMsg can't findhe datatype" );

1011  
FALSE
;

1018 
	`t
( "IEC101S:DealBusMsg can't findhe msgtype" );

1019  
FALSE
;

1023  
TRUE
;

1024 
	}
}

1035 
	gCIEC101S_2002
::
	$Add68HdAndTa
 ( cڡ 
BYTE
 *
byAsduBuf
, 
iAsduL
, BYTE *
buf
 )

1038 if
iAsduL
 < 6 )

1043 
buf
[0] = 0x68;

1044 
buf
[1] = 
iAsduL
 + 2;

1045 
buf
[2] = 
iAsduL
 + 2;

1046 
buf
[3] = 0x68;

1047 i
	`IsHaveLev1Da
( ) )

1049 
buf
[4] = 0x28;

1053 
buf
[4] = 0x08;

1055 
buf
[5] = 
m_wDevAddr
;

1058 
	`memy

buf
+6, 
byAsduBuf
, 
iAsduL
 );

1061 
buf
[
iAsduL
 + 6] = 
	`GCs
( buf+4, iAsduLen + 2 );

1062 
buf
[
iAsduL
 + 7] = 0x16;

1064  
iAsduL
 + 8;

1065 
	}
}

1077 
BOOL
 
	gCIEC101S_2002
::
	$GLkStusBuf
 ( 
BYTE
 *
buf
, &
n
 )

1079 
n
 = 0;

1080 
buf
[
n
++] = 0x10;

1081 
buf
[
n
++] = 0x0b;

1082 
buf
[
n
++] = 
m_wDevAddr
;

1083 
buf
[
n
++] = 
	`GCs
( buf + 1, 2 );

1084 
buf
[
n
++] = 0x16;

1086  
TRUE
;

1087 
	}
}

1098 
BOOL
 
	gCIEC101S_2002
::
	$GRecڙiBuf
 ( 
BYTE
 *
buf
, &
n
 )

1100 
n
 = 0;

1101 
buf
[
n
++] = 0x10;

1102 i
	`IsHaveLev1Da
( ) )

1104 
buf
[
n
++] = 0x20;

1108 
buf
[
n
++] = 0x00;

1110 
buf
[
n
++] = 
m_wDevAddr
;

1111 
buf
[
n
++] = 
	`GCs
( buf + 1, 2 );

1112 
buf
[
n
++] = 0x16;

1114  
TRUE
;

1115 
	}
}

1126 
BOOL
 
	gCIEC101S_2002
::
	$GUrDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

1128  
	`GLev1Da

buf
, 
n
 );

1129 
	}
}

1141 
BOOL
 
	gCIEC101S_2002
::
	$GNeDaBuf
 ( 
BYTE
 *
buf
, &
n
 )

1143 
n
 = 0;

1144 
buf
[
n
++] = 0x10;

1145 
buf
[
n
++] = 0x09;

1146 
buf
[
n
++] = 
m_wDevAddr
;

1147 
buf
[
n
++] = 
	`GCs
( buf + 1, 2 );

1148 
buf
[
n
++] = 0x16;

1150  
TRUE
;

1151 
	}
}

1162 
BOOL
 
	gCIEC101S_2002
::
	$GTٮClRecoBuf
 ( 
BYTE
 *
buf
, &
n
, BYTE 
byC
 )

1164 
	`t
( "ȷ֡" );

1165 
BYTE
 
byAsduBuf
[256];

1166 
iAsduL
 = 0;

1168 
byAsduBuf
[
iAsduL
++] = 0x64;

1169 
byAsduBuf
[
iAsduL
++] = 0x01;

1172 
byAsduBuf
[
iAsduL
++] = 
byC
;

1173 if2 =
m_byCL
 )

1175 
byAsduBuf
[
iAsduL
++] = 0x00;

1179 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1180 i2 =
m_byAddrL
 )

1182 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1186 
byAsduBuf
[
iAsduL
++] = 0x00;

1187 
byAsduBuf
[
iAsduL
++] = 0x00;

1188 i3 =
m_byInfoAddrL
 )

1190 
byAsduBuf
[
iAsduL
++] = 0x00;

1194 
byAsduBuf
[
iAsduL
++] = 0x14;

1196 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

1197 if(
n
 <= 0)

1199  
FALSE
;

1202  
TRUE
;

1203 
	}
}

1214 
BOOL
 
	gCIEC101S_2002
::
	$GClYmRecoBuf
 ( 
BYTE
 *
buf
, &
n
, BYTE 
byC
 )

1216 
BYTE
 
byAsduBuf
[256];

1217 
iAsduL
 = 0;

1219 
byAsduBuf
[
iAsduL
++] = 0x65;

1220 
byAsduBuf
[
iAsduL
++] = 0x01;

1223 
byAsduBuf
[
iAsduL
++] = 
byC
;

1224 if2 =
m_byCL
 )

1226 
byAsduBuf
[
iAsduL
++] = 0x00;

1230 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1231 i2 =
m_byAddrL
 )

1233 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1237 
byAsduBuf
[
iAsduL
++] = 0x00;

1238 
byAsduBuf
[
iAsduL
++] = 0x00;

1239 i3 =
m_byInfoAddrL
 )

1241 
byAsduBuf
[
iAsduL
++] = 0x00;

1245 
byAsduBuf
[
iAsduL
++] = 0x05;

1247 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

1248 if(
n
 <= 0)

1250  
FALSE
;

1253  
TRUE
;

1254 
	}
}

1265 
BOOL
 
	gCIEC101S_2002
::
	$GTimeSyncRecoBuf
 ( 
BYTE
 *
buf
, &
n
, BYTE 
byC
 )

1267 
BYTE
 
byAsduBuf
[256];

1268 
iAsduL
 = 0;

1270 
byAsduBuf
[
iAsduL
++] = 0x67;

1271 
byAsduBuf
[
iAsduL
++] = 0x01;

1274 
byAsduBuf
[
iAsduL
++] = 
byC
;

1275 if2 =
m_byCL
 )

1277 
byAsduBuf
[
iAsduL
++] = 0x00;

1281 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1282 i2 =
m_byAddrL
 )

1284 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1288 
byAsduBuf
[
iAsduL
++] = 0x00;

1289 
byAsduBuf
[
iAsduL
++] = 0x00;

1290 i3 =
m_byInfoAddrL
 )

1292 
byAsduBuf
[
iAsduL
++] = 0x00;

1296 
CP56TIME2A
 
t
;

1297 
	`GCp56Time2a
&
t
 );

1299 
byAsduBuf
[
iAsduL
++] = 
t
.
byLoMis
;

1300 
byAsduBuf
[
iAsduL
++] = 
t
.
byHiMis
;

1301 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

1302 
byAsduBuf
[
iAsduL
++] = 
t
.
byHour
;

1303 
byAsduBuf
[
iAsduL
++] = 
t
.
byDay
;

1304 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

1305 
byAsduBuf
[
iAsduL
++] = 
t
.
byYr
;

1307 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

1308 if(
n
 <= 0)

1310  
FALSE
;

1313  
TRUE
;

1314 
	}
}

1326 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NA_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

1328 
BYTE
 
byAsduBuf
[256];

1329 
iAsduL
 = 0;

1331 
byAsduBuf
[
iAsduL
++] = 0x09;

1332 
byAsduBuf
[
iAsduL
++] = 0x81;

1335 
byAsduBuf
[
iAsduL
++] = 0x14;

1336 if2 =
m_byCL
 )

1338 
byAsduBuf
[
iAsduL
++] = 0x00;

1342 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1343 i2 =
m_byAddrL
 )

1345 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1350 
WORD
 
wP
 = 
m_wDaIndex
 + 
m_wYcSAddr
;

1351 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

1352 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

1353 i3 =
m_byInfoAddrL
 )

1355 
byAsduBuf
[
iAsduL
++] = 0x00;

1359 
BYTE
 
byCou
 = 0;

1360  
i
=
m_wDaIndex
; i<
m_wAISum
; i++)

1362 
BYTE
 
byQds
 = 0;

1363 
fV
 = 
m_fYcBuf
[
i
];

1364 if
m_pAIMTab
[
i
].
wS
>0 && m_pAIMTab[i].
wPNum
>0 )

1365 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
i
].
wS
, m_pAIMTab[i].
wPNum
, 
m_fYcBuf
[i]);

1367 
sV
 = ( )
fV
;

1368 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
sV
);

1369 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
sV
);

1372 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YC_TRANSTOSERIALNO
 , 
i
 ) ;

1373 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

1374 if
bDevS
 =
COM_DEV_ABNORMAL
 )

1376 
byQds
 |= 0xC0 ;

1378 
byAsduBuf
[
iAsduL
++] = 
byQds
;

1380 
byCou
 ++;

1382 i
byCou
 > 40 )

1387 
byAsduBuf
[1] = 0x80 | 
byCou
;

1390 
m_wDaIndex
 +
byCou
;

1391 i
m_wDaIndex
 >
m_wAISum
 )

1393 
m_dwSdFg
 &~
IEC101S_TOTAL_YC
;

1394 
m_wDaIndex
 = 0;

1398 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

1399 if(
n
 <= 0)

1401  
FALSE
;

1404  
TRUE
;

1405 
	}
}

1417 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NA_1_ChgeFme
 ( 
BYTE
 *
buf
, &
n
 )

1419 
BYTE
 
byAsduBuf
[256];

1420 
iAsduL
 = 0;

1422 
byAsduBuf
[
iAsduL
++] = 0x09;

1423 
byAsduBuf
[
iAsduL
++] = 0x01;

1426 
byAsduBuf
[
iAsduL
++] = 0x03;

1427 if2 =
m_byCL
 )

1429 
byAsduBuf
[
iAsduL
++] = 0x00;

1433 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1434 i2 =
m_byAddrL
 )

1436 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1440 
BYTE
 
byCou
 = 0;

1441 
iSize
 = 
m_dwAIEQueue
.
	`size
();

1442  
i
=0; i<
iSize
; i++)

1445 
WORD
 
wSlNo
;

1446 
WORD
 
wNum
;

1447 
WORD
 
wV
;

1448 
fV
;

1449 if!
	`GAlogEvt

wSlNo
, 
wNum
, 
fV
 ) )

1453 
wV
 = (
WORD
)
fV
;

1456 
WORD
 
wP
 = 
wNum
 + 
m_wYcSAddr
;

1457 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

1458 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

1459 i3 =
m_byInfoAddrL
 )

1461 
byAsduBuf
[
iAsduL
++] = 0x00;

1465 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wV
);

1466 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
wV
);

1469 
BYTE
 
byQds
 = 0;

1471 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

1472 if
bDevS
 =
COM_DEV_ABNORMAL
 )

1474 
byQds
 |= 0xC0 ;

1476 
byAsduBuf
[
iAsduL
++] = 
byQds
;

1478 
byCou
 ++;

1480 i
byCou
 > 40 )

1485 
byAsduBuf
[1] = 
byCou
;

1488 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

1489 if(
n
 <= 0)

1491  
FALSE
;

1494  
TRUE
;

1495 
	}
}

1507 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NA_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

1509 if
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

1511  
	`G_M_ME_NA_1_TٮFme

buf
, 
n
 );

1514 if
IEC101S_2002_CHANGE_TYPE
 =
iFg
 )

1516  
	`G_M_ME_NA_1_ChgeFme

buf
, 
n
 );

1519  
FALSE
;

1520 
	}
}

1532 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TA_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

1534 
	`t
( "δ֯ASDU 10 M_ME_TA_1 ͻ" );

1535  
FALSE
;

1536 
	}
}

1548 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TA_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

1550 if
IEC101S_2002_SOE_TYPE
 =
iFg
 )

1552  
	`G_M_ME_TA_1_SFme

buf
, 
n
 );

1555  
FALSE
;

1556 
	}
}

1568 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NB_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

1570 
BYTE
 
byAsduBuf
[256];

1571 
iAsduL
 = 0;

1573 
byAsduBuf
[
iAsduL
++] = 0x0b;

1574 
byAsduBuf
[
iAsduL
++] = 0x81;

1577 
byAsduBuf
[
iAsduL
++] = 0x14;

1578 if2 =
m_byCL
 )

1580 
byAsduBuf
[
iAsduL
++] = 0x00;

1584 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1585 i2 =
m_byAddrL
 )

1587 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1592 
WORD
 
wP
 = 
m_wDaIndex
 + 
m_wYcSAddr
;

1593 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

1594 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

1595 i3 =
m_byInfoAddrL
 )

1597 
byAsduBuf
[
iAsduL
++] = 0x00;

1601 
BYTE
 
byCou
 = 0;

1602  
i
=
m_wDaIndex
; i<
m_wAISum
; i++)

1604 
BYTE
 
byQds
 = 0;

1605 
fV
 = 
m_fYcBuf
[
i
];

1606 if
m_pAIMTab
[
i
].
wS
>0 && m_pAIMTab[i].
wPNum
>0 )

1607 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
i
].
wS
, m_pAIMTab[i].
wPNum
, 
m_fYcBuf
[i]);

1609 
sV
 = ()
fV
;

1610 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
sV
);

1611 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
sV
);

1614 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YC_TRANSTOSERIALNO
 , 
i
 ) ;

1615 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

1616 if
bDevS
 =
COM_DEV_ABNORMAL
 )

1618 
byQds
 |= 0xC0 ;

1620 
byAsduBuf
[
iAsduL
++] = 
byQds
;

1622 
byCou
 ++;

1624 i
byCou
 > 40 )

1629 
byAsduBuf
[1] = 0x80 | 
byCou
;

1632 
m_wDaIndex
 +
byCou
;

1633 i
m_wDaIndex
 >
m_wAISum
 )

1635 
m_dwSdFg
 &~
IEC101S_TOTAL_YC
;

1636 
m_wDaIndex
 = 0;

1640 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

1641 if(
n
 <= 0)

1643  
FALSE
;

1646  
TRUE
;

1647 
	}
}

1659 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NB_1_ChgeFme
 ( 
BYTE
 *
buf
, &
n
 )

1661 
BYTE
 
byAsduBuf
[256];

1662 
iAsduL
 = 0;

1664 
byAsduBuf
[
iAsduL
++] = 0x0b;

1665 
byAsduBuf
[
iAsduL
++] = 0x01;

1668 
byAsduBuf
[
iAsduL
++] = 0x03;

1669 if2 =
m_byCL
 )

1671 
byAsduBuf
[
iAsduL
++] = 0x00;

1675 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1676 i2 =
m_byAddrL
 )

1678 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1682 
BYTE
 
byCou
 = 0;

1683 
iSize
 = 
m_dwAIEQueue
.
	`size
();

1684  
i
=0; i<
iSize
; i++)

1687 
WORD
 
wSlNo
;

1688 
WORD
 
wNum
;

1689 
WORD
 
wV
;

1690 
fV
;

1691 if!
	`GAlogEvt

wSlNo
, 
wNum
, 
fV
 ) )

1695 
wV
 = (
WORD
)
fV
;

1698 
WORD
 
wP
 = 
wNum
 + 
m_wYcSAddr
;

1699 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

1700 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

1701 i3 =
m_byInfoAddrL
 )

1703 
byAsduBuf
[
iAsduL
++] = 0x00;

1707 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wV
);

1708 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
wV
);

1711 
BYTE
 
byQds
 = 0;

1713 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

1714 if
bDevS
 =
COM_DEV_ABNORMAL
 )

1716 
byQds
 |= 0xC0 ;

1718 
byAsduBuf
[
iAsduL
++] = 
byQds
;

1720 
byCou
 ++;

1722 i
byCou
 > 40 )

1727 
byAsduBuf
[1] = 
byCou
;

1731 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

1732 if(
n
 <= 0)

1734  
FALSE
;

1737  
TRUE
;

1738 
	}
}

1750 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NB_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

1752 if
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

1754  
	`G_M_ME_NB_1_TٮFme

buf
, 
n
 );

1757 if
IEC101S_2002_CHANGE_TYPE
 =
iFg
 )

1759  
	`G_M_ME_NB_1_ChgeFme
(
buf
, 
n
);

1762  
FALSE
;

1763 
	}
}

1775 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TB_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

1777 
	`t
( "not organize M_ME_TB_1 ASDU12" );

1778  
FALSE
;

1779 
	}
}

1791 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TB_1_Fme
 ( 
BYTE
 *
buf
, &
n
 , 
iFg
 )

1793 if
IEC101S_2002_SOE_TYPE
 =
iFg
 )

1795  
	`G_M_ME_TB_1_SFme

buf
, 
n
 );

1798  
FALSE
;

1799 
	}
}

1811 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NC_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

1813 
BYTE
 
byAsduBuf
[256];

1814 
iAsduL
 = 0;

1816 
byAsduBuf
[
iAsduL
++] = 0x0d;

1817 
byAsduBuf
[
iAsduL
++] = 0x81;

1820 
byAsduBuf
[
iAsduL
++] = 0x14;

1821 if2 =
m_byCL
 )

1823 
byAsduBuf
[
iAsduL
++] = 0x00;

1827 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1828 i2 =
m_byAddrL
 )

1830 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1835 
WORD
 
wP
 = 
m_wDaIndex
 + 
m_wYcSAddr
;

1836 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

1837 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

1838 i3 =
m_byInfoAddrL
 )

1840 
byAsduBuf
[
iAsduL
++] = 0x00;

1844 
BYTE
 
byCou
 = 0;

1845  
i
=
m_wDaIndex
; i<
m_wAISum
; i++)

1848 
fV
 = 
m_fYcBuf
[
i
];

1849 if
m_pAIMTab
[
i
].
wS
>0 && m_pAIMTab[i].
wPNum
>0 )

1851 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
i
].
wS
, m_pAIMTab[i].
wPNum
, ()
m_fYcBuf
[i]);

1855 
BYTE
 
byBufr
[ 4 ] ;

1856 
BYTE
 
byBufr1
[ 4 ] ;

1857 
	`memy

byBufr
 , &
fV
 , 4 ) ;

1858 
	`GlobCyByEndn
(
byBufr1
,
byBufr
,4);

1864 
	`memy
(&
byAsduBuf
[
iAsduL
], 
byBufr1
, 4);

1865 
iAsduL
 += 4;

1868 
BYTE
 
byQds
 = 0;

1870 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YC_TRANSTOSERIALNO
 , 
i
 ) ;

1871 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

1872 if
bDevS
 =
COM_DEV_ABNORMAL
 )

1874 
byQds
 |= 0xC0 ;

1876 
byAsduBuf
[
iAsduL
++] = 
byQds
;

1878 
byCou
 ++;

1880 i
byCou
 > 40 )

1885 
byAsduBuf
[1] = 0x80 | 
byCou
;

1888 
m_wDaIndex
 +
byCou
;

1889 i
m_wDaIndex
 >
m_wAISum
 )

1891 
m_dwSdFg
 &~
IEC101S_TOTAL_YC
;

1892 
m_wDaIndex
 = 0;

1896 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

1897 if(
n
 <= 0)

1899  
FALSE
;

1902  
TRUE
;

1903 
	}
}

1915 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NC_1_ChgeFme
 ( 
BYTE
 *
buf
, &
n
 )

1917 
BYTE
 
byAsduBuf
[256];

1918 
iAsduL
 = 0;

1920 
byAsduBuf
[
iAsduL
++] = 0x0d;

1921 
byAsduBuf
[
iAsduL
++] = 0x01;

1924 
byAsduBuf
[
iAsduL
++] = 0x03;

1925 if2 =
m_byCL
 )

1927 
byAsduBuf
[
iAsduL
++] = 0x00;

1931 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

1932 i2 =
m_byAddrL
 )

1934 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

1938 
BYTE
 
byCou
 = 0;

1939 
iSize
 = 
m_dwAIEQueue
.
	`size
();

1940  
i
=0; i<
iSize
; i++)

1943 
WORD
 
wSlNo
;

1944 
WORD
 
wNum
;

1946 
fYcV
;

1947 if!
	`GAlogEvt

wSlNo
, 
wNum
, 
fYcV
 ) )

1953 
WORD
 
wP
 = 
wNum
 + 
m_wYcSAddr
;

1954 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

1955 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

1956 i3 =
m_byInfoAddrL
 )

1958 
byAsduBuf
[
iAsduL
++] = 0x00;

1962 
fV
 = 
fYcV
;

1963 
BYTE
 
byBufr1
[4];

1964 
BYTE
 
byBufr
[4];

1965 if
m_pAIMTab
[
wNum
].
wS
>0 &&

1966 
m_pAIMTab
[
wNum
].
wPNum
>0 )

1968 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
wNum
].
wS
-1,

1969 
m_pAIMTab
[
wNum
].
wPNum
-1,

1970 
fV
);

1971 
	`memy

byBufr
 , &
fV
 , 4 ) ;

1972 
	`GlobCyByEndn
(
byBufr1
,
byBufr
,4);

1978 
	`memy
(&
byAsduBuf
[
iAsduL
], &
byBufr1
, 4);

1979 
iAsduL
 += 4;

1982 
BYTE
 
byQds
 = 0;

1984 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

1985 if
bDevS
 =
COM_DEV_ABNORMAL
 )

1987 
byQds
 |= 0xC0 ;

1989 
byAsduBuf
[
iAsduL
++] = 
byQds
;

1991 
byCou
 ++;

1993 i
byCou
 > 40 )

1998 
byAsduBuf
[1] = 
byCou
;

2002 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2003 if(
n
 <= 0)

2005  
FALSE
;

2008  
TRUE
;

2009 
	}
}

2021 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_NC_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2023 if
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

2025  
	`G_M_ME_NC_1_TٮFme

buf
, 
n
 );

2028 if
IEC101S_2002_CHANGE_TYPE
 =
iFg
 )

2030  
	`G_M_ME_NC_1_ChgeFme

buf
, 
n
 );

2033  
FALSE
;

2034 
	}
}

2046 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TC_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

2048 
	`t
( "not organize M_ME_TC_1 ASDU14 soeFrame" );

2049  
FALSE
;

2050 
	}
}

2062 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TC_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2064 i
IEC101S_2002_SOE_TYPE
 =
iFg
 )

2066  
	`G_M_ME_TC_1_SFme

buf
, 
n
 );

2069  
FALSE
;

2070 
	}
}

2081 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_ND_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

2083 
BYTE
 
byAsduBuf
[256];

2084 
iAsduL
 = 0;

2086 
byAsduBuf
[
iAsduL
++] = 0x15;

2087 
byAsduBuf
[
iAsduL
++] = 0x81;

2090 
byAsduBuf
[
iAsduL
++] = 0x14;

2091 if2 =
m_byCL
 )

2093 
byAsduBuf
[
iAsduL
++] = 0x00;

2097 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

2098 i2 =
m_byAddrL
 )

2100 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

2105 
WORD
 
wP
 = 
m_wDaIndex
 + 
m_wYcSAddr
;

2106 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

2107 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

2108 i3 =
m_byInfoAddrL
 )

2110 
byAsduBuf
[
iAsduL
++] = 0x00;

2114 
BYTE
 
byCou
 = 0;

2115  
i
=
m_wDaIndex
; i<
m_wAISum
; i++)

2117 
fV
 = 
m_fYcBuf
[
i
];

2118 if
m_pAIMTab
[
i
].
wS
>0 && m_pAIMTab[i].
wPNum
>0 )

2119 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
i
].
wS
, m_pAIMTab[i].
wPNum
, 
m_fYcBuf
[i]);

2121 
sV
 = ( )
fV
;

2122 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
sV
);

2123 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
sV
);

2125 
byCou
 ++;

2127 i
byCou
 > 40 )

2132 
byAsduBuf
[1] = 0x80 | 
byCou
;

2135 
m_wDaIndex
 +
byCou
;

2136 i
m_wDaIndex
 >
m_wAISum
 )

2138 
m_dwSdFg
 &~
IEC101S_TOTAL_YC
;

2139 
m_wDaIndex
 = 0;

2143 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2144 if(
n
 <= 0)

2146  
FALSE
;

2149  
TRUE
;

2150 
	}
}

2161 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_ND_1_ChgeFme
 ( 
BYTE
 *
buf
, &
n
 )

2163 
BYTE
 
byAsduBuf
[256];

2164 
iAsduL
 = 0;

2166 
byAsduBuf
[
iAsduL
++] = 0x15;

2167 
byAsduBuf
[
iAsduL
++] = 0x01;

2170 
byAsduBuf
[
iAsduL
++] = 0x03;

2171 if2 =
m_byCL
 )

2173 
byAsduBuf
[
iAsduL
++] = 0x00;

2177 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

2178 i2 =
m_byAddrL
 )

2180 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

2184 
BYTE
 
byCou
 = 0;

2185 
iSize
 = 
m_dwAIEQueue
.
	`size
();

2186  
i
=0; i<
iSize
; i++)

2189 
WORD
 
wSlNo
;

2190 
WORD
 
wNum
;

2191 
WORD
 
wV
;

2192 
fV
;

2193 if!
	`GAlogEvt

wSlNo
, 
wNum
, 
fV
 ) )

2197 
wV
 = (
WORD
)
fV
;

2200 
WORD
 
wP
 = 
wNum
 + 
m_wYcSAddr
;

2201 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

2202 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

2203 i3 =
m_byInfoAddrL
 )

2205 
byAsduBuf
[
iAsduL
++] = 0x00;

2209 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wV
);

2210 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
wV
);

2212 
byCou
 ++;

2214 i
byCou
 > 40 )

2219 
byAsduBuf
[1] = 
byCou
;

2222 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2223 if(
n
 <= 0)

2225  
FALSE
;

2228  
TRUE
;

2229 
	}
}

2240 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_ND_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2242 if
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

2244  
	`G_M_ME_ND_1_TٮFme

buf
, 
n
 );

2247 if
IEC101S_2002_CHANGE_TYPE
 =
iFg
 )

2249  
	`G_M_ME_ND_1_ChgeFme

buf
, 
n
 );

2252  
FALSE
;

2253 
	}
}

2265 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TD_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

2267 
	`t
( "not organize M_ME_TD_1 ASDU34 SoeFrame" );

2268  
FALSE
;

2269 
	}
}

2281 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TD_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2283 i
IEC101S_2002_SOE_TYPE
 =
iFg
 )

2285  
	`G_M_ME_TD_1_SFme

buf
, 
n
 );

2288  
FALSE
;

2289 
	}
}

2301 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TE_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

2303 
	`t
( "not organize M_ME_TE_1 ASDU35 SoeFrame" );

2305  
FALSE
;

2306 
	}
}

2317 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TE_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2319 i
IEC101S_2002_SOE_TYPE
 =
iFg
 )

2321  
	`G_M_ME_TE_1_SFme

buf
, 
n
 );

2324  
FALSE
;

2325 
	}
}

2336 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TF_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

2338 
	`t
( "not organize M_ME_TE_1 ASDU36 SoeFrame" );

2340  
FALSE
;

2341 
	}
}

2352 
BOOL
 
	gCIEC101S_2002
::
	$G_M_ME_TF_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2354 i
IEC101S_2002_SOE_TYPE
 =
iFg
 )

2356  
	`G_M_ME_TF_1_SFme

buf
, 
n
 );

2359  
FALSE
;

2360 
	}
}

2372 
BOOL
 
	gCIEC101S_2002
::
	$G_M_SP_NA_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

2374 
BYTE
 
byAsduBuf
[256];

2375 
iAsduL
 = 0;

2377 
byAsduBuf
[
iAsduL
++] = 0x01;

2378 
byAsduBuf
[
iAsduL
++] = 0x81;

2381 
byAsduBuf
[
iAsduL
++] = 0x14;

2382 if2 =
m_byCL
 )

2384 
byAsduBuf
[
iAsduL
++] = 0x00;

2388 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

2389 i2 =
m_byAddrL
 )

2391 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

2395 
WORD
 
wP
;

2396 
wP
 = 
m_wDaIndex
 + 
m_wYxSAddr
;

2397 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

2398 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

2399 i3 =
m_byInfoAddrL
 )

2401 
byAsduBuf
[
iAsduL
++] = 0x00;

2405 
BYTE
 
byCou
 = 0;

2406 
i
=
m_wDaIndex
; i<
m_wDISum
; i++)

2408 
WORD
 
wV
;

2410 
	`GRlV
(1, (
WORD
)
i
, &
wV
);

2411 
BYTE
 
bySiq
 = 0 ;

2413 if
wV
 )

2414 
bySiq
 = 1 ;

2416 
bySiq
 = 0 ;

2419 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YX_TRANSTOSERIALNO
 , 
i
 ) ;

2420 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

2421 if
bDevS
 =
COM_DEV_ABNORMAL
 )

2423 
bySiq
 |= 0xC0 ;

2427 
byAsduBuf
[
iAsduL
++] = 
bySiq
 ;

2430 
byCou
++;

2431 i
byCou
 >= 127 )

2437 
byAsduBuf
[1] = 0x80 | 
byCou
;

2440 
m_wDaIndex
 +
byCou
;

2442 i
m_wDaIndex
 >
m_wDISum
 )

2444 
m_dwSdFg
 &~
IEC101S_TOTAL_YX
;

2445 
m_wDaIndex
 = 0;

2449 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2450 if(
n
 <= 0)

2452  
FALSE
;

2455  
TRUE
;

2456 
	}
}

2467 
BOOL
 
	gCIEC101S_2002
::
	$G_M_SP_NA_1_ChgeFme
 ( 
BYTE
 *
buf
, &
n
 )

2469 
BYTE
 
byAsduBuf
[256];

2470 
iAsduL
 = 0;

2472 
byAsduBuf
[
iAsduL
++] = 0x01;

2473 
byAsduBuf
[
iAsduL
++] = 0x01;

2476 
byAsduBuf
[
iAsduL
++] = 0x03;

2477 if2 =
m_byCL
 )

2479 
byAsduBuf
[
iAsduL
++] = 0x00;

2483 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

2484 i2 =
m_byAddrL
 )

2486 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

2490 
BYTE
 
byCou
 = 0;

2491 
iSize
 = 
m_dwDIEQueue
.
	`size
();

2492 
i
=0; i<
iSize
; i++)

2494 
WORD
 
wSlNo
;

2495 
WORD
 
wP
;

2496 
WORD
 
wV
;

2497 if(!
	`GDigEvt

wSlNo
 , 
wP
, 
wV
 ))

2503 
wP
 +
m_wYxSAddr
;

2504 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

2505 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

2506 i3 =
m_byInfoAddrL
 )

2508 
byAsduBuf
[
iAsduL
++] = 0x00;

2512 
BYTE
 
bySiq
 = 0;

2513 i
wV
 & 0x01 )

2515 
bySiq
 = 0x01 ;

2519 
bySiq
 = 0 ;

2521 
BOOL
 
bDevS
 = 
FALSE
 ;

2522 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

2523 if
bDevS
 =
COM_DEV_ABNORMAL
 )

2525 
bySiq
 |= 0xC0 ;

2527 
byAsduBuf
[
iAsduL
++] = 
bySiq
;

2530 
byCou
++;

2531 i
byCou
 > 20 )

2536 
byAsduBuf
[1] = 
byCou
;

2539 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2540 if(
n
 <= 0)

2542  
FALSE
;

2545  
TRUE
;

2546 
	}
}

2558 
BOOL
 
	gCIEC101S_2002
::
	$G_M_SP_NA_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2561 if
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

2563  
	`G_M_SP_NA_1_TٮFme

buf
, 
n
 );

2566 if
IEC101S_2002_CHANGE_TYPE
 =
iFg
 )

2568  
	`G_M_SP_NA_1_ChgeFme

buf
, 
n
 );

2571  
FALSE
;

2572 
	}
}

2584 
BOOL
 
	gCIEC101S_2002
::
	$G_M_SP_TA_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

2586 
BYTE
 
byAsduBuf
[256];

2587 
iAsduL
 = 0;

2589 
byAsduBuf
[
iAsduL
++] = 0x02;

2590 
byAsduBuf
[
iAsduL
++] = 0x01;

2593 
byAsduBuf
[
iAsduL
++] = 0x03;

2594 if2 =
m_byCL
 )

2596 
byAsduBuf
[
iAsduL
++] = 0x00;

2600 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

2601 i2 =
m_byAddrL
 )

2603 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

2607 
BYTE
 
byCou
 = 0;

2608 
m_iSOE_rd_p
 !
m_iSOE_wr_p
)

2610 
WORD
 
wSlNo
;

2611 
WORD
 
wP
;

2612 
WORD
 
wV
;

2613 
tm
 
tmSu
;

2614 
WORD
 
wMiSecd
;

2615 
WORD
 
wTime
;

2617 
	`GSOEInfo

wSlNo
 , &
wP
, &
wV
, &
tmSu
, &
wMiSecd
 );

2620 
wP
 +
m_wYxSAddr
;

2621 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

2622 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

2623 i3 =
m_byInfoAddrL
 )

2625 
byAsduBuf
[
iAsduL
++] = 0x00;

2629 
wV
 = wVal & 0x0001;

2630 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wV
);

2633 
wTime
 = 
tmSu
.
tm_c
*1000 + 
wMiSecd
;

2634 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wTime
);

2635 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
wTime
);

2636 
byAsduBuf
[
iAsduL
++] = (
BYTE
)
tmSu
.
tm_m
;

2639 
byCou
++;

2640 if
byCou
 > 20 )

2645 
byAsduBuf
[1] = 
byCou
;

2648 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2649 if(
n
 <= 0)

2651  
FALSE
;

2654  
TRUE
;

2655 
	}
}

2666 
BOOL
 
	gCIEC101S_2002
::
	$G_M_SP_TA_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2668 if
IEC101S_2002_SOE_TYPE
 =
iFg
)

2670  
	`G_M_SP_TA_1_SFme

buf
, 
n
 );

2673  
FALSE
;

2674 
	}
}

2685 
BOOL
 
	gCIEC101S_2002
::
	$G_M_DP_NA_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

2687 
BYTE
 
byAsduBuf
[256];

2688 
iAsduL
 = 0;

2689 
WORD
 
wP
;

2690 
BYTE
 
byCou
 = 0;

2692 
byAsduBuf
[
iAsduL
++] = 0x03;

2693 
byAsduBuf
[
iAsduL
++] = 0x81;

2696 
byAsduBuf
[
iAsduL
++] = 0x14;

2697 if2 =
m_byCL
 )

2699 
byAsduBuf
[
iAsduL
++] = 0x00;

2703 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

2704 i2 =
m_byAddrL
 )

2706 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

2710 
wP
 = 
m_wDaIndex
 + 
m_wYxSAddr
;

2711 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

2712 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

2713 i3 =
m_byInfoAddrL
 )

2715 
byAsduBuf
[
iAsduL
++] = 0x00;

2719 
i
=
m_wDaIndex
; i<
m_wDISum
; i++)

2721 
WORD
 
wV
;

2723 
	`GRlV
(1, (
WORD
)
i
, &
wV
);

2724 
BYTE
 
bySiq
 = 0 ;

2726 if
wV
 )

2727 
bySiq
 = 2 ;

2729 
bySiq
 = 1 ;

2732 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

YX_TRANSTOSERIALNO
 , 
i
 ) ;

2733 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

2734 if
bDevS
 =
COM_DEV_ABNORMAL
 )

2736 
bySiq
 |= 0xC0 ;

2740 
byAsduBuf
[
iAsduL
++] = 
bySiq
 ;

2743 
byCou
++;

2744 i
byCou
 >= 127 )

2750 
byAsduBuf
[1] = 0x80 | 
byCou
;

2753 
m_wDaIndex
 +
byCou
;

2754 i
m_wDaIndex
 >
m_wDISum
 )

2756 
m_dwSdFg
 &~
IEC101S_TOTAL_YX
;

2757 
m_wDaIndex
 = 0;

2761 
m_wDaIndex
 +
byCou
;

2762 i
m_wDaIndex
 >
m_wDISum
 )

2764 
m_dwSdFg
 &~
IEC101S_TOTAL_YX
;

2765 
m_wDaIndex
 = 0;

2769 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2770 if(
n
 <= 0)

2772  
FALSE
;

2774  
TRUE
;

2775 
	}
}

2786 
BOOL
 
	gCIEC101S_2002
::
	$G_M_DP_NA_1_ChgeFme
 ( 
BYTE
 *
buf
, &
n
 )

2788 
BYTE
 
byAsduBuf
[256];

2789 
iAsduL
 = 0;

2791 
byAsduBuf
[
iAsduL
++] = 0x03;

2792 
byAsduBuf
[
iAsduL
++] = 0x01;

2795 
byAsduBuf
[
iAsduL
++] = 0x03;

2796 if2 =
m_byCL
 )

2798 
byAsduBuf
[
iAsduL
++] = 0x00;

2802 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

2803 i2 =
m_byAddrL
 )

2805 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

2809 
BYTE
 
byCou
 = 0;

2810 
iSize
 = 
m_dwDIEQueue
.
	`size
();

2811 
i
=0; i<
iSize
; i++)

2813 
WORD
 
wSlNo
;

2814 
WORD
 
wP
;

2815 
WORD
 
wV
;

2816 if(!
	`GDigEvt

wSlNo
 , 
wP
, 
wV
 ))

2822 
wP
 +
m_wYxSAddr
;

2823 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

2824 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

2825 i3 =
m_byInfoAddrL
 )

2827 
byAsduBuf
[
iAsduL
++] = 0x00;

2831 
BYTE
 
byDiq
 = 0;

2832 i
wV
 & 0x01 )

2834 
byDiq
 = 0x02 ;

2838 
byDiq
 = 0x01 ;

2840 
BOOL
 
bDevS
 = 
FALSE
 ;

2841 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

2842 if
bDevS
 =
COM_DEV_ABNORMAL
 )

2844 
byDiq
 |= 0xC0 ;

2846 
byAsduBuf
[
iAsduL
++] = 
byDiq
;

2849 
byCou
++;

2850 i
byCou
 > 20 )

2855 
byAsduBuf
[1] = 
byCou
;

2858 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2859 if(
n
 <= 0)

2861  
FALSE
;

2864  
TRUE
;

2865 
	}
}

2876 
BOOL
 
	gCIEC101S_2002
::
	$G_M_DP_NA_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2878 if
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

2880  
	`G_M_DP_NA_1_TٮFme

buf
, 
n
 );

2883 if
IEC101S_2002_CHANGE_TYPE
 =
iFg
 )

2885  
	`G_M_DP_NA_1_ChgeFme

buf
, 
n
 );

2888  
FALSE
;

2889 
	}
}

2900 
BOOL
 
	gCIEC101S_2002
::
	$G_M_DP_TA_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

2902 
BYTE
 
byAsduBuf
[256];

2903 
iAsduL
 = 0;

2905 
byAsduBuf
[
iAsduL
++] = 0x04;

2906 
byAsduBuf
[
iAsduL
++] = 0x01;

2909 
byAsduBuf
[
iAsduL
++] = 0x03;

2910 if2 =
m_byCL
 )

2912 
byAsduBuf
[
iAsduL
++] = 0x00;

2916 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

2917 i2 =
m_byAddrL
 )

2919 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

2923 
BYTE
 
byCou
 = 0;

2924 
m_iSOE_rd_p
 !
m_iSOE_wr_p
)

2926 
WORD
 
wSlNo
;

2927 
WORD
 
wP
;

2928 
WORD
 
wV
;

2929 
tm
 
tmSu
;

2930 
WORD
 
wMiSecd
;

2931 
WORD
 
wTime
;

2933 
	`GSOEInfo

wSlNo
 , &
wP
, &
wV
, &
tmSu
, &
wMiSecd
 );

2936 
wP
 +
m_wYxSAddr
;

2937 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

2938 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

2939 i3 =
m_byInfoAddrL
 )

2941 
byAsduBuf
[
iAsduL
++] = 0x00;

2945 
wV
 = wVal & 0x0001;

2946 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wV
) + 1;

2949 
wTime
 = 
tmSu
.
tm_c
*1000 + 
wMiSecd
;

2950 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wTime
);

2951 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
wTime
);

2952 
byAsduBuf
[
iAsduL
++] = (
BYTE
)
tmSu
.
tm_m
;

2955 
byCou
++;

2956 if
byCou
 > 20 )

2961 
byAsduBuf
[1] = 
byCou
;

2965 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

2966 if(
n
 <= 0)

2968  
FALSE
;

2971  
TRUE
;

2972 
	}
}

2984 
BOOL
 
	gCIEC101S_2002
::
	$G_M_DP_TA_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

2986 if
IEC101S_2002_SOE_TYPE
 =
iFg
 )

2988  
	`G_M_DP_TA_1_SFme

buf
, 
n
 );

2991  
FALSE
;

2992 
	}
}

3003 
BOOL
 
	gCIEC101S_2002
::
	$G_M_SP_TB_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

3005 
BYTE
 
byAsduBuf
[256];

3006 
iAsduL
 = 0;

3008 
byAsduBuf
[
iAsduL
++] = 0x1e;

3009 
byAsduBuf
[
iAsduL
++] = 0x01;

3012 
byAsduBuf
[
iAsduL
++] = 0x03;

3013 if2 =
m_byCL
 )

3015 
byAsduBuf
[
iAsduL
++] = 0x00;

3019 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3020 i2 =
m_byAddrL
 )

3022 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3026 
BYTE
 
byCou
 = 0;

3027 
m_iSOE_rd_p
 !
m_iSOE_wr_p
)

3029 
WORD
 
wSlNo
;

3030 
WORD
 
wP
;

3031 
WORD
 
wV
;

3032 
tm
 
tmSu
;

3033 
WORD
 
wMiSecd
;

3035 
	`GSOEInfo

wSlNo
 , &
wP
, &
wV
, &
tmSu
, &
wMiSecd
 );

3038 
wP
 +
m_wYxSAddr
;

3039 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

3040 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

3041 i3 =
m_byInfoAddrL
 )

3043 
byAsduBuf
[
iAsduL
++] = 0x00;

3047 
wV
 = wVal & 0x0001;

3048 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wV
) ;

3051 
CP56TIME2A
 
t
 = 
	`GTmToCp56Time2a

tmSu
, 
wMiSecd
 );

3052 
byAsduBuf
[
iAsduL
++] = 
t
.
byLoMis
;

3053 
byAsduBuf
[
iAsduL
++] = 
t
.
byHiMis
;

3054 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

3055 
byAsduBuf
[
iAsduL
++] = 
t
.
byHour
;

3056 
byAsduBuf
[
iAsduL
++] = 
t
.
byDay
;

3057 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

3058 
byAsduBuf
[
iAsduL
++] = 
t
.
byYr
;

3061 
byCou
++;

3062 if
byCou
 > 20 )

3067 
byAsduBuf
[1] = 
byCou
;

3070 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3071 if(
n
 <= 0)

3073  
FALSE
;

3076  
TRUE
;

3077 
	}
}

3088 
BOOL
 
	gCIEC101S_2002
::
	$G_M_SP_TB_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

3090 if
IEC101S_2002_SOE_TYPE
 =
iFg
 )

3092  
	`G_M_SP_TB_1_SFme

buf
, 
n
 );

3095  
FALSE
;

3096 
	}
}

3107 
BOOL
 
	gCIEC101S_2002
::
	$G_M_DP_TB_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

3109 
BYTE
 
byAsduBuf
[256];

3110 
iAsduL
 = 0;

3112 
byAsduBuf
[
iAsduL
++] = 0x1f;

3113 
byAsduBuf
[
iAsduL
++] = 0x01;

3116 
byAsduBuf
[
iAsduL
++] = 0x03;

3117 if2 =
m_byCL
 )

3119 
byAsduBuf
[
iAsduL
++] = 0x00;

3123 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3124 i2 =
m_byAddrL
 )

3126 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3130 
BYTE
 
byCou
 = 0;

3131 
m_iSOE_rd_p
 !
m_iSOE_wr_p
)

3133 
WORD
 
wSlNo
;

3134 
WORD
 
wP
;

3135 
WORD
 
wV
;

3136 
tm
 
tmSu
;

3137 
WORD
 
wMiSecd
;

3139 
	`GSOEInfo

wSlNo
 , &
wP
, &
wV
, &
tmSu
, &
wMiSecd
 );

3142 
wP
 +
m_wYxSAddr
;

3143 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

3144 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

3145 i3 =
m_byInfoAddrL
 )

3147 
byAsduBuf
[
iAsduL
++] = 0x00;

3151 
wV
 = wVal & 0x0001;

3152 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
wV
) + 1 ;

3155 
CP56TIME2A
 
t
 = 
	`GTmToCp56Time2a

tmSu
, 
wMiSecd
 );

3156 
byAsduBuf
[
iAsduL
++] = 
t
.
byLoMis
;

3157 
byAsduBuf
[
iAsduL
++] = 
t
.
byHiMis
;

3158 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

3159 
byAsduBuf
[
iAsduL
++] = 
t
.
byHour
;

3160 
byAsduBuf
[
iAsduL
++] = 
t
.
byDay
;

3161 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

3162 
byAsduBuf
[
iAsduL
++] = 
t
.
byYr
;

3165 
byCou
++;

3166 if
byCou
 > 20 )

3171 
byAsduBuf
[1] = 
byCou
;

3174 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3175 if(
n
 <= 0)

3177  
FALSE
;

3180  
TRUE
;

3181 
	}
}

3192 
BOOL
 
	gCIEC101S_2002
::
	$G_M_DP_TB_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

3194 i
IEC101S_2002_SOE_TYPE
 =
iFg
 )

3196  
	`G_M_DP_TB_1_SFme

buf
, 
n
 );

3199  
FALSE
;

3200 
	}
}

3211 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_NA_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

3213 
BYTE
 
byAsduBuf
[256];

3214 
iAsduL
 = 0;

3216 
byAsduBuf
[
iAsduL
++] = 0x0f;

3217 
byAsduBuf
[
iAsduL
++] = 0x01;

3220 
byAsduBuf
[
iAsduL
++] = 0x25;

3221 if2 =
m_byCL
 )

3223 
byAsduBuf
[
iAsduL
++] = 0x00;

3227 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3228 i2 =
m_byAddrL
 )

3230 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3234 
WORD
 
wP
 = 
m_wDaIndex
 + 
m_wYmSAddr
;

3235 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

3236 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

3237 i3 =
m_byInfoAddrL
 )

3239 
byAsduBuf
[
iAsduL
++] = 0x00;

3242 
m_pMhod
->
	`RdAYmDa
(&
m_dwYmBuf
[0]);

3244 
BYTE
 
byCou
 = 0;

3245 
i
=
m_wDaIndex
; i<
m_wDISum
; i++)

3247 
DWORD
 
dwV
 = 
m_dwYmBuf
[
i
];

3249 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
	`LOWORD
(
dwV
));

3250 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
	`LOWORD
(
dwV
));

3251 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
	`HIWORD
(
dwV
));

3252 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
	`HIWORD
(
dwV
));

3256 
BYTE
 
bySiq
 = 0 ;

3258 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

DD_TRANSTOSERIALNO
 , 
i
 ) ;

3259 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

3260 if
bDevS
 =
COM_DEV_ABNORMAL
 )

3262 
bySiq
 |= 0xC0 ;

3265 
byAsduBuf
[
iAsduL
++] = 
bySiq
 ;

3268 
byCou
++;

3269 i
byCou
 >= 20 )

3275 
byAsduBuf
[1] = 0x80 | 
byCou
;

3278 
m_wDaIndex
 +
byCou
;

3279 i
m_wDaIndex
 >
m_wPISum
 )

3281 
m_dwSdFg
 &~
IEC101S_TOTAL_YM
;

3282 
m_wDaIndex
 = 0;

3286 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3287 if(
n
 <= 0)

3289  
FALSE
;

3292  
TRUE
;

3293 
	}
}

3304 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_NA_1_ChgeFme
 ( 
BYTE
 *
buf
, &
n
 )

3306 
BYTE
 
byAsduBuf
[256];

3307 
iAsduL
 = 0;

3309 
byAsduBuf
[
iAsduL
++] = 0x0f;

3310 
byAsduBuf
[
iAsduL
++] = 0x01;

3313 
byAsduBuf
[
iAsduL
++] = 0x03;

3314 if2 =
m_byCL
 )

3316 
byAsduBuf
[
iAsduL
++] = 0x00;

3320 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3321 i2 =
m_byAddrL
 )

3323 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3330 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3331 if(
n
 <= 0)

3333  
FALSE
;

3336  
TRUE
;

3337 
	}
}

3348 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_NA_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

3350 i
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

3352  
	`G_M_IT_NA_1_TٮFme
(
buf
, 
n
);

3355 i
IEC101S_2002_CHANGE_TYPE
 =
iFg
 )

3357  
	`G_M_IT_NA_1_ChgeFme
(
buf
, 
n
);

3359  
FALSE
;

3360 
	}
}

3371 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_TA_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

3373 
BYTE
 
byAsduBuf
[256];

3374 
iAsduL
 = 0;

3376 
byAsduBuf
[
iAsduL
++] = 0x10;

3377 
byAsduBuf
[
iAsduL
++] = 0x01;

3380 
byAsduBuf
[
iAsduL
++] = 0x25;

3381 if2 =
m_byCL
 )

3383 
byAsduBuf
[
iAsduL
++] = 0x00;

3387 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3388 i2 =
m_byAddrL
 )

3390 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3393 
m_pMhod
->
	`RdAYmDa
(&
m_dwYmBuf
[0]);

3395 
BYTE
 
byCou
 = 0;

3396 
i
=
m_wDaIndex
; i<
m_wDISum
; i++)

3398 
DWORD
 
dwV
 = 
m_dwYmBuf
[
i
];

3400 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
	`LOWORD
(
dwV
));

3401 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
	`LOWORD
(
dwV
));

3402 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
	`HIWORD
(
dwV
));

3403 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
	`HIWORD
(
dwV
));

3407 
BYTE
 
bySiq
 = 0 ;

3409 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

DD_TRANSTOSERIALNO
 , 
i
 ) ;

3410 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

3411 if
bDevS
 =
COM_DEV_ABNORMAL
 )

3413 
bySiq
 |= 0xC0 ;

3416 
byAsduBuf
[
iAsduL
++] = 
bySiq
 ;

3419 
CP56TIME2A
 
t
;

3420 
	`GCp56Time2a
&
t
 );

3421 
byAsduBuf
[
iAsduL
++] = 
t
.
byLoMis
;

3422 
byAsduBuf
[
iAsduL
++] = 
t
.
byHiMis
;

3423 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

3426 
byCou
++;

3427 i
byCou
 >= 20 )

3433 
byAsduBuf
[1] = 0x80 | 
byCou
;

3436 
m_wDaIndex
 +
byCou
;

3437 i
m_wDaIndex
 >
m_wPISum
 )

3439 
m_dwSdFg
 &~
IEC101S_TOTAL_YM
;

3440 
m_wDaIndex
 = 0;

3445 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3446 if(
n
 <= 0)

3448  
FALSE
;

3451  
TRUE
;

3452 
	}
}

3463 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_TA_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

3465 
BYTE
 
byAsduBuf
[256];

3466 
iAsduL
 = 0;

3468 
byAsduBuf
[
iAsduL
++] = 0x10;

3469 
byAsduBuf
[
iAsduL
++] = 0x01;

3472 
byAsduBuf
[
iAsduL
++] = 0x03;

3473 if2 =
m_byCL
 )

3475 
byAsduBuf
[
iAsduL
++] = 0x00;

3479 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3480 i2 =
m_byAddrL
 )

3482 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3489 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3490 if(
n
 <= 0)

3492  
FALSE
;

3495  
TRUE
;

3496 
	}
}

3507 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_TA_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

3509 i
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

3511  
	`G_M_IT_TA_1_TٮFme

buf
, 
n
 );

3514 i
IEC101S_2002_SOE_TYPE
 =
iFg
 )

3516  
	`G_M_IT_TA_1_SFme

buf
, 
n
 );

3519  
FALSE
;

3520 
	}
}

3531 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_TB_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 )

3533 
BYTE
 
byAsduBuf
[256];

3534 
iAsduL
 = 0;

3536 
byAsduBuf
[
iAsduL
++] = 0x25;

3537 
byAsduBuf
[
iAsduL
++] = 0x01;

3540 
byAsduBuf
[
iAsduL
++] = 0x25;

3541 if2 =
m_byCL
 )

3543 
byAsduBuf
[
iAsduL
++] = 0x00;

3547 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3548 i2 =
m_byAddrL
 )

3550 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3553 
m_pMhod
->
	`RdAYmDa
(&
m_dwYmBuf
[0]);

3555 
BYTE
 
byCou
 = 0;

3556 
i
=
m_wDaIndex
; i<
m_wDISum
; i++)

3558 
DWORD
 
dwV
 = 
m_dwYmBuf
[
i
];

3560 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
	`LOWORD
(
dwV
));

3561 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
	`LOWORD
(
dwV
));

3562 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
	`HIWORD
(
dwV
));

3563 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
	`HIWORD
(
dwV
));

3567 
BYTE
 
bySiq
 = 0 ;

3569 
WORD
 
wSlNo
 = 
	`GSlNoFromTns

DD_TRANSTOSERIALNO
 , 
i
 ) ;

3570 
BOOL
 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

3571 if
bDevS
 =
COM_DEV_ABNORMAL
 )

3573 
bySiq
 |= 0xC0 ;

3576 
byAsduBuf
[
iAsduL
++] = 
bySiq
 ;

3579 
CP56TIME2A
 
t
;

3580 
	`GCp56Time2a
&
t
 );

3581 
byAsduBuf
[
iAsduL
++] = 
t
.
byLoMis
;

3582 
byAsduBuf
[
iAsduL
++] = 
t
.
byHiMis
;

3583 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

3584 
byAsduBuf
[
iAsduL
++] = 
t
.
byHour
;

3585 
byAsduBuf
[
iAsduL
++] = 
t
.
byDay
;

3586 
byAsduBuf
[
iAsduL
++] = 
t
.
byM
;

3587 
byAsduBuf
[
iAsduL
++] = 
t
.
byYr
;

3590 
byCou
++;

3591 i
byCou
 >= 20 )

3597 
byAsduBuf
[1] = 0x80 | 
byCou
;

3600 
m_wDaIndex
 +
byCou
;

3601 i
m_wDaIndex
 >
m_wPISum
 )

3603 
m_dwSdFg
 &~
IEC101S_TOTAL_YM
;

3604 
m_wDaIndex
 = 0;

3608 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3609 if(
n
 <= 0)

3611  
FALSE
;

3614  
TRUE
;

3615 
	}
}

3626 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_TB_1_SFme
 ( 
BYTE
 *
buf
, &
n
 )

3628 
BYTE
 
byAsduBuf
[256];

3629 
iAsduL
 = 0;

3631 
byAsduBuf
[
iAsduL
++] = 0x10;

3632 
byAsduBuf
[
iAsduL
++] = 0x01;

3635 
byAsduBuf
[
iAsduL
++] = 0x03;

3636 if2 =
m_byCL
 )

3638 
byAsduBuf
[
iAsduL
++] = 0x00;

3642 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3643 i2 =
m_byAddrL
 )

3645 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3652 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3653 if(
n
 <= 0)

3655  
FALSE
;

3658  
TRUE
;

3659 
	}
}

3670 
BOOL
 
	gCIEC101S_2002
::
	$G_M_IT_TB_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 )

3672 i
IEC101S_2002_TOTAL_TYPE
 =
iFg
 )

3674  
	`G_M_IT_TB_1_TٮFme

buf
, 
n
 );

3677 i
IEC101S_2002_SOE_TYPE
 =
iFg
 )

3679  
	`G_M_IT_TB_1_SFme

buf
, 
n
 );

3682  
TRUE
;

3683 
	}
}

3695 
BOOL
 
	gCIEC101S_2002
::
	$GYkRDaFme
 ( 
BYTE
 *
buf
, &
n
, 
byYkRTy
 )

3697 
BYTE
 
byAsduBuf
[256];

3698 
iAsduL
 = 0;

3700 if
m_byYKAsduTy
 == 45 || m_byYKAsduType == 46 )

3702 
byAsduBuf
[
iAsduL
++] = 
m_byYKAsduTy
;

3706  
FALSE
;

3708 
byAsduBuf
[
iAsduL
++] = 0x01;

3711 if
m_dwSdFg
 & 
IEC101S_YK_CANCEL
 )

3713 
byAsduBuf
[
iAsduL
++] = 0x09;

3714 
m_dwSdFg
 &~
IEC101S_YK_CANCEL
;

3718 
byAsduBuf
[
iAsduL
++] = 0x07;

3719 if
m_dwSdFg
 & 
IEC101S_YK_SEL
 )

3721 
m_dwSdFg
 &~
IEC101S_YK_SEL
;

3723 if
m_dwSdFg
 & 
IEC101S_YK_EXE
 )

3725 
m_dwSdFg
 &~
IEC101S_YK_EXE
;

3729  
FALSE
;

3732 if2 =
m_byCL
 )

3734 
byAsduBuf
[
iAsduL
++] = 0x00;

3738 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE
(
m_wDevAddr
);

3739 i2 =
m_byAddrL
 )

3741 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE
(
m_wDevAddr
);

3745 
WORD
 
wP
 = 
m_wYkP
 + 
m_wYkSAddr
;

3746 if
wP
 < 
m_wYkSAddr
 || wPnt > ( m_wYkStartAddr + 0x400 ) )

3748 
	`tf
 ( "IEC101S Yk=%d\n", 
wP
 );

3749  
FALSE
;

3751 
byAsduBuf
[
iAsduL
++] = 
	`LOBYTE

wP
 );

3752 
byAsduBuf
[
iAsduL
++] = 
	`HIBYTE

wP
 );

3753 if3 =
m_byInfoAddrL
 )

3755 
byAsduBuf
[
iAsduL
++] = 0x00;

3759 
BYTE
 
byStus
 = 0;

3760  
byYkRTy
 )

3762 
IEC101S_YK_SEL
:

3763 
byStus
 = 
m_byYkStus
 | 0x80;

3766 
IEC101S_YK_EXE
:

3767 
byStus
 = 
m_byYkStus
;

3770 
IEC101S_YK_CANCEL
:

3771 
byStus
 = 
m_byYkStus
;

3775 
	`tf
 ( "IEC101S SDCSrr\n" );

3776  
FALSE
;

3779 if
m_byYKAsduTy
 == 46 )

3781 
byAsduBuf
[
iAsduL
++] = 
byStus
 + 1;

3785 
byAsduBuf
[
iAsduL
++] = 
byStus
;

3789 
n
 = 
	`Add68HdAndTa

byAsduBuf
, 
iAsduL
, 
buf
 );

3790 if(
n
 <= 0)

3792  
FALSE
;

3795  
TRUE
;

3796 
	}
}

3808 
BOOL
 
	gCIEC101S_2002
::
	$GChgeYcDa
 ( 
BYTE
 *
buf
, &
n
 )

3810  
m_byChgeYc
 )

3813  
	`G_M_ME_NA_1_Fme

buf
, 
n
, 
IEC101S_2002_CHANGE_TYPE
 );

3817  
	`G_M_ME_NB_1_Fme

buf
, 
n
, 
IEC101S_2002_CHANGE_TYPE
 );

3821  
	`G_M_ME_NC_1_Fme

buf
, 
n
, 
IEC101S_2002_CHANGE_TYPE
 );

3825  
	`G_M_ME_ND_1_Fme

buf
, 
n
, 
IEC101S_2002_CHANGE_TYPE
 );

3829 
	`t
( "IEC101S:GetTotalYcData can't findhe changycype" );

3833  
	`GNeDaBuf

buf
, 
n
 );

3834 
	}
}

3845 
BOOL
 
	gCIEC101S_2002
::
	$GLev2Da
 ( 
BYTE
 *
buf
, &
n
 )

3848 if
	`IsHaveSclDa
( ) )

3850  
	`GSclDa

buf
, 
n
 );

3853 i
	`IsHaveLev1Da
( ) )

3855  
	`GRecڙiBuf

buf
, 
n
 );

3859 if
	`IsHaveYxSDa
( ) )

3861 
	`t
( "仯SOE" );

3863  
	`GSYxDa
 (
buf
, 
n
);

3867 if
	`IsHaveChgeYcDa
( ) )

3869 
	`t
( "仯ң" );

3870  
	`GChgeYcDa

buf
, 
n
 );

3873  
	`GNeDaBuf

buf
, 
n
 );

3874 
	}
}

3885 
BOOL
 
	gCIEC101S_2002
::
	$IsHaveLev1Da
 ( )

3888 i(
m_dwSdFg
 & 
IEC101S_TOTAL_YX
|| 
	`IsHaveChgeYxDa
( ) )

3890  
TRUE
;

3894  
FALSE
;

3896 
	}
}

3907 
BOOL
 
	gCIEC101S_2002
::
	$IsHaveSclDa
 ( ) const

3909 i
m_dwSdFg
 & 
IEC101S_SPECIAL_DATA
 )

3911  
TRUE
;

3915  
FALSE
;

3917 
	}
}

3928 
BOOL
 
	gCIEC101S_2002
::
	$IsHaveYxSDa
 ( ) const

3930 i
m_iSOE_rd_p
 !
m_iSOE_wr_p
 )

3932  
TRUE
;

3936  
FALSE
;

3938 
	}
}

3950 
BOOL
 
	gCIEC101S_2002
::
	$IsHaveChgeYxDa
 ( )

3952 i
m_dwDIEQueue
.
	`size
( ) > 0 )

3954  
TRUE
;

3958  
FALSE
;

3960 
	}
}

3971 
BOOL
 
	gCIEC101S_2002
::
	$IsHaveChgeYcDa
 ( )

3973 i
m_dwAIEQueue
.
	`size
( ) > 0 )

3975  
TRUE
;

3979  
FALSE
;

3981 
	}
}

3992 
BOOL
 
	gCIEC101S_2002
::
	$GTٮYmDa
 ( 
BYTE
 *
buf
, &
n
 )

3994  
m_byTٮClYm
 )

3997 
	`t
( "ۼ" );

3998  
	`G_M_IT_NA_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4002 
	`t
( "ʱۼ" );

4003  
	`G_M_IT_TA_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4007 
	`t
( "CP56TIME2aʱۼ" );

4008  
	`G_M_IT_TB_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4012 
	`rtf

m_szPrtBuf
, "ȫңô m_byTٮClYm=%d", 
m_byTٮClYm
 );

4013 
	`t

m_szPrtBuf
 );

4016  
	`GNeDaBuf

buf
, 
n
 );

4017 
	}
}

4028 
BOOL
 
	gCIEC101S_2002
::
	$GTٮYcDa
 ( 
BYTE
 *
buf
, &
n
 )

4030  
m_byTٮClYc
 )

4033 
	`t
( "һֵ" );

4034  
	`G_M_ME_NA_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4038 
	`t
( "ʱĹһֵ" );

4042 
	`t
( "Ȼֵ" );

4043  
	`G_M_ME_NB_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4047 
	`t
( "ʱıȻֵ" );

4051 
	`t
( "̸" );

4052  
	`G_M_ME_NC_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4056 
	`t
( "ʱĶ̸" );

4060 
	`t
( "ֵ ƷʵĹһֵ" );

4061  
	`G_M_ME_ND_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4065 
	`t
( "CP55Time2aĹһֵ" );

4069 
	`t
( "CP55Time2aıȻֵ" );

4073 
	`t
( "CP55Time2aĶ̸" );

4077 
	`rtf

m_szPrtBuf
, "ȫңô m_byTٮClYc=%d", 
m_byTٮClYc
 );

4078 
	`t

m_szPrtBuf
 );

4082  
	`GNeDaBuf

buf
, 
n
 );

4083 
	}
}

4095 
BOOL
 
	gCIEC101S_2002
::
	$GTٮYxDa
 ( 
BYTE
 *
buf
, &
n
 )

4097  
m_byTٮClYx
 )

4100 
	`t
( "ȫңŵϢ" );

4101  
	`G_M_SP_NA_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4105 
	`t
( "ȫңŴʱĵϢ" );

4109 
	`t
( "ȫңŴʱĵϢ" );

4110  
	`G_M_DP_NA_1_Fme

buf
, 
n
, 
IEC101S_2002_TOTAL_TYPE
 );

4114 
	`t
( "ȫң˫Ϣ" );

4118 
	`t
( "ȫңŴCP56Time2aʱĵϢ" );

4122 
	`t
( "ȫңŴCP56Time2aʱĵϢ" );

4126 
	`rtf

m_szPrtBuf
, "ȫңô m_byTٮClYx=%d", 
m_byTٮClYx
 );

4127 
	`t

m_szPrtBuf
 );

4131  
FALSE
;

4132 
	}
}

4143 
BOOL
 
	gCIEC101S_2002
::
	$GSclDa
 ( 
BYTE
 *
buf
, &
n
 )

4145 if
m_dwSdFg
 & 
IEC101S_TOTAL_CALL
 )

4147 i
	`GTٮClRecoBuf

buf
, 
n
, 0x07 ) )

4149 
m_dwSdFg
 &~
IEC101S_TOTAL_CALL
;

4150  
TRUE
;

4153 if
m_dwSdFg
 & 
IEC101S_TOTAL_YX
 )

4155  
	`GTٮYxDa

buf
, 
n
 );

4157 if
m_dwSdFg
 & 
IEC101S_TOTAL_YC
 )

4159  
	`GTٮYcDa

buf
, 
n
 );

4161 if
m_dwSdFg
 & 
IEC101S_TOTAL_CALL_END
 )

4163 if
	`GTٮClRecoBuf

buf
, 
n
, 0x0a ) )

4165 
m_dwSdFg
 &~
IEC101S_TOTAL_CALL_END
;

4166 
m_dwSdFg
 &~
IEC101S_SPECIAL_DATA
;

4167  
TRUE
;

4170 if
m_dwSdFg
 & 
IEC101S_CALL_YM
 )

4172 if
	`GClYmRecoBuf

buf
, 
n
, 0x07 ) )

4174 
m_dwSdFg
 &~
IEC101S_CALL_YM
;

4175  
TRUE
;

4178 if
m_dwSdFg
 & 
IEC101S_TOTAL_YM
 )

4180  
	`GTٮYmDa

buf
, 
n
 );

4182 if
m_dwSdFg
 & 
IEC101S_CALL_YM_END
 )

4184 if
	`GClYmRecoBuf

buf
, 
n
, 0x0a ) )

4186 
m_dwSdFg
 &~
IEC101S_CALL_YM_END
;

4187 
m_dwSdFg
 &~
IEC101S_SPECIAL_DATA
;

4188  
TRUE
;

4191 if
m_dwSdFg
 & 
IEC101S_TIME_SYNC
 )

4193 if
	`GTimeSyncRecoBuf

buf
, 
n
, 0x07 ) )

4195 
m_dwSdFg
 &~
IEC101S_TIME_SYNC
;

4196  
TRUE
;

4199 if
m_dwSdFg
 & 
IEC101S_TIME_SYNC_END
 )

4201 if
	`GTimeSyncRecoBuf

buf
,
n
,0x0a ) )

4203 
m_dwSdFg
 &~
IEC101S_TIME_SYNC_END
;

4204 
m_dwSdFg
 &~
IEC101S_SPECIAL_DATA
;

4205  
TRUE
;

4209  
	`GNeDaBuf

buf
, 
n
 );

4210 
	}
}

4222 
BOOL
 
	gCIEC101S_2002
::
	$GChgeYxDa
 ( 
BYTE
 *
buf
, &
n
 )

4224  
m_byChgeYx
 )

4227  
	`G_M_SP_NA_1_Fme

buf
, 
n
, 
IEC101S_2002_CHANGE_TYPE
 );

4231  
	`G_M_DP_NA_1_Fme

buf
, 
n
, 
IEC101S_2002_CHANGE_TYPE
 );

4235 
	`t
( "IEC101S:GetChangeYxDatarr" );

4239  
	`GNeDaBuf

buf
, 
n
 );

4240 
	}
}

4251 
BOOL
 
	gCIEC101S_2002
::
	$GSYxDa
 ( 
BYTE
 *
buf
, &
n
 )

4253  
m_bySYx
 )

4256  
	`G_M_SP_TA_1_Fme

buf
, 
n
, 
IEC101S_2002_SOE_TYPE
 );

4260  
	`G_M_DP_TA_1_Fme

buf
, 
n
, 
IEC101S_2002_SOE_TYPE
 );

4264  
	`G_M_SP_TB_1_Fme

buf
, 
n
, 
IEC101S_2002_SOE_TYPE
 );

4268  
	`G_M_DP_TB_1_Fme

buf
, 
n
, 
IEC101S_2002_SOE_TYPE
 );

4272 
	`t
( "IEC101S GetSoeYxDatarr" );

4276  
	`GNeDaBuf

buf
, 
n
 );

4277 
	}
}

4289 
BOOL
 
	gCIEC101S_2002
::
	$GLev1Da
 ( 
BYTE
 *
buf
, &
n
 )

4292 if
	`IsHaveSclDa
( ) )

4295  
	`GSclDa

buf
, 
n
 );

4299 if
	`IsHaveChgeYxDa
( ) )

4301 
	`t
( "仯ң" );

4303  
	`GChgeYxDa

buf
, 
n
 );

4308  
	`GNeDaBuf

buf
, 
n
 );

4309 
	}
}

4321 
BOOL
 
	gCIEC101S_2002
::
	$GYkRDa
 ( 
BYTE
 *
buf
, &
n
 )

4323 if
m_dwSdFg
 & 
IEC101S_YK_CANCEL
 )

4325  
	`GYkRDaFme

buf
, 
n
, 
IEC101S_YK_CANCEL
 );

4327 if
m_dwSdFg
 & 
IEC101S_YK_SEL
 )

4329  
	`GYkRDaFme

buf
, 
n
, 
IEC101S_YK_SEL
 );

4331 if
m_dwSdFg
 & 
IEC101S_YK_EXE
 )

4333  
	`GYkRDaFme

buf
, 
n
, 
IEC101S_YK_EXE
 );

4336 
	`tf
 ( "IEC101S GetYkRtnDatarr\n" );

4338  
	`GNeDaBuf

buf
, 
n
 );

4339 
	}
}

4351 
BOOL
 
	gCIEC101S_2002
::
	$GSdBuf
 ( 
BYTE
 *
buf
, &
n
 )

4353 
BOOL
 
bR
 = 
FALSE
;

4355 if
m_bReSdg
 && 
m_bLkStus
 )

4357 
m_SdStus
 = 
RESEND
;

4362  
m_SdStus
 )

4364 
LINK_STATUS
:

4365 
	`t
( "Ӧ֡ ·״̬Ҫ" );

4366 
bR
 = 
	`GLkStusBuf

buf
, 
n
 );

4369 
RECOGNITION
:

4370 
	`t
( "ȷ֡ Ͽ" );

4371 
bR
 = 
	`GRecڙiBuf

buf
, 
n
 );

4374 
USER_DATA
:

4375 
	`t
( "ûȷ֡ Ͽ" );

4376 
bR
 = 
	`GUrDaBuf

buf
, 
n
 );

4379 
LEVEL2_DATA
:

4380 
	`t
( "" );

4381 
bR
 = 
	`GLev2Da

buf
, 
n
 );

4384 
LEVEL1_DATA
:

4385 
	`t
( "һ" );

4386 
bR
 = 
	`GLev1Da

buf
, 
n
 );

4389 
YK_RTN_DATA
:

4390 
	`t
( "ңط" );

4391 
bR
 = 
	`GYkRDa

buf
, 
n
 );

4394 
RESEND
:

4395 
	`t
( "ط" );

4396 
	`memy

buf
, 
m_byRendBuf
, 
m_byRendL
 );

4397 
n
 = 
m_byRendL
;

4398 
m_byRendCou
 ++;

4399 
bR
 = 
TRUE
;

4403 
	`rtf

m_szPrtBuf
, "n'fd m_SdStus=%d", 
m_SdStus
 );

4404 if
m_bLkStus
 )

4406 
	`t

m_szPrtBuf
 );

4412 if
bR
 )

4414 
m_byRendL
 = (
BYTE
)
n
;

4415 
	`memy

m_byRendBuf
, 
buf
, 
m_byRendL
 );

4418  
bR
;

4419 
	}
}

4430 
	gCIEC101S_2002
::
	$SSdPam
 ( )

4432 
m_bSdg
 = 
TRUE
;

4433 
m_bySdCou
 ++;

4435 if
m_bySdCou
 > 1 )

4437 
m_bReSdg
 = 
TRUE
;

4440 
m_SdStus
 = 
NULL_STATUS
;

4441 
	}
}

4455 
BOOL
 
	gCIEC101S_2002
::
	$RdCfgTeme
 ( )

4457 
FILE
 *

 ;

4458 
szFeName
[256] = "";

4459 
	`rtf

szFeName
, "%s%s" , 
IEC101SPREFIXFILENAME
, 
m_sTemePh
);

4461 
szLeBuf
[256];

4462 
iLeNum
 = 0;

4464 

 = 
	`fݒ

szFeName
, "r" );

4465 if

 =
NULL
 )

4467 
	`tf
 ( "ݒ f%r!!!\n", 
szFeName
 );

4468  
FALSE
;

4471  
	`fgs
(
szLeBuf
, (szLeBuf), 

!
NULL
 && 
iLeNum
 < 30 )

4473 
iLeNum
 ++;

4474 if
	`cmp

szLeBuf
, "COTLEN=", 7 ) == 0 )

4476 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[7] );

4477 if2 =
byCfgV
 || 1 == byCfgVal )

4480 
m_byCL
 = 
byCfgV
;

4483 if
	`cmp

szLeBuf
, "ADDRLEN=", 8 ) == 0 )

4485 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[8] );

4486 if2 =
byCfgV
 || 1 == byCfgVal )

4489 
m_byAddrL
 = 
byCfgV
;

4492 if
	`cmp

szLeBuf
, "INFOADDRLEN=", 12 ) == 0 )

4494 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[12] );

4495 if2 =
byCfgV
 || 3 == byCfgVal )

4498 
m_byInfoAddrL
 = 
byCfgV
;

4501 if
	`cmp

szLeBuf
, "TOTALYCTYPE=", 12 ) == 0 )

4503 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[12] );

4504 if1 =
byCfgV
 || 3 == byCfgVal )

4507 
m_byTٮClYx
 = 
byCfgV
;

4510 if
	`cmp

szLeBuf
, "TOTALYXTYPE=", 12 ) == 0 )

4512 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[12] );

4513 if9 =
byCfgV
 || 11 == byCfgVal || 13==byCfgVal || 21==byCfgVal )

4516 
m_byTٮClYc
 = 
byCfgV
;

4520 if
	`cmp

szLeBuf
, "TOTALYMTYPE=", 12 ) == 0 )

4522 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[12] );

4523 if15 =
byCfgV
 || 16 == byCfgVal || 17==byCfgVal )

4526 
m_byTٮClYm
 = 
byCfgV
;

4529 if
	`cmp

szLeBuf
, "CHANGEYX=", 9 ) == 0 )

4531 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[9] );

4532 if3 =
byCfgV
 || 1 == byCfgVal)

4535 
m_byChgeYx
 = 
byCfgV
;

4538 if
	`cmp

szLeBuf
, "CHANGEYC=", 9 ) == 0 )

4540 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[9] );

4541 if11 =
byCfgV
 || 13 == byCfgVal || 21==byCfgVal || 9==byCfgVal )

4544 
m_byChgeYc
 = 
byCfgV
;

4547 if
	`cmp

szLeBuf
, "SOEYX=", 6 ) == 0 )

4549 
BYTE
 
byCfgV
 = 
	`oi
&
szLeBuf
[6] );

4550 if2 =
byCfgV
 || 4 == byCfgVal || 30==byCfgVal || 31==byCfgVal )

4553 
m_bySYx
 = 
byCfgV
;

4558 
	`fo


 );

4560  
TRUE
;

4561 
	}
}

4573 
BOOL
 
	gCIEC101S_2002
::
	$RdCfgM
 ( )

4575 
szFeName
[256] = "";

4576 
	`rtf

szFeName
, "%s%s" , 
IEC101SPREFIXFILENAME
, 
m_sTemePh
);

4577 
	`t

szFeName
 );

4580 
	`RdMCfig

szFeName
 );

4582  
TRUE
;

4583 
	}
}

4595 
BOOL
 
	gCIEC101S_2002
::
	$RdCfgInfo
 ( )

4597 if!
	`RdCfgTeme
( ) )

4599  
FALSE
;

4602 if!
	`RdCfgM
( ) )

4604  
FALSE
;

4607  
TRUE
;

4608 
	}
}

4619 
	gCIEC101S_2002
::
	$InProcS
 ( )

4621 
m_bLkStus
 = 
FALSE
;

4622 
m_dwSdFg
 |
IEC101S_SPECIAL_DATA
;

4625 
m_byYKAsduTy
 = 0;

4626 
m_byYkC
 = 0;

4627 
m_wYkS
 = 0;

4628 
m_wYkP
 = 0;

4629 
m_byYkStus
 = 0;

4631 
m_wDaIndex
 = 0;

4632 
m_bDaIn
 = 1;

4635 
m_bSdg
 = 
FALSE
;

4636 
m_bReSdg
 = 
FALSE
;

4639 
m_bySdCou
 = 0;

4640 
m_byRecvCou
 = 0;

4641 
m_byRendCou
 = 0;

4644 
	`memt

m_byRendBuf
, 0, 256 );

4645 
m_byRendL
 = 0;

4648 
m_bFcb
 = 
FALSE
;

4649 
	}
}

4661 
	gCIEC101S_2002
::
	$InProcTnsTab
 ( )

4664 
	`CeTnsTab
();

4665 
	}
}

4677 
	gCIEC101S_2002
::
	$InProcDa
 ( )

4680 
m_pMhod
->
	`RdAYcDa
(&
m_fYcBuf
[0]);

4681 
m_pMhod
->
	`RdAYmDa
(&
m_dwYmBuf
[0]);

4682 
m_pMhod
->
	`RdAYxDa
&
m_byYxBuf
[ 0 ] ) ;

4683 
	}
}

4694 
	gCIEC101S_2002
::
	$InProc
 ( )

4697 
	`InProcS
( );

4700 
	`InProcTnsTab
( );

4703 
	`InProcDa
( );

4704 
	}
}

4717 
	gCIEC101S_2002
::
	$TimProc
 ( )

4719 
	`RdChgDa
();

4722 if
m_bySdCou
 > 
IEC101S_2002_MAX_SEND_COUNT
 )

4724 
	`t
( "IEC101S m_bySendCount > 3" );

4725 
	`InProcS
( );

4728 if
m_byRendCou
 > 
IEC101S_2002_MAX_RESEND_COUNT
 )

4730 
	`t
( "IEC101S m_RCount > 3" );

4731 
	`InProcS
( );

4733 
	}
}

4745 
BOOL
 
	gCIEC101S_2002
::
	$ProssProcBuf
 ( 
BYTE
 *
pBuf
, 
n
 )

4748 if!
	`WhhBufVid

pBuf
, 
n
 ) )

4750 
	`t
( "WhetherBufValidrr" );

4751 
m_bReSdg
 = 
TRUE
;

4752  
FALSE
;

4756 if!
	`ProssRecvBuf

pBuf
, 
n
 ) )

4758 
	`t
( "IEC101S:ProcessRecvBufrr!!!" );

4759  
FALSE
;

4763 
	`SRecvPam
( );

4765  
TRUE
;

4766 
	}
}

4779 
BOOL
 
	gCIEC101S_2002
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

4781 
	`as

buf
 !
NULL
 );

4782 
BOOL
 
bR
 = 
TRUE
;

4784 if
pBusMsg
 )

4787 i!
	`DlBusMsg

pBusMsg
 ) )

4789 
	`tf
( "IEC101S:Ϣ\n" );

4795 if!
	`GSdBuf

buf
, 
n
 ) )

4797 
bR
 = 
FALSE
;

4803 if
m_bLkStus
 )

4806 
	`SSdPam
( );

4807 if
bR
 )

4809 
m_byRecvCou
 = 0;

4813  
bR
;

4814 
	}
}

4825 
BOOL
 
	gCIEC101S_2002
::
	$In
 ( 
BYTE
 
byLeNo
 )

4828 i!
	`RdCfgInfo
( ) )

4830 
	`tf
( "IEC101S_2002:ReadCfgInforr!!!\n" );

4831  
FALSE
;

4835 
	`InProc
( );

4837  
TRUE
;

4838 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/IEC101S_2002.h

22 #ide 
IEC101S_2002_INC


23 
	#IEC101S_2002_INC


	)

26 
	~"CProc_IEC101S.h
"

28 
	#IEC101S_2002_MAX_YC_NUM
 4096

	)

29 
	#IEC101S_2002_MAX_YX_NUM
 8192

	)

30 
	#IEC101S_2002_MAX_YM_NUM
 1024

	)

33 
	#IEC101S_2002_TOTAL_TYPE
 1

	)

34 
	#IEC101S_2002_CHANGE_TYPE
 2

	)

35 
	#IEC101S_2002_SOE_TYPE
 3

	)

36 
	#IEC101S_2002_YKSINGLE_TYPE
 4

	)

37 
	#IEC101S_2002_YKDOUBLE_TYPE
 5

	)

39 
	#IEC101S_2002_MAX_SEND_COUNT
 3

	)

40 
	#IEC101S_2002_MAX_RESEND_COUNT
 3

	)

48 as
	cCIEC101S_2002
 : 
public
 
CProc_IEC101S


50 
public
:

52 
CIEC101S_2002
 ();

53 ~
CIEC101S_2002
 ();

56 
vtu
 
TimProc
( );

58 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

60 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

62 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
pBuf
 , 
n
 ) ;

64 
vtu
 
GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
);

65 
vtu
 
BOOL
 
WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
fV
) ;

66 
vtu
 
BOOL
 
WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
) ;

67 
vtu
 
BOOL
 
WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
) ;

68 
vtu
 
BOOL
 
WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
) ;

70 
	meed
:

73 
vtu
 
BOOL
 
ProssCB

BYTE
 
c
 );

75 
SRecvPam
( );

77 
BOOL
 
ProssHd10Buf
cڡ 
BYTE
 *
pBuf
, 
n
 );

79 
SYkPam

BYTE
 
byTy
, BYTE 
byC
, 
WORD
 
wS
, WORD 
wP
, BYTE 
byStus
 );

81 
BOOL
 
	$IsYkPamTrue

BYTE
 
byTy
, BYTE 
byC
, 
WORD
 
wS
, WORD 
wP
, BYTE 
byStus
 ) const;

83 
BOOL
 
	`ProssYkBuf
cڡ 
BYTE
 *
buf
, 
n
 );

85 
BOOL
 
	`ProssTٮClBuf
cڡ 
BYTE
 *
buf
, 
n
 );

87 
BOOL
 
	`ProssYMClBuf
cڡ 
BYTE
 *
buf
, 
n
 );

89 
BOOL
 
	`ProssTimeSyncBuf
cڡ 
BYTE
 *
buf
, 
n
 );

91 
BOOL
 
	`ProssHd68Buf
cڡ 
BYTE
 *
pBuf
, 
n
 );

93 
BOOL
 
	`ProssRecvBuf
cڡ 
BYTE
 *
pBuf
, 
n
 );

97 
BOOL
 
	`DlBusMsg

PBUSMSG
 
pBusMsg
 );

99 
	`Add68HdAndTa
cڡ 
BYTE
 *
byAsduBuf
, 
iAsduL
, BYTE *
buf
 );

101 
BOOL
 
	`GLkStusBuf

BYTE
 *
buf
, &
n
 );

103 
BOOL
 
	`GRecڙiBuf

BYTE
 *
buf
, &
n
 );

105 
BOOL
 
	`GUrDaBuf

BYTE
 *
buf
, &
n
 );

107 
BOOL
 
	`GNeDaBuf

BYTE
 *
buf
, &
n
 );

109 
BOOL
 
	`GTٮClRecoBuf

BYTE
 *
buf
, &
n
, BYTE 
byC
 );

111 
BOOL
 
	`GTimeSyncRecoBuf

BYTE
 *
buf
, &
n
, BYTE 
byC
 );

113 
BOOL
 
	`GClYmRecoBuf

BYTE
 *
buf
, &
n
, BYTE 
byC
 );

116 
BOOL
 
	`G_M_ME_NA_1_TٮFme

BYTE
 *
buf
, &
n
 );

118 
BOOL
 
	`G_M_ME_NA_1_ChgeFme

BYTE
 *
buf
, &
n
 );

120 
BOOL
 
	`G_M_ME_NA_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

123 
BOOL
 
	`G_M_ME_TA_1_SFme

BYTE
 *
buf
, &
n
 );

125 
BOOL
 
	`G_M_ME_TA_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

128 
BOOL
 
	`G_M_ME_NB_1_TٮFme

BYTE
 *
buf
, &
n
 );

130 
BOOL
 
	`G_M_ME_NB_1_ChgeFme

BYTE
 *
buf
, &
n
 );

132 
BOOL
 
	`G_M_ME_NB_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

135 
BOOL
 
	`G_M_ME_TB_1_SFme

BYTE
 *
buf
, &
n
 );

137 
BOOL
 
	`G_M_ME_TB_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

140 
BOOL
 
	`G_M_ME_NC_1_TٮFme

BYTE
 *
buf
, &
n
 );

142 
BOOL
 
	`G_M_ME_NC_1_ChgeFme

BYTE
 *
buf
, &
n
 );

144 
BOOL
 
	`G_M_ME_NC_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

147 
BOOL
 
	`G_M_ME_TC_1_SFme

BYTE
 *
buf
, &
n
 );

149 
BOOL
 
	`G_M_ME_TC_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

152 
BOOL
 
	`G_M_ME_ND_1_TٮFme
 ( 
BYTE
 *
buf
, &
n
 );

154 
BOOL
 
	`G_M_ME_ND_1_ChgeFme
 ( 
BYTE
 *
buf
, &
n
 );

156 
BOOL
 
	`G_M_ME_ND_1_Fme
 ( 
BYTE
 *
buf
, &
n
, 
iFg
 );

159 
BOOL
 
	`G_M_ME_TD_1_SFme

BYTE
 *
buf
, &
n
 );

161 
BOOL
 
	`G_M_ME_TD_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

164 
BOOL
 
	`G_M_ME_TE_1_SFme

BYTE
 *
buf
, &
n
 );

166 
BOOL
 
	`G_M_ME_TE_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

169 
BOOL
 
	`G_M_ME_TF_1_SFme

BYTE
 *
buf
, &
n
 );

171 
BOOL
 
	`G_M_ME_TF_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

174 
BOOL
 
	`G_M_SP_NA_1_TٮFme

BYTE
 *
buf
, &
n
 );

176 
BOOL
 
	`G_M_SP_NA_1_ChgeFme

BYTE
 *
buf
, &
n
 );

178 
BOOL
 
	`G_M_SP_NA_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

181 
BOOL
 
	`G_M_SP_TA_1_SFme

BYTE
 *
buf
, &
n
 );

183 
BOOL
 
	`G_M_SP_TA_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

187 
BOOL
 
	`G_M_DP_NA_1_TٮFme

BYTE
 *
buf
, &
n
 );

189 
BOOL
 
	`G_M_DP_NA_1_ChgeFme

BYTE
 *
buf
, &
n
 );

191 
BOOL
 
	`G_M_DP_NA_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

194 
BOOL
 
	`G_M_DP_TA_1_SFme

BYTE
 *
buf
, &
n
 );

196 
BOOL
 
	`G_M_DP_TA_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

199 
BOOL
 
	`G_M_SP_TB_1_SFme

BYTE
 *
buf
, &
n
 );

201 
BOOL
 
	`G_M_SP_TB_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

204 
BOOL
 
	`G_M_DP_TB_1_SFme

BYTE
 *
buf
, &
n
 );

206 
BOOL
 
	`G_M_DP_TB_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

209 
BOOL
 
	`G_M_IT_NA_1_TٮFme

BYTE
 *
buf
, &
n
 );

211 
BOOL
 
	`G_M_IT_NA_1_ChgeFme

BYTE
 *
buf
, &
n
 );

213 
BOOL
 
	`G_M_IT_NA_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

216 
BOOL
 
	`G_M_IT_TA_1_TٮFme

BYTE
 *
buf
, &
n
 );

218 
BOOL
 
	`G_M_IT_TA_1_SFme

BYTE
 *
buf
, &
n
 );

220 
BOOL
 
	`G_M_IT_TA_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

223 
BOOL
 
	`G_M_IT_TB_1_TٮFme

BYTE
 *
buf
, &
n
 );

225 
BOOL
 
	`G_M_IT_TB_1_SFme

BYTE
 *
buf
, &
n
 );

227 
BOOL
 
	`G_M_IT_TB_1_Fme

BYTE
 *
buf
, &
n
, 
iFg
 );

230 
BOOL
 
	`GYkRDaFme
 ( 
BYTE
 *
buf
, &
n
, 
byYkRTy
 );

233 
BOOL
 
	`IsHaveChgeYcDa
( );

235 
BOOL
 
	`GChgeYcDa

BYTE
 *
buf
, &
n
 );

237 
BOOL
 
	`GLev2Da

BYTE
 *
buf
, &
n
 );

239 
BOOL
 
	`IsHaveLev1Da
( );

241 
BOOL
 
	$IsHaveSclDa
( ) const;

243 
BOOL
 
	`GTٮYxDa

BYTE
 *
buf
, &
n
 );

245 
BOOL
 
	`GTٮYcDa

BYTE
 *
buf
, &
n
 );

247 
BOOL
 
	`GTٮYmDa

BYTE
 *
buf
, &
n
 );

249 
BOOL
 
	`GSclDa

BYTE
 *
buf
, &
n
 );

251 
BOOL
 
	`IsHaveChgeYxDa
( );

253 
BOOL
 
	$IsHaveYxSDa
 ( ) const;

255 
BOOL
 
	`GChgeYxDa

BYTE
 *
buf
, &
n
 );

257 
BOOL
 
	`GSYxDa
 ( 
BYTE
 *
buf
, &
n
 );

259 
BOOL
 
	`GLev1Da

BYTE
 *
buf
, &
n
 );

261 
BOOL
 
	`IsYkRBusMsgVid
 ( 
PBUSMSG
 
pBusMsg
, 
DWORD
 
dwYkTy
 );

263 
BOOL
 
	`GYkRDa

BYTE
 *
buf
, &
n
 );

265 
BOOL
 
	`GSdBuf

BYTE
 *
buf
, &
n
 );

267 
	`SSdPam
( );

270 
BOOL
 
	`RdCfgTeme
 ( );

272 
BOOL
 
	`RdCfgInfo
 ( );

274 
BOOL
 
	`RdCfgM
 ( );

276 
	`InProcS
 ( );

278 
	`InProcTnsTab
( );

280 
	`InProcDa
( );

282 
	`InProc
( );

284 
eed
:

288 
WORD
 
m_wYcSAddr
;

289 
WORD
 
m_wYxSAddr
;

290 
WORD
 
m_wYkSAddr
;

291 
WORD
 
m_wYmSAddr
;

292 
WORD
 
m_wComSAddr
;

295 
BYTE
 
m_byCL
;

296 
BYTE
 
m_byAddrL
;

297 
BYTE
 
m_byInfoAddrL
;

300 
BYTE
 
m_byTٮClYx
;

301 
BYTE
 
m_byTٮClYc
;

302 
BYTE
 
m_byTٮClYm
;

305 
BYTE
 
m_byChgeYx
;

306 
BYTE
 
m_bySYx
;

307 
BYTE
 
m_byChgeYc
;

308 
BYTE
 
m_byYkTy
;

310 
ive
:

314 
BYTE
 
m_byYKAsduTy
;

315 
BYTE
 
m_byYkC
;

316 
WORD
 
m_wYkS
;

317 
WORD
 
m_wYkP
;

318 
BYTE
 
m_byYkStus
;

320 
WORD
 
m_wDaIndex
;

322 
BOOL
 
m_bLkStus
;

323 
BOOL
 
m_bDaIn
;

324 
BOOL
 
m_bSdg
;

325 
BOOL
 
m_bReSdg
;

327 
BYTE
 
m_bySdCou
;

328 
BYTE
 
m_byRecvCou
;

329 
BYTE
 
m_byRendCou
;

331 
BYTE
 
m_byRendBuf
[256];

332 
BYTE
 
m_byRendL
;

334 
m_fYcBuf
[
IEC101S_2002_MAX_YC_NUM
];

335 
DWORD
 
m_dwYmBuf
[
IEC101S_2002_MAX_YM_NUM
];

336 
BYTE
 
m_byYxBuf
[
IEC101S_2002_MAX_YX_NUM
] ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_IEC101S.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

10 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

12 
CProc
 * 
pProc
 = 
NULL
 ;

13 
pProc
 = 
w
 
CProc_IEC101S
 ;

14 if
pProc
 )

16 
pProc
->
m_pMhod
 = 
pMhod
 ;

17 
	`tf
( "IEC101Slave DLL OK.\n " ) ;

20  
pProc
 ;

21 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/CProtocol_IEC103.cpp

1 
	~"CProc_IEC103.h
"

2 
	~"IEC103.h
"

4 
	#MODULE_RTU
 1

	)

6 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

8 
	gCProc_IEC103
::
	$CProc_IEC103
()

11 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

13 
	}
}

15 
	gCProc_IEC103
::~
	$CProc_IEC103
()

18 
size
 = 
m_modu
.
	`size
() ;

19  
i
 = 0 ; i < 
size
 ; i++ )

21 
de
 
m_modu
[ 
i
 ] ;

23 
m_modu
.
	`r
() ;

24 
	`tf
( "Delete All CProtocol_IEC103 OK . \n" );

25 
	}
}

27 
BOOL
 
	gCProc_IEC103
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

29  
FALSE
 ;

30 
	}
}

32 
BOOL
 
	gCProc_IEC103
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

34  
FALSE
 ;

35 
	}
}

37 
BOOL
 
	gCProc_IEC103
::
	$In

BYTE
 
byLeNo
 )

41 
m_byLeNo
 = 
byLeNo
 ;

43 
m_ProTy
 = 
PROTOCO_GATHER
 ;

45  
	`GDevDa
( ) ;

46 
	}
}

48 
BOOL
 
	gCProc_IEC103
::
	$GDevDa
( )

50 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

51 
	`rtf

m_sDevPh
 , "%s/IEC103/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

52 
CProfe
 
	`ofe

m_sDevPh
 ) ;

54  
	`ProssFeDa

ofe
 ) ;

55 
	}
}

57 
BOOL
 
	gCProc_IEC103
::
	$ProssFeDa

CProfe
 &
ofe
 )

59 
BOOL
 
bR
 = 
FALSE
;

60 if!
ofe
.
	`IsVid
() )

62 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

63  
FALSE
 ;

66 
sSe
[ 200 ] = "DEVNUM" ;

67 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

69 
WORD
 
wModu
 = 0 ;

70 
ro
=1 ;

71 
WORD
 
addr
 =3 ;

72 
sName
[ 50 ] = { 0 };

73 
eme
[ 200 ] = { 0 };

74 
iNum
 = 0 ;

76 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

77 if
iNum
 == 0 )

79 
	`tf
( "Get DEVNUM Failed ! \n " );

80  
FALSE
 ;

83  
i
 = 0 ; i < 
iNum
 ; i++ )

85 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

87 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

88 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

89 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

90 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

91 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

94 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

95 i!
bR
 )

97 
	`tf
 ( "CModBuModu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

99  
FALSE
;

103  
TRUE
 ;

104 
	}
}

106 
BOOL
 
	gCProc_IEC103
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

108 
CProc_IEC103
 * 
pProc
 = 
NULL
 ;

110  
iModu
 )

112 
MODULE_RTU
:

114 
pProc
 = 
w
 
CIEC103
 ;

115 
pProc
->
m_byLeNo
 = m_byLineNo ;

116 
pProc
->
m_wModuTy
 = 
iModu
 ;

117 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

118 
pProc
->
m_SlNo
 = 
iSlNo
 ;

120 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

121 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

122 
pProc
->
m_pMhod
 = m_pMethod ;

123 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

125 if!
pProc
->
	`In

m_byLeNo
 ) )

126  
FALSE
 ;

127 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

132 
	`tf
( "ModBus don't containhis module Failed .\n" );

133  
FALSE
 ;

136 
m_modu
.
	`push_back

pProc
 ) ;

138  
TRUE
 ;

139 
	}
}

141 
BYTE
 
	gCProc_IEC103
::
	$GCs

BYTE
 * 
pBuf
 , 
n
 )

143 
BYTE
 
byR
 = 0x00;

144 
i
;

146 if
pBuf
 =
NULL
 || 
n
 <= 0 )

147  
byR
;

149  
i
=0; i<
n
 ; i++ )

151 
byR
 +
pBuf
[
i
];

154  
byR
;

155 
	}
}

157 
BOOL
 
	gCProc_IEC103
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

160 
dex
 = 0 ;

161 
buf
[ 
dex
++ ] = 0xFF ;

162 
buf
[ 
dex
++ ] = 0x02 ;

163 
buf
[ 
dex
++ ] = 0x03 ;

164 
buf
[ 
dex
++ ] = 0x04 ;

166 
WORD
 
wCRC
 = 
	`GCs

buf
, 
dex
 );

167 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

168 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

170 
n
 = 
dex
 ;

172 
	`tf
( "\n CProtocol_IEC103 TestBroadCast \n " ) ;

173  
TRUE
 ;

174 
	}
}

186 
BOOL
 
	gCProc_IEC103
::
	$WhhBufVue
 (
BYTE
 *
buf
, &
n
, &
pos
 )

188 
BYTE
 *
por
 = 
buf
;

189 
d
 = 0;

190 
BYTE
 
byCrc
;

191 
PrtBuf
[256];

192 
pos
 = 0;

194 if
buf
 =
NULL
 || 
n
 <= 0 )

195  
FALSE
;

197  
n
 > 0 )

199 *
por
)

203 
n
--;

204 
por
++;

205 
pos
 ++;

211 if(*(
por
+3) != *pointer)

212 || (*(
por
+1) != *(pointer+2)))

214 
n
--;

215 
por
++;

216 
pos
 ++;

222 
d
=*(
por
+1);

223 if
d
+6>
n
 )

225 
n
--;

226 
por
++;

227 
pos
 ++;

228 
	`rtf
(
PrtBuf
, "IEC103ecv d=%d=%d", 
d
, 
n
 );

229 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
PrtBuf
, 
	`
(PrintBuf), 2 );

234 
byCrc
=
	`GCs
(
por
+4,
d
);

235 if(*(
por
+
d
+4)!=
byCrc


236 || *(
por
+
d
+5)!=0x16)

238 
n
--;

239 
por
++;

240 
pos
 ++;

241 
	`rtf
(
PrtBuf
, "IEC103ecv cr GCrc=%d crc=%d oϡ by !0x16 =%x", 
byCrc
, *(
por
+
d
+4), *(pointer+datalen+5));

242 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
PrtBuf
, 
	`
(PrintBuf), 2 );

247 i*(
por
 + 5!
m_wDevAddr
 && *(pointer + 5) != 0xff )

249 
n
--;

250 
por
++;

251 
pos
 ++;

252 
	`rtf
(
PrtBuf
, "IEC103ecvddr Gaddr=%dddr=%d ", *(
por
 + 5), 
m_wDevAddr
 );

253 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
PrtBuf
, 
	`
(PrintBuf), 2 );

258 
n
 = 
d
 + 6;

259 
buf
 = bu+ 
pos
;

260  
TRUE
;

266 
byCrc
=
	`GCs
(
por
+1,2);

267 if*(
por
+3)!=
byCrc
 || *(pointer+4)!=0x16 )

269 
n
--;

270 
por
++;

271 
pos
 ++;

272 
	`rtf
(
PrtBuf
, "IEC103ecv cr GCrc=%d crc=%d oϡ by !0x16 =%x", 
byCrc
, *(
por
+3), *(pointer+4));

273 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
PrtBuf
, 
	`
(PrintBuf), 2 );

278 i*(
por
+2!
m_wDevAddr
 )

280 
n
--;

281 
por
++;

282 
pos
 ++;

283 
	`rtf
(
PrtBuf
, "IEC103ecvddr Gaddr=%dddr=%d ", *(
por
+2), 
m_wDevAddr
 );

284 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
PrtBuf
, 
	`
(PrintBuf), 2 );

287 
buf
 = bu+ 
pos
;

289  
TRUE
;

293 
n
--;

294 
por
++;

295 
pos
 ++;

302  
FALSE
;

303 
	}
}

315 
BYTE
 
	gCProc_IEC103
::
	$ChgeFcb
 ( 
BYTE
 
byCB
, 
BOOL
 &
bFCB
 )

317 if
bFCB
 )

318 
byCB
 &
IEC103_FCB_0
;

320 
byCB
 |
IEC103_FCB_1
;

322 
bFCB
 ^= 1;

324  
byCB
;

325 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/CProtocol_IEC103.h

2 #ide
CPROTOCOL_IEC103_H


3 
	#CPROTOCOL_IEC103_H


	)

5 
	~"../../she/CProc.h
"

6 
	~"../../she/CMhod.h
"

7 
	~<time.h
>

8 
	~<sys/time.h
>

11 
	#IEC103_FCB_1
 0x20

	)

12 
	#IEC103_FCB_0
 0xd

	)

14 
	#IEC103_YX_DATATYPE
 1

	)

15 
	#IEC103_YC_DATATYPE
 2

	)

16 
	#IEC103_YM_DATATYPE
 3

	)

17 
	#IEC103_YK_DATATYPE
 4

	)

18 
	#IEC103_DD_DATATYPE
 5

	)

21 as
	cCProc_IEC103
 : 
public
 
CProc


23 
public
:

24 
CProc_IEC103
();

25 
	mvtu
 ~
CProc_IEC103
();

26 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

27 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

28 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

30 
vtu
 
BYTE
 
GCs
BYTE * 
pBuf
 , 
n
 );

31 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 ) ;

32 
vtu
 
	$TimProc
(){ ; }

34 
vtu
 
BOOL
 
	`WhhBufVue
(
BYTE
 *
buf
, &
n
, &
pos
 );

36 
eed
:

37 
BOOL
 
	`GDevDa
( ) ;

39 
BYTE
 
	`ChgeFcb
(BYTE 
byCB
, 
BOOL
 &
bFCB
);

40 
eed
:

41 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

42 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

44 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/IEC103.cpp

43 
	~"IEC103.h
"

44 
	~"../../she/glob.h
"

48 
	#IEC103DEBUG
 1

49 
	#IEC103BUSDEBUG


	)

50 
	#IEC103DISPLAYCOT


	)

53 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

54 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

62 
	gCIEC103
::
	$CIEC103
 ()

64 
	`InProcStus
( );

65 
	}
}

74 
	gCIEC103
::~
	$CIEC103
 ()

76 
m_IEC103_CfgInfo
.
	`r
();

77 
	}
}

88 
	gCIEC103
::
	$t
 ( *
buf
, 
n
 )

90 #ifde 
IEC103DEBUG


91 
	`tf
 ( "%s\n", 
buf
 );

94 #ifde 
IEC103BUSDEBUG


95 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
buf
, 
	`
(buf), 2 );

97 
	}
}

108 
	gCIEC103
::
	$DiyC
 ( 
BYTE
 
byC
 )

111 #ifde 
IEC103DISPLAYCOT


114  
byC
 )

117 
	`t
( (*)"Է(ͻ)" );

121 
	`t
( (*)"ѭ" );

125 
	`t
( (*)"λ֡" );

129 
	`t
( (*)"λͨŵԪ" );

133 
	`t
( (*)"/" );

137 
	`t
( (*)"Դ" );

141 
	`t
( (*)"ģʽ" );

145 
	`t
( (*)"ʱͬ" );

149 
	`t
( (*)"ܲѯ" );

153 
	`t
( (*)"ܲѯֹ" );

157 
	`t
( (*)"ز" );

161 
	`t
( (*)"Զ" );

165 
	`t
( (*)"϶Ͽ" );

169 
	`t
( (*)"Ͽ" );

173 
	`t
( (*)"Ŷݴ" );

177 
	`t
( (*)"ͨд϶Ͽ" );

181 
	`t
( (*)"ͨдϿ" );

185 
	`t
( (*)"ͨöЧӦ" );

189 
	`t
( (*)"ͨöЧӦ" );

193 
	`t
( (*)"ͨдȷ" );

201 
	}
}

212 
BOOL
 
	gCIEC103
::
	$GModuP

BYTE
 
byDaTy
, BYTE 
byFunTy
, BYTE 
byInfoIndex
, 
WORD
 &
wP
 )

214 
i
;

215  
i
=0; i<()
m_IEC103_CfgInfo
.
	`size
(); i++ )

218 if
byDaTy
 =
m_IEC103_CfgInfo
[
i
].
DaTy
 )

222 if(
byFunTy
 =
m_IEC103_CfgInfo
[
i
].
FunTy
)

223 && (
byInfoIndex
 >
m_IEC103_CfgInfo
[
i
].
InfoIndex
)

224 && (
byInfoIndex
 < (
m_IEC103_CfgInfo
[
i
].
InfoIndex
 + m_IEC103_CfgInfo[i].
DaNum
)))

227 i
m_IEC103_CfgInfo
[
i
].
AddInfo
 == 0 )

229 
wP
 = 
byInfoIndex
 - 
m_IEC103_CfgInfo
[
i
].
InfoIndex
 + m_IEC103_CfgInfo[i].
SIndex
;

231  
TRUE
;

241 i
i
 >()
m_IEC103_CfgInfo
.
	`size
() )

243 
	`rtf

DebugBuf
, "DaTy=%d FunTy=%d InfoIndex=%d found",
byDaTy
, 
byFunTy
, 
byInfoIndex
 );

244 
	`t

DebugBuf
 );

245  
FALSE
;

248  
TRUE
;

249 
	}
}

260 
BOOL
 
	gCIEC103
::
	$GModuInfo
 ( 
BYTE
 
byDaTy
, 
WORD
 
wP
, 
CfgInfo
 &
tCfgInfo
, BYTE &
byFunTy
, BYTE &
byInfoIndex
 )

262 
i
;

263  
i
=0; i<()
m_IEC103_CfgInfo
.
	`size
( ); i++ )

265 if
byDaTy
 =
m_IEC103_CfgInfo
[
i
].
DaTy
 )

267 if(
wP
 >
m_IEC103_CfgInfo
[
i
].
SIndex


268 && 
wP
 < 
m_IEC103_CfgInfo
[
i
].
SIndex
 + m_IEC103_CfgInfo[i].
DaNum
 )

270 
byFunTy
 = 
m_IEC103_CfgInfo
[
i
].
FunTy
;

271 
byInfoIndex
 = 
wP
 - 
m_IEC103_CfgInfo
[
i
].
SIndex
 + m_IEC103_CfgInfo[i].
InfoIndex
;

272 
	`memy
&
tCfgInfo
, &
m_IEC103_CfgInfo
[
i
], (
CfgInfo
));

273  
TRUE
;

278 i
i
 >()
m_IEC103_CfgInfo
.
	`size
() )

280 
	`rtf

DebugBuf
, "yk wP = %d found", 
wP
);

281 
	`t

DebugBuf
 );

282  
FALSE
;

285  
TRUE
;

286 
	}
}

297 
BOOL
 
	gCIEC103
::
	$M_IRCFS_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

299 
BYTE
 
C
 = 
buf
[8];

301  
C
 )

307 
	`t
( (*)"λͨŵԪ(CU)" );

308 
m_SdStus
 = 
C_SYN_Ta_3
;

312 
	`t
( (*)"/ лʱͬ" );

313 
m_SdStus
 = 
C_SYN_Ta_3
;

320  
FALSE
;

323  
TRUE
;

324 
	}
}

335 
BOOL
 
	gCIEC103
::
	$C_SYN_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

337  
TRUE
;

338 
	}
}

349 
BOOL
 
	gCIEC103
::
	$M_TGI_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

351  
TRUE
;

352 
	}
}

363 
BOOL
 
	gCIEC103
::
	$M_TTM_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

365 
BYTE
 
byFunTy
 = 0;

366 
BYTE
 
byInfoIndex
 = 0;

367 
BYTE
 
byYxVue
;

368 
WORD
 
wP
;

369 
TIMEDATA
 
tTimeDa
;

370 
TIMEDATA
 *
pTime
 = &
tTimeDa
;

371 
WORD
 
wMiSec
;

374 i
n
 !20 || ((
buf
[7] & 0x7f) != 1) )

375  
FALSE
;

377 
	`DiyC

buf
[8] );

379 
byFunTy
 = 
buf
[10];

380 
byInfoIndex
 = 
buf
[11];

383 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
, 
wP
 ) )

385  
FALSE
;

389 
byYxVue
 = 
buf
[12] & 0x03;

390 if
byYxVue
 != 0x02 && byYxValue != 0x01)

392  
FALSE
;

396 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
-1 );

399 
wMiSec
 = 
buf
[13] | buf[14] << 8;

400 
pTime
->
MiSec
 = 
wMiSec
 % 1000;

401 
pTime
->
Secd
 = 
wMiSec
/1000;

402 
pTime
->
Mu
 = 
buf
[15] & 0x3f;

403 
pTime
->
Hour
 = 
buf
[16] & 0x1f;

405 
REALTIME
 
curTime
;

406 
	`GCutTime
&
curTime
 );

407 
pTime
->
Day
 = 
curTime
.
wDay
;

408 
pTime
->
Mth
 = 
curTime
.
wMth
;

409 
pTime
->
Yr
 = 
curTime
.
wYr
 - 1900;

413 
	`rtf

DebugBuf
, "YxUpde:dev%d%d=%dime=%d-%d-%d %d:%d:%d", 
m_wDevAddr
, 
wP
, 
byYxVue
-1,

414 
pTime
->
Yr
+1900,

415 
pTime
->
Mth
,

416 
pTime
->
Day
,

417 
pTime
->
Hour
,

418 
pTime
->
Mu
,

419 
pTime
->
Secd
);

420 
	`t

DebugBuf
 );

422  
TRUE
 ;

423 
	}
}

434 
BOOL
 
	gCIEC103
::
	$M_TMR_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

436 
BYTE
 
byFunTy
 = 0;

437 
BYTE
 
byInfoIndex
 = 0;

438 
BYTE
 
byYxVue
;

439 
WORD
 
wP
;

440 
TIMEDATA
 
tTimeDa
;

441 
TIMEDATA
 *
pTime
 = &
tTimeDa
;

442 
WORD
 
wMiSec
;

445 i
n
 !24 || ((
buf
[7] & 0x7f) != 1) )

446  
FALSE
;

448 
	`DiyC

buf
[8] );

450 
byFunTy
 = 
buf
[10];

451 
byInfoIndex
 = 
buf
[11];

454 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
, 
wP
 ) )

456  
FALSE
;

460 
byYxVue
 = 
buf
[12] & 0x03;

461 if
byYxVue
 != 0x02 && byYxValue != 0x01)

463  
FALSE
;

467 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
-1 );

470 
wMiSec
 = 
buf
[17] | buf[18] << 8;

471 
pTime
->
MiSec
 = 
wMiSec
 % 1000;

472 
pTime
->
Secd
 = 
wMiSec
/1000;

473 
pTime
->
Mu
 = 
buf
[19] & 0x3f;

474 
pTime
->
Hour
 = 
buf
[20] & 0x1f;

476 
REALTIME
 
curTime
;

477 
	`GCutTime
&
curTime
 );

479 
pTime
->
Day
 = 
curTime
.
wDay
;

480 
pTime
->
Mth
 = 
curTime
.
wMth
;

481 
pTime
->
Yr
 = 
curTime
.
wYr
 - 1900;

485 
	`rtf

DebugBuf
, "YxUpde:dev%d%d=%dime=%d-%d-%d %d:%d:%d", 
m_wDevAddr
, 
wP
, 
byYxVue
-1,

486 
pTime
->
Yr
+1900,

487 
pTime
->
Mth
,

488 
pTime
->
Day
,

489 
pTime
->
Hour
,

490 
pTime
->
Mu
,

491 
pTime
->
Secd
);

492 
	`t

DebugBuf
 );

494  
TRUE
;

495 
	}
}

506 
BOOL
 
	gCIEC103
::
	$M_SP_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

508 
BYTE
 
byYxNum
;

509 
BYTE
 
byFunTy
;

510 
BYTE
 
byInfoIndex
;

511 
BYTE
 
byYxVue
;

512 
WORD
 
wP
;

513 
i
=0;

515 
byYxNum
 = 
buf
[7] & 0x7f;

517 
	`DiyC

buf
[8] );

519 if0x80 & 
buf
[7] )

523 i13 + 3 * 
byYxNum
 ) !
n
 )

524  
FALSE
;

526  
i
=0; i<
byYxNum
; i++ )

528 
byFunTy
 = 
buf
[10 + 3 * 
i
];

529 
byInfoIndex
 = 
buf
[11 + 3 * 
i
];

532 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
, 
wP
 ) )

538 
byYxVue
 = 
buf
[12 + 3 * 
i
] & 0x01;

541 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

548 i15 + 
byYxNum
 ) !
n
 )

549  
FALSE
;

551 
byFunTy
 = 
buf
[10];

552 
byInfoIndex
 = 
buf
[11];

553  
i
=0; i<
byYxNum
; i++ )

556 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

562 
byYxVue
 = 
buf
[12 + 
i
] & 0x01;

565 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

570  
TRUE
;

571 
	}
}

582 
BOOL
 
	gCIEC103
::
	$M_DP_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

584 
BYTE
 
byYxNum
;

585 
BYTE
 
byFunTy
;

586 
BYTE
 
byInfoIndex
;

587 
BYTE
 
byYxVue
;

588 
WORD
 
wP
;

589 
i
=0;

591 
byYxNum
 = 
buf
[7] & 0x7f;

592 
	`DiyC

buf
[8] );

594 if0x80 & 
buf
[7] )

598 i13 + 3 * 
byYxNum
 ) !
n
 )

599  
FALSE
;

601  
i
=0; i<
byYxNum
; i++ )

603 
byFunTy
 = 
buf
[10 + 3 * 
i
];

604 
byInfoIndex
 = 
buf
[11 + 3 * 
i
];

607 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
, 
wP
 ) )

613 
byYxVue
 = 
buf
[12 + 3 * 
i
] & 0x03;

614 i
byYxVue
 != 0x01 && byYxValue != 0x02 )

620 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
-1 );

628 i15 + 
byYxNum
 ) !
n
 )

629  
FALSE
;

631 
byFunTy
 = 
buf
[10];

632 
byInfoIndex
 = 
buf
[11];

633  
i
=0; i<
byYxNum
; i++ )

636 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

638  
FALSE
;

642 
byYxVue
 = 
buf
[12 + 3 * 
i
] & 0x03;

643 i
byYxVue
 != 0x01 && byYxValue != 0x02 )

649 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
-1 );

653  
TRUE
;

654 
	}
}

665 
BOOL
 
	gCIEC103
::
	$M_SP_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

667 
BYTE
 
byYxNum
;

668 
BYTE
 
byFunTy
;

669 
BYTE
 
byInfoIndex
;

670 
BYTE
 
byYxVue
;

671 
WORD
 
wMiSec
;

672 
TIMEDATA
 
tTimeDa
;

673 
TIMEDATA
 *
pTime
 = &
tTimeDa
;

674 
REALTIME
 
curTime
;

675 
WORD
 
wP
;

676 
i
=0;

678 
byYxNum
 = 
buf
[7] & 0x7f;

679 
	`DiyC

buf
[8] );

683 i13 + 7 * 
byYxNum
 ) !
n
 )

684  
FALSE
;

686 
	`GCutTime
&
curTime
 );

688  
i
=0; i<
byYxNum
; i++)

690 
byFunTy
 = 
buf
[10 + 7 * 
i
];

691 
byInfoIndex
 = 
buf
[11 + 7 * 
i
];

694 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
, 
wP
 ) )

700 
byYxVue
 = 
buf
[12 + 7 * 
i
] & 0x01;

703 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

706 
wMiSec
 = 
buf
[13] | buf[14] << 8;

707 
pTime
->
MiSec
 = 
wMiSec
 % 1000;

708 
pTime
->
Secd
 = 
wMiSec
/1000;

709 
pTime
->
Mu
 = 
buf
[15] & 0x3f;

710 
pTime
->
Hour
 = 
buf
[16] & 0x1f;

712 
pTime
->
Day
 = 
curTime
.
wDay
;

713 
pTime
->
Mth
 = 
curTime
.
wMth
;

714 
pTime
->
Yr
 = 
curTime
.
wYr
 - 1900;

717 
m_pMhod
->
	`SYxDaWhTime

m_SlNo
, 
wP
, 
byYxVue
, 
pTime
);

719  
TRUE
 ;

720 
	}
}

731 
BOOL
 
	gCIEC103
::
	$M_DP_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

733 
BYTE
 
byYxNum
;

734 
BYTE
 
byFunTy
;

735 
BYTE
 
byInfoIndex
;

736 
BYTE
 
byYxVue
;

737 
WORD
 
wP
;

738 
TIMEDATA
 
tTimeDa
;

739 
TIMEDATA
 *
pTime
 = &
tTimeDa
;

740 
REALTIME
 
curTime
;

741 
WORD
 
wMiSec
;

742 
i
=0;

744 
byYxNum
 = 
buf
[7] & 0x7f;

748 i13 + 7 * 
byYxNum
 ) !
n
 )

749  
FALSE
;

750 
	`DiyC

buf
[8] );

752 
	`GCutTime
&
curTime
 );

754  
i
=0; i<
byYxNum
; i++)

756 
byFunTy
 = 
buf
[10 + 7 * 
i
];

757 
byInfoIndex
 = 
buf
[11 + 7 * 
i
];

760 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
, 
wP
 ) )

766 
byYxVue
 = 
buf
[12 + 7 * 
i
] & 0x03;

767 i
byYxVue
 != 0x01 && byYxValue != 0x02 )

773 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
-1 );

776 
wMiSec
 = 
buf
[13] | buf[14] << 8;

777 
pTime
->
MiSec
 = 
wMiSec
 % 1000;

778 
pTime
->
Secd
 = 
wMiSec
/1000;

779 
pTime
->
Mu
 = 
buf
[15] & 0x3f;

780 
pTime
->
Hour
 = 
buf
[16] & 0x1f;

782 
pTime
->
Day
 = 
curTime
.
wDay
;

783 
pTime
->
Mth
 = 
curTime
.
wMth
;

784 
pTime
->
Yr
 = 
curTime
.
wYr
 - 1900;

787 
m_pMhod
->
	`SYxDaWhTime

m_SlNo
, 
wP
, 
byYxVue
-1, 
pTime
);

790  
TRUE
 ;

791 
	}
}

802 
BOOL
 
	gCIEC103
::
	$M_SS_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

804 
BYTE
 
byYxNum
;

805 
BYTE
 
byFunTy
;

806 
BYTE
 
byInfoIndex
;

807 
BYTE
 
byYxVue
;

808 
WORD
 
wSt
;

809 
WORD
 
wP
;

810 
i
=0, 
j
=0;

812 
byYxNum
 = 
buf
[7] & 0x3f;

813 
	`DiyC

buf
[8] );

815 i
buf
[7] & 0x80 )

819 if13 + 7 * 
byYxNum
 !
n
 )

820  
FALSE
;

822  
i
=0; i<
byYxNum
; i++)

824 
byFunTy
 = 
buf
[10 + 7 * 
i
];

825 
byInfoIndex
 = 
buf
[11 + 7 * 
i
];

826 
wSt
 = 
buf
[12 + 7 * 
i
] | buf[13 + 7 * i];

828  
j
=0; j<16; j++)

831 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
j
+
i
*16, 
wP
 ) )

836 if
wSt
 & (1 << 
j
) )

838 
byYxVue
 = 1;

842 
byYxVue
 = 0;

846 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

855 if15 + 5 * 
byYxNum
 !
n
 )

856  
FALSE
;

858 
byFunTy
 = 
buf
[10 + 5 * 
i
];

859 
byInfoIndex
 = 
buf
[11 + 5 * 
i
];

861  
i
=0; i<
byYxNum
; i++)

863 
wSt
 = 
buf
[12 + 5 * 
i
] | buf[13 + 5 * i];

865  
j
=0; j<16; j++)

868 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
j
+
i
*16, 
wP
 ) )

873 if
wSt
 & (1 << 
j
) )

875 
byYxVue
 = 1;

879 
byYxVue
 = 0;

883 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

888  
TRUE
;

889 
	}
}

900 
BOOL
 
	gCIEC103
::
	$M_DS_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

902 
BYTE
 
byYxNum
;

903 
BYTE
 
byFunTy
;

904 
BYTE
 
byInfoIndex
;

905 
BYTE
 
byYxVue
;

906 
WORD
 
wSt
;

907 
WORD
 
wP
;

908 
i
=0, 
j
=0;

910 
byYxNum
 = 
buf
[7] & 0x3f;

911 
	`DiyC

buf
[8] );

913 i
buf
[7] & 0x80 )

917 if13 + 7 * 
byYxNum
 !
n
 )

918  
FALSE
;

920  
i
=0; i<
byYxNum
; i++)

922 
byFunTy
 = 
buf
[10 + 7 * 
i
];

923 
byInfoIndex
 = 
buf
[11 + 7 * 
i
];

924 
wSt
 = 
buf
[12 + 7 * 
i
] | buf[13 + 7 * i];

926  
j
=0; j<8; j++)

929 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
j
+
i
*8, 
wP
 ) )

935 if
wSt
 & ( 0x03 << (2*
j
) ) ) >> (2*j) ==0x02)

937 
byYxVue
=1;

939 if((
wSt
 & ( 0x03 << (2*
j
) ) ) >> (2*j) == 0x01)

941 
byYxVue
=0;

949 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

958 if15 + 5 * 
byYxNum
 !
n
 )

959  
FALSE
;

961 
byFunTy
 = 
buf
[10 + 5 * 
i
];

962 
byInfoIndex
 = 
buf
[11 + 5 * 
i
];

963  
i
=0; i<
byYxNum
; i++)

965 
wSt
 = 
buf
[12 + 5 * 
i
] | buf[13 + 5 * i];

967  
j
=0; j<16; j++)

970 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
j
+
i
*16, 
wP
 ) )

976 if
wSt
 & ( 0x03 << (2*
j
) ) ) >> (2*j) ==0x02)

978 
byYxVue
=1;

980 if((
wSt
 & ( 0x03 << (2*
j
) ) ) >> (2*j) == 0x01)

982 
byYxVue
=0;

990 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

995  
TRUE
;

996 
	}
}

1007 
BOOL
 
	gCIEC103
::
	$M_SS_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1009 
BYTE
 
byYxNum
;

1010 
BYTE
 
byFunTy
;

1011 
BYTE
 
byInfoIndex
;

1012 
BYTE
 
byYxVue
;

1013 
WORD
 
wSt
;

1014 
WORD
 
wP
;

1015 
TIMEDATA
 
tTimeDa
;

1016 
TIMEDATA
 *
pTime
 = &
tTimeDa
;

1017 
REALTIME
 
curTime
;

1018 
WORD
 
wMiSec
;

1019 
i
=0, 
j
=0;

1021 
byYxNum
 = 
buf
[7] & 0x7f;

1024 if14 + 10 * 
byYxNum
 !
n
 )

1025  
FALSE
;

1026 
	`DiyC

buf
[8] );

1029 
	`GCutTime
&
curTime
 );

1031 
byFunTy
 = 
buf
[10];

1033  
i
=0; i<
byYxNum
; i++)

1035 
byFunTy
 = 
buf
[10];

1036 
byInfoIndex
 = 
buf
[11 + 10 * 
i
];

1037 
wSt
 = 
buf
[12 + 10 * 
i
] | buf[13 + 10 * i];

1040 
wMiSec
 = 
buf
[17] | buf[18] << 8;

1041 
pTime
->
MiSec
 = 
wMiSec
 % 1000;

1042 
pTime
->
Secd
 = 
wMiSec
/1000;

1043 
pTime
->
Mu
 = 
buf
[19] & 0x3f;

1044 
pTime
->
Hour
 = 
buf
[20] & 0x1f;

1045 
pTime
->
Day
 = 
curTime
.
wDay
;

1046 
pTime
->
Mth
 = 
curTime
.
wMth
;

1047 
pTime
->
Yr
 = 
curTime
.
wYr
 - 1900;

1049  
j
=0; j<16; j++)

1052 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
j
 + 
i
*16, 
wP
 ) )

1057 if
wSt
 & (1 << 
j
) )

1059 
byYxVue
 = 1;

1063 
byYxVue
 = 0;

1067 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

1069 
m_pMhod
->
	`SYxDaWhTime

m_SlNo
, 
wP
, 
byYxVue
, 
pTime
);

1073  
TRUE
;

1074 
	}
}

1085 
BOOL
 
	gCIEC103
::
	$M_DS_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1087 
BYTE
 
byYxNum
;

1088 
BYTE
 
byFunTy
;

1089 
BYTE
 
byInfoIndex
;

1090 
BYTE
 
byYxVue
;

1091 
WORD
 
wSt
;

1092 
WORD
 
wP
;

1093 
TIMEDATA
 
tTimeDa
;

1094 
TIMEDATA
 *
pTime
 = &
tTimeDa
;

1095 
REALTIME
 
curTime
;

1096 
WORD
 
wMiSec
;

1097 
i
=0, 
j
=0;

1099 
byYxNum
 = 
buf
[7] & 0x7f;

1102 if14 + 10 * 
byYxNum
 !
n
 )

1103  
FALSE
;

1104 
	`DiyC

buf
[8] );

1107 
	`GCutTime
&
curTime
 );

1109 
byFunTy
 = 
buf
[10];

1110  
i
=0; i<
byYxNum
; i++)

1112 
byInfoIndex
 = 
buf
[11 + 10 * 
i
];

1113 
wSt
 = 
buf
[12 + 10 * 
i
] | buf[13 + 10 * i];

1116 
wMiSec
 = 
buf
[17] | buf[18] << 8;

1117 
pTime
->
MiSec
 = 
wMiSec
 % 1000;

1118 
pTime
->
Secd
 = 
wMiSec
/1000;

1119 
pTime
->
Mu
 = 
buf
[19] & 0x3f;

1120 
pTime
->
Hour
 = 
buf
[20] & 0x1f;

1121 
pTime
->
Day
 = 
curTime
.
wDay
;

1122 
pTime
->
Mth
 = 
curTime
.
wMth
;

1123 
pTime
->
Yr
 = 
curTime
.
wYr
 - 1900;

1125  
j
=0; j<8; j++)

1128 if!
	`GModuP

IEC103_YX_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
j
+
i
+8, 
wP
 ) )

1134 if
wSt
 & ( 0x03 << (2*
j
) ) ) >> (2*j) ==0x02)

1136 
byYxVue
=1;

1138 if((
wSt
 & ( 0x03 << (2*
j
) ) ) >> (2*j) == 0x01)

1140 
byYxVue
=0;

1148 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

1150 
m_pMhod
->
	`SYxDaWhTime

m_SlNo
, 
wP
, 
byYxVue
, 
pTime
);

1155  
TRUE
;

1156 
	}
}

1167 
BOOL
 
	gCIEC103
::
	$M_MEI_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1169 
BYTE
 
byYcNum
 = 
buf
[7] & 0x7f;

1170 
BYTE
 
byFunTy
;

1171 
BYTE
 
byInfoIndex
;

1172 
WORD
 
wYcVue
;

1173 
WORD
 
wP
;

1174 
fYcVue
;

1175 
i
=0;

1179 if14 + 
byYcNum
 * 2!
n
 )

1180  
FALSE
;

1181 
	`DiyC

buf
[8] );

1183 
byFunTy
 = 
buf
[10];

1184 
byInfoIndex
 = 
buf
[11];

1186 
i
=0; i<
byYcNum
; i++)

1189 if!
	`GModuP

IEC103_YC_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

1196 
wYcVue
 = 
buf
[12+2*
i
] | ( buf[13+2*i] << 8 );

1197 
wYcVue
=(wYcValue>>3)&0x1FFF;

1198 if(
wYcVue
&0x1000)

1200 
wYcVue
=((~wYcValue)+1)&0x1FFF;

1201 
fYcVue
=
wYcVue
;

1202 
fYcVue
=-fYcValue;

1206 
fYcVue
=
wYcVue
;

1209 
fYcVue
/=4096.0;

1213 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
, 
fYcVue
 );

1214 
	`rtf

DebugBuf
, "YcUpde:dev%d%d=%f", 
m_wDevAddr
, 
wP
, 
fYcVue
 );

1215 
	`t

DebugBuf
 );

1218  
TRUE
;

1219 
	}
}

1230 
BOOL
 
	gCIEC103
::
	$M_TME_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1239 i
n
 != 26 )

1240  
FALSE
;

1241 
	`DiyC

buf
[8] );

1245  
TRUE
;

1246 
	}
}

1257 
BOOL
 
	gCIEC103
::
	$M_MEII_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1259  
	`M_MEI_NA_3_Fme

buf
, 
n
 );

1260 
	}
}

1271 
BOOL
 
	gCIEC103
::
	$M_MEIII_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1274  
TRUE
;

1275 
	}
}

1287 
BOOL
 
	gCIEC103
::
	$M_MEIII_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1290 
BYTE
 
byYcNum
 = 
buf
[7] & 0x7f;

1291 
BYTE
 
byFunTy
;

1292 
BYTE
 
byInfoIndex
;

1293 
WORD
 
wYcVue
;

1294 
WORD
 
wP
;

1295 
fYcVue
;

1296 
i
=0;

1300 if18 + 
byYcNum
 * 2!
n
 )

1301  
FALSE
;

1302 
	`DiyC

buf
[8] );

1304 
	`DiyC

buf
[8] );

1306 
byFunTy
 = 
buf
[10];

1307 
byInfoIndex
 = 
buf
[11];

1309 
i
=0; i<
byYcNum
; i++)

1312 if!
	`GModuP

IEC103_YC_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

1319 
wYcVue
 = 
buf
[12+2*
i
] | ( buf[13+2*i] << 8 );

1320 
wYcVue
=(wYcValue>>3)&0x1FFF;

1321 if(
wYcVue
&0x1000)

1323 
wYcVue
=((~wYcValue)+1)&0x1FFF;

1324 
fYcVue
=
wYcVue
;

1325 
fYcVue
=-fYcValue;

1329 
fYcVue
=
wYcVue
;

1332 
fYcVue
/=4096.0;

1336 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
, 
fYcVue
 );

1339  
TRUE
;

1343 
	}
}

1355 
BOOL
 
	gCIEC103
::
	$M_MEIV_TA_3_Fme
 ( 
BYTE
 *
buf
 , 
n
 )

1357  
	`M_MEIII_TA_3_Fme

buf
, 
n
 );

1360 
	}
}

1372 
BOOL
 
	gCIEC103
::
	$M_MEV_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1374  
TRUE
;

1375 
	}
}

1386 
BOOL
 
	gCIEC103
::
	$M_MEVI_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1388  
TRUE
;

1389 
	}
}

1400 
BOOL
 
	gCIEC103
::
	$M_MEVII_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1402 
BYTE
 
byYcNum
 = 
buf
[7] & 0x7f;

1403 
BYTE
 
byFunTy
;

1404 
BYTE
 
byInfoIndex
;

1405 
WORD
 
wYcVue
;

1406 
WORD
 
wP
;

1407 
fYcVue
;

1408 
i
=0;

1410 
	`DiyC

buf
[8] );

1412 if
buf
[7] & 0x80 )

1416 if13 + 
byYcNum
 * 3!
n
 )

1417  
FALSE
;

1419 
byFunTy
 = 
buf
[10];

1420 
i
=0; i<
byYcNum
; i++)

1422 
byInfoIndex
 = 
buf
[11 + 3 * 
i
];

1424 if!
	`GModuP

IEC103_YC_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

1430 
wYcVue
 = 
buf
[12+3*
i
] | ( buf[13+3*i] << 8 );

1431 
wYcVue
=(wYcValue>>3)&0x1FFF;

1432 if(
wYcVue
&0x1000)

1434 
wYcVue
=((~wYcValue)+1)&0x1FFF;

1435 
fYcVue
=
wYcVue
;

1436 
fYcVue
=-fYcValue;

1440 
fYcVue
=
wYcVue
;

1442 
fYcVue
/=4096.0;

1446 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
, 
fYcVue
 );

1452 
byFunTy
 = 
buf
[10];

1453 
byInfoIndex
 = 
buf
[11 ];

1455 
i
=0; i<
byYcNum
; i++)

1458 if!
	`GModuP

IEC103_YC_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

1465 
wYcVue
 = 
buf
[12+3*
i
] | ( buf[13+3*i] << 8 );

1466 
wYcVue
=(wYcValue>>3)&0x1FFF;

1467 if(
wYcVue
&0x1000)

1469 
wYcVue
=((~wYcValue)+1)&0x1FFF;

1470 
fYcVue
=
wYcVue
;

1471 
fYcVue
=-fYcValue;

1475 
fYcVue
=
wYcVue
;

1478 
fYcVue
/=4096.0;

1482 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
, 
fYcVue
 );

1485  
	`M_MEI_NA_3_Fme

buf
, 
n
 );

1487  
TRUE
;

1488 
	}
}

1499 
BOOL
 
	gCIEC103
::
	$M_IT_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1501 
BYTE
 
byYmNum
 = 
buf
[7] & 0x7f;

1502 
BYTE
 
byFunTy
;

1503 
BYTE
 
byInfoIndex
;

1504 
WORD
 
wP
;

1505 
DWORD
 
dwYmVue
;

1506 
fYmVue
;

1507 
BYTE
 
byYmBuf
[4];

1508 
i
=0;

1511 if15 + 
byYmNum
 * 5!
n
 )

1512  
FALSE
;

1514 
	`DiyC

buf
[8] );

1515 
byFunTy
 = 
buf
[10];

1516 
byInfoIndex
 = 
buf
[11];

1518  
i
=0; i<
byYmNum
; i++)

1520 if!
	`GModuP

IEC103_YM_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

1525 
	`GlobCyByEndn

byYmBuf
, &
buf
[12 + 5*
i
 ], 4);

1532 
	`memy
&
dwYmVue
, 
byYmBuf
, 4 );

1533 
fYmVue
 = ()
dwYmVue
;

1535 
m_pMhod
->
	`SYmDa

m_SlNo
, 
wP
, 
fYmVue
 );

1537  
TRUE
;

1538 
	}
}

1550 
BOOL
 
	gCIEC103
::
	$M_IT_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1552 
BYTE
 
byYmNum
 = 
buf
[7] & 0x7f;

1553 
BYTE
 
byFunTy
;

1554 
BYTE
 
byInfoIndex
;

1555 
WORD
 
wP
;

1556 
DWORD
 
dwYmVue
;

1557 
fYmVue
;

1558 
BYTE
 
byYmBuf
[4];

1559 
i
 = 0;

1562 if15 + 
byYmNum
 * 9!
n
 )

1563  
FALSE
;

1565 
	`DiyC

buf
[8] );

1566 
byFunTy
 = 
buf
[10];

1567 
byInfoIndex
 = 
buf
[11];

1569  
i
=0; i<
byYmNum
; i++)

1571 if!
	`GModuP

IEC103_YM_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

1577 
	`GlobCyByEndn
(
byYmBuf
, &
buf
[12 + 9 * 
i
], 4);

1583 
	`memy
&
dwYmVue
, 
byYmBuf
, 4 );

1584 
fYmVue
 = ()
dwYmVue
;

1586 
m_pMhod
->
	`SYmDa

m_SlNo
, 
wP
, 
fYmVue
 );

1588  
TRUE
;

1589 
	}
}

1600 
BOOL
 
	gCIEC103
::
	$M_IT_TA_3_SIPROTEC_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1602 
BYTE
 
byYmNum
 = 
buf
[7] & 0x7f;

1603 
BYTE
 
byFunTy
;

1604 
BYTE
 
byInfoIndex
;

1605 
WORD
 
wP
;

1606 
DWORD
 
dwYmVue
;

1607 
fYmVue
;

1608 
BYTE
 
byYmBuf
[4];

1609 
i
 = 0;

1612 if14 + 
byYmNum
 * 8!
n
 )

1613  
FALSE
;

1615 
	`DiyC

buf
[8] );

1616 
byFunTy
 = 
buf
[10];

1617 
byInfoIndex
 = 
buf
[11];

1619  
i
=0; i<
byYmNum
; i++)

1621 if!
	`GModuP

IEC103_YM_DATATYPE
, 
byFunTy
, 
byInfoIndex
+
i
, 
wP
 ) )

1631 
	`GlobCyByEndn
(
byYmBuf
,&
buf
[12 + 8 * 
i
], 4);

1633 
	`memy
&
dwYmVue
, 
byYmBuf
, 4 );

1634 
fYmVue
 = ()
dwYmVue
;

1636 
m_pMhod
->
	`SYmDa

m_SlNo
, 
wP
, 
fYmVue
 );

1637 
	`rtf

DebugBuf
, "YmUpde:dev%d%d=%lu ", 
m_wDevAddr
, 
wP
, 
dwYmVue
);

1638 
	`t

DebugBuf
 );

1641  
TRUE
;

1642 
	}
}

1653 
BOOL
 
	gCIEC103
::
	$C_DC_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 )

1655 
BYTE
 
byFunTy
;

1656 
BYTE
 
byInfoIndex
;

1657 
WORD
 
wP
;

1658 
BYTE
 
byYkVue
;

1659 
BYTE
 
byDaTy
;

1661 
	`DiyC

buf
[8] );

1663 if
m_wDevAddr
 !
buf
[5] && 0x0c != buf[8] && 0x14 != buf[8] )

1664  
FALSE
;

1666 
byYkVue
 = 
buf
[12] & 0x03;

1667 if
byYkVue
 != 0x01 && byYkValue != 0x02 )

1668  
FALSE
;

1670 
byFunTy
 = 
buf
[10];

1671 
byInfoIndex
 = 
buf
[11];

1672 if!
	`GModuP

IEC103_YK_DATATYPE
, 
byFunTy
, 
byInfoIndex
, 
wP
 ) )

1673  
FALSE
;

1676 
byDaTy
 = 
buf
[12] & 0xc0;

1677 if
byDaTy
 == 0x80 )

1678 
m_pMhod
->
	`SYkSR

this
, 
m_byRemeBusNo
, 
m_byRemeAddr
, 
wP
, 
byYkVue
 - 1 );

1679 i
byDaTy
 == 0 )

1680 
m_pMhod
->
	`SYkExeR

this
, 
m_byRemeBusNo
, 
m_byRemeAddr
, 
wP
, 
byYkVue
 - 1 );

1682 
m_pMhod
->
	`SYkClR
(
this
, 
m_byRemeBusNo
, 
m_byRemeAddr
, 
wP
, 
byYkVue
 - 1);

1683  
TRUE
;

1684 
	}
}

1695 
BOOL
 
	gCIEC103
::
	$ProssHd10Buf
 ( 
BYTE
 *
buf
, 
n
 )

1707 if
m_bIsTٮCl
 )

1709 
m_SdStus
 = 
C_IGI_NA_3
;

1710 
m_bIsTٮCl
 = 
FALSE
;

1712 if
m_bIsYmCl
 )

1714 
m_SdStus
 = 
C_PL1_NA_3
;

1715 
m_bIsYmCl
 = 
FALSE
;

1717 if
buf
[1] & 0x20 )

1719 
m_SdStus
 = 
C_PL1_NA_3
;

1723 
m_SdStus
 = 
C_PL2_NA_3
;

1726  
buf
[1] & 0x0f )

1729 
	`t
( (*)"ȷ֡" );

1733 
	`t
( (*)"֡" );

1737 
	`t
( (*)"ٻ" );

1741 
	`t
( (*)"·״̬ش֡" );

1766 
	`t
( (*)"default" );

1767  
FALSE
;

1772  
TRUE
;

1773 
	}
}

1784 
BOOL
 
	gCIEC103
::
	$ProssHd68Buf
 ( 
BYTE
 *
buf
, 
n
 )

1786 
BOOL
 
bR
 = 
TRUE
;

1792 if
m_bIsTٮCl
 )

1794 
m_SdStus
 = 
C_IGI_NA_3
;

1795 
m_bIsTٮCl
 = 
FALSE
;

1797 if
buf
[4] & 0x20 )

1798 
m_SdStus
 = 
C_PL1_NA_3
;

1800 
m_SdStus
 = 
C_PL2_NA_3
;

1802  
buf
[6] )

1805 
	`t
( (*)"ʶ ASDU5" );

1806 
bR
 = 
	`M_IRCFS_TA_3_Fme

buf
, 
n
 );

1810 
	`t
( (*)"ʱͬ ASDU6 лܲѯ" );

1811 
bR
 = 
	`C_SYN_TA_3_Fme

buf
, 
n
 );

1812 
m_SdStus
 = 
C_IGI_NA_3
;

1813 
m_bIsTٮCl
 = 
TRUE
;

1817 
	`t
( (*)"ܲѯ ASDU8 ٻң" );

1818 
m_bIsYmCl
 = 
TRUE
;

1819 
bR
 = 
	`M_TGI_NA_3_Fme

buf
, 
n
 );

1821 
m_SdStus
 = 
C_CI_NA_3
;

1825 
	`t
( (*)"ʱı ASDU1" );

1826 
bR
 = 
	`M_TTM_TA_3_Fme

buf
, 
n
 );

1830 
	`t
( (*)"ʱʱ걨 ASDU2" );

1831 
bR
 = 
	`M_TMR_TA_3_Fme

buf
, 
n
 );

1835 
	`t
( (*)"ٻʱĵϢ״̬֡ ASDU40" );

1836 
bR
 = 
	`M_SP_NA_3_Fme
(
buf
, 
n
);

1840 
	`t
( (*)"ٻʱ˫Ϣ״̬֡ ASDU42" );

1841 
bR
 = 
	`M_DP_NA_3_Fme
(
buf
, 
n
);

1845 
	`t
( (*)"ʱĵϢ״̬仯֡ ASDU41" );

1846 
bR
 = 
	`M_SP_TA_3_Fme
(
buf
, 
n
);

1850 
	`t
( (*)"ʱ˫Ϣ״̬仯֡ ASDU43" );

1851 
bR
 = 
	`M_DP_TA_3_Fme
(
buf
, 
n
);

1855 
	`t
( (*)"ٻʱĵ״̬״̬仯Ϣ֡ ASDU44" );

1856 
bR
 = 
	`M_SS_NA_3_Fme
(
buf
, 
n
);

1860 
	`t
( (*)"ٻʱ˫״̬״̬仯Ϣ֡ ASDU46" );

1861 
bR
 = 
	`M_DS_NA_3_Fme
(
buf
, 
n
);

1865 
	`t
( (*)"״̬仯ʱĵ״̬״̬仯Ϣ ASDU45" );

1866 
bR
 = 
	`M_SS_TA_3_Fme
(
buf
, 
n
);

1870 
	`t
( (*)"״̬仯ʱ˫״̬״̬仯Ϣ ASDU47" );

1871 
bR
 = 
	`M_DS_TA_3_Fme
(
buf
, 
n
);

1875 
	`t
( (*)"ֵI ASDU3" );

1876 
bR
 = 
	`M_MEI_NA_3_Fme

buf
, 
n
 );

1880 
	`t
( (*)"ʱʱ걻ֵ ASDU4" );

1881 
	`M_TME_TA_3_Fme
(
buf
, 
n
);

1885 
	`t
( (*)"ֵII ASUD9" );

1886 
bR
 = 
	`M_MEII_NA_3_Fme

buf
, 
n
 );

1890 
	`t
( (*)"ֵIII ASDU15" );

1891 
bR
 = 
	`M_MEIII_NA_3_Fme

buf
, 
n
 );

1895 
	`t
( (*)"ֵIII ASDU32" );

1896 
bR
 = 
	`M_MEIII_TA_3_Fme

buf
, 
n
 );

1900 
	`t
( (*)"ֵIV ASDU33 " );

1901 
bR
 = 
	`M_MEIV_TA_3_Fme

buf
, 
n
 );

1905 
	`t
( (*)"ֵV ASDU34 " );

1906 
bR
 = 
	`M_MEV_TA_3_Fme

buf
, 
n
 );

1910 
	`t
( (*)"ʱıֵVI ASDU35" );

1911 
bR
 = 
	`M_MEVI_TA_3_Fme

buf
, 
n
 );

1915 
	`t
( (*)"ӦٻıֵVII ֵñֵII ASDU50" );

1916 
bR
 = 
	`M_MEVII_NA_3_Fme

buf
, 
n
 );

1920 
	`t
( (*)"ңȷ ASUD88" );

1924 
	`t
( (*)"֡ ASUD36" );

1925 
	`M_IT_NA_3_Fme

buf
, 
n
 );

1929 
	`t
( (*)"ʱĵ֡ ASUD37" );

1930 
	`M_IT_TA_3_Fme

buf
, 
n
 );

1934 
	`t
( (*)"ʱĵ֡ ASUD205()" );

1935 
	`M_IT_TA_3_SIPROTEC_Fme

buf
, 
n
 );

1947 
	`t
( (*)"һ ·  ASUD20 ASDU64 ASDU41" );

1948 i!
	`C_DC_NA_3_Fme

buf
, 
n
 ) )

1950 
	`t
( (*)"ңؽ" );

1952 
m_byYkECou
 = 0;

1962  
bR
;

1963 
	}
}

1974 
BOOL
 
	gCIEC103
::
	$RetFmeCouB
 ( 
BYTE
 *
buf
, &
n
 )

1976 
buf
[0] = 0x10;

1977 
buf
[1] = 0x47;

1978 
buf
[2] = 
m_wDevAddr
;

1979 
buf
[3] = 
	`GCs
( &buf[1], 2 );

1980 
buf
[4] = 0x16;

1982 
n
 = 5;

1983  
TRUE
;

1984 
	}
}

1995 
BOOL
 
	gCIEC103
::
	$RetCommUn
 ( 
BYTE
 *
buf
, &
n
 )

1997 
buf
[0] = 0x10;

1998 
buf
[1] = 0x40;

1999 
buf
[2] = 
m_wDevAddr
;

2000 
buf
[3] = 
	`GCs
( &buf[1], 2 );

2001 
buf
[4] = 0x16;

2003 
n
 = 5;

2004  
TRUE
;

2005 
	}
}

2016 
BOOL
 
	gCIEC103
::
	$ClLev1Da
 ( 
BYTE
 *
buf
, &
n
 )

2018 
buf
[0] = 0x10;

2019 
buf
[1] = 
	`ChgeFcb
(0x5A, 
m_bFcb
);

2020 
buf
[2] = 
m_wDevAddr
;

2021 
buf
[3] = 
	`GCs
( &buf[1], 2 );

2022 
buf
[4] = 0x16;

2024 
n
 = 5;

2025  
TRUE
;

2026 
	}
}

2037 
BOOL
 
	gCIEC103
::
	$ClLev2Da
 ( 
BYTE
 *
buf
, &
n
 )

2039 
buf
[0] = 0x10;

2040 
buf
[1] = 
	`ChgeFcb
(0x5B, 
m_bFcb
);

2041 
buf
[2] = 
m_wDevAddr
;

2042 
buf
[3] = 
	`GCs
( &buf[1], 2 );

2043 
buf
[4] = 0x16;

2045 
n
 = 5;

2046  
TRUE
;

2047 
	}
}

2058 
BOOL
 
	gCIEC103
::
	$RequeLkS
 ( 
BYTE
 *
buf
, &
n
 )

2060 
buf
[0] = 0x10;

2061 
buf
[1] = 0x49;

2062 
buf
[2] = 
m_wDevAddr
;

2063 
buf
[3] = 
	`GCs
( &buf[1], 2 );

2064 
buf
[4] = 0x16;

2066 
n
 = 5;

2067  
TRUE
;

2068 
	}
}

2079 
BOOL
 
	gCIEC103
::
	$TimeSyn

BYTE
 *
buf
, &
n
 )

2081 
time_t
 
lSecd
;

2082 
tm
 
cuTime
;

2083 
timev
 
tv
;

2084 
timeze
 
tz
;

2086 
	`gtimeofday
&
tv
, &
tz
 );

2087 
lSecd
 = (
time_t
)(
tv
.
tv_c
);

2088 
	`loime_r
&
lSecd
, &
cuTime
 );

2090 
buf
[0] = 0x68;

2091 
buf
[1] = 0x0F;

2092 
buf
[2] = 0x0F;

2093 
buf
[3] = 0x68;

2094 
buf
[4] = 
	`ChgeFcb
(0x53, 
m_bFcb
);

2095 
buf
[5] = 
m_wDevAddr
;

2096 
buf
[6] = 0x06;

2097 
buf
[7] = 0x81;

2098 
buf
[8] = 0x08;

2099 
buf
[9] = 
m_wDevAddr
;

2100 
buf
[10] = 0xff;

2101 
buf
[11] = 0x00;

2103 
BYTE
 
byM
 = 
cuTime
.
tm_m
;

2104 
BYTE
 
bywDay
 = 
cuTime
.
tm_wday
 ;

2105 
BYTE
 
bymDay
 = 
cuTime
.
tm_mday
;

2107 
buf
[12] = ( 
tv
.
tv_uc
/1000 ) & 0xff;

2108 
buf
[13] = ( ( 
tv
.
tv_uc
/1000 ) >> 8) & 0xff;

2109 
buf
[14] = 
byM
 & 0x3f;

2110 
buf
[15] = ( (
BYTE
)
cuTime
.
tm_hour
 ) & 0x1f;

2111 
buf
[16] =
bywDay
 << 5 ) &0xE0 ) | ( 
bymDay
 & 0x1f ) ) ;

2112 
buf
[17] = (
cuTime
.
tm_m
 + 1)& 0x0f;

2113 
buf
[18] = 
cuTime
.
tm_yr
 % 100;

2117 
buf
[19] = 
	`GCs
(buf+4, 15);

2118 
buf
[20] = 0x16;

2120 
n
 = 21;

2121  
TRUE
;

2122 
	}
}

2133 
BOOL
 
	gCIEC103
::
	$TٮClDa

BYTE
 *
buf
, &
n
 )

2135 
buf
[0] = 0x68;

2136 
buf
[1] = 0x09;

2137 
buf
[2] = 0x09;

2138 
buf
[3] = 0x68;

2139 
buf
[4] = 
	`ChgeFcb
(0x53, 
m_bFcb
);

2140 
buf
[5] = 
m_wDevAddr
;

2141 
buf
[6] = 0x07;

2142 
buf
[7] = 0x81;

2143 
buf
[8] = 0x09;

2144 
buf
[9] = 
m_wDevAddr
;

2145 
buf
[10] = 0xff;

2146 
buf
[11] = 0x00;

2147 
buf
[12] = 0x00;

2149 
buf
[13] = 
	`GCs
(buf+4, 9);

2150 
buf
[14] = 0x16;

2152 
n
 = 15;

2153  
TRUE
;

2154 
	}
}

2165 
BOOL
 
	gCIEC103
::
	$ClYmDa
 ( 
BYTE
 *
buf
, &
n
 )

2167 
buf
[0] = 0x68;

2168 
buf
[1] = 0x0A;

2169 
buf
[2] = 0x0A;

2170 
buf
[3] = 0x68;

2171 
buf
[4] = 
	`ChgeFcb
(0x53, 
m_bFcb
);

2172 
buf
[5] = 
m_wDevAddr
;

2173 
buf
[6] = 0x58;

2174 
buf
[7] = 0x81;

2175 
buf
[8] = 0x02;

2176 
buf
[9] = 
m_wDevAddr
;

2177 
buf
[10] = 0x01;

2178 
buf
[11] = 0x00;

2179 
buf
[12] = 0x05;

2180 
buf
[13] = 0x00;

2182 
buf
[14] = 
	`GCs
(buf+4, 10);

2183 
buf
[15] = 0x16;

2185 
n
 = 16;

2186  
TRUE
;

2187 
	}
}

2198 
BOOL
 
	gCIEC103
::
	$GSdBuf
 ( 
BYTE
 *
buf
, &
n
 )

2200 
BOOL
 
bR
 = 
TRUE
;

2201  
m_SdStus
 )

2203 
C_RFB_NA_3
:

2204 
	`RetFmeCouB

buf
, 
n
 );

2207 
C_RCU_NA_3
:

2208 
	`t
( (*)"λͨŵԪ" );

2209 
	`RetCommUn

buf
, 
n
 );

2212 
C_PL1_NA_3
:

2213 
	`t
( (*)"ٻһ" );

2214 
	`ClLev1Da

buf
, 
n
 );

2217 
C_PL2_NA_3
:

2218 
	`t
( (*)"ٻû" );

2219 
	`ClLev2Da

buf
, 
n
 );

2222 
C_RLK_NA_3
:

2223 
	`t
( (*)"·״̬" );

2224 
	`RequeLkS

buf
, 
n
 );

2227 
C_SYN_Ta_3
:

2228 
	`t
( (*)"ʱͬ" );

2229 
	`TimeSyn

buf
, 
n
 );

2230 
m_SdStus
 = 
C_IGI_NA_3
;

2231 
m_bIsTٮCl
 = 
TRUE
;

2232 
m_bIsNdRend
 = 
FALSE
;

2235 
C_IGI_NA_3
:

2236 
	`t
( (*)"ܲѯ" );

2237 
	`TٮClDa

buf
, 
n
 );

2238 
m_bIsTٮCl
 = 
FALSE
;

2241 
C_CI_NA_3
:

2242 
	`t
( (*)"ٻң" );

2243 
	`ClYmDa

buf
, 
n
 );

2246 
C_GD_NA_3
:

2249 
C_GRC_NA_3
:

2252 
C_GC_NA_3
:

2255 
C_ODT_NA_3
:

2258 
C_ADT_NA_3
:

2262 
	`rtf
 (
DebugBuf
, "IEC103:GProcBun'fd m_SdStu%d\n", 
m_SdStus
 );

2263 
	`t

DebugBuf
 );

2267  
bR
;

2268 
	}
}

2279 
BOOL
 
	gCIEC103
::
	$YkS
 ( 
YK_DATA
 *
pYkDa
, 
BYTE
 *
buf
, &
n
 )

2281 
CfgInfo
 
tCfgInfo
;

2282 
BYTE
 
byFunTy
;

2283 
BYTE
 
byInfoIndex
;

2284 
BYTE
 
byDCC
 = 0;

2286 i!
	`GModuInfo

IEC103_YK_DATATYPE
, 
pYkDa
->
wP
, 
tCfgInfo
, 
byFunTy
, 
byInfoIndex
) )

2287  
FALSE
;

2291 if
pYkDa
->
byV
 == 0 )

2293 
byDCC
 = 0x81;

2295 if
pYkDa
->
byV
 == 1 )

2297 
byDCC
 = 0x82;

2300 
buf
[0] =0x68;

2301 
buf
[1] =0x0A;

2302 
buf
[2] =0x0A;

2303 
buf
[3] =0x68;

2304 
buf
[4] =
	`ChgeFcb
(0x53,
m_bFcb
);

2305 
buf
[5] =
m_wDevAddr
;

2308  
tCfgInfo
.
DaFm
 )

2311 
buf
[6] =64;

2312 
buf
[8] =12;

2316 
buf
[6] =20;

2317 
buf
[8] =20;

2321 
buf
[6] =65;

2322 
buf
[8] =12;

2334 
buf
[7] =0x81;

2335 
buf
[9] =
m_wDevAddr
;

2336 
buf
[10]=
byFunTy
;

2337 
buf
[11]=
byInfoIndex
;

2338 
buf
[12]=
byDCC
;

2339 
buf
[13]=0x00;

2341 
buf
[14]=
	`GCs
((buf+4),10);

2342 
buf
[15]=0x16;

2344 
n
 = 16;

2345  
TRUE
;

2346 
	}
}

2357 
BOOL
 
	gCIEC103
::
	$YkEx
 ( 
YK_DATA
 *
pYkDa
, 
BYTE
 *
buf
, &
n
 )

2359 
CfgInfo
 
tCfgInfo
;

2360 
BYTE
 
byFunTy
;

2361 
BYTE
 
byInfoIndex
;

2362 
BYTE
 
byDCC
 = 0;

2364 i!
	`GModuInfo

IEC103_YK_DATATYPE
, 
pYkDa
->
wP
, 
tCfgInfo
, 
byFunTy
, 
byInfoIndex
) )

2365  
FALSE
;

2367 if
pYkDa
->
byV
 == 0 )

2369 
byDCC
 = 0x01;

2371 if
pYkDa
->
byV
 == 1 )

2373 
byDCC
 = 0x02;

2376 
buf
[0] =0x68;

2377 
buf
[1] =0x0A;

2378 
buf
[2] =0x0A;

2379 
buf
[3] =0x68;

2380 
buf
[4] =
	`ChgeFcb
(0x53,
m_bFcb
);

2381 
buf
[5] =
m_wDevAddr
;

2384  
tCfgInfo
.
DaFm
 )

2387 
buf
[6] =64;

2388 
buf
[8] =12;

2392 
buf
[6] =20;

2393 
buf
[8] =20;

2397 
buf
[6] =65;

2398 
buf
[8] =12;

2410 
buf
[7] =0x81;

2411 
buf
[9] =
m_wDevAddr
;

2412 
buf
[10]=
byFunTy
;

2413 
buf
[11]=
byInfoIndex
;

2414 
buf
[12]=
byDCC
;

2415 
buf
[13]=0x00;

2417 
buf
[14]=
	`GCs
((buf+4),10);

2418 
buf
[15]=0x16;

2420 
n
 = 16;

2421  
TRUE
;

2422 
	}
}

2433 
BOOL
 
	gCIEC103
::
	$YkCl
 ( 
YK_DATA
 *
pYkDa
, 
BYTE
 *
buf
, &
n
 )

2435 
CfgInfo
 
tCfgInfo
;

2436 
BYTE
 
byFunTy
;

2437 
BYTE
 
byInfoIndex
;

2438 
BYTE
 
byDCC
 = 0;

2440 i!
	`GModuInfo

IEC103_YK_DATATYPE
, 
pYkDa
->
wP
, 
tCfgInfo
, 
byFunTy
, 
byInfoIndex
) )

2441  
FALSE
;

2443 if
pYkDa
->
byV
 == 0 )

2445 
byDCC
 = 0xc1;

2447 if
pYkDa
->
byV
 == 1 )

2449 
byDCC
 = 0xc2;

2452 
buf
[0] =0x68;

2453 
buf
[1] =0x0A;

2454 
buf
[2] =0x0A;

2455 
buf
[3] =0x68;

2456 
buf
[4] =
	`ChgeFcb
(0x53,
m_bFcb
);

2457 
buf
[5] =
m_wDevAddr
;

2460  
tCfgInfo
.
DaFm
 )

2463 
buf
[6] =64;

2464 
buf
[8] =12;

2468 
buf
[6] =20;

2469 
buf
[8] =20;

2473 
buf
[6] =65;

2474 
buf
[8] =12;

2486 
buf
[7] =0x81;

2487 
buf
[9] =
m_wDevAddr
;

2488 
buf
[10]=
byFunTy
;

2489 
buf
[11]=
byInfoIndex
;

2490 
buf
[12]=
byDCC
;

2491 
buf
[13]=0x00;

2493 
buf
[14]=
	`GCs
((buf+4),10);

2494 
buf
[15]=0x16;

2496 
n
 = 16;

2497  
TRUE
;

2498 
	}
}

2509 
BOOL
 
	gCIEC103
::
	$ProssBusMsg
 ( 
PBUSMSG
 
pBusMsg
, 
BYTE
 *
buf
, &
n
 )

2511 
BOOL
 
bR
 = 
TRUE
;

2512  
pBusMsg
->
byMsgTy
 )

2514 
YK_PROTO
:

2516 
m_byRemeBusNo
 = 
pBusMsg
->
SrcInfo
.
byBusNo
;

2517 
m_byRemeAddr
 = 
pBusMsg
->
SrcInfo
.
wDevNo
;

2518 
YK_DATA
 *
pYkDa
 = (YK_DATA *)
pBusMsg
->
pDa
;

2519  
pBusMsg
->
dwDaTy
 )

2521 
YK_SEL
:

2522 
	`t
( (*)"ңѡ" );

2523 
bR
 = 
	`YkS

pYkDa
, 
buf
, 
n
 );

2524 
m_byYkECou
 = 1;

2527 
YK_EXCT
:

2528 
	`t
( (*)"ңִ" );

2529 
bR
 = 
	`YkEx

pYkDa
, 
buf
, 
n
 );

2530 
m_byYkECou
 = 1;

2533 
YK_CANCEL
:

2534 
	`t
( (*)"ңȡ" );

2535 
bR
 = 
	`YkCl

pYkDa
, 
buf
, 
n
 );

2536 
m_byYkECou
 = 0;

2543 
m_byYkSdL
 = 
n
;

2544 
	`memy
(
m_byYkSdBuf
, 
buf
, 
m_byYkSdL
 );

2545 
m_dwYkTimeOut
 = 0;

2551 
	`rtf

DebugBuf
, "IEC103:ProssBusMsg c'fd msgty = %d\n", 
pBusMsg
->
byMsgTy
 );

2552 
	`t
 ( 
DebugBuf
 );

2553  
FALSE
;

2556  
bR
;

2557 
	}
}

2568 
BOOL
 
	gCIEC103
::
	$RdCfgInfo
 ( )

2570 
FILE
 *

 = 
NULL
;

2571 
szLeBuf
[256];

2572 
CfgInfo
 
tCfgInfo
;

2573 *
p
 = 
NULL
;

2574 
BYTE
 
i
 = 0;

2575 
iNum
;

2576 
szFeName
[256] = "";

2578 
	`rtf

szFeName
, "%s%s", 
IEC103PREFIXFILENAME
, 
m_sTemePh
);

2579 

 = 
	`fݒ

szFeName
, "r" );

2580 if

 =
NULL
 )

2582 
	`rtf
(
DebugBuf
, "CIEC103:RdCfgInffݒ %r!!!\n", 
szFeName
 );

2583 
	`t

DebugBuf
 );

2584 
	`tf
 ( "%s", 
DebugBuf
 );

2585  
FALSE
;

2589 
	`rtf
(
DebugBuf
, "CIEC103:RdCfgInffݒ %Ok!!!\n", 
szFeName
 );

2590 
	`t

DebugBuf
 );

2591 
	`tf
 ( "%s", 
DebugBuf
 );

2594  
	`fgs

szLeBuf
, (szLeBuf), 

 ) !
NULL
 )

2596 
i
 = 0;

2597 
	`rim

szLeBuf
 );

2598 if
szLeBuf
[0] == '#' || szLineBuf[0] == ';'

2599 || (
szLeBuf
[0]-'0') < 0 || (szLineBuf[0] - '0') > 9)

2604 
p
 = 
	`ok

szLeBuf
, "," );

2605 if
p
 =
NULL
 )

2611 
tCfgInfo
.
FunTy
 = 
	`oi

p
 );

2614  ( 
p
 = 
	`ok

NULL
, "," ) ) )

2616 ++
i
;

2617 
iNum
 = 
	`oi
(
p
);

2618 if
iNum
 > 255 || iNum < 0 )

2620 
	`rtf

DebugBuf
, "CIEC103:RdCfgInffe: %le:%d by:%d ir!!! \n", 
m_sTemePh
,()
m_IEC103_CfgInfo
.
	`size
(), 
i
);

2621 
	`t
 ( 
DebugBuf
 );

2624  
i
 )

2627 
tCfgInfo
.
InfoIndex
 = 
	`oi

p
 );

2631 
tCfgInfo
.
AddInfo
 = 
	`oi

p
 );

2635 
tCfgInfo
.
DaTy
 = 
	`oi

p
 );

2639 
tCfgInfo
.
SIndex
 = 
	`oi

p
 );

2643 
tCfgInfo
.
DaNum
 = 
	`oi

p
 );

2647 
tCfgInfo
.
DaFm
 = 
	`oi

p
 );

2658 
m_IEC103_CfgInfo
.
	`push_back

tCfgInfo
 );

2661 
	`fo


 );

2662  
TRUE
;

2663 
	}
}

2674 
BOOL
 
	gCIEC103
::
	$InProcStus
 ( )

2676 
m_bLkStus
 = 
FALSE
;

2677 
m_SdStus
 = 
C_RCU_NA_3
;

2678 
m_dwLkTimeOut
 = 0;

2679 
m_dwYkTimeOut
 = 0;

2680 
m_dwTٮClTime
 = 0;

2681 
m_byYkECou
 = 0;

2682 
m_byRecvECou
 = 0;

2683 
m_bFcb
 = 0;

2684 
m_bIsReSd
 = 
FALSE
;

2685 
m_byRendCou
 = 0;

2686 
m_bIsSdg
 = 
FALSE
;

2687 
m_bIsNdRend
 = 
TRUE
;

2688 
m_bIsYkg
 = 
FALSE
;

2689 
m_bIsTٮCl
 = 
FALSE
;

2690 
m_bIsYmCl
 = 
FALSE
;

2692 
m_wReSdL
 = 0;

2693 
m_byYkSdL
 = 0;

2694 
m_byRemeBusNo
 = 0;

2695 
m_byRemeAddr
 = 0;

2696 
	`memt

m_byReSdBuf
, 0, 
IEC103_MAX_BUF_LEN
 );

2697 
	`memt

m_byYkSdBuf
, 0, ( m_byYkSendBuf ) );

2698 
	`memt

DebugBuf
, 0, ( DebugBuf ) );

2703  
TRUE
;

2704 
	}
}

2715 
BOOL
 
	gCIEC103
::
	$GDevCommS
 ( )

2717 if
m_bLkStus
 )

2718  
COM_NORMAL
;

2720  
COM_DEV_ABNORMAL
;

2721 
	}
}

2732 
	gCIEC103
::
	$TimProc
 ( )

2737 
Iv
 = 250;

2739 
m_dwTٮClTime
 +
Iv
;

2740 if
m_dwTٮClTime
 >
IEC103_TOTAL_CALL
 )

2742 
m_SdStus
 = 
C_IGI_NA_3
;

2743 
m_bIsTٮCl
 = 
TRUE
;

2744 
m_dwTٮClTime
 = 0;

2748 
m_dwLkTimeOut
 +
Iv
;

2749 if(
m_dwLkTimeOut
 >
IEC103_LINK_TIMEOUT
)

2751 if
m_bLkStus
 =
TRUE
 )

2753 
	`InProcStus
();

2758 if
m_byYkECou
 > 0 )

2760 
m_dwYkTimeOut
 +
Iv
;

2761 if
m_dwYkTimeOut
 >
IEC103_YK_TIMEOUT
 )

2763 
m_dwYkTimeOut
 = 0;

2764 
m_byYkECou
 ++;

2765 
m_bIsYkg
 = 
TRUE
;

2766 if
m_byYkECou
 > 3 )

2768 
m_byYkECou
 = 0;

2775 if
m_byRecvECou
 > 
IEC103_MAX_ERROR_COUNT
 )

2777 
m_byRendCou
 = 0;

2778 
	`InProcStus
();

2782 if
m_byRendCou
 >
IEC103_MAX_RESEND_COUNT
 )

2784 
m_byRendCou
 = 0;

2785 
	`InProcStus
( );

2787 
	}
}

2798 
BOOL
 
	gCIEC103
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

2800 
pos
=0;

2801 
BOOL
 
bR
 = 
TRUE
;

2803 if!
	`WhhBufVue

buf
, 
n
, 
pos
 ) )

2805 
	`t
 ( (*)"CIEC103:ProcessProtocolBuf buf Recvrr!!!\n" );

2806 
m_byRecvECou
 ++;

2807 
m_bIsReSd
 = 
TRUE
;

2808  
FALSE
;

2811 if
buf
[
pos
] == 0x10 )

2813 
bR
 = 
	`ProssHd10Buf
&
buf
[
pos
], 
n
 );

2815 if
buf
[
pos
] == 0x68)

2817 
bR
 = 
	`ProssHd68Buf
&
buf
[
pos
], 
n
 );

2821 
	`rtf
 (
DebugBuf
, "CIEC103:ProssProcBubuf[0]=%x!!!\n", 
buf
[
pos
] );

2822 
	`t

DebugBuf
 );

2826 if!
bR
 )

2828 
	`t
( (*)"ķδ" );

2834 
m_byRecvECou
 = 0;

2835 
m_bLkStus
 = 
TRUE
;

2836 
m_dwLkTimeOut
 = 0;

2837 
m_bIsReSd
 = 
FALSE
;

2838 
m_byRendCou
 = 0;

2839 
m_bIsSdg
 = 
FALSE
;

2842  
bR
;

2843 
	}
}

2854 
BOOL
 
	gCIEC103
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

2856 
BOOL
 
bR
 = 
TRUE
;

2857 i
m_bIsYkg
 )

2859 
	`t
( (*)"ңط" );

2860 
	`memy

buf
, 
m_byYkSdBuf
, 
m_byYkSdL
 );

2861 
n
 = 
m_byYkSdL
;

2862 
buf
[4] =
	`ChgeFcb
(0x53,
m_bFcb
);

2863 
buf
[14]=
	`GCs
((buf+4),10);

2864 
m_bIsYkg
 = 
FALSE
;

2866 i
m_bIsReSd
 || 
m_bIsSdg
 && 
m_SdStus
 !
C_RCU_NA_3
)

2868 
n
 = 
m_wReSdL
;

2869 
	`memy

buf
, 
m_byReSdBuf
, 
n
 );

2870 
m_byRendCou
 ++;

2871 
	`rtf

DebugBuf
, "ط %d ", 
m_byRendCou
 );

2872 
	`t

DebugBuf
 );

2874 if
pBusMsg
 !
NULL
 && 
m_bLkStus
)

2876 
	`t
( (*)"Ϣ" );

2877 if!
	`ProssBusMsg

pBusMsg
, 
buf
, 
n
 ) )

2879 
	`t
( (*)"Ϣʧ" );

2880  
FALSE
;

2885 
bR
 = 
	`GSdBuf

buf
, 
n
 );

2886 if
bR
 )

2888 
m_wReSdL
 = 
n
;

2889 
	`memy

m_byReSdBuf
, 
buf
, 
m_wReSdL
 );

2890 
m_bIsSdg
 = 
TRUE
;

2891 if!
m_bIsNdRend
 )

2893 
m_bIsSdg
 = 
FALSE
;

2894 
m_bIsNdRend
 = 
TRUE
;

2900  
bR
;

2901 
	}
}

2912 
BOOL
 
	gCIEC103
::
	$In
 ( 
BYTE
 
byLeNo
 )

2914 if!
	`RdCfgInfo
() )

2916 
	`t
 ( (*)"CIEC103:ReadCfgInfo Err!!!\n" );

2917  
FALSE
;

2920 if!
	`InProcStus
() )

2922 
	`t
 ( (*)"CIEC103:InitProtocolStatus Err\n" );

2923  
FALSE
;

2926  
TRUE
;

2927 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/IEC103.h

21 #ide 
_IEC103_H__INC


22 
	#_IEC103_H__INC


	)

25 
	~<ve
>

27 
	~"../../she/tydef.h
"

28 
	~"../../she/CProc.h
"

29 
	~"../../she/gDaTy.h
"

30 
	~"CProc_IEC103.h
"

32 
usg
 
mea
 
	gd
;

34 
	#IEC103PREFIXFILENAME
 "/mynd/cfig/IEC103/me/"

	)

36 
	#IEC103_MAX_YC_NUM
 256

	)

37 
	#IEC103_MAX_YX_NUM
 512

	)

38 
	#IEC103_MAX_YK_NUM
 256

	)

39 
	#IEC103_MAX_YM_NUM
 256

	)

40 
	#IEC103_TOTAL_CALL
 10*60*1000

	)

41 
	#IEC103_TIME_SYN
 10*60*1000

	)

42 
	#IEC103_LINK_TIMEOUT
 15*1000

	)

43 
	#IEC103_YK_TIMEOUT
 5*1000

	)

44 
	#IEC103_MAX_ERROR_COUNT
 3

	)

45 
	#IEC103_MAX_YKERROT_COUNT
 3

	)

46 
	#IEC103_MAX_BUF_LEN
 256

	)

47 
	#IEC103_MAX_RESEND_COUNT
 3

	)

48 
	#IEC103_MAX_DEBUG_BUF_LEN
 1024

	)

58 as
	cCfgInfo


60 
	mpublic
:

61 
	$CfgInfo
 ()

63 
FunTy
 = 0;

64 
InfoIndex
 = 0;

65 
AddInfo
 = 0;

66 
DaTy
 = 0;

67 
SIndex
 = 0;

68 
DaNum
 = 0;

69 
DaFm
 = 0;

72 
BYTE
 
FunTy
;

73 
BYTE
 
InfoIndex
;

74 
BYTE
 
AddInfo
;

75 
BYTE
 
DaTy
;

76 
BYTE
 
SIndex
;

77 
BYTE
 
DaNum
;

78 
BYTE
 
DaFm
;

79 
	}
};

85 
	e_SENDSTATUS


88 
	mC_RFB_NA_3
,

89 
	mC_RCU_NA_3
,

90 
	mC_PL1_NA_3
,

91 
	mC_PL2_NA_3
,

92 
	mC_RLK_NA_3
,

95 
	mC_SYN_Ta_3
,

96 
	mC_IGI_NA_3
,

97 
	mC_CI_NA_3
,

98 
	mC_GD_NA_3
,

99 
	mC_GRC_NA_3
,

100 
	mC_GC_NA_3
,

101 
	mC_ODT_NA_3
,

102 
	mC_ADT_NA_3
,

104 }
	tSENDSTATUS
;

113 as
	cCIEC103
:
public
 
CProc_IEC103


115 
public
:

117 
CIEC103
 ();

118 ~
CIEC103
 ();

124 
vtu
 
TimProc
();

126 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

128 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

130 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

132 
vtu
 
BOOL
 
GDevCommS
( ) ;

134 
	meed
:

137 
ive
:

140 
BOOL
 
m_bLkStus
;

141 
BOOL
 
	mm_bFcb
;

142 
BOOL
 
	mm_bIsReSd
;

143 
BOOL
 
	mm_bIsSdg
;

144 
BOOL
 
	mm_bIsNdRend
;

145 
BOOL
 
	mm_bIsYkg
;

146 
BOOL
 
	mm_bIsTٮCl
;

147 
BOOL
 
	mm_bIsYmCl
;

149 
DWORD
 
	mm_dwTٮClTime
;

150 
DWORD
 
	mm_dwLkTimeOut
;

151 
DWORD
 
	mm_dwYkTimeOut
;

153 
BYTE
 
	mm_byRecvECou
;

154 
BYTE
 
	mm_byYkECou
;

155 
BYTE
 
	mm_byReSdBuf
[
IEC103_MAX_BUF_LEN
];

156 
BYTE
 
	mm_byYkSdBuf
[
IEC103_MAX_BUF_LEN
];

157 
BYTE
 
	mm_byRendCou
;

158 
WORD
 
	mm_wReSdL
;

159 
BYTE
 
	mm_byYkSdL
;

160 
BYTE
 
	mm_byRemeBusNo
;

161 
BYTE
 
	mm_byRemeAddr
;

164 
	mDebugBuf
[
IEC103_MAX_DEBUG_BUF_LEN
];

168 
	mve
 < 
	mCfgInfo
 > 
	mm_IEC103_CfgInfo
;

169 
SENDSTATUS
 
	mm_SdStus
;

173 
t
*
buf
, 
n
 = 0 );

175 
DiyC

BYTE
 
byC
 );

177 
BOOL
 
GModuP

BYTE
 
byDaTy
, BYTE 
byFunTy
, BYTE 
byInfoIndex
, 
WORD
 &
wP
 );

179 
BOOL
 
GModuInfo

BYTE
 
byDaTy
, 
WORD
 
wP
, 
CfgInfo
 &
tCfgInfo
, BYTE &
byFunTy
, BYTE &
byInfoIndex
 );

183 
BOOL
 
RdCfgInfo
();

185 
BOOL
 
InProcStus
();

189 
BOOL
 
ProssBusMsg
(
PBUSMSG
 
pBusMsg
, 
BYTE
 *
buf
, &
n
);

192 
BOOL
 
GSdBuf

BYTE
 *
buf
, &
n
 );

194 
BOOL
 
RetFmeCouB

BYTE
 *
buf
, &
n
 );

196 
BOOL
 
RetCommUn
(
BYTE
 *
buf
, &
n
);

198 
BOOL
 
ClLev1Da
(
BYTE
 *
buf
, &
n
);

200 
BOOL
 
ClLev2Da
(
BYTE
 *
buf
, &
n
);

202 
BOOL
 
RequeLkS
(
BYTE
 *
buf
, &
n
);

207 
BOOL
 
TimeSyn
(
BYTE
 *
buf
, &
n
);

209 
BOOL
 
TٮClDa
(
BYTE
 *
buf
, &
n
);

211 
BOOL
 
ClYmDa

BYTE
 *
buf
, &
n
 );

213 
BOOL
 
GCssDa
(
BYTE
 *
buf
, &
n
);

215 
BOOL
 
GCommd
(
BYTE
 *
buf
, &
n
);

217 
BOOL
 
CommCommd
(
BYTE
 *
buf
, &
n
);

223 
BOOL
 
YkS

YK_DATA
 *
pYkDa
, 
BYTE
 *
buf
, &
n
 );

225 
BOOL
 
YkEx

YK_DATA
 *
pYkDa
, 
BYTE
 *
buf
, &
n
 );

227 
BOOL
 
YkCl

YK_DATA
 *
pYkDa
, 
BYTE
 *
buf
, &
n
 );

231 
BOOL
 
ProssHd10Buf
(
BYTE
 *
buf
, 
n
);

233 
BOOL
 
ProssHd68Buf
(
BYTE
 *
buf
, 
n
);

236 
BOOL
 
CfigFme
(
BYTE
 *
buf
, 
n
);

238 
BOOL
 
BusyFme
(
BYTE
 *
buf
, 
n
);

240 
BOOL
 
NeRequeFme
(
BYTE
 *
buf
, 
n
);

242 
BOOL
 
LkRunFme
(
BYTE
 *
buf
, 
n
);

244 
BOOL
 
LkNeRunFme
(
BYTE
 *
buf
, 
n
);

246 
BOOL
 
LkUnFishFme
(
BYTE
 *
buf
, 
n
);

250 
BOOL
 
M_IRCFS_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

252 
BOOL
 
C_SYN_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

254 
BOOL
 
M_TGI_NA_3_Fme
(
BYTE
 *
buf
, 
n
);

258 
BOOL
 
M_TTM_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

260 
BOOL
 
M_TMR_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

262 
BOOL
 
M_SP_NA_3_Fme
(
BYTE
 *
buf
, 
n
);

264 
BOOL
 
M_DP_NA_3_Fme
(
BYTE
 *
buf
, 
n
);

266 
BOOL
 
M_SP_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

268 
BOOL
 
M_DP_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

270 
BOOL
 
M_SS_NA_3_Fme

BYTE
 *
buf
, 
n
 );

272 
BOOL
 
M_DS_NA_3_Fme

BYTE
 *
buf
, 
n
 );

274 
BOOL
 
M_SS_TA_3_Fme

BYTE
 *
buf
, 
n
 );

276 
BOOL
 
M_DS_TA_3_Fme

BYTE
 *
buf
, 
n
 );

280 
BOOL
 
M_MEI_NA_3_Fme
(
BYTE
 *
buf
, 
n
);

282 
BOOL
 
M_TME_TA_3_Fme

BYTE
 *
buf
, 
n
 );

284 
BOOL
 
M_MEII_NA_3_Fme
(
BYTE
 *
buf
, 
n
);

286 
BOOL
 
M_MEIII_NA_3_Fme
(
BYTE
 *
buf
, 
n
);

288 
BOOL
 
M_MEIII_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

290 
BOOL
 
M_MEIV_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

292 
BOOL
 
M_MEV_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

294 
BOOL
 
M_MEVI_TA_3_Fme
(
BYTE
 *
buf
, 
n
);

296 
BOOL
 
M_MEVII_NA_3_Fme
(
BYTE
 *
buf
, 
n
 );

300 
BOOL
 
M_IT_NA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 );

302 
BOOL
 
M_IT_TA_3_Fme
 ( 
BYTE
 *
buf
, 
n
 );

304 
BOOL
 
M_IT_TA_3_SIPROTEC_Fme

BYTE
 *
buf
, 
n
 );

308 
BOOL
 
C_DC_NA_3_Fme
(
BYTE
 *
buf
, 
n
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_IEC103.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

12 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

14 
CProc
 * 
pProc
 = 
NULL
 ;

15 
pProc
 = 
w
 
CProc_IEC103
 ;

16 if
pProc
 )

18 
pProc
->
m_pMhod
 = 
pMhod
 ;

19 
	`tf
( "IEC103 DLL OK.\n " ) ;

22  
pProc
 ;

23 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/CProtocol_IEC104.cpp

1 
	~"CProc_IEC104.h
"

2 
	~"../../she/CProc.h
"

3 
	~"Rtu104.h
"

4 
	~"rg.h
"

5 
	~"Proc_ESD_IEC104.h
"

7 
	gCProc_IEC104
::
	$CProc_IEC104
()

10 
	}
}

12 
CProc_IEC104
::~
	$CProc_IEC104
()

15 
size
 = 
m_modu
.
	`size
() ;

16  
i
 = 0 ; i < 
size
 ; i++ )

18 
de
 
m_modu
[ 
i
 ] ;

20 
m_modu
.
	`r
() ;

21 
	`tf
( "Delete All CProtocol_IEC104 OK . \n" );

23 
	}
}

25 
BOOL
 
	gCProc_IEC104
::
	$In

BYTE
 
byLeNo
 )

27 
m_byLeNo
 = 
byLeNo
 ;

28 
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

31  
	`GDevDa
( ) ;

32 
	}
}

34 
BOOL
 
	gCProc_IEC104
::
	$GDevDa
( )

36 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

37 
	`rtf

m_sDevPh
 , "%s/IEC104Sve/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

38 
CProfe
 
	`ofe

m_sDevPh
 ) ;

40  
	`ProssFeDa

ofe
 ) ;

41 
	}
}

43 
BOOL
 
	gCProc_IEC104
::
	$ProssFeDa

CProfe
 &
ofe
 )

45 if!
ofe
.
	`IsVid
() )

47 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

48  
FALSE
 ;

51 
sSe
[ 200 ] = "DEVNUM" ;

52 
sKey
[ 20 ][ 50 ]={ "module" , "addr" , "name" , "masteraddr" , "template" , "ycdead" , "ycProperty" , "timing"} ;

54 
BOOL
 
bR
;

55 
WORD
 
wModu
 = 0 ;

57 
WORD
 
addr
 =0 ;

58 
sName
[ 50 ] = { 0 };

59 
eme
[ 200 ] = { 0 };

60 
iNum
 = 0 ;

61 
sMaAddr
[ 200 ] = { 0 } ;

63 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

64 if
iNum
 == 0 )

66 
	`tf
( "Get DEVNUM Failed ! \n " );

67  
FALSE
 ;

70 
BYTE
 
byIndex
 = 0 ;

71  
i
 = 0 ; i < 
iNum
 ; i++ )

73 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

75 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 
byIndex
++ ] , 0 ) ;

76 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 
byIndex
++ ] , 0 ) ;

78 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

79 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
sMaAddr
 , 
eme
 ) ) ;

80 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

83 
bR
 = 
	`CeModu

wModu
 ,
sMaAddr
 , 
addr
 , 
sName
 , 
eme
 ) ;

84 i!
bR
 )

86 
	`tf
 ( "CIEC104 Modu=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
addr
, 
sName
, 
eme
 );

88  
FALSE
;

92  
TRUE
 ;

93 
	}
}

95 
BOOL
 
	gCProc_IEC104
::
	$CeModu

iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

97 
CProc_IEC104
 * 
pProc
 = 
NULL
 ;

99  
iModu
 )

101 
MODULE_ESD_IEC104
:

103 
pProc
 = 
w
 
CProc_ESD_IEC104
 ;

104 if!
	`InIEC104_Modu

pProc
 , 
iModu
 , 
sMaAddr
 , 
iAddr
 , 
sName
 , 
ePh
 ) )

105  
FALSE
 ;

108 
MODULE_IEC104
:

110 
pProc
 = 
w
 
CRtu104
 ;

111 if!
	`InIEC104_Modu

pProc
 , 
iModu
 , 
sMaAddr
 , 
iAddr
 , 
sName
 , 
ePh
 ) )

112  
FALSE
 ;

117 
	`tf
( "%s don't containhis module Failed .\n" , "IEC104" );

118  
FALSE
 ;

122 
m_modu
.
	`push_back

pProc
 ) ;

123  
TRUE
 ;

124 
	}
}

126 
BOOL
 
	gCProc_IEC104
::
	$InIEC104_Modu

CProc_IEC104
 * 
pProc
 , 
iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

128 if
pProc
 =
NULL
 )

129  
FALSE
 ;

131 
pProc
->
m_byLeNo
 = m_byLineNo ;

132 
pProc
->
m_wModuTy
 = 
iModu
 ;

133 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

134 
	`tf
("iddr=%d m_byLeNo=%d\n", 
iAddr
, 
m_byLeNo
);

135 
	`ry

pProc
->
m_sDevName
 , 
sName
 ) ;

136 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

137 
	`ry

pProc
->
m_sMaAddr
 , 
sMaAddr
 ) ;

138 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

139 
pProc
->
m_pMhod
 = m_pMethod ;

140 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

142 if!
pProc
->
	`In

m_byLeNo
 ) )

143  
FALSE
 ;

144 
	`tf
" Add bu%d Add%d ProcNam%\n" , 
m_byLeNo
 , 
iAddr
 , 
sName
 ) ;

146  
TRUE
 ;

147 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/CProtocol_IEC104.h

1 #ide
CPROTOCOL_IEC104_H


2 
	#CPROTOCOL_IEC104_H


	)

4 
	~"../../she/Rtu.h
"

5 
	~"../../she/CMhod.h
"

8 
	#IEC104PREFIXFILENAME
 "/mynd/cfig/IEC104Sve/"

	)

9 
	#MODULE_ESD_IEC104
 1

10 
	#MODULE_IEC104
 2

11 

	)

12 as
	cCProc_IEC104
 : 
public
 
CRtuBa


14 
public
:

15 
CProc_IEC104
();

16 
	mvtu
 ~
CProc_IEC104
();

17 
BOOL
 
GDevDa
( );

18 
BOOL
 
ProssFeDa

CProfe
 &
ofe
 );

19 
BOOL
 
CeModu

iModu
 ,* 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

20 
BOOL
 
InIEC104_Modu

CProc_IEC104
 * 
pProc
 , 
iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 );

21 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

23 
	meed
:

24 
m_sMaAddr
[ 200 ] ;

25 
	mive
:

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/Protocol_ESD_IEC104.cpp

5 
	~"Proc_ESD_IEC104.h
"

11 
	gCProc_ESD_IEC104
::
	$CProc_ESD_IEC104
()

13 
bySticLeNo
 = 0 ;

14 
bySticDevAddr
 = 0 ;

15 
	}
}

17 
	gCProc_ESD_IEC104
::~
	$CProc_ESD_IEC104
()

18 {
	}
}

24 
BOOL
 
CProc_ESD_IEC104
::
	$ReSS
( )

26 
CRtu104
::
	`ReSS
( ) ;

27 
bySticLeNo
 = 0 ;

28 
bySticDevAddr
 = 0 ;

29  
TRUE
 ;

30 
	}
}

33 
	gCProc_ESD_IEC104
::
	$ComS_Mesge

WORD
 
wUnAddr
 )

35 
BYTE
 
byL
 = 0 , 
byCou
 = 0 ;

36 
WORD
 
wNS
 = 0 , 
wNR
 = 0 ;

37 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

38 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

41 
pTXBuf
[0] = 0x68;

42 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

43 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

44 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

45 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

46 
pTXBuf
[6] = 41;

47 
pTXBuf
[8] = 3;

48 
pTXBuf
[9] = 0;

49 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

50 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

51 
byL
 = 12;

53 
BYTE
 
byBusNum
 = 
m_pMhod
->
	`GToTBusNum
() ;

54 if
byBusNum
 == 0 )

57 if
bySticLeNo
 >
byBusNum
 )

58 
bySticLeNo
 = 0 ;

60  ; 
bySticLeNo
< 
byBusNum
 ; )

63 
BYTE
 
byTy
 = 
m_pMhod
->
	`GBusLeProcTy

bySticLeNo
 ) ;

64 if
PROTOCO_TRANSPROT
 =
byTy
 ) || ( byType == 0xFF ) )

66 
bySticLeNo
++ ;

70 
BYTE
 
byTٮDevNum
 = 
m_pMhod
->
	`GDevNum

bySticLeNo
 ) ;

71 if
bySticDevAddr
 >
byTٮDevNum
 )

72 
bySticDevAddr
 = 0 ;

74  
i
 = 0 ; 
bySticDevAddr
 < 
byTٮDevNum
 ; byStaticDevAddr++ )

76 if
i
 == 0 )

78 if
	`PackComSMsg

pTXBuf
 , 
byL
 , 
bySticLeNo
 , 0 , 
SEND_BUS_STATE
 ) )

79 
byCou
++ ;

82 if
byL
 > 239 )

86 
WORD
 
wDevAddr
 = 
m_pMhod
->
	`GAddrByLeNoAndModuNo

bySticLeNo
, (WORD)
bySticDevAddr
 );

87 if0 !
wDevAddr
 )

89 if
	`PackComSMsg

pTXBuf
 , 
byL
 , 
bySticLeNo
 , 
wDevAddr
 , 
SEND_DEV_STATE
 ) )

90 
byCou
++ ;

100 if
byL
 > 239 )

102 if
bySticDevAddr
 >
byTٮDevNum
 )

103 
bySticLeNo
++ ;

106 
i
++ ;

109 if
byL
 > 239 )

113 if
bySticDevAddr
 >
byTٮDevNum
 )

115 
bySticDevAddr
 = 0 ;

116 
bySticLeNo
++ ;

121 
pTXBuf
[7] = 
byCou
;

122 
pTXBuf
[1] = 
byL
-2;

123  
byL
;

124 
	}
}

127 
	gCProc_ESD_IEC104
::
	$ComS_Mesge

WORD
 
wUnAddr
 )

129 
BYTE
 
byL
 = 0 , 
byCou
 = 0 ;

130 
WORD
 
wNS
 = 0 , 
wNR
 = 0 ;

131 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

132 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

134 
BYTE
 
byTٮDevNum
 = 0;

137 
pTXBuf
[0] = 0x68;

138 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

139 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

140 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

141 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

142 
pTXBuf
[6] = 41;

143 
pTXBuf
[8] = 3;

144 
pTXBuf
[9] = 0;

145 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

146 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

147 
byL
 = 12;

150 
BYTE
 
byBusNum
 = 
m_pMhod
->
	`GToTBusNum
() ;

151 if
byBusNum
 == 0 )

154 if
bySticLeNo
 >
byBusNum
 )

155 
bySticLeNo
 = 0 ;

157 if(
QuyADevStus
){

158 
pTXBuf
[0] = 0x68;

159 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

160 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

161 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

162 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

163 
pTXBuf
[6] = 0x29;

164 
pTXBuf
[8] = 3;

165 
pTXBuf
[9] = 0;

166 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

167 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

168 
byL
 = 12;

169  ; 
bySticLeNo
< 
byBusNum
 ; )

172 
BYTE
 
byTy
 = 
m_pMhod
->
	`GBusLeProcTy

bySticLeNo
 ) ;

173 if
PROTOCO_TRANSPROT
 =
byTy
 ) || ( byType == 0xFF ) )

175 
bySticLeNo
++ ;

179 
byTٮDevNum
 = 
m_pMhod
->
	`GDevNum

bySticLeNo
 ) ;

180 if
bySticDevAddr
 >
byTٮDevNum
 ){

182 
bySticDevAddr
 = 0 ;

185  
i
 = 0 ; 
bySticDevAddr
 < 
byTٮDevNum
 ; byStaticDevAddr++ )

188 if
i
 == 0 )

190 if
	`PackComSMsg

pTXBuf
 , 
byL
 , 
bySticLeNo
 , 0 , 
SEND_BUS_STATE
 ) )

191 
byCou
++ ;

194 if
byL
 > 239 )

198 
WORD
 
wDevAddr
 = 
m_pMhod
->
	`GAddrByLeNoAndModuNo

bySticLeNo
, (WORD)
bySticDevAddr
 );

199 if0 !
wDevAddr
 )

202 if
	`PackComSMsg

pTXBuf
 , 
byL
 , 
bySticLeNo
 , 
wDevAddr
 , 
SEND_DEV_STATE
 ) )

203 
byCou
++ ;

213 if
byL
 > 239 )

215 if
bySticDevAddr
 >
byTٮDevNum
 )

216 
bySticLeNo
++ ;

219 
i
++ ;

222 if
byL
 > 239 )

226 if
bySticDevAddr
 >
byTٮDevNum
 )

228 
bySticDevAddr
 = 0 ;

229 
bySticLeNo
++ ;

235 if((
bySticLeNo
 >
byBusNum
))

236 
QuyADevStus
 = 
FALSE
;

238 if(
deque_
.
	`size
() != 0){

239 
pTXBuf
[0] = 0x68;

240 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

241 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

242 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

243 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

244 
pTXBuf
[6] = 0x29;

245 
pTXBuf
[8] = 3;

246 
pTXBuf
[9] = 0;

247 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

248 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

249 
byL
 = 12;

251 
deque_
.
	`size
()){

256 if
	`PackComSMsg

pTXBuf
 , 
byL
 , 
deque_
.
	`t
().
ro
, 
SEND_DEV_STATE
 ) )

257 
byCou
++ ;

258 if(
byL
 > 239)

263 
pTXBuf
[7] = 
byCou
;

264 
pTXBuf
[1] = 
byL
-2;

265  
byL
;

266 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/Protocol_ESD_IEC104.h

5 #i!
defed
(
AFX_PROTOCOL_ESD_IEC104_H__B25ED719_D5B5_4FF3_9241_76EE4FEC5256__INCLUDED_
)

6 
	#AFX_PROTOCOL_ESD_IEC104_H__B25ED719_D5B5_4FF3_9241_76EE4FEC5256__INCLUDED_


	)

8 #i
_MSC_VER
 > 1000

9 #agm



12 
	~"Rtu104.h
"

14 as
	cCProc_ESD_IEC104
 : 
public
 
CRtu104


16 
public
:

17 
CProc_ESD_IEC104
();

18 
	mvtu
 ~
CProc_ESD_IEC104
();

20 
vtu
 
ComS_Mesge

WORD
 
wUnAddr
 ) ;

21 
vtu
 
BOOL
 
ReSS
( ) ;

22 
	mive
:

23 
BYTE
 
bySticLeNo
 ;

24 
BYTE
 
	mbySticDevAddr
 ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/Rtu104.cpp

5 
	~<dio.h
>

6 
	~<dlib.h
>

7 
	~<rg.h
>

8 
	~<unid.h
>

9 
	~<f.h
>

10 
	~<rmios.h
>

11 
	~<y.h
>

12 
	~<sys/iol.h
>

13 
	~<sys/mm.h
>

14 
	~<sys/tys.h
>

15 
	~<sys/m.h
>

16 
	~<sys/.h
>

17 
	~<sys/time.h
>

18 
	~<sigl.h
>

19 
	~<o.h
>

20 
	~<t/.h
>

21 
	~<sys/sock.h
>

22 
	~</.h
>

23 
	~<tdb.h
>

25 
	~"Rtu104.h
"

26 
	~"../../she/TPt.h
"

27 
	~"../../she/msgdef.h
"

28 
	~"../../she/gDaTy.h
"

29 
	~"../../BayLay/CPublicMhod.h
"

32 
	#DATA_OK_TOUT
 240

33 
	#ERROR_CONST
 120

34 
	#FRAME_CONST
 2

35 

	)

36 
	#SEND_TOUT
 60

37 
	#RECV_TOUT
 40

38 
	#IDLE_TOUT
 80

39 

	)

40 
	#CMD_SST_BIT
 0x0004

41 
	#CMD_COA_BIT
 0x0020

42 
	#CMD_COE_BIT
 0x0040

43 
	#CMD_COC_BIT
 0x0080

44 
	#CMD_START_BIT
 0x0100

45 
	#CMD_STOP_BIT
 0x0200

46 
	#CMD_TEST_BIT
 0x0400

47 
	#CMD_TEST_SEND
 0x0001

48 
	#CMD_UFACK_BIT
 0x0800

49 
	#CMD_IGI_BIT
 0x1000

50 
	#CMD_RELAY_BIT
 0x00E0

51 

	)

53 
	#IEC104_W
 8

54 
	#IEC104_Q
 12

55 
	#MAXMUM_NUM
 0x8000

	)

56 
	#IEC104_T1
 15

57 
	#IEC104_T2
 10

58 
	#IEC104_T3
 20

59 
	#IEC104_T4
 30

60 
	#IEC104_YKTIME
 5

61 

	)

62 
	#IEC104_START_T1
 0x01

	)

63 
	#IEC104_START_T2
 0x02

	)

64 
	#IEC104_START_T3
 0x04

	)

65 
	#IEC104_START_T4
 0x08

	)

66 
	#IEC104_YK_STARTTIME
 0x10

	)

68 
	#IEC104_END_T1
 0xFE

	)

69 
	#IEC104_END_T2
 0xFD

	)

70 
	#IEC104_END_T3
 0xFB

	)

71 
	#IEC104_END_T4
 0xF7

	)

72 
	#IEC104_YK_ENDTIME
 0xEF

	)

74 
	#CMD_NULL
 0

	)

75 
	#CMD_TIME_CONFIRM
 1

76 
	#CMD_TIME_END
 2

77 
	#CMD_TOTAL_CONFIRM
 3

78 
	#CMD_YM_CONFIRM
 4

79 
	#CMD_YM_END
 5

80 
	#CMD_YM_ERROR
 6

81 
	#CMD_YK_ERROR
 7

82 

	)

83 
	#YX_START_ADDR
 0x0001

	)

84 
	#YC_START_ADDR
 0x4001

	)

85 
	#DO_START_ADDR
 0x6001

	)

86 
	#PA_START_ADDR
 0x6401

	)

87 
	#COM_STATE_ADDR
 50000

	)

89 
	#In_Addr
(
addr
ddr+1)%
RTU104_RX_BUF_SIZE


	)

90 
	#De_Addr
(
addr
ddr-1+
RTU104_RX_BUF_SIZE
)%
	)
RTU104_RX_BUF_SIZE

106 "C" 
SCutTime

REALTIME
 *
pRlTime
 );

107 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

110 #ifdef 
__lulus


115 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

116 
OutPromText
(*
szText
);

117 
LogPromText
(cڡ *
fmt
, ...);

118 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
);

120 * 
Rtu104Task
(*
pRtuObj
)

122 ((
CRtu104
 *)
pRtuObj
)->
TaskProcHd
();

123 
had_ex
(0);

124  
NULL
;

127 #ifdef 
__lulus


134 
CRtu104
::
	$CRtu104
()

136 
m_byProID
 = 4;

137 
m_byEb
 = 0;

138 
m_wDdV
 = 3;

139 
m_nTXCou
 = 0;

140 
m_nRXCou
 = 0;

141 
m_RQ_WR_P
 = 0;

142 
m_RQ_RD_P
 = 0;

144 
m_bDaIn
 = 
TRUE
;

145 
m_bSB
 = 
FALSE
;

146 
m_bADa
 = 
FALSE
;

147 
m_wCommd
 = 0;

148 
m_wStus
 = 0;

149 
m_bySdg
 = 0;

151 
m_wNumSd
 = 0;

152 
m_wNumRecv
 = 0;

153 
m_wNumRecBK
 = 0;

154 
m_wNumAck
 = 0;

156 
m_wDaIndex
 = 0 ;

157 
m_byDaSty
 = 0 ;

159 
m_wETim
 = 0;

160 
m_wTimCou
 = 0;

161 
m_wSdTim
 = 0;

162 
m_wRecvTim
 = 0;

163 
m_wIdTim
 = 0;

164 
m_wDRFTim
 = 0;

165 
m_wPARTim
 = 0;

166 
m_byTimeFg
 = 0 ;

167 
m_t1
 = 0 ;

168 
m_t2
 = 0 ;

169 
m_t3
 = 0 ;

171 
m_byECode
 = 0;

172 
m_wRendNum
 = 0;

173 
m_byToutNum
 = 0;

175 
QuyADevStus
 = 
TRUE
;

181 
InBufr
<>
m_wAIBuf
 , 
RTU104MAX_AI_LEN
 ) ;

182 
InBufr
<
DWORD
>
m_dwPIBuf
 , 
RTU104MAX_PI_LEN
 ) ;

183 
InBufr
<
BYTE
>
m_byDIbuf
 , 
RTU104MAX_DI_LEN
 ) ;

184 
	}
}

186 
CRtu104
::~
	$CRtu104
()

188 
m_bTaskRun
 = 
FALSE
;

189 
	}
}

191 
me
< 
tyme
 
Ty
 >
CRtu104
::
	$InBufr

Ty
 *
tDa
 , 
size
 )

193 if!
tDa
 )

196  
i
 = 0 ; i < 
size
 ; i++ )

197 
tDa
[ 
i
 ] = 0 ;

198 
	}
}

200 
BOOL
 
CRtu104
::
	$InRtuBa
( )

202 
UINT
 
uPt
;

203 
BOOL
 
bOk
 = 
FALSE
;

204 
szCl
[32];

208 
CBaPt
::
	`GCommArib
(
m_ComCl1
, 
szCl
, 
uPt
);

210 
m_wPtNum
 = (
WORD
)
uPt
 ;

213 
	`CeTnsTab
();

216 
m_pMhod
->
	`RdAYcDa
(&
m_wAIBuf
[0]);

217 
m_pMhod
->
	`RdAYmDa
(&
m_dwPIBuf
[0]);

218 
m_pMhod
->
	`RdAYxDa
&
m_byDIbuf
[ 0 ] ) ;

220 
m_bTaskRun
 = 
TRUE
;

221  
bOk
;

222 
	}
}

224 
CRtu104
::
	$TimProc
()

228 
	`RdChgDa
();

232 
	`RdChgeStus
(
m_
, 
deque_
);

234 
	`ProssIEC104Time
( ) ;

235 
	}
}

237 
CRtu104
::
	$ProssIEC104Time
( )

239 
BYTE
 
byTimeFg
 = 
	`GTimeFg
() ;

240 
time_t
 
timeTemp
 ;

241 
	`time
&
timeTemp
 ) ;

242 if
byTimeFg
 & 
IEC104_START_T1
 ) == IEC104_START_T1 )

244 if
	`difime

timeTemp
 , 
m_t1
 ) > 
IEC104_T1
 )

247 
	`ReSS
( ) ;

249 if
m_pMhod
 )

250 
m_pMhod
->
	`CloSock

m_byLeNo
 ) ;

254 if
byTimeFg
 & 
IEC104_START_T2
 ) == IEC104_START_T2 )

256 if
	`difime

timeTemp
 , 
m_t2
 ) > 
IEC104_T2
 )

259 
m_wCommd
 |
CMD_UFACK_BIT
 ;

263 if
byTimeFg
 & 
IEC104_START_T3
 ) == IEC104_START_T3 )

266 if
	`difime

timeTemp
 , 
m_t3
 ) > 
IEC104_T3
 )

269 
m_wCommd
 |
CMD_TEST_SEND
 ;

273 if
byTimeFg
 & 
IEC104_START_T4
 ) == IEC104_START_T4 )

275 if
	`difime

timeTemp
 , 
m_t4
 ) > 
IEC104_T4
 )

278 
	`ReSS
( ) ;

280 if
m_pMhod
 )

281 
m_pMhod
->
	`CloSock

m_byLeNo
 ) ;

285 if
byTimeFg
 & 
IEC104_YK_STARTTIME
 ) == IEC104_YK_STARTTIME )

287 
	`time
&
timeTemp
) ;

288 if
	`difime

timeTemp
 , 
m_YKTime
 ) > 
IEC104_YKTIME
 )

290 
BYTE
 
byAi
 = 0 ;

291 
WORD
 
wRayNum
 = 0 ;

292 
BYTE
 
byANum
 = 0 ;

293 
BYTE
 
byAMk
 = 0 ;

294 
WORD
 
wRs
 = 0 ;

295 
	`GYkDa

byAi
 , 
wRayNum
, 
byANum
 , 
byAMk
 , 
wRs
 ) ;

296 
	`YK_EPross

byAi
 , 
wRayNum
 , 
byANum
 , 
byAMk
 , 
wRs
 ) ;

297 
	`STTim

IEC104_YKTIME
 , 
IEC104_YK_ENDTIME
 ) ;

300 
	}
}

302 
BYTE
 
CRtu104
::
	$CBch
(
BYTE
* 
pBuf
, 
n
)

304 
i
;

305 
BYTE
 
byCheckCode
=0;

306 
i
=0; i<
n
; i++
byCheckCode
 +
pBuf
[i];

307  
byCheckCode
;

308 
	}
}

310 
CRtu104
::
	$GCommObjPr
(
COMMOBJ_PROP
* 
pObjPr
)

312 
pObjPr
->
bySty
 = 2;

313 
pObjPr
->
byObjNum
 = 
	`LOBYTE
(
m_wObjNum
);

314 
	`rtf
(
pObjPr
->
szObjName
, 
m_szObjName
);

315 
	`rtf
(
pObjPr
->
szChl
, 
m_ComCl1
);

316 
pObjPr
->
wPtNum
 = 
m_wPtNum
;

317 
pObjPr
->
wStus
 = 0;

318 if
	`IsPtVid
() )

319 
pObjPr
->
wStus
 = 1;

321 
	}
}

324 
CRtu104
::
	$GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
)

326 
WORD
 
wVue
 = 0 ;

327 
byTy
)

330 if(
wP
>=
RTU104MAX_AI_LEN
)  -2;

331 
	`memy
(
v
, &
m_wAIBuf
[
wP
], ());

335 if(
wP
>=
RTU104MAX_DI_LEN
)

338 if
m_byDIbuf
[ 
wP
 ] ==0 )

339 
wVue
 = 0;

341 
wVue
 = 1;

343 
	`memy
(
v
, &
wVue
, (
WORD
));

347 if(
wP
>=
RTU104MAX_PI_LEN
)  -2;

348 
	`memy
(
v
, &
m_dwPIBuf
[
wP
], (
DWORD
));

354 
	}
}

385 
BOOL
 
CRtu104
::
	$WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
fV
)

387 if(
m_pwAITns
==
NULL
 
FALSE
;

388 
WORD
 
wNum
 = 
m_pwAITns
[
wP
];

389 if(
wNum
> 
m_wAISum
 )  
FALSE
;

390 if(
wNum
<
RTU104MAX_AI_LEN
)

392 
nDt
 = 
fV
 - 
m_wAIBuf
[
wNum
];

393 if(
	`abs
()
nDt
)>=
m_wDdV
)

395 
m_wAIBuf
[
wNum
] = 
fV
;

396 if(
m_bDaIn
){

398 
	`AddAlogEvt

wSlNo
 , 
wNum
, 
fV
 );

402  
TRUE
 ;

403 
	}
}

405 
BOOL
 
CRtu104
::
	$WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
)

407 if(
m_pwDITns
==
NULL
 
FALSE
;

408 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

409 if(
wNum
>
m_wDISum
 )  
FALSE
;

410 if
wNum
<
RTU104MAX_DI_LEN
)

412 if
m_byDIbuf
[ 
wNum
 ] !
wV
 )

414 
m_byDIbuf
[ 
wNum
 ] = 
wV
 ;

415 if(
m_bDaIn
)

416 
	`AddDigEvt

wSlNo
 , 
wNum
, 
wV
);

419  
TRUE
 ;

420 
	}
}

422 
BOOL
 
CRtu104
::
	$WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
)

424 if(
m_pwPITns
==
NULL
 
FALSE
;

425 
WORD
 
wNum
 = 
m_pwPITns
[
wP
];

426 if(
wNum
> 
m_wPISum
 )  
FALSE
;

427 if(
wNum
<
RTU104MAX_PI_LEN
)

429 
m_dwPIBuf
[
wNum
] = 
dwV
;

431  
TRUE
 ;

432 
	}
}

434 
BOOL
 
CRtu104
::
	$WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

436 if(
m_pwDITns
==
NULL
 
FALSE
;

437 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

438 if(
wNum
>
m_wDISum
 )  
FALSE
;

439 if(
wNum
<
RTU104MAX_DI_LEN
)

441 
	`AddSOEInfo
(
wSlNo
 , 
wNum
, 
wV
, 
lTime
, 
wMiSecd
);

443  
TRUE
 ;

444 
	}
}

446 
CRtu104
::
	$RayEchoProc
(
BYTE
 
byCommd
, 
WORD
 
wIndex
, BYTE 
byResu
)

448 
BYTE
 
byAi
 = 0 ;

449 
WORD
 
wRayNum
 = 0 ;

450 
BYTE
 
byANum
 = 0 ;

451 
BYTE
 
byAMk
 = 0 ;

452 
WORD
 
wSeTime
 = 0 ;

453 
	`GYkDa

byAi
 , 
wRayNum
, 
byANum
 , 
byAMk
 , 
wSeTime
 ) ;

455 
WORD
 
wClNum
;

456 if(
byAi
 == 0) ;

457 if(
m_pwDOTns
==
NULL
) ;

458 
wClNum
 = 
m_pwDOTns
[
wIndex
] ;

459 
	`tf
("RelayProc\n");

460 
byCommd
)

462 
YK_SEL_RTN
:

463 
m_wYkFg
 = 
YK_SEL_RTN
;

464 if
wClNum
 =
wRayNum
 )

466 
m_wCommd
 |
CMD_COA_BIT
;

469 
YK_EXCT_RTN
:

470 
m_wYkFg
 = 
YK_EXCT_RTN
;

471 if
wClNum
 =
wRayNum
 )

473 
m_wCommd
 |
CMD_COA_BIT
;

476 
YK_CANCEL_RTN
:

477 
m_wYkFg
 = 
YK_CANCEL_RTN
 ;

478 if
wClNum
 =
wRayNum
 )

480 
m_wCommd
 |
CMD_COA_BIT
 ;

486 
	}
}

488 
CRtu104
::
	$TnsMesge

BYTE
 
byTy
, BYTE* 
pBuf
, 
nL
 )

491 
	}
}

494 
CRtu104
::
	$AckFme
()

496 
WORD
 
wNS
, 
wNR
;

498 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

500 
m_pTX_Buf
[0] = 0x68;

501 
m_pTX_Buf
[1] = 0x04;

502 
m_pTX_Buf
[2] = 0x01;

503 
m_pTX_Buf
[3] = 0x00;

504 
m_pTX_Buf
[4] = 
	`LOBYTE
(
wNR
);

505 
m_pTX_Buf
[5] = 
	`HIBYTE
(
wNR
);

507 
	}
}

509 
CRtu104
::
	$SDaAck
()

511 
m_pTX_Buf
[0] = 0x68;

512 
m_pTX_Buf
[1] = 0x04;

513 
m_pTX_Buf
[2] = 0x03+0x08;

514 
m_pTX_Buf
[3] = 0x00;

515 
m_pTX_Buf
[4] = 0x00;

516 
m_pTX_Buf
[5] = 0x00;

518 
	}
}

520 
CRtu104
::
	$StDaAck
()

522 
m_pTX_Buf
[0] = 0x68;

523 
m_pTX_Buf
[1] = 0x04;

524 
m_pTX_Buf
[2] = 0x03+0x20;

525 
m_pTX_Buf
[3] = 0x00;

526 
m_pTX_Buf
[4] = 0x00;

527 
m_pTX_Buf
[5] = 0x00;

529 
	}
}

531 
CRtu104
::
	$TeFmeAck
()

533 
m_pTX_Buf
[0] = 0x68;

534 
m_pTX_Buf
[1] = 0x04;

535 
m_pTX_Buf
[2] = 0x03+0x80;

536 
m_pTX_Buf
[3] = 0x00;

537 
m_pTX_Buf
[4] = 0x00;

538 
m_pTX_Buf
[5] = 0x00;

540 
	}
}

542 
CRtu104
::
	$TeSd
( )

544 
m_pTX_Buf
[0] = 0x68;

545 
m_pTX_Buf
[1] = 0x04;

546 
m_pTX_Buf
[2] = 0x03+0x40;

547 
m_pTX_Buf
[3] = 0x00;

548 
m_pTX_Buf
[4] = 0x00;

549 
m_pTX_Buf
[5] = 0x00;

551 
	}
}

553 
CRtu104
::
	$ADaEcho
(
WORD
 
wUnAddr
, 
BYTE
 
byRs
)

555 
WORD
 
wNS
, 
wNR
;

556 
BYTE
 
byL
;

557 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

559 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

561 
pTXBuf
[0] = 0x68;

562 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

563 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

564 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

565 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

566 
pTXBuf
[6] = 0x64;

567 
pTXBuf
[7] = 0x01;

568 
pTXBuf
[8] = 
byRs
;

569 
pTXBuf
[9] = 0;

570 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

571 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

572 
pTXBuf
[12] = 0;

573 
pTXBuf
[13] = 0;

574 
pTXBuf
[14] = 0;

575 
pTXBuf
[15] = 0x14;

576 
byL
 = 16;

577 
pTXBuf
[1] = 
byL
-2;

578  
byL
;

579 
	}
}

581 
CRtu104
::
	$ReqPulEcho
(
WORD
 
wUnAddr
, 
BYTE
 
byRs
, BYTE 
byQCC
)

583 
WORD
 
wNS
, 
wNR
;

584 
BYTE
 
byL
;

585 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

587 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

588 
pTXBuf
[0] = 0x68;

589 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

590 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

591 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

592 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

593 
pTXBuf
[6] = 0x65;

594 
pTXBuf
[7] = 0x01;

595 
pTXBuf
[8] = 
byRs
;

596 
pTXBuf
[9] = 0;

597 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

598 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

599 
pTXBuf
[12] = 0;

600 
pTXBuf
[13] = 0;

601 
pTXBuf
[14] = 0;

602 
pTXBuf
[15] = 
byQCC
;

603 
byL
 = 16;

604 
pTXBuf
[1] = 
byL
-2;

605  
byL
;

606 
	}
}

608 
CRtu104
::
	$LdAIEFme21
(
WORD
 
wUnAddr
)

610 
WORD
 
wNS
, 
wNR
, 
wP
 ;

611 
fV
;

612 
BYTE
 
byL
, 
byCou
;

613 
i
, 
nSize
;

614 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

615 
WORD
 
wSlNo
 = 0 ;

617 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

618 
pTXBuf
[0] = 0x68;

619 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

620 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

621 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

622 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

623 
pTXBuf
[6] = 0x15;

624 
pTXBuf
[8] = 0x03;

625 
pTXBuf
[9] = 0;

626 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

627 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

628 
byL
 = 12;

630 
byCou
 = 0;

631 
nSize
 = 
m_dwAIEQueue
.
	`size
();

632 
i
=0; i<
nSize
; i++)

634 if(!
	`GAlogEvt
(
wSlNo
 , 
wP
, 
fV
)) ;

635 
WORD
 
wV
 = 
ic_
<WORD>
fV
 ) ;

637 
wP
 +
YC_START_ADDR
;

638 
pTXBuf
[
byL
] = 
	`LOBYTE
(
wP
);

639 
pTXBuf
[
byL
+1] = 
	`HIBYTE
(
wP
);

640 
pTXBuf
[
byL
+2] = 0;

641 
pTXBuf
[
byL
+3] = 
	`LOBYTE
(
wV
);

642 
pTXBuf
[
byL
+4] = 
	`HIBYTE
(
wV
);

643 
byCou
++;

644 
byL
 += 5;

645 if
byL
 >= 250 ) ;

647 
pTXBuf
[7] = 
byCou
;

648 
pTXBuf
[1] = 
byL
-2;

649  
byL
;

650 
	}
}

652 
CRtu104
::
	$LdAIEFme13
(
WORD
 
wUnAddr
)

654 
WORD
 
wNS
, 
wNR
;

655 
WORD
 
wP
, 
wNum
 ;

656 
fGV
 = 0.0f ;

657 
BYTE
 
byL
, 
byCou
;

658 
i
, 
nSize
;

659 
fV
;

660 
WORD
 
wSlNo
 = 0 ;

661 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

663 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

664 
pTXBuf
[0] = 0x68;

665 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

666 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

667 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

668 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

669 
pTXBuf
[6] = 13;

670 
pTXBuf
[8] = 0x03;

671 
pTXBuf
[9] = 0;

672 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

673 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

674 
byL
 = 12;

676 
byCou
 = 0;

677 
nSize
 = 
m_dwAIEQueue
.
	`size
();

678 
i
=0; i<
nSize
; i++)

680 if(!
	`GAlogEvt

wSlNo
 , 
wNum
, 
fGV
))

682 
BYTE
 
byBufr
[ 4 ] ;

683 
BYTE
 
byBufr1
[ 4 ] ;

685 
fV
 = 
fGV
;

686 if
m_pAIMTab
[
wNum
].
wS
>0 &&

687 
m_pAIMTab
[
wNum
].
wPNum
>0 )

689 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
wNum
].
wS
,

690 
m_pAIMTab
[
wNum
].
wPNum
,

691 
fGV
);

692 
	`memy

byBufr
 , &
fV
 , 4 ) ;

693 
	`GlobCyByEndn

byBufr1
, 
byBufr
, 4);

700 
wP
 = 
YC_START_ADDR
 + 
wNum
;

701 
pTXBuf
[
byL
] = 
	`LOBYTE
(
wP
);

702 
pTXBuf
[
byL
+1] = 
	`HIBYTE
(
wP
);

703 
pTXBuf
[
byL
+2] = 0;

704 
	`memy
(&
pTXBuf
[
byL
+3], &
byBufr1
, 4);

707 
BOOL
 
bDevS
 = 
FALSE
 ;

708 
BYTE
 
bySiq
 = 0 ;

710 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

711 if
bDevS
 =
COM_DEV_ABNORMAL
 )

712 
bySiq
 |= 0xC0 ;

714 
pTXBuf
[
byL
+7] = 
bySiq
 ;

715 
byCou
++;

716 
byL
 += 8;

717 if
byL
 > 245 ) ;

719 
pTXBuf
[7] = 
byCou
;

720 
pTXBuf
[1] = 
byL
-2;

721  
byL
;

722 
	}
}

724 
CRtu104
::
	$LdDIEFme
(
WORD
 
wUnAddr
)

726 
WORD
 
wNS
, 
wNR
, 
wP
, 
wV
;

727 
BYTE
 
byL
, 
byCou
;

728 
i
, 
nSize
;

729 
BYTE
 
bySiq
 = 0 ;

730 
WORD
 
wSlNo
 = 0 ;

731 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

733 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

734 
pTXBuf
[0] = 0x68;

735 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

736 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

737 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

738 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

739 
pTXBuf
[6] = 0x01;

740 
pTXBuf
[8] = 0x03;

741 
pTXBuf
[9] = 0;

742 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

743 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

744 
byL
 = 12;

746 
byCou
 = 0;

747 
nSize
 = 
m_dwDIEQueue
.
	`size
();

748 
i
=0; i<
nSize
; i++)

750 if(!
	`GDigEvt

wSlNo
 , 
wP
, 
wV
)) ;

751 
wP
 +
YX_START_ADDR
;

752 
pTXBuf
[
byL
] = 
	`LOBYTE
(
wP
);

753 
pTXBuf
[
byL
+1] = 
	`HIBYTE
(
wP
);

754 
pTXBuf
[
byL
+2] = 0;

756 i
wV
 & 0x01 )

758 
bySiq
 = 0x01 ;

761 
bySiq
 = 0 ;

763 
BOOL
 
bDevS
 = 
FALSE
 ;

764 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

765 if
bDevS
 =
COM_DEV_ABNORMAL
 )

766 
bySiq
 |= 0xC0 ;

768 
pTXBuf
[
byL
+3] = 
bySiq
 ;

769 
byCou
++;

770 
byL
 += 4;

771 if
byL
 >= 251 ) ;

773 
pTXBuf
[7] = 
byCou
;

774 
pTXBuf
[1] = 
byL
-2;

775  
byL
;

776 
	}
}

778 
CRtu104
::
	$LdSOEFme_30
 (
WORD
 
wUnAddr
)

780 
WORD
 
wNS
, 
wNR
;

781 
WORD
 
wP
, 
wV
, 
wTime
, 
wMiSecd
;

782 
tm
 
tmSu
;

783 
BYTE
 
byL
 = 0 , 
byCou
 = 0 ;

784 
WORD
 
wSlNo
 = 0 ;

785 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

787 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

788 
pTXBuf
[
byL
++] = 0x68;

789 
pTXBuf
[
byL
++] = 0 ;

790 
pTXBuf
[
byL
++] = 
	`LOBYTE
(
wNS
);

791 
pTXBuf
[
byL
++] = 
	`HIBYTE
(
wNS
);

792 
pTXBuf
[
byL
++] = 
	`LOBYTE
(
wNR
);

793 
pTXBuf
[
byL
++] = 
	`HIBYTE
(
wNR
);

794 
pTXBuf
[
byL
++] = 0x1E;

795 
pTXBuf
[
byL
++] = 0 ;

796 
pTXBuf
[
byL
++] = 0x03;

797 
pTXBuf
[
byL
++] = 0;

798 
pTXBuf
[
byL
++] = 
	`LOBYTE
(
wUnAddr
);

799 
pTXBuf
[
byL
++] = 
	`HIBYTE
(
wUnAddr
);

801 
byCou
 = 0;

802 
m_iSOE_rd_p
 !
m_iSOE_wr_p
)

804 
	`GSOEInfo

wSlNo
 , &
wP
, &
wV
, &
tmSu
, &
wMiSecd
);

806 
wP
 = wP + 
YX_START_ADDR
;

807 
wV
 = wVal & 0x0001;

809 
wTime
=
tmSu
.
tm_c
 * 1000 +
wMiSecd
;

811 
pTXBuf
[
byL
++] = 
	`LOBYTE
(
wP
);

812 
pTXBuf
[
byL
++] = 
	`HIBYTE
(
wP
);

813 
pTXBuf
[
byL
++] = 0;

815 
pTXBuf
[
byL
++] = 
	`LOBYTE
(
wV
);

817 
pTXBuf
[
byL
++]=
	`LOBYTE
(
wTime
);

818 
pTXBuf
[
byL
++]=
	`HIBYTE
(
wTime
);

819 
pTXBuf
[
byL
++]=
tmSu
.
tm_m
;

820 
pTXBuf
[
byL
++]=
tmSu
.
tm_hour
;

821 
pTXBuf
[
byL
++]=
tmSu
.
tm_mday
;

822 
pTXBuf
[
byL
++]=
tmSu
.
tm_m
;

823 
pTXBuf
[
byL
++]=
tmSu
.
tm_yr
%100;

825 
byCou
++;

826 if
byL
 > 246 ) ;

828 
pTXBuf
[7] = 
byCou
;

829 
pTXBuf
[1] = 
byL
-2;

830  
byL
;

831 
	}
}

833 
CRtu104
::
	$LdSOEFme_02
(
WORD
 
wUnAddr
)

835 
WORD
 
wNS
, 
wNR
;

836 
WORD
 
wP
, 
wV
, 
wTime
, 
wMiSecd
;

837 
tm
 
tmSu
;

838 
BYTE
 
byL
, 
byCou
;

839 
WORD
 
wSlNo
 = 0 ;

840 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

842 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

843 
pTXBuf
[0] = 0x68;

844 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

845 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

846 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

847 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

848 
pTXBuf
[6] = 0x02;

849 
pTXBuf
[8] = 0x03;

850 
pTXBuf
[9] = 0;

851 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

852 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

853 
byL
 = 12;

855 
byCou
 = 0;

856 
m_iSOE_rd_p
 !
m_iSOE_wr_p
)

858 
	`GSOEInfo

wSlNo
 , &
wP
, &
wV
, &
tmSu
, &
wMiSecd
);

859 
wP
 = wP + 
YX_START_ADDR
;

860 
wV
 = wVal & 0x0001;

861 
wTime
 = 
tmSu
.
tm_c
*1000 + 
wMiSecd
;

862 
pTXBuf
[
byL
] = 
	`LOBYTE
(
wP
);

863 
pTXBuf
[
byL
+1] = 
	`HIBYTE
(
wP
);

864 
pTXBuf
[
byL
+2] = 0;

865 
pTXBuf
[
byL
+3] = 
	`LOBYTE
(
wV
);

866 
pTXBuf
[
byL
+4] = 
	`LOBYTE
(
wTime
);

867 
pTXBuf
[
byL
+5] = 
	`HIBYTE
(
wTime
);

868 
pTXBuf
[
byL
+6] = (
BYTE
)
tmSu
.
tm_m
;

869 
byCou
++;

870 
byL
 += 7;

871 if
byL
 > 246 ) ;

873 
pTXBuf
[7] = 
byCou
;

874 
pTXBuf
[1] = 
byL
-2;

875  
byL
;

876 
	}
}

878 
CRtu104
::
	$LdAlogDa21
(
WORD
 
wUnAddr
)

880 
WORD
 
wNS
, 
wNR
, 
wP
 ;

881 
fV
 = 0.0f;

882 
BYTE
 
byL
, 
byCou
;

883 
i
;

884 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

886 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

887 
pTXBuf
[0] = 0x68;

888 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

889 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

890 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

891 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

892 
pTXBuf
[6] = 0x15;

893 
pTXBuf
[8] = 0x14;

894 
pTXBuf
[9] = 0;

895 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

896 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

897 
wP
 = 
YC_START_ADDR
 + 
m_wDaIndex
;

898 
pTXBuf
[12] = 
	`LOBYTE
(
wP
);

899 
pTXBuf
[13] = 
	`HIBYTE
(
wP
);

900 
pTXBuf
[14] = 0;

901 
byL
 = 15;

903 
byCou
 = 0;

904 
i
=
m_wDaIndex
; i< 
m_wAISum
 ; i++)

906 
fV
 = 
m_wAIBuf
[
i
];

907 if
m_pAIMTab
[
i
].
wS
>0 && m_pAIMTab[i].
wPNum
>0 )

908 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
i
].
wS
, m_pAIMTab[i].
wPNum
, 
m_wAIBuf
[i]);

909 
WORD
 
wV
 = ( WORD )
fV
 ;

910 
pTXBuf
[
byL
] = 
	`LOBYTE
(
wV
);

911 
pTXBuf
[
byL
+1] = 
	`HIBYTE
(
wV
);

912 
byCou
++;

913 
byL
 += 2;

914 if
byL
 >= 253 ) ;

916 
pTXBuf
[7] = 0x80 | 
byCou
;

917 
pTXBuf
[1] = 
byL
-2;

919 
m_wDaIndex
 +
byCou
;

920 if(
m_wDaIndex
>=
m_wAISum
 )

922 
	`STnsIndex
( 0 , 0x20 ) ;

924  
byL
;

925 
	}
}

927 
CRtu104
::
	$LdAlogDa13
(
WORD
 
wUnAddr
)

929 
WORD
 
wNS
, 
wNR
, 
wP
;

930 
BYTE
 
byL
, 
byCou
;

931 
i
;

932 
fV
;

933 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

935 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

936 
pTXBuf
[0] = 0x68;

937 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

938 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

939 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

940 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

941 
pTXBuf
[6] = 13;

942 
pTXBuf
[8] = 0x14;

943 
pTXBuf
[9] = 0;

944 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

945 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

946 
wP
 = 
YC_START_ADDR
 + 
m_wDaIndex
;

947 
pTXBuf
[12] = 
	`LOBYTE
(
wP
);

948 
pTXBuf
[13] = 
	`HIBYTE
(
wP
);

949 
pTXBuf
[14] = 0;

950 
byL
 = 15;

952 
byCou
 = 0;

953 
WORD
 
wAISum
 = 
m_wAISum
;

954 
i
=
m_wDaIndex
; i<
wAISum
; i++)

956 
fV
 = 
m_wAIBuf
[
i
];

957 if
m_pAIMTab
[
i
].
wS
>0 && m_pAIMTab[i].
wPNum
>0 )

958 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
i
].
wS
, m_pAIMTab[i].
wPNum
, 
m_wAIBuf
[i]);

961 
BYTE
 
byBufr
[ 4 ] ;

962 
BYTE
 
byBufr1
[ 4 ] ;

963 
	`memy

byBufr
 , &
fV
 , 4 ) ;

964 
	`GlobCyByEndn

byBufr1
, 
byBufr
, 4);

970 
	`memy
(&
pTXBuf
[
byL
], 
byBufr1
, 4);

973 
WORD
 
wSlNo
 = 0xFFFF ;

974 
BYTE
 
bySiq
 = 0 ;

975 
wSlNo
 = 
	`GSlNoFromTns

YC_TRANSTOSERIALNO
 , 
i
 ) ;

976 
BOOL
 
bDevS
 = 
FALSE
 ;

977 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

978 if
bDevS
 =
COM_DEV_ABNORMAL
 )

979 
bySiq
 |= 0xC0 ;

981 
pTXBuf
[
byL
+4] = 
bySiq
 ;

982 
byCou
++;

983 
byL
 += 5;

984 if
byL
 > 248 ) ;

986 
pTXBuf
[7] = 0x80 | 
byCou
;

987 
pTXBuf
[1] = 
byL
-2;

989 
m_wDaIndex
 +
byCou
;

990 if(
m_wDaIndex
>
wAISum
)

992 
	`STnsIndex
( 0 , 0x20 ) ;

994  
byL
;

995 
	}
}

997 
CRtu104
::
	$LdAlogGroup
(
BYTE
 
byGroup
, 
WORD
 
wUnAddr
, BYTE 
byRs
)

999 
WORD
 
wNS
, 
wNR
, 
wIndex
, 
wP
, 
wV
;

1000 
BYTE
 
byL
, 
byCou
;

1001 
i
;

1002 
fV
 = 0.0f ;

1003 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

1005 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

1006 
pTXBuf
[0] = 0x68;

1007 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

1008 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

1009 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

1010 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

1011 
pTXBuf
[6] = 0x15;

1012 
pTXBuf
[8] = 
byRs
;

1013 
pTXBuf
[9] = 0;

1014 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

1015 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

1017 
wIndex
 = 
byGroup
 * 128;

1018 
wP
 = 
YC_START_ADDR
 + 
wIndex
;

1019 
pTXBuf
[12] = 
	`LOBYTE
(
wP
);

1020 
pTXBuf
[13] = 
	`HIBYTE
(
wP
);

1021 
pTXBuf
[14] = 0;

1022 
byL
 = 15;

1024 
byCou
 = 0;

1025 
WORD
 
wAISum
 = 
	`GPSum

YC_SUM
 ) ;

1026 
i
=
wIndex
; i< 
wAISum
; i++)

1028 
fV
 = 
m_wAIBuf
[
i
];

1029 if
m_pAIMTab
[
i
].
wS
>0 && m_pAIMTab[i].
wPNum
>0 )

1030 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
i
].
wS
, m_pAIMTab[i].
wPNum
, 
m_wAIBuf
[i]);

1031 
wV
 = ( 
WORD
 )
fV
 ;

1032 
pTXBuf
[
byL
] = 
	`LOBYTE
(
wV
);

1033 
pTXBuf
[
byL
+1] = 
	`HIBYTE
(
wV
);

1034 
byCou
++;

1035 
byL
 += 2;

1036 if
byL
 >= 253 ) ;

1038 
pTXBuf
[7] = 0x80 | 
byCou
;

1039 
pTXBuf
[1] = 
byL
-2;

1040  
byL
;

1041 
	}
}

1043 
CRtu104
::
	$LdDigDa
(
WORD
 
wUnAddr
)

1045 
WORD
 
wNS
, 
wNR
, 
wP
, 
wV
;

1046 
BYTE
 
byL
, 
byCou
;

1047 
i
;

1048 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

1050 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

1051 
pTXBuf
[0] = 0x68;

1052 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

1053 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

1054 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

1055 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

1056 
pTXBuf
[6] = 0x01;

1057 
pTXBuf
[8] = 0x14;

1058 
pTXBuf
[9] = 0;

1059 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

1060 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

1061 
wP
 = 
YX_START_ADDR
 + 
m_wDaIndex
;

1062 
pTXBuf
[12] = 
	`LOBYTE
(
wP
);

1063 
pTXBuf
[13] = 
	`HIBYTE
(
wP
);

1064 
pTXBuf
[14] = 0;

1065 
byL
 = 15;

1067 
byCou
 = 0;

1068 
WORD
 
wSlNo
 = 0 ;

1070 
i
=
m_wDaIndex
; i<
m_wDISum
 ; i++)

1072 
	`GRlV
(1, (
WORD
)
i
, &
wV
);

1074 
BYTE
 
bySiq
 = 0 ;

1076 if
wV
 )

1077 
bySiq
 = 1 ;

1079 
bySiq
 = 0 ;

1081 
wSlNo
 = 
	`GSlNoFromTns

YX_TRANSTOSERIALNO
 , 
i
 ) ;

1082 
BOOL
 
bDevS
 = 
FALSE
 ;

1083 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

1084 if
bDevS
 =
COM_DEV_ABNORMAL
 )

1085 
bySiq
 |= 0xC0 ;

1087 
pTXBuf
[
byL
] = 
bySiq
 ;

1088 
byCou
++;

1089 
byL
 += 1;

1090 if
byL
 >= 15+127 ) ;

1092 
pTXBuf
[7] = 0x80 | 
byCou
;

1093 
pTXBuf
[1] = 
byL
-2;

1095 
m_wDaIndex
 +
byCou
;

1096 if(
m_wDaIndex
>=
m_wDISum
)

1098 
	`STnsIndex
( 0 , 0 ) ;

1099 
m_wCommd
 |
CMD_IGI_BIT
;

1101  
byL
;

1102 
	}
}

1104 
CRtu104
::
	$LdDigGroup
(
BYTE
 
byGroup
, 
WORD
 
wUnAddr
, BYTE 
byRs
)

1106 
WORD
 
wNS
, 
wNR
, 
wIndex
, 
wP
, 
wV
;

1107 
BYTE
 
byL
, 
byCou
;

1108 
i
;

1109 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

1111 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

1112 
pTXBuf
[0] = 0x68;

1113 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

1114 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

1115 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

1116 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

1117 
pTXBuf
[6] = 0x01;

1118 
pTXBuf
[8] = 
byRs
;

1119 
pTXBuf
[9] = 0;

1120 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

1121 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

1123 
wIndex
 = 
byGroup
 * 128;

1124 
wP
 = 
YX_START_ADDR
 + 
wIndex
;

1125 
pTXBuf
[12] = 
	`LOBYTE
(
wP
);

1126 
pTXBuf
[13] = 
	`HIBYTE
(
wP
);

1127 
pTXBuf
[14] = 0;

1128 
byL
 = 15;

1130 
byCou
 = 0;

1131 
i
=
wIndex
; i<
	`GPSum

YX_SUM
 ); i++)

1133 
	`GRlV
(1, (
WORD
)
i
, &
wV
);

1134 
pTXBuf
[
byL
] = 
	`LOBYTE
(
wV
) & 0x81;

1135 
byCou
++;

1136 
byL
 += 1;

1137 if
byL
 >= 15+127 ) ;

1139 
pTXBuf
[7] = 0x80 | 
byCou
;

1140 
pTXBuf
[1] = 
byL
-2;

1141  
byL
;

1142 
	}
}

1144 
CRtu104
::
	$LdPulDa
(
WORD
 
wUnAddr
)

1146 
WORD
 
wNS
, 
wNR
, 
wP
;

1147 
BYTE
 
byL
, 
byCou
;

1148 
i
;

1149 
DWORD
 
dwV
;

1150 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

1152 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

1153 
pTXBuf
[0] = 0x68;

1154 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

1155 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

1156 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

1157 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

1158 
pTXBuf
[6] = 0x0f;

1159 
pTXBuf
[8] = 0x25;

1160 
pTXBuf
[9] = 0;

1161 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

1162 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

1163 
wP
 = 
PA_START_ADDR
 + 
m_wDaIndex
;

1164 
pTXBuf
[12] = 
	`LOBYTE
(
wP
);

1165 
pTXBuf
[13] = 
	`HIBYTE
(
wP
);

1166 
pTXBuf
[14] = 0;

1167 
byL
 = 15;

1169 
byCou
 = 0;

1170 
i
=
m_wDaIndex
; i<
m_wPISum
; i++)

1172 
dwV
 = 
m_dwPIBuf
[
i
];

1174 
pTXBuf
[
byL
] = 
	`LOBYTE
(
	`LOWORD
(
dwV
));

1175 
pTXBuf
[
byL
+1] = 
	`HIBYTE
(
	`LOWORD
(
dwV
));

1176 
pTXBuf
[
byL
+2] = 
	`LOBYTE
(
	`HIWORD
(
dwV
));

1177 
pTXBuf
[
byL
+3] = 
	`HIBYTE
(
	`HIWORD
(
dwV
));

1180 
WORD
 
wSlNo
 = 0xFFFF ;

1181 
BYTE
 
bySiq
 = 0 ;

1182 
wSlNo
 = 
	`GSlNoFromTns

DD_TRANSTOSERIALNO
 , 
i
 ) ;

1183 
BOOL
 
bDevS
 = 
FALSE
 ;

1184 
bDevS
 = 
m_pMhod
->
	`GDevCommS

wSlNo
 ) ;

1185 if
bDevS
 =
COM_DEV_ABNORMAL
 )

1186 
bySiq
 |= 0xC0 ;

1188 
pTXBuf
[
byL
+4] = 
bySiq
 ;

1189 
byCou
++;

1190 
byL
 += 5;

1191 if
byL
 >= 175 ) ;

1193 
pTXBuf
[7] = 0x80 | 
byCou
;

1194 
pTXBuf
[1] = 
byL
-2;

1196 
m_wDaIndex
 +
byCou
;

1197 if(
m_wDaIndex
>=
m_wPISum
 )

1199 
	`STnsIndex
( 0 , 0 ) ;

1200 
	`SCommd

CMD_YM_END
 );

1203  
byL
;

1204 
	}
}

1206 
CRtu104
::
	$LdPulGroup
(
BYTE
 
byGroup
, 
WORD
 
wUnAddr
, BYTE 
byRs
)

1208 
WORD
 
wNS
, 
wNR
, 
wIndex
, 
wP
;

1209 
BYTE
 
byL
, 
byCou
;

1210 
i
;

1211 
DWORD
 
dwV
;

1212 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

1214 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

1215 
pTXBuf
[0] = 0x68;

1216 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

1217 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

1218 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

1219 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

1220 
pTXBuf
[6] = 0x0f;

1221 
pTXBuf
[8] = 
byRs
;

1222 
pTXBuf
[9] = 0;

1223 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

1224 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

1226 
wIndex
 = 
byGroup
 * 32;

1227 
wP
 = 
PA_START_ADDR
 + 
wIndex
;

1228 
pTXBuf
[12] = 
	`LOBYTE
(
wP
);

1229 
pTXBuf
[13] = 
	`HIBYTE
(
wP
);

1230 
pTXBuf
[14] = 0;

1231 
byL
 = 15;

1233 
byCou
 = 0;

1234 
i
=
wIndex
; i<
	`GPSum

YM_SUM
 ); i++)

1237 
dwV
 = 
	`CcPulReV
(
m_pPIMTab
[
i
].
wS
,

1238 
m_pPIMTab
[
i
].
wPNum
,

1239 
m_dwPIBuf
[
i
]);

1241 
pTXBuf
[
byL
] = 
	`LOBYTE
(
	`LOWORD
(
dwV
));

1242 
pTXBuf
[
byL
+1] = 
	`HIBYTE
(
	`LOWORD
(
dwV
));

1243 
pTXBuf
[
byL
+2] = 
	`LOBYTE
(
	`HIWORD
(
dwV
));

1244 
pTXBuf
[
byL
+3] = 
	`HIBYTE
(
	`HIWORD
(
dwV
));

1245 
pTXBuf
[
byL
+4] = 0;

1246 
byCou
++;

1247 
byL
 += 5;

1248 if
byL
 >= 175 ) ;

1250 
pTXBuf
[7] = 0x80 | 
byCou
;

1251 
pTXBuf
[1] = 
byL
-2;

1252  
byL
;

1253 
	}
}

1255 
CRtu104
::
	$LdADa
(
WORD
 
wUnAddr
)

1257 
m_byDaSty
 & 0xf0)

1261  
	`LdAlogDa13
(
wUnAddr
);

1263  
	`LdAlogDa21
(
wUnAddr
);

1265  
	`LdDigDa
(
wUnAddr
);

1267  
	`LdPulDa
(
wUnAddr
);

1270 
	}
}

1272 
CRtu104
::
	$LdRayEchoFme
(
WORD
 
wUnAddr
, 
BYTE
 
byTy
, BYTE 
byRs
, WORD 
wIndexNum
, BYTE 
byCmd
)

1274 
WORD
 
wP
, 
wNS
, 
wNR
;

1275 
BYTE
 
byL
;

1276 
BYTE
 *
pTXBuf
 = 
m_pTX_Buf
;

1278 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

1279 
pTXBuf
[0] = 0x68;

1280 
pTXBuf
[2] = 
	`LOBYTE
(
wNS
);

1281 
pTXBuf
[3] = 
	`HIBYTE
(
wNS
);

1282 
pTXBuf
[4] = 
	`LOBYTE
(
wNR
);

1283 
pTXBuf
[5] = 
	`HIBYTE
(
wNR
);

1284 
byL
 = 4;

1285 
pTXBuf
[6] = 
byTy
;

1286 
pTXBuf
[7] = 0x01;

1287 
pTXBuf
[8] = 
byRs
;

1288 
pTXBuf
[9] = 0;

1289 
pTXBuf
[10] = 
	`LOBYTE
(
wUnAddr
);

1290 
pTXBuf
[11] = 
	`HIBYTE
(
wUnAddr
);

1291 
wP
 = 
DO_START_ADDR
 + 
wIndexNum
;

1292 
pTXBuf
[12] = 
	`LOBYTE
(
wP
);

1293 
pTXBuf
[13] = 
	`HIBYTE
(
wP
);

1294 
pTXBuf
[14] = 0;

1295 
pTXBuf
[15] = 
byCmd
;

1296 
byL
 += 10;

1298 
pTXBuf
[1] = 
byL
;

1299  
byL
+2;

1300 
	}
}

1302 
CRtu104
::
	$Rend_Proc
( )

1304  
m_nTXCou
;

1305 
	}
}

1307 
CRtu104
::
	$RecvToutProc
()

1309 
	}
}

1311 
CRtu104
::
	$AckMesgeProc
(
BYTE
* 
pDaBuf
, 
nL
)

1314 
	}
}

1316 
CRtu104
::
	$RayCmdProc

BYTE
 
byTyID
 , BYTE 
byRs
 , 
WORD
 
wInfoAddr
 , BYTE 
byV
 )

1318 
WORD
 
wP
 = 0 , 
wNum
 = 0 ;

1319 
WORD
 
wS
 = 0;

1320 
BYTE
 
byDCO
 = 0 , 
byStus
=0xff;

1321 
nSize
 = 0 ;

1322 
wNum
 = 
wInfoAddr
 - 
DO_START_ADDR
;

1323 
byDCO
 = 
byV
 ;

1325 if
byTyID
 != 45 && byTypeID != 46 )

1330 if
wInfoAddr
 < 0x6001 || wInfoAddr > 0x6200 )

1335 if
wNum
 >
	`GPSum

YK_SUM
 ) )

1337 
	`YK_EPross

byTyID
 , 
wNum
 , 
wP
 , 
byDCO
 , 
byRs
 ) ;

1341 
wS
 = 
m_pDOMTab
[
wNum
].wStn - 1 ;

1342 
wP
 = 
m_pDOMTab
[
wNum
].
wPNum
 - 1 ;

1344 
BYTE
 
bySDCO
 = 
	`GS_DCO

byTyID
 , 
byDCO
 ) ;

1345  
bySDCO
 )

1348 
byStus
 = 0x00;

1351 
byStus
 = 0x01;

1354 
	`YK_EPross

byTyID
 , 
wNum
 , 
wP
 , 
byDCO
 , 
byRs
 ) ;

1358 if
byRs
 ==0x06 )

1360 if(
byDCO
 & 0x80) != 0)

1362 
	`SYKDa

byTyID
 , 
wNum
 , 
wP
 , 
byDCO
 , 
byRs
 ) ;

1363 
nSize
 = 
	`RaySeProc

wS
 , 
wP
, 
byStus
);

1364 
	`STTim

IEC104_YKTIME
 , 
IEC104_YK_STARTTIME
 ) ;

1369 
BYTE
 
byAi
 = 0 ;

1370 
WORD
 
wRayNum
 = 0 ;

1371 
BYTE
 
byANum
 = 0 ;

1372 
BYTE
 
byAMk
 = 0 ;

1373 
WORD
 
wSeTime
 = 0 ;

1374 
	`GYkDa

byAi
 , 
wRayNum
, 
byANum
 , 
byAMk
 , 
wSeTime
 ) ;

1377 
byAi
 =
byTyID
 ) &&

1378 
wRayNum
 =
wNum
 ) &&

1379 
byAMk
 & 0x7F ) =
byDCO
 ) &&

1380 
	`YK_IsCSd
()

1383 
	`SYKDa

byAi
 , 
wRayNum
 , 
wP
 , 
byDCO
 , 
byRs
 ) ;

1384 
	`RayExecuProc

wS
, 
wP
, 
byStus
 );

1385 
	`STTim

IEC104_YKTIME
 , 
IEC104_YK_STARTTIME
 ) ;

1389 
	`YK_EPross

byAi
 , 
wRayNum
 , 
byANum
 , 
byDCO
 , 
byRs
 ) ;

1393 if
byRs
 ==0x08 )

1395 if
	`YK_IsCSd
() )

1397 
	`SYKDa

byTyID
 , 
wNum
 , 
wP
 , 
byDCO
 , 
byRs
 ) ;

1398 
	`RayClProc

wS
 , 
wP
, 
byStus
);

1399 
	`STTim

IEC104_YKTIME
 , 
IEC104_YK_STARTTIME
 ) ;

1402 
	`YK_EPross

byTyID
 , 
wNum
 , 
wP
 , 
byDCO
 , 
byRs
 ) ;

1405 
	`YK_EPross

byTyID
 , 
wNum
 , 
wP
 , 
byDCO
 , 
byRs
 ) ;

1407  
nSize
;

1408 
	}
}

1410 
CRtu104
::
	$YK_PS

BOOL
 
bPSFg
 )

1412 
m_YkFg
 = 
bPSFg
 ;

1413 
	}
}

1415 
BOOL
 
CRtu104
::
	$YK_IsCSd
( )

1417  
m_YkFg
 ;

1418 
	}
}

1421 
BYTE
 
CRtu104
::
	$GS_DCO

BYTE
 
byTyID
 , BYTE 
byV
 )

1423 if
byTyID
 != 45 ) && ( byTypeID != 46 ) )

1426 if
byTyID
 == 45 )

1428  
byV
 & 0x01 )

1431  
FALSE
 ;

1433  
TRUE
 ;

1436 if
byTyID
 == 46 )

1438  
byV
 & 0x03 )

1441  
FALSE
 ;

1443  
TRUE
 ;

1452 
	}
}

1454 
CRtu104
::
	$GYkDa

BYTE
 &
byAi
 , 
WORD
 &
wRayNum
 , BYTE & 
byANum
 ,

1455 
BYTE
 & 
byAMk
 , 
WORD
 & 
wRs
)

1457 
byAi
 = 
m_byAi
 ;

1458 
wRayNum
 = 
m_wRayNum
;

1459 
byAMk
 = 
m_byAMk
 ;

1460 
wRs
 = 
m_wSeTim
 ;

1461 
	}
}

1468 
CRtu104
::
	$SYKDa

BYTE
 
byAi
 , 
WORD
 
wRayNum
 , BYTE 
byANum
 ,

1469 
BYTE
 
byAMk
 , 
WORD
 
wRs
 )

1471 
m_byAi
 = 
byAi
 ;

1472 
m_wRayNum
 = 
wRayNum
;

1473 
m_wANum
 = 
byANum
 ;

1474 
m_byAMk
 = 
byAMk
 ;

1475 
m_wSeTim
 = 
wRs
 ;

1476 
	}
}

1478 
CRtu104
::
	$RaySeProc
(
WORD
 
wS
, WORD 
wClNum
, 
BYTE
 
byStus
)

1480 
BYTE
 
byBusNo
;

1481 
WORD
 
wDevAddr
;

1483 if(
m_pMhod
->
	`GBusLeAndAddr
(
wS
, 
byBusNo
, 
wDevAddr
))

1484 
m_pMhod
->
	`SYkS
(
this
, 
byBusNo
, 
wDevAddr
, 
wClNum
, 
byStus
);

1486 
	`tf
("[Rtu104]:serialnorr");

1488 
	}
}

1490 
CRtu104
::
	$RayExecuProc
(
WORD
 
wS
, WORD 
wClNum
, 
BYTE
 
byStus
)

1492 
BYTE
 
byBusNo
;

1493 
WORD
 
wDevAddr
;

1495 if(
m_pMhod
->
	`GBusLeAndAddr
(
wS
, 
byBusNo
, 
wDevAddr
))

1496 
m_pMhod
->
	`SYkExe
(
this
, 
byBusNo
, 
wDevAddr
, 
wClNum
, 
byStus
);

1498 
	`tf
("[Rtu104]:serialnorr");

1500 
	}
}

1502 
CRtu104
::
	$RayClProc
(
WORD
 
wS
, WORD 
wClNum
, 
BYTE
 
byStus
)

1504 
BYTE
 
byBusNo
;

1505 
WORD
 
wDevAddr
;

1507 if(
m_pMhod
->
	`GBusLeAndAddr
(
wS
, 
byBusNo
, 
wDevAddr
))

1508 
m_pMhod
->
	`SYkCl
(
this
, 
byBusNo
, 
wDevAddr
, 
wClNum
, 
byStus
);

1510 
	`tf
("[Rtu104]:serialnorr");

1512 
	}
}

1514 
CRtu104
::
	$GroupReqProc
(
BYTE
* 
pDaBuf
, 
nL
)

1516 
WORD
 
wRtuAddr
 = 
	`MAKEWORD
(
pDaBuf
[4],DataBuf[5]);

1517 
BYTE
 
byQOI
 = 
pDaBuf
[9];

1519 if(
byQOI
>=29 && byQOI<=36)

1520  
	`LdAlogGroup
(
byQOI
-29, 
wRtuAddr
, byQOI);

1521 if(
byQOI
>=21 && byQOI<=28)

1522  
	`LdDigGroup
(
byQOI
-21, 
wRtuAddr
, byQOI);

1525 
	}
}

1527 
CRtu104
::
	$PulReqProc
(
BYTE
* 
pDaBuf
, 
nL
)

1529 
BYTE
 
byQCC
 = 
pDaBuf
[9] & 0x3f ;

1531 if
byQCC
 == 5 )

1533 
	`SCommd

CMD_YM_CONFIRM
 ) ;

1537 
	`SCommd

CMD_YM_ERROR
 ) ;

1541 
	}
}

1543 
BOOL
 
CRtu104
::
	$SysClockProc
(
BYTE
* 
pDaBuf
, 
nL
)

1545 if
pDaBuf
 =
NULL
 || 
nL
 < 16 )

1546  
FALSE
 ;

1548 
REALTIME
 
t
;

1549 
WORD
 
wMSecd
;

1551 if(
m_wRecvClock
>0)

1553 
wMSecd
 = 
	`MAKEWORD
(
pDaBuf
[9],DataBuf[10]);

1554 
t
.
wMliSec
 = 
wMSecd
 % 1000;

1555 
t
.
wSecd
 = 
wMSecd
 / 1000;

1556 
t
.
wMu
 = 
pDaBuf
[11] & 0x3f;

1557 
t
.
wHour
 = 
pDaBuf
[12] & 0x1f;

1558 
t
.
wDay
 = 
pDaBuf
[13] & 0x1f;

1559 
t
.
wMth
 = 
pDaBuf
[14] & 0x0f;

1560 if(
pDaBuf
[15]>30)

1561 
t
.
wYr
 = 
pDaBuf
[15] + 1970;

1563 
t
.
wYr
 = 
pDaBuf
[15] + 2000;

1565 if
t
.
wSecd
 < 60 &&

1566 
t
.
wMu
 < 60 &&

1567 
t
.
wHour
 < 24 &&

1568 
t
.
wDay
 <= 31 &&

1569 
t
.
wMth
 <= 12 &&

1570 
t
.
wYr
 < 2030 )

1572 
	`SCutTime
&
t
 );

1575  
TRUE
 ;

1576 
	}
}

1578 
CRtu104
::
	$DlBusMsgInfo
(
PBUSMSG
 
pBusMsg
)

1580 
YK_DATA
 *
pDa
 = (YK_DATA *)(
pBusMsg
->pData);

1581 
WORD
 
wSlNo
;

1582  
pBusMsg
->
byMsgTy
 )

1584 
YK_PROTO
:

1585  
pBusMsg
->
dwDaTy
 )

1587 
YK_SEL_RTN
:

1588 
YK_EXCT_RTN
:

1589 
YK_CANCEL_RTN
:

1591 if
pBusMsg
->
DaNum
 != 1

1592 || 
pBusMsg
->
DaL
 !(
YK_DATA
) )

1594 
	`tf
("IEC104 Yk DataNumrr\n");

1598 
mp
 = 
m_pMhod
->
	`GSlNo
(
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
);

1599 if
mp
 == -1 )

1602 
wSlNo
 = ( 
WORD
 ) 
mp
 ;

1604 if
pDa
->
byV
 =
YK_ERROR
 )

1608 
BYTE
 
byAi
 = 0 ;

1609 
WORD
 
wRayNum
 = 0 ;

1610 
BYTE
 
byANum
 = 0 ;

1611 
BYTE
 
byAMk
 = 0 ;

1612 
WORD
 
wRs
 = 0 ;

1613 
	`GYkDa

byAi
 , 
wRayNum
 , 
byANum
 , 
byAMk
 , 
wRs
 ) ;

1614 
	`YK_EPross

byAi
 , 
wRayNum
 , 
byANum
 , 
byAMk
 , 
wRs
 ) ;

1618 
	`RayProc
((
BYTE
)
pBusMsg
->
dwDaTy
, 
wSlNo
, 
pDa
->
wP
, (BYTEDa->
byV
);

1626 
	`tf
("IEC104 c'fdhYK_DATATYPE %d\n", ()
pBusMsg
->
dwDaTy
);

1636 
	}
}

1641 
CRtu104
::
	$TaskProcHd
()

1643 
	}
}

1646 
BOOL
 
CRtu104
::
	$In

BYTE
 
byLeNo
 )

1648 
m_byLeNo
 = 
byLeNo
 ;

1649 
m_byProID
 = 4;

1650 
m_byEb
 = 1;

1651 
m_wObjNum
 = 1;

1652 
	`rtf

m_szObjName
, "%s", 
m_sDevName
 );

1653 
	`rtf

m_ComCl1
, "%s", 
m_sMaAddr
 );

1654 
m_wRtuAddr
 = 
m_wDevAddr
 ;

1655 
szFeName
[256] = "";

1657 
	`rtf

szFeName
, "%s%s", 
IEC104PREFIXFILENAME
, 
m_sTemePh
 );

1659 
	`RdMCfig

szFeName
 );

1662 
	`InRtuBa
() ;

1665 
	`time
&
m_DevSTime
 ) ;

1666  
TRUE
 ;

1667 
	}
}

1669 
CRtu104
::
	$SedPross

WORD
 
wAddr
 )

1671 
n
 = 0 ;

1672 if
	`GCommd
(=
CMD_TIME_CONFIRM
 )

1674 
n
 = 
	`SysClockCfm

wAddr
 ) ;

1675 
	`SCommd

CMD_NULL
 ) ;

1677 if
	`GCommd
(=
CMD_TOTAL_CONFIRM
 )

1679 
n
 = 
	`ADaEcho
(
m_wRtuAddr
, 0x07);

1680 
	`SCommd

CMD_NULL
 ) ;

1683 if
m_byDaSty
 != 0 )

1684 
n
 = 
	`LdADa
(
wAddr
);

1686 if(
m_wCommd
 & 
CMD_IGI_BIT
) != 0 )

1688 
m_wCommd
 &~
CMD_IGI_BIT
;

1689 
n
 = 
	`ADaEcho
(
wAddr
, 10);

1691 if
	`GCommd
(=
CMD_YM_CONFIRM
 )

1693 
	`STnsIndex
( 0 , 0x30 ) ;

1694 
	`SCommd

CMD_NULL
 ) ;

1695 
n
 = 
	`ReqPulEcho

wAddr
 , 7, 0x05 );

1697 if
	`GCommd
=
CMD_YM_ERROR
)

1699 
n
 = 
	`ReqPulEcho

wAddr
 , 47, 0x05 );

1700 
	`SCommd

CMD_NULL
 ) ;

1703 if
	`GCommd
=
CMD_YM_END
 )

1705 
n
 = 
	`ReqPulEcho

wAddr
 , 10 , 0x05 );

1706 
	`SCommd

CMD_NULL
 ) ;

1709 
n
 = 
	`ChgeDaPross

wAddr
 ) ;

1711  
n
 ;

1712 
	}
}

1714 
CRtu104
::
	$PPross

WORD
 
wAddr
 )

1716 
n
 = 0 ;

1718 if((
m_wCommd
 & 
CMD_TEST_BIT
) != 0)

1720 
n
 = 
	`TeFmeAck
();

1721 
m_wCommd
 &~
CMD_TEST_BIT
;

1723 if
m_wCommd
 & 
CMD_TEST_SEND
 )

1725 
n
 = 
	`TeSd
( ) ;

1726 
m_wCommd
 &~
CMD_TEST_SEND
 ;

1729 
	`STTim

IEC104_T3
 , 
IEC104_END_T3
 ) ;

1730 
	`STTim

IEC104_T1
 , 
IEC104_START_T1
 ) ;

1732 if((
m_wCommd
 & 
CMD_START_BIT
) != 0)

1734 
n
 = 
	`SDaAck
();

1735 
m_wCommd
 &~
CMD_START_BIT
;

1736 
m_bSB
 = 
TRUE
;

1738 if((
m_wCommd
 & 
CMD_STOP_BIT
) != 0)

1740 
n
 = 
	`StDaAck
();

1741 
m_wCommd
 &~
CMD_STOP_BIT
;

1742 
m_bSB
 = 
FALSE
;

1744 if((
m_wCommd
 & 
CMD_UFACK_BIT
) != 0)

1746 
n
 = 
	`AckFme
();

1747 
m_wCommd
 &~
CMD_UFACK_BIT
;

1750 
	`STTim

IEC104_T2
 , 
IEC104_START_T2
 ) ;

1753 if(
m_wCommd
 & 
CMD_COA_BIT
) != 0 )

1755 
	`YK_R

n
 ) ;

1756 
m_wCommd
 &~
CMD_COA_BIT
;

1758 if
	`GCommd
(=
CMD_YK_ERROR
 )

1760 
BYTE
 
byAi
 = 0 ;

1761 
WORD
 
wRayNum
 = 0 ;

1762 
BYTE
 
byANum
 = 0 ;

1763 
BYTE
 
byAMk
 = 0 ;

1764 
WORD
 
wRs
 = 0 ;

1765 
	`GYkDa

byAi
 , 
wRayNum
 , 
byANum
 , 
byAMk
 , 
wRs
 ) ;

1767 
n
 = 
	`LdRayEchoFme

m_wRtuAddr
, 
byAi
, 
wRs
, 
wRayNum
 , 
byAMk
 );

1768 
	`SCommd

CMD_NULL
 ) ;

1771  
n
 ;

1772 
	}
}

1774 
CRtu104
::
	$YK_R
&
n
 )

1776 
BYTE
 
byAi
 = 0 ;

1777 
WORD
 
wRayNum
 = 0 ;

1778 
BYTE
 
byANum
 = 0 ;

1779 
BYTE
 
byAMk
 = 0 ;

1780 
WORD
 
wSeTime
 = 0 ;

1781 
	`GYkDa

byAi
 , 
wRayNum
 , 
byANum
 , 
byAMk
 , 
wSeTime
 ) ;

1783 if(
m_wYkFg
 =
YK_SEL_RTN
 )

1785 
n
 = 
	`LdRayEchoFme
(
m_wRtuAddr
, 
byAi
, 0x07, 
wRayNum
, 0x80 | 
byAMk
);

1786 
	`YK_RCfm

TRUE
 ) ;

1788 if(
m_wYkFg
 =
YK_EXCT_RTN
 )

1790 
n
 = 
	`LdRayEchoFme
(
m_wRtuAddr
, 
byAi
, 0x07, 
wRayNum
, 
byAMk
);

1791 
	`YK_RCfm

FALSE
 ) ;

1793 if
m_wYkFg
 =
YK_CANCEL_RTN
 )

1795 
n
 = 
	`LdRayEchoFme
(
m_wRtuAddr
, 
byAi
, 0x09, 
wRayNum
, 0x80 | 
m_byAMk
);

1796 
	`YK_RCfm

FALSE
 ) ;

1799 
	}
}

1801 
CRtu104
::
	$YK_RCfm

BOOL
 
bFg
 )

1803 
	`YK_PS

bFg
 ) ;

1804 
	`STTim

IEC104_YKTIME
 , 
IEC104_YK_ENDTIME
 ) ;

1805 
	}
}

1807 
CRtu104
::
	$ChgeDaPross

WORD
 
wAddr
 )

1809 
n
 = 0 ;

1812 
time_t
 
timeTemp
 ;

1813 
	`time
&
timeTemp
 ) ;

1815 if
m_dwDIEQueue
.
	`size
() > 0 )

1816 
n
 = 
	`LdDIEFme

wAddr
 );

1818 if
m_iSOE_rd_p
 !
m_iSOE_wr_p
 )

1819 
n
 = 
	`LdSOEFme_30
(
wAddr
);

1821 if(!
QuyADevStus
 && (
deque_
.
	`size
(!0|| (
	`difime

timeTemp
 , 
m_DevSTime
 ) > 10))

1823 
n
 = 
	`ComS_Mesge

wAddr
 ) ;

1824 
	`time
&
m_DevSTime
 ) ;

1826 if
m_dwAIEQueue
.
	`size
() > 0 )

1832 
n
 = 
	`LdAIEFme13
(
wAddr
);

1835  
n
 ;

1836 
	}
}

1838 
BOOL
 
CRtu104
::
	$IsCSd
( )

1840 if
m_wNumSd
 - 
m_wNumAck
 >
IEC104_Q
 )

1843  
FALSE
 ;

1845 if
m_wNumSd
 < 
m_wNumAck
 )

1847  
FALSE
;

1850  
TRUE
 ;

1851 
	}
}

1853 
BOOL
 
CRtu104
::
	$LdRtuMesge

BYTE
 * 
pBuf
 , &
n
 )

1855 if
pBuf
 =
NULL
 )

1856  
FALSE
 ;

1858 
WORD
 
wAddr
;

1859 
wAddr
 = 
m_wRtuAddr
;

1860 
m_pTX_Buf
 = 
pBuf
 ;

1862 
n
 = 
	`PPross

wAddr
 ) ;

1863 if
n
 > 0 )

1867 if
m_bSB
 )

1869 if!
	`IsCSd
( ) )

1870  
FALSE
 ;

1872 
n
 = 
	`SedPross

wAddr
 ) ;

1876 if
n
 <= 0 )

1877  
FALSE
;

1881 if(
m_pTX_Buf
[2] & 0x01) == 0 )

1883 
m_wNumSd
 = (m_wNumSd+1% 
MAXMUM_NUM
;

1885 
	`STTim

IEC104_T2
 , 
IEC104_START_T2
 ) ;

1886 
	`STTim

IEC104_T3
 , 
IEC104_START_T3
 ) ;

1889 
m_wTimCou
= 0;

1892  
TRUE
 ;

1893 
	}
}

1895 
BOOL
 
CRtu104
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

1897 if
buf
 =
NULL
 )

1898  
FALSE
 ;

1900 if
pBusMsg
 )

1902 
	`DlBusMsgInfo
(
pBusMsg
);

1906 if!
m_pMhod
->
	`IsPtVid
() )

1908 
	`ReSS
() ;

1911 
	`LdRtuMesge

buf
 , 
n
 ) ;

1917  
TRUE
;

1918 
	}
}

1920 
BOOL
 
CRtu104
::
	$ProssProcBuf

BYTE
 * 
pbuf
 , 
n
 )

1922 if
n
 =0 || 
pbuf
 =
NULL
 )

1923  
FALSE
 ;

1925 
	`RtuCommdProc

pbuf
 , 
n
 );

1927  
TRUE
 ;

1928 
	}
}

1930 
BOOL
 
CRtu104
::
	$GSDt
( )

1932  
m_bSB
 ;

1933 
	}
}

1935 
WORD
 
CRtu104
::
	$GSeqNo

BYTE
 * 
pBuf
 )

1937 
WORD
 
wSeqNo
;

1939 if(
pBuf
==
NULL
)

1942 
wSeqNo
=
	`MAKEWORD
(*
pBuf
 ,*(Buf+1 ) );

1943 
wSeqNo
>>=1;

1945  
wSeqNo
;

1946 
	}
}

1948 
BOOL
 
CRtu104
::
	$ProcRecvNo

WORD
 
wRecNo
 )

1950 if
wRecNo
 !
m_wNumRecv
 )

1951  
FALSE
;

1953 
m_wNumRecv
++;

1954 if
m_wNumRecv
 >
MAXMUM_NUM
 )

1955 
m_wNumRecv
 = 0 ;

1957 if
m_wNumRecBK
 > 
m_wNumRecv


1958 && 
m_wNumRecv
+
MAXMUM_NUM
 - 
m_wNumRecBK
 >
IEC104_W
 )

1961 
m_wCommd
 |
CMD_UFACK_BIT
;

1964 if
m_wNumRecBK
 < 
m_wNumRecv


1965 && 
wRecNo
- 
m_wNumRecBK
 >
IEC104_W
 )

1968 
m_wCommd
 |
CMD_UFACK_BIT
;

1971  
TRUE
 ;

1972 
	}
}

1974 
BOOL
 
CRtu104
::
	$ProcSdNo

WORD
 
wAckNo
 )

1977 if
m_wNumAck
 =
wAckNo
)

1978  
TRUE
;

1980 if
m_wNumSd
 > 
m_wNumAck
 )

1982 if
wAckNo
 < 
m_wNumAck
 || wAckNo> 
m_wNumSd
 )

1983  
FALSE
;

1985 if
m_wNumSd
 < 
m_wNumAck
 )

1987 if
wAckNo
 > 
m_wNumSd
 && wAckNo<
m_wNumAck
 )

1988  
FALSE
;

1992 if(
wAckNo
!=
m_wNumSd
 )

1993  
FALSE
;

1996 
m_wNumAck
 = 
wAckNo
 ;

1999 if
m_wNumAck
!
m_wNumSd
 )

2001 
	`STTim

IEC104_T4
 , 
IEC104_START_T4
 );

2005 
	`STTim

IEC104_T4
 , 
IEC104_END_T4
 );

2008  
TRUE
 ;

2009 
	}
}

2012 
CRtu104
::
	$RtuCommdProc
(
BYTE
* 
pRecvBuf
, 
nL
)

2014 
BYTE
 
byCmd
;

2015 
WORD
 
wNS
, 
wNR
;

2016 
WORD
 
wIndex
 = 0 ;

2017 
WORD
 
n
 = 0 ;

2020 
m_pRX_Buf
 = 
pRecvBuf
 ;

2021 
m_nRXCou
 = 
nL
;

2023 if
m_nRXCou
 < 1 )

2026 if
m_pRX_Buf
[ 
wIndex
++ ] != 0x68 )

2029 
n
 = 
m_pRX_Buf
[ 
wIndex
] + 2;

2031 if
m_nRXCou
 !
n
 )

2034 
byCmd
 = 
pRecvBuf
[2];

2035 
byCmd
 & 0x03)

2040 if
	`GSDt
(=
FALSE
 )

2044 
wNR
 = 
	`GSeqNo

pRecvBuf
 + 2 ) ;

2047 if!
	`ProcRecvNo

wNR
 ) )

2049 
	`ReSS
() ;

2050 if
m_pMhod
 )

2051 
m_pMhod
->
	`CloSock

m_byLeNo
 ) ;

2056 
wNS
 = 
	`GSeqNo

pRecvBuf
 + 4 ) ;

2059 if!
	`ProcSdNo

wNS
 ) )

2061 
	`ReSS
() ;

2062 if
m_pMhod
 )

2063 
m_pMhod
->
	`CloSock

m_byLeNo
 ) ;

2067 if(
nL
 > 6)

2069 
	`InfoMesgeProc
(&
pRecvBuf
[6], 
nL
-6);

2070 
	`STTim

IEC104_T2
 , 
IEC104_START_T2
 ) ;

2071 
	`STTim

IEC104_T3
 , 
IEC104_START_T3
 ) ;

2077 
wNR
 = 
	`MAKEWORD
(
pRecvBuf
[4],RecvBuf[5])>>1;

2080 if!
	`ProcSdNo

wNR
 ) )

2082 
	`ReSS
() ;

2083 if
m_pMhod
 )

2084 
m_pMhod
->
	`CloSock

m_byLeNo
 ) ;

2088 
	`STTim

IEC104_T3
 , 
IEC104_START_T3
 ) ;

2093 if((
byCmd
 & 0x04) != 0)

2095 
	`ReSS
( ) ;

2097 
m_wCommd
 |
CMD_START_BIT
;

2099 
	`STTim

IEC104_T2
 , 
IEC104_START_T2
 ) ;

2100 
	`STTim

IEC104_T3
 , 
IEC104_START_T3
 ) ;

2102 if((
byCmd
 & 0x10) != 0)

2103 
m_wCommd
 |
CMD_STOP_BIT
;

2104 if((
byCmd
 & 0x40) != 0)

2106 
m_wCommd
 |
CMD_TEST_BIT
;

2107 
	`STTim

IEC104_T3
 , 
IEC104_START_T3
 ) ;

2109 if
byCmd
 & 0x80 ) !=0 )

2112 
	`STTim

IEC104_T1
 , 
IEC104_END_T1
 ) ;

2113 
	`STTim

IEC104_T3
 , 
IEC104_START_T3
 ) ;

2122 
	}
}

2124 
BOOL
 
CRtu104
::
	$ReSS
( )

2127 
m_wNumRecv
 = 0;

2128 
m_wNumRecBK
 = 0;

2131 
m_wNumSd
 = 0;

2132 
m_wNumAck
 = 0;

2135 
m_byTimeFg
 = 0 ;

2137 
	`STTim

IEC104_T1
 , 
IEC104_END_T1
 ) ;

2138 
	`STTim

IEC104_T2
 , 
IEC104_END_T2
 ) ;

2139 
	`STTim

IEC104_T3
 , 
IEC104_END_T3
 ) ;

2140 
	`STTim

IEC104_T4
 , 
IEC104_END_T4
 ) ;

2141 
	`STTim

IEC104_YK_STARTTIME
 , 
IEC104_YK_ENDTIME
 ) ;

2144 
m_bSB
 = 
FALSE
 ;

2147 
m_wCommd
 = 0 ;

2150 
	`YK_PS

FALSE
 ) ;

2151 
m_YKTime
 = 0 ;

2154 
	`time
&
m_DevSTime
 ) ;

2156  
TRUE
 ;

2157 
	}
}

2160 
BOOL
 
CRtu104
::
	$STTim

BYTE
 
byTime
 , BYTE 
byS
 )

2162  
byTime
 )

2164 
IEC104_T1
:

2166 
	`SIEC104Time
&
m_t1
 , 
byS
 , 
IEC104_START_T1
 , 
IEC104_END_T1
 ) ;

2169 
IEC104_T2
:

2171 
	`SIEC104Time
&
m_t2
 , 
byS
 , 
IEC104_START_T2
 , 
IEC104_END_T2
 ) ;

2174 
IEC104_T3
 :

2176 
	`SIEC104Time
&
m_t3
 , 
byS
 , 
IEC104_START_T3
 , 
IEC104_END_T3
 ) ;

2179 
IEC104_T4
 :

2181 
	`SIEC104Time
&
m_t4
 , 
byS
 , 
IEC104_START_T4
 , 
IEC104_END_T4
 ) ;

2184 
IEC104_YKTIME
:

2186 
	`SIEC104Time
&
m_YKTime
 , 
byS
 , 
IEC104_YK_STARTTIME
 , 
IEC104_YK_ENDTIME
 ) ;

2190  
FALSE
 ;

2193  
TRUE
 ;

2194 
	}
}

2196 
CRtu104
::
	$SIEC104Time

time_t
 *
tTime
 , 
BYTE
 
byS
 , BYTE 
byBegT
 , BYTE 
byEndT
 )

2198 if
byS
 =
byBegT
 )

2200 
m_byTimeFg
 |
byBegT
 ;

2201 
	`time

tTime
 ) ;

2203 if
byS
 =
byEndT
 )

2205 
m_byTimeFg
 &
byEndT
 ;

2207 
	}
}

2209 
BYTE
 
CRtu104
::
	$GTimeFg
( )

2211  
m_byTimeFg
 ;

2212 
	}
}

2214 
CRtu104
::
	$InfoMesgeProc
(
BYTE
* 
pDaBuf
, 
nL
)

2216 
nSize
 = 0;

2217 
BYTE
 
byIndex
 = 0 ;

2218 
BYTE
 
byTyID
 = 
pDaBuf
[ 
byIndex
++ ];

2221 if
pDaBuf
[ 
byIndex
++ ] != 0x01 )

2224 
BYTE
 
byRs
 = 
pDaBuf
[ 
byIndex
++] & 0x3f;

2225 if
byRs
 >> 6 ) & 0x01 ) != 0 )

2228 
byIndex
++ ;

2231 
WORD
 
wRtuAddr
 = 
	`MAKEWORD
(
pDaBuf
[ 
byIndex
 ],DataBuf[ byIndex + 1 ]);

2232 if
wRtuAddr
 !
m_wRtuAddr
 )

2235 
byIndex
 += 2 ;

2238 
WORD
 
wInfoAddr
 = 
	`MAKEWORD
(
pDaBuf
[ 
byIndex
 ],DataBuf[ byIndex + 1 ] ) ;

2239 
byIndex
 += 3 ;

2241  
byTyID
 )

2246 
BYTE
 
SCO
 = 
pDaBuf
[ 
byIndex
 ] ;

2247 if(
byRs
==0x06 || byReason==0x08)

2248 
nSize
 = 
	`RayCmdProc
 ( 
byTyID
 , 
byRs
 , 
wInfoAddr
 , 
SCO
 );

2254 if(
byRs
==0x06)

2256 
	`STnsIndex
( 0 , 0x10 ) ;

2257 
m_dwAIEQueue
.
	`r
();

2258 
	`SCommd

CMD_TOTAL_CONFIRM
 );

2277 if
byRs
 == 0x06 )

2279 
m_pMhod
->
	`RdAYmDa
(&
m_dwPIBuf
[0]);

2280 
nSize
 = 
	`PulReqProc
(
pDaBuf
, 
nL
);

2285 
	`SCommd

CMD_TIME_CONFIRM
 ) ;

2286 
nSize
 = 
	`SysClockProc
(
pDaBuf
, 
nL
);

2296  
nSize
;

2297 
	}
}

2299 
CRtu104
::
	$STnsIndex

WORD
 
Index
 , WORD 
DaSty
 )

2301 
m_wDaIndex
 = 
Index
 ;

2302 
m_byDaSty
 = 
DaSty
 ;

2303 
	}
}

2305 
BOOL
 
CRtu104
::
	$GSdRecvNo

WORD
 &
wSd
 , WORD &
wRecv
 )

2307 
wSd
 = 
m_wNumSd
<<1;

2308 
wRecv
 = 
m_wNumRecv
<<1;

2310 
m_wNumRecBK
 = 
m_wNumRecv
 ;

2312  
TRUE
 ;

2313 
	}
}

2315 
CRtu104
::
	$SysClockCfm

WORD
 
wAddr
 )

2317 
WORD
 
wNS
, 
wNR
;

2318 
WORD
 
wMSecd
;

2319 
REALTIME
 
t
;

2320 
	`GSdRecvNo

wNS
 , 
wNR
 ) ;

2321 
m_pTX_Buf
[0] = 0x68;

2322 
m_pTX_Buf
[1] = 0 ;

2323 
m_pTX_Buf
[2] = 
	`LOBYTE
(
wNS
);

2324 
m_pTX_Buf
[3] = 
	`HIBYTE
(
wNS
);

2325 
m_pTX_Buf
[4] = 
	`LOBYTE
(
wNR
);

2326 
m_pTX_Buf
[5] = 
	`HIBYTE
(
wNR
);

2328 
m_pTX_Buf
[6] = 0x67;

2329 
m_pTX_Buf
[7] = 0x01;

2330 
m_pTX_Buf
[8] = 0x07;

2331 
m_pTX_Buf
[9] = 0;

2332 
m_pTX_Buf
[10] = 
	`LOBYTE

wAddr
 );

2333 
m_pTX_Buf
[11] = 
	`HIBYTE

wAddr
 );

2334 
m_pTX_Buf
[12] = 0;

2335 
m_pTX_Buf
[13] = 0;

2336 
m_pTX_Buf
[14] = 0;

2339 
	`GCutTime
&
t
 );

2340 
wMSecd
 = 
t
.
wSecd
*1000 +.
wMliSec
;

2341 
m_pTX_Buf
[15] = 
	`LOBYTE
(
wMSecd
);

2342 
m_pTX_Buf
[16] = 
	`HIBYTE
(
wMSecd
);

2343 
m_pTX_Buf
[17] = (
BYTE
)
t
.
wMu
;

2344 
m_pTX_Buf
[18] = (
BYTE
)
t
.
wHour
;

2345 
m_pTX_Buf
[19] = 
	`LOBYTE
((
t
.
wDayOfWk
<<5)+t.
wDay
);

2346 
m_pTX_Buf
[20] = (
BYTE
)
t
.
wMth
;

2347 
m_pTX_Buf
[21] = 
t
.
wYr
 - 2000 ;

2349 
m_pTX_Buf
[1] = 22 - 2 ;

2351 
	}
}

2353 
BOOL
 
CRtu104
::
	$SCommd

WORD
 
wCommd
 )

2355 
m_wExCmd
 = 
wCommd
 ;

2356  
TRUE
 ;

2357 
	}
}

2359 
WORD
 
CRtu104
::
	$GCommd
( )

2361  
m_wExCmd
 ;

2362 
	}
}

2364 
CRtu104
::
	$YK_EPross

BYTE
 
byAi
 , 
WORD
 
wRayNum
 , BYTE 
byANum
 ,

2365 
BYTE
 
byAMk
 , 
WORD
 
wRs
 )

2367 if
wRs
 == 6 )

2368 
wRs
 = 0x47 ;

2369 if
wRs
 == 8 )

2370 
wRs
 = 0x49 ;

2372 
	`SCommd

CMD_YK_ERROR
 ) ;

2373 
	`SYKDa

byAi
 , 
wRayNum
 , 
byANum
 , 
byAMk
 , 
wRs
 ) ;

2374 
	}
};

2385 
BOOL
 
	gCRtu104
::
	$GUrossBuf
 ( cڡ 
BYTE
 *
pBuf
, cڡ 
iL
, *
pVoid
 )

2387 
iTmpL
 = 
iL
;

2388 
iPos
 = 0;

2389 
UNPROCESSBUF
 *
pDa
, 
tDa
;

2391 
pDa
 = (
UNPROCESSBUF
 *)
pVoid
;

2393 i
iTmpL
 < 6 )

2395 
	`tf
 ( "IEC104ecv%d\n", 
iTmpL
 );

2396  
FALSE
;

2400 
iTmpL
 = 
pBuf
[
iPos
 + 1] + 2;

2401  
iTmpL
 >6 && iTmpL <253 && 0x68 =
pBuf
[
iPos
])

2403 if
iTmpL
 > 
iL
 - 
iPos
 )

2405 
tDa
.
n
 = 
iTmpL
;

2406 
	`memy

tDa
.
buf
, 
pBuf
,Da.
n
 );

2407 
m_UnProssBuf
.
	`push

tDa
 );

2409 
iPos
 +
iTmpL
 + 2 );

2410 
iTmpL
 = 
pBuf
[
iPos
 + 1] + 2;

2414 if!
m_UnProssBuf
.
	`emy
() )

2416 
tDa
 = 
m_UnProssBuf
.
	`t
();

2417 
pDa
->
n
 = 
tDa
.len;

2418 
	`memy
(
pDa
->
buf
, 
tDa
.buf,Da.
n
);

2419 
m_UnProssBuf
.
	`p
();

2422  
FALSE
;

2424  
TRUE
;

2425 
	}
}

2427 
BOOL
 
	gCRtu104
::
	$GDevCommS
( )

2429 if
m_bSB
 )

2430  
COM_DEV_NORMAL
 ;

2432  
COM_DEV_ABNORMAL
 ;

2433 
	}
}

2436 
BOOL
 
	gCRtu104
::
	$PackComSMsg

BYTE
 * 
pBuf
 , BYTE &
ƒ
 , BYTE 
byLeNo
 , BYTE 
byDevAddr
 , BYTE 
byFg
 )

2438 if!
m_pMhod
 || 
ƒ
 < 12 || 
pBuf
 =
NULL
 )

2439  
FALSE
 ;

2441 
BYTE
 
byBusNum
 = 
m_pMhod
->
	`GToTBusNum
() ;

2442 if
byLeNo
 >
byBusNum
 )

2443  
FALSE
 ;

2449 
BYTE
 
byIndex
 = 0 ;

2450 
BYTE
 
byTy
 = 0 , 
byS
 = 0 ;

2452 
REALTIME
 
tm1
;

2453 
	`GCutTime
&
tm1
 );

2455 
WORD
 
wP
 = 0 ;

2456 
wP
 = 
COM_STATE_ADDR
 + 
byIndex
;

2457 
pBuf
[
ƒ
++] = 
	`LOBYTE
(
wP
);

2458 
pBuf
[
ƒ
++] = 
	`HIBYTE
(
wP
);

2459 
pBuf
[
ƒ
++] = 0;

2461 
pBuf
[
ƒ
++]=
	`LOBYTE
(
tm1
.
wMliSec
);

2462 
pBuf
[
ƒ
++]=
	`HIBYTE
(
tm1
.
wMliSec
);

2463 
pBuf
[
ƒ
++]=
tm1
.
wSecd
;

2464 
pBuf
[
ƒ
++]=
tm1
.
wMu
;

2465 
pBuf
[
ƒ
++]=
tm1
.
wHour
;

2466 
pBuf
[
ƒ
++]=
tm1
.
wDay
;

2467 
pBuf
[
ƒ
++]=
tm1
.
wMth
;

2468 
pBuf
[
ƒ
++]=
tm1
.
wYr
 ) % 100;

2470 if
byFg
 =
SEND_BUS_STATE
 )

2472 
byTy
=1;

2473 
byS

	`GComS

byLeNo
 ) ;

2475 if
byFg
 =
SEND_DEV_STATE
 )

2477 
byTy
=2;

2478 
byS
=
	`GDevCommS

byLeNo
 , 
byDevAddr
 ) ;

2481  
FALSE
 ;

2484 
pBuf
[
ƒ
++]=
byLeNo
 + 1;

2485 
pBuf
[
ƒ
++]=
byDevAddr
;

2486 
pBuf
[
ƒ
++]=
byS
;

2487 
pBuf
[
ƒ
++]=
byTy
;

2489  
TRUE
 ;

2490 
	}
}

2494 
BOOL
 
	gCRtu104
::
	$PackComSMsg

BYTE
 * 
pBuf
 , BYTE &
ƒ
 , BYTE 
byLeNo
 , BYTE 
byDevAddr
 , BYTE 
byFg
 )

2496 if!
m_pMhod
 || 
ƒ
 < 12 || 
pBuf
 =
NULL
 )

2497  
FALSE
 ;

2499 
BYTE
 
byBusNum
 = 
m_pMhod
->
	`GToTBusNum
() ;

2500 if
byLeNo
 >
byBusNum
 )

2501  
FALSE
 ;

2507 
BYTE
 
byIndex
 = 0 ;

2508 
BYTE
 
byTy
 = 0 , 
byS
 = 0 ;

2510 
REALTIME
 
tm1
;

2511 
	`GCutTime
&
tm1
 );

2513 
WORD
 
wP
 = 0 ;

2514 
wP
 = 
COM_STATE_ADDR
 + 
byIndex
;

2515 
pBuf
[
ƒ
++] = 
	`LOBYTE
(
wP
);

2516 
pBuf
[
ƒ
++] = 
	`HIBYTE
(
wP
);

2517 
pBuf
[
ƒ
++] = 0;

2519 
pBuf
[
ƒ
++]=
	`LOBYTE
(
tm1
.
wMliSec
);

2520 
pBuf
[
ƒ
++]=
	`HIBYTE
(
tm1
.
wMliSec
);

2521 
pBuf
[
ƒ
++]=
tm1
.
wSecd
;

2522 
pBuf
[
ƒ
++]=
tm1
.
wMu
;

2523 
pBuf
[
ƒ
++]=
tm1
.
wHour
;

2524 
pBuf
[
ƒ
++]=
tm1
.
wDay
;

2525 
pBuf
[
ƒ
++]=
tm1
.
wMth
;

2526 
pBuf
[
ƒ
++]=
tm1
.
wYr
 ) % 100;

2528 if(
QuyADevStus
){

2529 if
byFg
 =
SEND_BUS_STATE
 )

2531 
byTy
=1;

2532 
byS

	`GComS

byLeNo
 ) ;

2534 if
byFg
 =
SEND_DEV_STATE
 )

2536 
byTy
=2;

2537 
byS
=
	`GDevCommS

byLeNo
 , 
byDevAddr
 ) ;

2540 
WORD
 
ro
 = 
m_pMhod
->
	`GSlNo
(
byLeNo
, 
byDevAddr
);

2541 
m_
[
ro
] = 
byS
;

2545  
FALSE
 ;

2547 
byS
 = 
deque_
.
	`t
().

;

2548 
deque_
.
	`p_t
();

2552 
pBuf
[
ƒ
++]=
byLeNo
 + 1;

2553 
pBuf
[
ƒ
++]=
byDevAddr
;

2554 
pBuf
[
ƒ
++]=
byS
;

2556 
pBuf
[
ƒ
++]=
byTy
;

2558  
TRUE
 ;

2559 
	}
}

2562 
BOOL
 
	gCRtu104
::
	$PackComSMsg

BYTE
 * 
pBuf
 , BYTE &
ƒ
 , 
WORD
 
ro
 , BYTE 
byFg
 )

2564 if!
m_pMhod
 || 
ƒ
 < 12 || 
pBuf
 =
NULL
 )

2565  
FALSE
 ;

2567 
BYTE
 
byLeNo
 = 0;

2568 
WORD
 
byDevAddr
 = 0;

2569 if(!
m_pMhod
->
	`GBusLeAndAddr
(
ro
, 
byLeNo
, 
byDevAddr
)){

2570 
	`
("Failedo GetBusLineAndAddr!");

2571  
FALSE
;

2574 
BYTE
 
byBusNum
 = 
m_pMhod
->
	`GToTBusNum
() ;

2575 if
byLeNo
 >
byBusNum
 )

2576  
FALSE
 ;

2582 
BYTE
 
byIndex
 = 0 ;

2583 
BYTE
 
byTy
 = 0 , 
byS
 = 0 ;

2585 
REALTIME
 
tm1
;

2586 
	`GCutTime
&
tm1
 );

2588 
WORD
 
wP
 = 0 ;

2589 
wP
 = 
COM_STATE_ADDR
 + 
byIndex
;

2590 
pBuf
[
ƒ
++] = 
	`LOBYTE
(
wP
);

2591 
pBuf
[
ƒ
++] = 
	`HIBYTE
(
wP
);

2592 
pBuf
[
ƒ
++] = 0;

2594 
pBuf
[
ƒ
++]=
	`LOBYTE
(
tm1
.
wMliSec
);

2595 
pBuf
[
ƒ
++]=
	`HIBYTE
(
tm1
.
wMliSec
);

2596 
pBuf
[
ƒ
++]=
tm1
.
wSecd
;

2597 
pBuf
[
ƒ
++]=
tm1
.
wMu
;

2598 
pBuf
[
ƒ
++]=
tm1
.
wHour
;

2599 
pBuf
[
ƒ
++]=
tm1
.
wDay
;

2600 
pBuf
[
ƒ
++]=
tm1
.
wMth
;

2601 
pBuf
[
ƒ
++]=
tm1
.
wYr
 ) % 100;

2604 if(
QuyADevStus
){

2605 if
byFg
 =
SEND_BUS_STATE
 )

2607 
byTy
=1;

2608 
byS

	`GComS

byLeNo
 ) ;

2610 if
byFg
 =
SEND_DEV_STATE
 )

2612 
byTy
=2;

2613 
byS
=
	`GDevCommS

byLeNo
 , 
byDevAddr
 ) ;

2616 
m_
[
ro
] = 
byS
;

2619  
FALSE
 ;

2621 
byS
 = 
deque_
.
	`t
().

;

2622 
deque_
.
	`p_t
();

2626 
pBuf
[
ƒ
++]=
byLeNo
 + 1;

2627 
pBuf
[
ƒ
++]=
byDevAddr
;

2628 
pBuf
[
ƒ
++]=
byS
;

2630 
pBuf
[
ƒ
++]=2;

2632  
TRUE
 ;

2633 
	}
}

2635 
BOOL
 
	gCRtu104
::
	$GComS

BYTE
 
byLeNo
 )

2637 if!
m_pMhod
 )

2638  
COM_ABNORMAL
 ;

2640 
PBUSMANAGER
 
pBus
 = 
m_pMhod
->
	`GBus

byLeNo
 ) ;

2641 if!
pBus
 )

2642  
COM_ABNORMAL
 ;

2644 
CProc
 * 
pProc
 = 
pBus
->
m_Proc
 ;

2645 if!
pProc
 )

2646  
COM_ABNORMAL
 ;

2649 
BOOL
 
bStus
 = 
COM_ABNORMAL
 ;

2659 
bStus

m_pMhod
->
	`GCommS

byLeNo
 );

2661  
bStus
 ;

2662 
	}
}

2664 
BOOL
 
	gCRtu104
::
	$GDevCommS

BYTE
 
byLeNo
 , BYTE 
byAddr
 )

2666 if!
m_pMhod
 )

2667  
COM_DEV_ABNORMAL
 ;

2669 
PBUSMANAGER
 
pBus
 = 
m_pMhod
->
	`GBus

byLeNo
 ) ;

2670 if!
pBus
 )

2671  
COM_DEV_ABNORMAL
 ;

2673 
CProc
 * 
pProc
 = 
pBus
->
m_Proc
 ;

2674 if!
pProc
 )

2675  
COM_DEV_ABNORMAL
 ;

2678 
BOOL
 
bStus
 = 
COM_DEV_ABNORMAL
 ;

2689 
bStus
=
m_pMhod
->
	`GDevCommS

byLeNo
 , 
byAddr
 );

2691  
bStus
 ;

2692 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/Rtu104.h

5 #ide
_RTU104_H_


6 
	#_RTU104_H_


	)

8 
	~<queue
>

10 
	~"CProc_IEC104.h
"

11 
	~"../../she/gDaTy.h
"

13 
	#RTU104_TX_BUF_SIZE
 1024

	)

14 
	#RTU104_RX_BUF_SIZE
 1024

	)

16 
	#RTU104MAX_AI_LEN
 4096

	)

17 
	#RTU104MAX_DI_LEN
 8192

	)

18 
	#RTU104MAX_PI_LEN
 2048

	)

19 
	#RTU104MAX_DO_LEN
 512

	)

25 
	#SEND_BUS_STATE
 1

	)

26 
	#SEND_DEV_STATE
 2

	)

28 as
	cCRtu104
 : 
public
 
CProc_IEC104


30 
public
:

31 
CRtu104
();

32 ~
CRtu104
();

35 
	mpublic
:

36 
BOOL
 
m_bDaIn
;

37 
BOOL
 
	mm_bSB
;

38 
BOOL
 
	mm_bADa
;

40 
WORD
 
	mm_wCommd
;

41 
WORD
 
	mm_wExCmd
 ;

42 
WORD
 
	mm_wStus
;

43 
BYTE
 
	mm_bySdg
;

45 
	meed
:

46 
BYTE
 *
m_pTX_Buf
 ;

47 
BYTE
 * 
	mm_pRX_Buf
 ;

48 
	mm_nRXCou
;

49 
	mm_nTXCou
;

50 
	mm_RQ_WR_P
;

51 
	mm_RQ_RD_P
;

53 
WORD
 
	mm_wNumSd
;

54 
WORD
 
	mm_wNumRecv
;

55 
WORD
 
	mm_wNumRecBK
;

56 
WORD
 
	mm_wNumAck
;

57 
WORD
 
	mm_wYkFg
;

59 
	mive
:

60 
BYTE
 
m_byDaSty
;

61 
WORD
 
	mm_wDaIndex
;

63 
WORD
 
	mm_wTimCou
;

64 
WORD
 
	mm_wETim
;

65 
WORD
 
	mm_wSdTim
;

66 
WORD
 
	mm_wRecvTim
;

67 
WORD
 
	mm_wIdTim
;

68 
BYTE
 
	mm_byTimeFg
 ;

69 
WORD
 
	mm_wDRFTim
;

70 
WORD
 
	mm_wPARTim
;

71 
time_t
 
	mm_t1
 , 
	mm_t2
 , 
	mm_t3
 , 
	mm_t4
 , 
	mm_YKTime
;

72 
time_t
 
	mm_DevSTime
 ;

73 
BOOL
 
	mm_YkFg
 ;

74 
WORD
 
	mm_wRendNum
;

75 
BYTE
 
	mm_byToutNum
;

76 
BYTE
 
	mm_byECode
;

78 
	mm_wAIBuf
[
RTU104MAX_AI_LEN
];

79 
DWORD
 
	mm_dwPIBuf
[
RTU104MAX_PI_LEN
];

80 
	md
::
queue
<
UNPROCESSBUF
> 
m_UnProssBuf
;

82 
BYTE
 
	mm_byDIbuf
[ 
RTU104MAX_DI_LEN
 ] ;

84 
	meed
:

85 
BYTE
 
CBch
(BYTE* 
pTBuf
, 
n
);

86 
AckMesgeProc
(
BYTE
* 
pDaBuf
, 
nL
);

87 
InfoMesgeProc
(
BYTE
* 
pDaBuf
, 
nL
);

88 
DlBusMsgInfo
(
PBUSMSG
 
pBusMsg
);

90 
RayCmdProc

BYTE
 
byTyID
 , BYTE 
byRs
 , 
WORD
 
wInfoAddr
 , BYTE 
byV
 );

91 
RaySeProc
(
WORD
 
wS
, WORD 
wClNum
, 
BYTE
 
byStus
);

92 
RayExecuProc
(
WORD
 
wS
, WORD 
wClNum
, 
BYTE
 
byStus
);

93 
RayClProc
(
WORD
 
wS
, WORD 
wClNum
, 
BYTE
 
byStus
);

94 
GroupReqProc
(
BYTE
* 
pDaBuf
, 
nL
);

95 
PulReqProc
(
BYTE
* 
pDaBuf
, 
nL
);

96 
BOOL
 
SysClockProc
(
BYTE
* 
pDaBuf
, 
nL
);

97 
RetProc
(
BYTE
* 
pDaBuf
, 
nL
);

99 
AckFme
();

100 
TeFmeAck
();

101 
SDaAck
();

102 
StDaAck
();

103 
ADaEcho
(
WORD
 
wUnAddr
, 
BYTE
 
byRs
);

104 
ReqPulEcho
(
WORD
 
wUnAddr
, 
BYTE
 
byRs
, BYTE 
byQCC
);

106 
LdAIEFme21
(
WORD
 
wUnAddr
);

107 
LdAIEFme13
(
WORD
 
wUnAddr
);

108 
LdDIEFme
(
WORD
 
wUnAddr
);

109 
LdSOEFme_30
(
WORD
 
wUnAddr
);

110 
LdSOEFme_02
(
WORD
 
wUnAddr
);

112 
LdAlogDa21
(
WORD
 
wUnAddr
);

113 
LdAlogDa13
(
WORD
 
wUnAddr
);

114 
LdDigDa
(
WORD
 
wUnAddr
);

115 
LdPulDa
(
WORD
 
wUnAddr
);

116 
LdADa
(
WORD
 
wUnAddr
);

117 
LdAlogGroup
(
BYTE
 
byGroup
, 
WORD
 
wUnAddr
, BYTE 
byRs
);

118 
LdDigGroup
(
BYTE
 
byGroup
, 
WORD
 
wUnAddr
, BYTE 
byRs
);

119 
LdPulGroup
(
BYTE
 
byGroup
, 
WORD
 
wUnAddr
, BYTE 
byRs
);

120 
LdRayEchoFme
(
WORD
 
wUnAddr
, 
BYTE
 
byTy
, BYTE 
byRs
, WORD 
wIndexNum
, BYTE 
byCmd
);

121 
SysClockCfm

WORD
 
wAddr
 ) ;

122 
BOOL
 
GSDt
( );

123 
WORD
 
GSeqNo

BYTE
 * 
por
 );

124 
BOOL
 
GSdRecvNo

WORD
 &
wSd
 , WORD &
wRecv
 ) ;

125 
BOOL
 
ProcSdNo

WORD
 
wAckNo
 ) ;

126 
BOOL
 
ProcRecvNo

WORD
 
wRecNo
 ) ;

128 
vtu
 
BOOL
 
ReSS
( ) ;

129 
ProssIEC104Time
( );

130 
BYTE
 
GTimeFg
( ) ;

131 
BOOL
 
STTim

BYTE
 
byTime
 , BYTE 
byS
 );

132 
TeSd
( ) ;

133 
STnsIndex

WORD
 
Index
 , WORD 
DaSty
 );

134 
BYTE
 
GS_DCO
BYTE 
byTyID
 , BYTE 
byV
 ) ;

135 
GYkDa

BYTE
 &
byAi
 , 
WORD
 &
wRayNum
 , BYTE & 
byANum
 ,

136 
BYTE
 & 
byAMk
 , 
WORD
 & 
wSeTime
 ) ;

137 
SYKDa

BYTE
 
byAi
 , 
WORD
 
wRayNum
 , BYTE 
byANum
 ,

138 
BYTE
 
byAMk
 , 
WORD
 
wSeTime
 ) ;

139 
SIEC104Time

time_t
 *
tTime
 , 
BYTE
 
byS
 , BYTE 
byBegT
 , BYTE 
byEndT
 );

140 
YK_EPross

BYTE
 
byAi
 , 
WORD
 
wRayNum
 , BYTE 
byANum
 ,

141 
BYTE
 
byAMk
 , 
WORD
 
wSeTime
 ) ;

142 
YK_PS

BOOL
 
bPSFg
 ) ;

143 
BOOL
 
YK_IsCSd
( ) ;

144 
YK_RCfm

BOOL
 
bFg
 ) ;

145 
YK_R
&
n
 ) ;

147 
Rend_Proc
( );

148 
RecvToutProc
( );

149 
SedPross

WORD
 
wAddr
 ) ;

150 
PPross

WORD
 
wAddr
 ) ;

151 
ChgeDaPross

WORD
 
wAddr
 ) ;

152 
BOOL
 
IsCSd
( ) ;

153 
vtu
 
BOOL
 
GDevCommS
( ) ;

154 
vtu
 
	$ComS_Mesge

WORD
 
wUnAddr
 ) {  0 ; }

155 
BOOL
 
	`PackComSMsg

BYTE
 * 
pBuf
 , BYTE &
ƒ
 , BYTE 
byLeNo
 , BYTE 
byDevAddr
 , BYTE 
byFg
 ) ;

156 
BOOL
 
	`PackComSMsg

BYTE
 * 
pBuf
 , BYTE &, 
WORD
, BYTE 
byFg
 );

157 
BOOL
 
	`GComS

BYTE
 
byLeNo
 );

158 
BOOL
 
	`GDevCommS

BYTE
 
byLeNo
 , BYTE 
byAddr
 ) ;

160 
BOOL
 
QuyADevStus
;

162 
public
:

163 
vtu
 * 
	$ProName
(){ (*)"IEC104";
	}
}

164 
vtu
 
BOOL
 
InRtuBa
();

165 
BOOL
 
LdRtuMesge

BYTE
 * 
pBuf
 , &
n
 );

166 
vtu
 
RtuCommdProc

BYTE
* 
pRecvBuf
, 
nL
 );

167 
vtu
 
TimProc
();

169 
vtu
 
GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
);

171 
vtu
 
BOOL
 
	$WreCIV

WORD
 
wSlNo
 , WORD 
wP
, 
fV
){  
FALSE
 ;
	}
}

172 
vtu
 
BOOL
 
WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
fV
) ;

173 
vtu
 
BOOL
 
WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
) ;

174 
vtu
 
BOOL
 
WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
) ;

175 
vtu
 
BOOL
 
WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
) ;

177 
vtu
 
RayEchoProc
(
BYTE
 
byCommd
, 
WORD
 
wIndex
, BYTE 
byResu
);

178 
vtu
 
TnsMesge

BYTE
 
byTy
, BYTE* 
pBuf
, 
nL
 );

179 
vtu
 
GCommObjPr
(
COMMOBJ_PROP
* 
pObjPr
);

181 
TaskProcHd
();

182 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

183 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

184 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

185 
vtu
 
BOOL
 
GUrossBuf
 ( cڡ 
BYTE
 *
pBuf
, cڡ 
iL
, *
pVoid
 );

187 
BOOL
 
SCommd

WORD
 
wCommd
 ) ;

188 
WORD
 
GCommd
( ) ;

190 
	gme
< 
tyme
 
	gTy
 > 
InBufr

Ty
 *
tDa
 , 
size
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/main.cpp

1 
	~<dio.h
>

2 
	~"CProc_IEC104.h
"

6 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

9 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

11 
CProc
 * 
pProc
 = 
NULL
 ;

12 
pProc
 = 
w
 
CProc_IEC104
 ;

13 if
pProc
 )

15 
pProc
->
m_pMhod
 = 
pMhod
 ;

19  
pProc
 ;

20 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/CProtocol_ModBusTcp.cpp

1 
	~"CProc_ModBusT.h
"

2 
	~"ModBusT_Tnsr.h
"

4 
	#MODULE_T
 1

	)

7 
	gCProc_ModBusT_Tnsr
::
	$CProc_ModBusT_Tnsr
()

10 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

12 
	}
}

14 
	gCProc_ModBusT_Tnsr
::~
	$CProc_ModBusT_Tnsr
()

17 
size
 = 
m_modu
.
	`size
() ;

18  
i
 = 0 ; i < 
size
 ; i++ )

20 
de
 
m_modu
[ 
i
 ] ;

22 
m_modu
.
	`r
() ;

23 
	`tf
( "Delete All CProtocol_ModBusTcp_Transfer OK . \n" );

24 
	}
}

26 
BOOL
 
	gCProc_ModBusT_Tnsr
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

28  
FALSE
 ;

29 
	}
}

31 
BOOL
 
	gCProc_ModBusT_Tnsr
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

33  
FALSE
 ;

34 
	}
}

36 
BOOL
 
	gCProc_ModBusT_Tnsr
::
	$In

BYTE
 
byLeNo
 )

40 
m_byLeNo
 = 
byLeNo
 ;

43 
m_ProTy
 = 
PROTOCO_TRANSPROT
;

45  
	`GDevDa
( ) ;

46 
	}
}

48 
BOOL
 
	gCProc_ModBusT_Tnsr
::
	$GDevDa
( )

50 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

51 
	`rtf

m_sDevPh
 , "%s/KunMg/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

52 
CProfe
 
	`ofe

m_sDevPh
 ) ;

54  
	`ProssFeDa

ofe
 ) ;

55 
	}
}

57 
BOOL
 
	gCProc_ModBusT_Tnsr
::
	$ProssFeDa

CProfe
 &
ofe
 )

59 
BOOL
 
bR
 = 
FALSE
;

60 if!
ofe
.
	`IsVid
() )

62 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

63  
FALSE
 ;

66 
sSe
[ 200 ] = "DEVNUM" ;

67 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

69 
WORD
 
wModu
 = 0 ;

70 
ro
=1 ;

71 
WORD
 
addr
 =3 ;

72 
sName
[ 50 ] = { 0 };

73 
eme
[ 200 ] = { 0 };

74 
iNum
 = 0 ;

76 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

77 if
iNum
 == 0 )

79 
	`tf
( "Get DEVNUM Failed ! \n " );

80  
FALSE
 ;

83  
i
 = 0 ; i < 
iNum
 ; i++ )

85 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

87 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

88 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

89 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

90 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

91 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

94 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

95 i!
bR
 )

97 
	`tf
 ( "CModBusT Modu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

99  
FALSE
;

103  
TRUE
 ;

104 
	}
}

105 
BOOL
 
	gCProc_ModBusT_Tnsr
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

107 
CProc_ModBusT_Tnsr
 * 
pProc
 = 
NULL
 ;

108 
BOOL
 
bR
 = 
FALSE
;

109  
iModu
 )

111 
MODULE_T
:

112 
pProc
 = 
w
 
ModBusT_KunMg
;

114 
pProc
->
m_byLeNo
 = m_byLineNo ;

115 
pProc
->
m_wModuTy
 = 
iModu
 ;

116 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

117 
pProc
->
m_SlNo
 = 
iSlNo
 ;

119 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

120 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

121 
pProc
->
m_pMhod
 = m_pMethod ;

123 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

125 
bR
 = 
pProc
->
	`In

m_byLeNo
 ) ;

126 i!
bR
 )

128 
	`tf
 ( "Init Error \n");

129  
FALSE
;

131 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

135 
	`tf
( "ModBusTcp don't containhis module Failed .\n" );

136  
FALSE
 ;

139 
m_modu
.
	`push_back

pProc
 ) ;

141  
TRUE
 ;

142 
	}
}

144 
BOOL
 
	gCProc_ModBusT_Tnsr
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

147 
dex
 = 0 ;

148 
buf
[ 
dex
++ ] = 0xFF ;

149 
buf
[ 
dex
++ ] = 0x02 ;

150 
buf
[ 
dex
++ ] = 0x03 ;

151 
buf
[ 
dex
++ ] = 0x04 ;

157 
n
 = 
dex
 ;

159 
	`tf
( "\n CProtocol_ModBusTcp_Transfer TestBroadCast \n " ) ;

160  
TRUE
 ;

161 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/CProtocol_ModBusTcp.h

1 #ide
CPROTOCOL_MODBUSTCP_H


2 
	#CPROTOCOL_MODBUSTCP_H


	)

4 
	~"../../she/CProc.h
"

5 
	~"../../she/CMhod.h
"

7 as
	cCProc_ModBusT_Tnsr
 : 
public
 
CProc


9 
public
:

10 
CProc_ModBusT_Tnsr
();

11 
	mvtu
 ~
CProc_ModBusT_Tnsr
();

12 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

13 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

14 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

15 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 ) ;

16 
vtu
 
	$TimProc
(){ ; }

17 
eed
:

18 
BOOL
 
	`GDevDa
( ) ;

19 
eed
:

20 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

21 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

23 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/ModBusTcp_Transfer.cpp

1 
	~"ModBusT_Tnsr.h
"

2 
	#CONFIGPATH
 "/mynd/cfig/KunMg/me/"

	)

4 
	gModBusT_KunMg
::
	$ModBusT_KunMg
():
	`ERROR_CONST
(5),
	`COMSTATUS_ONLINE
(1),
	$COMSTATUS_FAULT
(0)

6 
af_ty
 = 0;

7 
le
 = 0;

8 
lesum
 = 0;

9 
vec_yx
.
	`r
();

10 
vec_yc_ym
.
	`r
();

11 
vec_cf
.
	`r
();

13 
m_byPtStus
 = 0;

14 
	}
}

16 
	gModBusT_KunMg
::~
	$ModBusT_KunMg
()

18 
vec_cf
.
	`r
();

19 
vec_yc_ym
.
	`r
();

20 
vec_yx
.
	`r
();

21 
	}
}

23 
BOOL
 
	gModBusT_KunMg
::
	$GProcBuf
(
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
)

25 
buf
[
n
++] = 
af_ty
 >> 8;

26 
buf
[
n
++] = 
af_ty
;

27 
buf
[
n
++] = 0x00;

28 
buf
[
n
++] = 0x00;

29 
n
 += 2;

30 
buf
[
n
++] = 
m_wDevAddr
;

31 
buf
[
n
++] = 0x10;

33 if((
vec_cf
[
le
].
ty
 =0&& !
	`FchYcYmDa
())

34  
FALSE
;

35 if((
vec_cf
[
le
].
ty
 =1&& !
	`FchYxDa
())

36  
FALSE
;

38 if(
vec_cf
[
le
].
ty
 == 0)

39 
	`GYcYmFme
(
buf
, 
n
);

41 
	`GYxFme
(
buf
, 
n
);

43 
buf
[4] = (
n
 - 6) >> 8;

44 
buf
[5] = 
n
 - 6;

45 
af_ty
++;

46 
le
 = ++l% 
lesum
;

47  
TRUE
;

48 
	}
}

50 
	gModBusT_KunMg
::
ReOrd
(
ve
<
DWORD
> &
vec_mp
)

52 
vec_yc_ym
.
push_back
(
vec_mp
[7]);

53 
	gvec_yc_ym
.
push_back
(
vec_mp
[8]);

54 
	gvec_yc_ym
.
push_back
(
vec_mp
[9]);

55 
	gvec_yc_ym
.
push_back
(
vec_mp
[0]);

56 
	gvec_yc_ym
.
push_back
(
vec_mp
[1]);

57 
	gvec_yc_ym
.
push_back
(
vec_mp
[2]);

58 
	gvec_yc_ym
.
push_back
(
vec_mp
[14]);

59 
	gvec_yc_ym
.
push_back
(
vec_mp
[6]);

60 
	gvec_yc_ym
.
push_back
(
vec_mp
[11]);

61 
	gvec_yc_ym
.
push_back
(
vec_mp
[12]);

62 
	gvec_yc_ym
.
push_back
(
vec_mp
[15]);

63 
	gvec_yc_ym
.
push_back
(
vec_mp
[16]);

66 
BOOL
 
	gModBusT_KunMg
::
	$FchYcYmDa
()

68 
m_SlNo
 = 0;

69 
ve
<
DWORD
> 
vec_mp
;

70 
DWORD
 
ym_mp
 = 0;

71 
vec_yc_ym
.
	`r
();

72 
m
 = 0; m < 
vec_cf
[
le
].
bus_cou
; m++){

73 
n
 = 0; < 
vec_cf
[
le
].
dev_cou
;++){

74 if((
m_SlNo
 = 
m_pMhod
->
	`GSlNo
(
vec_cf
[
le
].
buo
 + 
m
, vec_cf[le].
devno
 + 
n
)) == -1)

75  
FALSE
;

76 
i
 = 1; i <= 15; i++)

77 
vec_mp
.
	`push_back
(
m_pMhod
->
	`RdYcDa
(
m_SlNo
, 
i
));

79 
m_pMhod
->
	`RdYmDa
(
m_SlNo
, 0, &
ym_mp
);

80 
vec_mp
.
	`push_back
(
ym_mp
);

82 
m_pMhod
->
	`RdYmDa
(
m_SlNo
, 1, &
ym_mp
);

83 
vec_mp
.
	`push_back
(
ym_mp
);

84 
	`tf
("********e:%d vec_mp:%d ********\n", 
__LINE__
, 
vec_mp
.
	`size
());

87 
	`ReOrd
(
vec_mp
);

88  
TRUE
;

89 
	}
}

91 
	gModBusT_KunMg
::
	$GYcYmFme
(
BYTE
 *
buf
, &
n
)

93 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
 >> 8;

94 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
;

95 
buf
[
n
++] = 
vec_yc_ym
.
	`size
() * 2 >> 8;

96 
buf
[
n
++] = 
vec_yc_ym
.
	`size
() * 2;

97 
buf
[
n
++] = 
vec_yc_ym
.
	`size
() * 4;

99 
ve
<
DWORD
>::

 
beg
=
vec_yc_ym
.
	`beg
(), 

=vec_yc_ym.
	`d
(); beg !=n; beg++){

100 
buf
[
n
++] = *
beg
 >> 8;

101 
buf
[
n
++] = *
beg
;

102 
buf
[
n
++] = *
beg
 >> 24;

103 
buf
[
n
++] = *
beg
 >> 16;

105 
	}
}

107 
BOOL
 
	gModBusT_KunMg
::
	$FchYxDa
()

109 
m_SlNo
 = 0;

110 
WORD
 
yx_mp
 = 0;

111 
ve
<
WORD
> 
vec_mp
;

112 
vec_yx
.
	`r
();

113 
j
 = 0; j < 
vec_cf
[
le
].
bus_cou
; j++){

114 
i
 = 0; i < 
vec_cf
[
le
].
dev_cou
; i++){

115 if((
m_SlNo
 = 
m_pMhod
->
	`GSlNo
(
vec_cf
[
le
].
buo
 + 
j
, vec_cf[le].
devno
 + 
i
)) == -1)

116  
FALSE
;

117 
m_pMhod
->
	`RdYxDa
(
m_SlNo
, 1, &
yx_mp
);

118 
vec_yx
.
	`push_back
(
yx_mp
 ? 1 : 0);

119 
m_pMhod
->
	`RdYxDa
(
m_SlNo
, 2, &
yx_mp
);

120 
vec_yx
.
	`push_back
(
yx_mp
 ? 1 : 0);

121 
vec_yx
.
	`push_back
(
m_pMhod
->
	`GDevCommS
(
m_SlNo
) ? 0 : 1);

124  
TRUE
;

125 
	}
}

127 
	gModBusT_KunMg
::
	$GYxFme
(
BYTE
 *
buf
, &
n
)

129 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
 >> 8;

130 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
;

131 
buf
[
n
++] = 
vec_yx
.
	`size
() >> 8;

132 
buf
[
n
++] = 
vec_yx
.
	`size
();

133 
buf
[
n
++] = 
vec_yx
.
	`size
() * 2;

138 
ve
<
WORD
>::

 
beg
 = 
vec_yx
.
	`beg
(), 

 = vec_yx.
	`d
(); beg !=n; beg++){

139 
buf
[
n
++] = *
beg
 >> 8;

140 
buf
[
n
++] = *
beg
;

142 
	}
}

144 
BOOL
 
	gModBusT_KunMg
::
	$ProssProcBuf
(
BYTE
 *
buf
, 
n
)

146  
TRUE
;

169 
	}
}

171 
BYTE
 
	gModBusT_KunMg
::
	$RdCf
(
BYTE
 *
fame
)

173 
FILE
 *
hFe
;

174 
szText
[256] = {0};

175 *
mp
;

176 
UINT
 
gvue
 = 0;

177 
BYTE
 
i
 = 0;

178 
BYTE
 
cag
 = 0;

179 
CfigIm
 
cf_mp
;

180 if((
hFe
 = 
	`fݒ
((cڡ *)
fame
, "r")=
NULL
)

182  
	`fgs
(
szText
, (szText), 
hFe
!
NULL
 )

184 
	`rim
(
szText
);

185 if
szText
[0]=='#' || szText[0]==';' )

187 
i
 = 0;

188 
cag
 = 0;

189 
	`memt
(&
cf_mp
,0,(conf_temp));

191 
mp
 = 
	`ok
(
szText
,",");

192 if(
mp
 =
NULL
)

194 if((
	`oi
(
mp
) == 0) || (atoi(temp) == 1))

195 
cf_mp
.
ty
 = 
	`oi
(
mp
);

197 
cag
 = 1;

198 
	`DeuCfig
(&
cf_mp
);

200 (
mp
 = 
	`ok
(
NULL
,","))){

201 
gvue
 = (
ULONG
)
	`l
(
mp
, 
NULL
, 16);

202 ++
i
){

204 if((
gvue
 > 0) && (segvalue) <= 0xFF)

205 
cf_mp
.
buo
 = 
gvue
 - 1;

207 
cag
 = 1;

210 if((
gvue
 > 0) && (segvalue) <= 0xFF)

211 
cf_mp
.
devno
 = 
gvue
;

213 
cag
 = 1;

216 if((
gvue
 > 0) && (segvalue) <= 0xFF)

217 
cf_mp
.
dev_cou
 = 
gvue
;

219 
cag
 = 1;

222 if((
gvue
 > 0) && (segvalue) <= 0xFF)

223 
cf_mp
.
bus_cou
 = 
gvue
;

225 
cag
 = 1;

228 if(((
UINT
)
	`l
(
mp
, 
NULL
, 16)) <= 0xFFFFFFFF)

229 
cf_mp
.
mask
 = 
gvue
;

231 
cag
 = 1;

234 if(
gvue
 <= 0xFFFF)

235 
cf_mp
.
gi_addr
 = 
gvue
;

237 
cag
 = 1;

241 if
cag
 == 1 )

243 
	`tf
("%num i%d %d\n\n\n",
fame
,
lesum
+1,
i
+1);

244 
	`DeuCfig
(&
cf_mp
);

245 
vec_cf
.
	`push_back
(
cf_mp
);

246 
lesum
 = 1;

249 
vec_cf
.
	`push_back
(
cf_mp
);

250 
lesum
++;

253 
	`fo
(
hFe
);

254  
lesum
;

255 
	}
}

257 
	gModBusT_KunMg
::
	$DeuCfig
(
CfigIm
 *
cf_mp
)

259 
cf_mp
->
ty
 = 0x00;

260 
cf_mp
->
buo
 = 0x04;

261 
cf_mp
->
devno
 = 0x06;

262 
cf_mp
->
dev_cou
 = 0x01;

263 
cf_mp
->
bus_cou
 = 0x01;

264 
cf_mp
->
mask
 = 0xFFFFFFFF;

265 
cf_mp
->
gi_addr
 = 0x7D0;

266 
	}
}

268 
BOOL
 
	gModBusT_KunMg
::
	$In
(
BYTE
 
byLeNo
)

270 
BYTE
 
szFeName
[128] = {0};

271 
	`rtf
((*)
szFeName
,"%s%s", 
CONFIGPATH
, "kunming_config.txt");

272 
CfigIm
 
cf_mp
;

273 
lesum
 = 
	`RdCf
(
szFeName
);

275 if(
lesum
 == 0){

276 
	`DeuCfig
(&
cf_mp
);

277 
vec_cf
.
	`push_back
(
cf_mp
);

278 
lesum
 = 1;

280 
ve
<
CfigIm
>::

 
beg
 = 
vec_cf
.
	`beg
(), 

 = vec_cf.
	`d
(); beg!=en; beg++)

281 
	`tf
("\n%2X,%2X,%2X,%2X,%2X,%8X,%4X\n", (*
beg
).
ty
, (*beg).
buo
, (*beg).
devno
, (*beg).
bus_cou
, (*beg).
dev_cou
, (*beg).
mask
, (*beg).
gi_addr
);

282 
	`tf
("=========================esum:%d ========================\n", 
lesum
);

283  
TRUE
;

284 
	}
}

286 
	gModBusT_KunMg
::
	$TimProc
()

289 
	}
}

291 
BOOL
 
ModBusT_KunMg
::
	$GDevCommS
()

294  
FALSE
;

296 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/ModBusTcp_Transfer.h

2 #ide
MODBUST_TRANSFER_H


3 
	#MODBUST_TRANSFER_H


	)

4 
	~<ve
>

5 
	~"CProc_ModBusT.h
"

6 
	tUINT
;

7 
	tUSHORT
;

8 
	tULONG
;

9 
usg
 
mea
 
	gd
;

11 as
	cCfigIm
{

12 
	mpublic
:

13 
BYTE
 
ty
;

14 
BYTE
 
	mbuo
;

15 
BYTE
 
	mdevno
;

16 
BYTE
 
	mbus_cou
;

17 
BYTE
 
	mdev_cou
;

18 
UINT
 
	mmask
;

19 
WORD
 
	mgi_addr
;

22 as
	cModBusT_KunMg
 : 
public
 
CProc_ModBusT_Tnsr
{

23 
public
:

24 
ModBusT_KunMg
();

25 
	mvtu
 ~
ModBusT_KunMg
();

27 
vtu
 
BOOL
 
GProcBuf
(
BYTE
*, &, 
PBUSMSG
 
pBusMsg
 = 
NULL
);

28 
vtu
 
ReOrd
(
ve
<
DWORD
> &);

29 
ReOrd
(
ve
<
DWORD
> &, vector<DWORD> &);

30 
BOOL
 
FchYcYmDa
();

31 
GYcYmFme
(
BYTE
 *, &);

32 
BOOL
 
FchYxDa
();

33 
GYxFme
(
BYTE
 *, &);

34 
vtu
 
BOOL
 
ProssProcBuf
(
BYTE
 *, );

35 
BYTE
 
RdCf
(BYTE *);

36 
DeuCfig
(
CfigIm
 *);

37 
vtu
 
BOOL
 
In
(
BYTE
);

38 
vtu
 
TimProc
();

39 
vtu
 
BOOL
 
GDevCommS
();

41 
	mive
:

42 
WORD
 
af_ty
;

43 
	mve
<
	mDWORD
> 
	mvec_yc_ym
;

44 
	mve
<
	mWORD
> 
	mvec_yx
;

45 
	mve
<
	mBYTE
> 
	mLeNo
;

46 
	mve
<
	mBYTE
> 
	mDevNo
;

47 
	mve
<
	mCfigIm
> 
	mvec_cf
;

48 
BYTE
 
	mm_byPtStus
;

49 
BYTE
 
	mlesum
;

50 
BYTE
 
	mle
;

51 
	mloag
;

52 cڡ 
	mERROR_CONST
;

53 cڡ 
	mCOMSTATUS_ONLINE
;

54 cڡ 
	mCOMSTATUS_FAULT
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/main.cpp

1 
	~<dio.h
>

2 
	~"CProc_ModBusT.h
"

6 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

9 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

11 
CProc
 * 
pProc
 = 
NULL
 ;

12 
pProc
 = 
w
 
CProc_ModBusT_Tnsr
;

13 if
pProc
 )

14 
pProc
->
m_pMhod
 = 
pMhod
 ;

16  
pProc
 ;

17 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/CProtocol_LFP.cpp

1 
	~"CProc_LFP.h
"

2 
	~"LFP_NSA3000.h
"

4 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

7 
	gCProc_LFP
::
	$CProc_LFP
()

9 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

10 
	}
}

12 
	gCProc_LFP
::~
	$CProc_LFP
()

15 
size
 = 
m_modu
.
	`size
() ;

16  
i
 = 0 ; i < 
size
 ; i++ )

18 
de
 
m_modu
[ 
i
 ] ;

20 
m_modu
.
	`r
() ;

22 
	}
}

24 
BOOL
 
	gCProc_LFP
::
	$In

BYTE
 
byLeNo
 )

28 
m_byLeNo
 = 
byLeNo
 ;

30 
m_ProTy
 = 
PROTOCO_GATHER
 ;

32  
	`GDevDa
( ) ;

33 
	}
}

35 
BOOL
 
	gCProc_LFP
::
	$GDevDa
( )

37 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

38 
	`rtf

m_sDevPh
 , "%s/LFP/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

39 
CProfe
 
	`ofe

m_sDevPh
 ) ;

41  
	`ProssFeDa

ofe
 ) ;

42 
	}
}

44 
BOOL
 
	gCProc_LFP
::
	$ProssFeDa

CProfe
 &
ofe
 )

46 if!
ofe
.
	`IsVid
() )

48 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

49  
FALSE
 ;

52 
sSe
[ 200 ] = "DEVNUM" ;

53 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

55 
sName
[ 50 ] = { 0 };

56 
eme
[ 200 ] = { 0 };

57 
iNum
 = 0 ;

59 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

60 if
iNum
 == 0 )

62 
	`tf
( "Get DEVNUM Failed ! \n " );

63  
FALSE
 ;

66  
i
 = 0 ; i < 
iNum
 ; i++ )

68 
WORD
 
wModu
 = 0 ;

69 
ro
 = 0 ;

70 
WORD
 
addr
 = 0 ;

71 
BOOL
 
bR
 = 
FALSE
;

73 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

75 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

76 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

77 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

78 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

79 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

82 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

83 i!
bR
 )

85 
	`tf
 ( "Create LFP Module=%d serialno=%dddr=%d sName=%s stemplate=%s Error \n",

86 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

87  
FALSE
;

91  
TRUE
 ;

92 
	}
}

94 
BOOL
 
	gCProc_LFP
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

96 
CProc_LFP
 * 
pProc
 = 
NULL
 ;

99  
iModu
 )

101 
NSA3000
:

103 
pProc
 = 
w
 
CL_N3000
 ;

104 
pProc
->
m_byLeNo
 = m_byLineNo ;

105 
pProc
->
m_wModuTy
 = 
iModu
 ;

106 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

107 
pProc
->
m_SlNo
 = 
iSlNo
 ;

108 
	`ry

pProc
->
m_sDevName
 , 
sName
 ) ;

109 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

110 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

111 
pProc
->
m_pMhod
 = m_pMethod ;

112 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

114 if!
pProc
->
	`In

m_byLeNo
 ) )

116 
	`tf
" Add bu%d Add%d s%d!!!\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

117  
FALSE
;

126 
	`tf
"LFP d'cڏhimodu, Modu No:%d, sName=%\n", 
iModu
, 
sName
);

127  
FALSE
 ;

130 if(
pProc
)

131 
m_modu
.
	`push_back

pProc
 ) ;

133  
TRUE
 ;

134 
	}
}

137 
WORD
 
	gCProc_LFP
::
	$GCrc

BYTE
 * 
pBuf
 , 
n
 )

139 
WORD
 
byR
 = 0x00;

140 
i
;

142 if
pBuf
 =
NULL
 || 
n
 <= 0 )

143  
byR
;

145  
i
=0; i<
n
 ; i++ )

147 
byR
 +
pBuf
[
i
];

150  
byR
;

151 
	}
}

162 
	gCProc_LFP
::
	$t
 ( cڡ *
szBuf
, 
n
 )

164 #ifde 
LFPPRINT


165 
	`tf
"%s\n", 
szBuf
 );

168 #ifde 
LFPDEBUG


169 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

171 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/CProtocol_LFP.h

2 #ide
CPROTOCOL_LFP_H


3 
	#CPROTOCOL_LFP_H


	)

5 
	~"../../she/CProc.h
"

6 
	~"../../she/CMhod.h
"

7 
	~<time.h
>

8 
	~<sys/time.h
>

10 
usg
 
mea
 
	gd
;

12 
	#LFPPREFIXFILENAME
 "/myp/cfig/LFP/me/"

	)

15 
	#LFPDEBUG


	)

17 
	#LFP_READDATA_DATATYPE
 1

	)

18 
	#LFP_TIME_DATATYPE
 2

	)

21 
	#LFP_MAX_BUF_LEN
 256

	)

22 
	#LFP_MAX_RESEND_COUNT
 3

	)

23 
	#LFP_MAX_RECV_ERR_COUNT
 3

	)

25 "C" 
GCutTime

REALTIME
 *
pRlTime
 );

33 as
	cCProc_LFP
 : 
public
 
CProc


35 
public
:

36 
CProc_LFP
();

37 
	mvtu
 ~
CProc_LFP
();

39 
	meed
:

41 
BOOL
 
GDevDa
( ) ;

43 
BOOL
 
ProssFeDa

CProfe
 &
ofe
 );

45 
BOOL
 
CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

46 
	mpublic
:

49 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

51 
vtu
 
WORD
 
GCrc

BYTE
 * 
pBuf
 , 
n
 );

53 
	meed
:

55 
t
cڡ *
szBuf
, 
n
=0 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/Lfp_Nsa3000.cpp

19 
	~<dio.h
>

20 
	~<as.h
>

21 
	~"L_N3000.h
"

23 
	#NSA3000_SYNC_INTERVAL
 60*20

	)

32 
	gCL_N3000
::
	$CL_N3000
 ()

34 
m_bLkStus
 = 
FALSE
;

35 
m_bySdCou
 = 0;

36 
m_byRecvCou
 = 0;

37 
m_byCodeIndex
 = 1;

38 
m_bNdCfm
 = 
FALSE
;

39 
	}
}

48 
	gCL_N3000
::~
	$CL_N3000
 ()

50 
	}
}

53 
BOOL
 
CL_N3000
::
	$In

BYTE
 
byLeNo
 )

56 if(
m_wModuTy
 !
NSA3000
)

57  
FALSE
;

59  
TRUE
 ;

60 
	}
}

62 
BOOL
 
	gCL_N3000
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
)

64 if(!
m_bNdCfm
)

66 
m_byCodeIndex
++;

67 if(
m_byCodeIndex
 >(
byVueCode
)/(
BYTE
))

68 
m_byCodeIndex
 = 0;

69 
n
 = 
	`PackMsg
(
buf
, 
byVueCode
[
m_byCodeIndex
]);

73 
m_bNdCfm
 = 
FALSE
;

74 
n
 = 
	`PackMsg
(
buf
, 
RCS_ACK
);

76 
m_bySdCou
++;

77  
TRUE
;

78 
	}
}

79 
BOOL
 
	gCL_N3000
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

81 if(
buf
[6] !
byVueCode
[
m_byCodeIndex
])

83 
m_bNdCfm
 = 
TRUE
;

84 
	`tf
("LFP: Nd Cfm, Code=0x%X\n", 
buf
[6]);

85 
m_byRecvCou
++;

86  
FALSE
;

90 if(!
	`memcmp
(
buf
, "\xeb\x90\xed\x90\x02", 5|| buf[
n
-1] !0x03 || buf[5] !
m_wDevAddr
)

92 
	`tf
("LFP: PackagCheck EܣAddr=%d,ame=%s\n", 
m_wDevAddr
, 
m_sDevName
);

93 
m_byRecvCou
++;

94  
FALSE
;

96 
iL
 = 
buf
[9]-4;

97 
BYTE
 *
pDa
 = 
buf
+10;

98 
byVueCode
[
m_byCodeIndex
])

100 
RCS_YC
:

101 
i
 = 0; i<
iL
; i+=2)

103 
WORD
 
wVue
 = 
	`MAKEWORD
(
pDa
[
i
+1],Data[i]);

105 
fVue
 = (
wVue
&0x07FF)/2048;

106 if(
wVue
 & 0x0800)

107 
fVue
 = -fValue;

108 if(
i
/2 < 11)

109 
m_pMhod
->
	`SYcDa
 ( 
m_SlNo
 ,
i
/2 , 
fVue
);

112 
RCS_YX
:

113 
i
 = 0; i<
iL
; i++)

115 
BYTE
 
byVue
 = 
pDa
[
i
];

116 
j
 = 0; j<8; j++)

118 
BYTE
 
bVue
 = 
byVue
 & (1<<
j
);

120 if(
i
*8+
j
 < 48)

121 
m_pMhod
->
	`SYxDa
 ( 
m_SlNo
 ,
i
*8+
j
 , 
bVue
?1:0);

125 
RCS_SWITCH
:

128 
pDa
 ++;

129 
WORD
 
wVue
 = 
	`MAKEWORD
(*
pDa
, *(pData+1));

130 
j
 = 0; j<16; j++)

132 
WORD
 
bVue
 = 
wVue
 & (1<<
j
);

133 
m_pMhod
->
	`SYxDa
 ( 
m_SlNo
 ,
j
 , 
bVue
?1:0);

142 
m_bLkStus
 = 
TRUE
;

143 
m_bySdCou
 = 0;

144 
m_byRecvCou
 = 0;

145  
TRUE
;

146 
	}
}

147 
	gCL_N3000
::
	$TimProc
()

149 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

151 
m_bySdCou
 = 0;

152 
m_byRecvCou
 = 0;

153 if
m_bLkStus
 )

155 
m_bLkStus
 = 
FALSE
;

156 
	`t
( ( * ) "CModBusLFP:unlink\n");

159 
	}
}

161 
BOOL
 
	gCL_N3000
::
	$GDevCommS
( )

163 i
m_bLkStus
 )

165  
COM_DEV_NORMAL
;

169  
COM_DEV_ABNORMAL
;

171 
	}
}

173 
	gCL_N3000
::
	$PackMsg
(
BYTE
 * 
byBuf
, BYTE 
byCode
, BYTE * 
byDa
, 
iDaL
)

175 
iL
 = 0;

176 
byBuf
[
iL
++] = 0xEB;

177 
byBuf
[
iL
++] = 0x90;

178 
byBuf
[
iL
++] = 0xEB;

179 
byBuf
[
iL
++] = 0x90;

180 
byBuf
[
iL
++] = 0x02;

181 
byBuf
[
iL
++] = 
m_wDevAddr
;

182 
byBuf
[
iL
++] = 
byCode
;

183 
byBuf
[
iL
++] = 0x01;

184 
byBuf
[
iL
++] = 0x00;

185 
byBuf
[
iL
++] = 4+
iDaL
;

186 if(
iDaL
 && 
byDa
)

188 
	`memy
(
byBuf
+
iL
, 
byDa
, 
iDaL
);

189 
iL
 +
iDaL
;

192 
WORD
 
wCrc
 = 
	`GCrc
(
byBuf
+5, 
iL
-5);

193 
byBuf
[
iL
++] = 
	`LOBYTE
(
wCrc
);

194 
byBuf
[
iL
++] = 
	`HIBYTE
(
wCrc
);

195 
byBuf
[
iL
++] = 0x03;

202  
iL
;

203 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/Lfp_Nsa3000.h

21 #ide 
_LFP_NSA3000_INC


22 
	#_LFP_NSA3000_INC


	)

24 
	~"CProc_LFP.h
"

27 
	mNSA3000
 = 1

30 
	#RCS_YC
 0x50

31 
	#RCS_YX
 0x54

	)

32 
	#RCS_ACK
 0x06

	)

33 
	#RCS_QUERY1
 0x40

	)

34 
	#RCS_QUERY2
 0x55

	)

35 
	#RCS_SWITCH
 0x44

36 

	)

41 cڡ 
BYTE
 
	gbyVueCode
[] = {
RCS_SWITCH
};

50 as
	cCL_N3000
 : 
public
 
CProc_LFP


52 
public
:

54 
CL_N3000
 ();

55 ~
CL_N3000
 ();

57 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 );

58 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

59 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

60 
vtu
 
TimProc
() ;

62 
vtu
 
BOOL
 
GDevCommS
( ) ;

64 
	meed
:

65 
BOOL
 
m_bNdCfm
;

66 
BOOL
 
	mm_bLkStus
;

67 
BYTE
 
	mm_bySdCou
;

68 
BYTE
 
	mm_byRecvCou
;

69 
BYTE
 
	mm_byCodeIndex
;

71 
	mive
:

72 
PackMsg
(
BYTE
 * 
byBuf
, BYTE 
byCode
, BYTE * 
byDa
 = 
NULL
, 
iDaL
 = 0);

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_LFP.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

10 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

12 
CProc
 * 
pProc
 = 
NULL
 ;

13 
pProc
 = 
w
 
CProc_LFP
 ;

14 if
pProc
 )

16 
pProc
->
m_pMhod
 = 
pMhod
 ;

20  
pProc
 ;

21 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/CProtocol_ModBus.cpp

1 
	~"CProc_ModBus.h
"

2 
	~"ModBusRTU.h
"

4 
	#MODULE_RTU
 1

	)

9 
	gAuchCRCHi
[256] = {

38 
	gAuchCRCLo
[256] = {

67 
	gCProc_ModBus
::
	$CProc_ModBus
()

70 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

72 
	}
}

74 
	gCProc_ModBus
::~
	$CProc_ModBus
()

77 
size
 = 
m_modu
.
	`size
() ;

78  
i
 = 0 ; i < 
size
 ; i++ )

80 
de
 
m_modu
[ 
i
 ] ;

82 
m_modu
.
	`r
() ;

83 
	`tf
( "Delete All CProtocol_ModBus OK . \n" );

84 
	}
}

86 
BOOL
 
	gCProc_ModBus
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

88  
FALSE
 ;

89 
	}
}

91 
BOOL
 
	gCProc_ModBus
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

93  
FALSE
 ;

94 
	}
}

96 
BOOL
 
	gCProc_ModBus
::
	$In

BYTE
 
byLeNo
 )

100 
m_byLeNo
 = 
byLeNo
 ;

102 
m_ProTy
 = 
PROTOCO_GATHER
 ;

104  
	`GDevDa
( ) ;

105 
	}
}

107 
BOOL
 
	gCProc_ModBus
::
	$GDevDa
( )

109 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

110 
	`rtf

m_sDevPh
 , "%s/ModBus/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

111 
CProfe
 
	`ofe

m_sDevPh
 ) ;

113  
	`ProssFeDa

ofe
 ) ;

114 
	}
}

116 
BOOL
 
	gCProc_ModBus
::
	$ProssFeDa

CProfe
 &
ofe
 )

118 
BOOL
 
bR
 = 
FALSE
;

119 if!
ofe
.
	`IsVid
() )

121 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

122  
FALSE
 ;

125 
sSe
[ 200 ] = "DEVNUM" ;

126 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

128 
WORD
 
wModu
 = 0 ;

129 
ro
=1 ;

130 
WORD
 
addr
 =3 ;

131 
sName
[ 50 ] = { 0 };

132 
eme
[ 200 ] = { 0 };

133 
iNum
 = 0 ;

135 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

136 if
iNum
 == 0 )

138 
	`tf
( "Get DEVNUM Failed ! \n " );

139  
FALSE
 ;

142  
i
 = 0 ; i < 
iNum
 ; i++ )

144 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

146 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

147 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

148 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

149 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

150 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

153 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

154 i!
bR
 )

156 
	`tf
 ( "CModBuModu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

158  
FALSE
;

162  
TRUE
 ;

163 
	}
}

165 
BOOL
 
	gCProc_ModBus
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

167 
CProc_ModBus
 * 
pProc
 = 
NULL
 ;

168 
BOOL
 
bR
 = 
FALSE
;

169  
iModu
 )

171 
MODULE_RTU
:

173 
pProc
 = 
w
 
CModBusRTU
 ;

174 
pProc
->
m_byLeNo
 = m_byLineNo ;

175 
pProc
->
m_wModuTy
 = 
iModu
 ;

176 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

177 
pProc
->
m_SlNo
 = 
iSlNo
 ;

179 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

180 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

181 
pProc
->
m_pMhod
 = m_pMethod ;

182 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

184 
bR
 = 
pProc
->
	`In

m_byLeNo
 ) ;

185 i!
bR
 )

187 
	`tf
 ( "Init Error \n");

188  
FALSE
;

190 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

195 
	`tf
( "ModBus don't containhis module Failed .\n" );

196  
FALSE
 ;

199 
m_modu
.
	`push_back

pProc
 ) ;

201  
TRUE
 ;

202 
	}
}

204 
WORD
 
	gCProc_ModBus
::
	$GCrc

BYTE
 * 
pBuf
 , 
n
 )

206 
uchCRCHi
 = 0xFF;

207 
uchCRCLo
 = 0xFF;

208 
uIndex
;

210  
n
-- )

212 
uIndex
 = 
uchCRCHi
 ^ *
pBuf
++ ;

213 
uchCRCHi
 = 
uchCRCLo
 ^ 
AuchCRCHi
[
uIndex
];

214 
uchCRCLo
 = 
AuchCRCLo
[
uIndex
] ;

216  (
uchCRCHi
 << 8 | 
uchCRCLo
) ;

217 
	}
}

219 
BOOL
 
	gCProc_ModBus
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

222 
dex
 = 0 ;

223 
buf
[ 
dex
++ ] = 0xFF ;

224 
buf
[ 
dex
++ ] = 0x02 ;

225 
buf
[ 
dex
++ ] = 0x03 ;

226 
buf
[ 
dex
++ ] = 0x04 ;

228 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

229 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

230 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

232 
n
 = 
dex
 ;

234 
	`tf
( "\n CProtocol_ModBus TestBroadCast \n " ) ;

235  
TRUE
 ;

236 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/CProtocol_ModBus.h

1 #ide
CPROTOCOL_MODBUS_H


2 
	#CPROTOCOL_MODBUS_H


	)

4 
	~"../../she/CProc.h
"

5 
	~"../../she/CMhod.h
"

7 as
	cCProc_ModBus
 : 
public
 
CProc


9 
public
:

10 
CProc_ModBus
();

11 
	mvtu
 ~
CProc_ModBus
();

12 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

13 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

14 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

15 
vtu
 
WORD
 
GCrc

BYTE
 * 
pBuf
 , 
n
 );

16 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 ) ;

17 
vtu
 
	$TimProc
(){ ; }

18 
eed
:

19 
BOOL
 
	`GDevDa
( ) ;

20 
eed
:

21 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

22 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

24 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/ModBusRTU.cpp

5 
	~"ModBusRTU.h
"

9 
	~<dio.h
>

10 
	~<time.h
>

11 
	~<sigl.h
>

12 
	~<ve
>

13 
	~<mh.h
>

16 
	#MODBUSRTUPREFIXFILENAME
 "/mynd/cfig/ModBus/me/"

	)

20 
	#TIME
 300

	)

21 
	#ERROR_CONST
 5

	)

22 
	#COMSTATUS_ONLINE
 1

	)

23 
	#COMSTATUS_FAULT
 0

	)

25 
	#MASK
 0xffffffff

	)

29 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

30 "C" 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
);

31 
usg
 
mea
 
	gd
;

36 
	gCModBusRTU
::
	$CModBusRTU
()

38 
pos_ag
 = -1;

39 
pos
 = 0;

40 
ime_pos
 = 0;

41 
yk_pos_num
 = 0;

42 
yk_ag
 = 0;

43 
adv_ag
 = -1;

44 
wrev_ag
 = -1;

45 
ϡ_ime
 = 0;

46 
timeag
 = 0;

47 
YkNo
 = 0;

48 
MsgEFg
 = 0;

49 
ESL411SOEFg
 = 0;

50 
	`memt
(
e_buf
,0,(store_buf));

52 
m_wETim
 = 
ERROR_CONST
+1;

53 
m_byPtStus
 = 
COMSTATUS_FAULT
;

54 
DevCFg
 = 
FALSE
;

55 
modbus_cf
.
	`rve
(100);

56 
	}
}

58 
	gCModBusRTU
::~
	$CModBusRTU
()

60 
	`tf
"DCModBusRTU bu%d , Add%d \n" , 
m_byLeNo
 , 
m_wDevAddr
 );

61 
yk_fo
.
	`r
();

64 
modbus_cf
.
	`r
() ;

66 
	}
}

68 
BOOL
 
	gCModBusRTU
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

74 if
modbus_cf
.
	`size
() <= 0 )

75  
FALSE
;

79 if
pBusMsg
 !
NULL
 )

81 if
pBusMsg
->
byMsgTy
 =
YK_PROTO
 )

83 if
TRUE
 =
	`GYKBufr

buf
 , 
n
 , 
pBusMsg
 ) )

85 if
pBusMsg
->
dwDaTy
 =
YK_EXCT
 || (BusMsg->dwDaTy =
YK_SEL
 && 
modbus_cf
[
pos_ag
].
YkSFg
 == 1 ) )

87 
m_wETim
++;

88 if
m_wETim
 > 60000 )

89 
m_wETim
 = 
ERROR_CONST
 + 1 ;

90 
MsgRegieAndDa
[0] = 
buf
[2];

91 
MsgRegieAndDa
[1] = 
buf
[3];

92 
MsgRegieAndDa
[2] = 
buf
[4];

93 
MsgRegieAndDa
[3] = 
buf
[5];

95  
TRUE
;

99  
FALSE
;

103 if
yk_ag
 > 0 )

105 
yk_ag
++;

106 if
yk_ag
 >= 3 )

108 
yk_ag
 = 0;

110 
	`memy

buf
 , 
YkBuf
 , 
YkL
 );

111 
n
 = 
YkL
;

115 if
DevCFg
 =
FALSE
 )

116  
FALSE
;

171 if
modbus_cf
[
pos
].
c_ag
 == 0 ) )

173 
pos
 = (pos+1)%
le
;

176 if
modbus_cf
[
pos
].
ty
 == 8 ) )

178 if
timeag
 > 
TIME
 )

180 
timeag
 = 0;

181 
	`SdBuf

modbus_cf
[
ime_pos
] , 
buf
 , &
n
 );

182 
pos_ag
 = 
ime_pos
;

183 
	`time
(&
ϡ_ime
);

184 
pos
 = (pos+1)%
le
;

189 
pos
 = (pos+1)%
le
;

193 if
modbus_cf
[
pos
].
ty
 == 3 ) )

195 
pos
 = (pos+1)%
le
;

199 
	`SdBuf

modbus_cf
[
pos
] , 
buf
 , &
n
 );

200 
pos_ag
 = 
pos
;

201 
pos
 = (pos+1)%
le
;

204 if
ESL411SOEFg
 == 1 )

206 
	`E411SSdBuf

buf
 , &
n
 );

210 
m_wETim
++;

211 if
m_wETim
 > 60000 )

212 
m_wETim
 = 
ERROR_CONST
 + 1 ;

213 
MsgRegieAndDa
[0] = 
buf
[2];

214 
MsgRegieAndDa
[1] = 
buf
[3];

215 
MsgRegieAndDa
[2] = 
buf
[4];

216 
MsgRegieAndDa
[3] = 
buf
[5];

217  
TRUE
 ;

218 
	}
}

220 
BOOL
 
	gCModBusRTU
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

224 
BYTE
 
mp_ag
 = 0;

225 
BYTE
 
CRC_ag
 = 0;

226 
WORD
 
wCRC
 = 0 ;

229  
n
 > 4 )

231 if
buf
[0] =
m_wDevAddr
 )

233 if
buf
[1] =
modbus_cf
[
pos_ag
].
func
 )

235 if
buf
[1] > 0 ) && ( buf[1] < 5 ) || buf[1] == 0x55 )

237 if
buf
[2] + 5 ) <
n
 )

259 if
modbus_cf
[
pos_ag
].
ty
 == 1 )

261 if
modbus_cf
[
pos_ag
].
gie_num
%8 !0&& ( 
buf
[2] == 1 + modbus_conf[pos_flag].registe_num/8 ) )

263 
CRC_ag
 = 1;

265 if
modbus_cf
[
pos_ag
].
gie_num
%8 =0&& ( 
buf
[2] == modbus_conf[pos_flag].registe_num/8 ) )

267 
CRC_ag
 = 1;

269 i
buf
[2] =
modbus_cf
[
pos_ag
].
gie_num
*2 )

271 
CRC_ag
 = 1;

276 if
buf
[1] == 0x55 )

278 
CRC_ag
 = 1;

280 i
buf
[2] =
modbus_cf
[
pos_ag
].
gie_num
*2 )

282 
CRC_ag
 = 1;

288 if
CRC_ag
 == 1 )

290 
wCRC
 = 
	`GCrc

buf
, buf[2] + 3 );

291 if
	`HIBYTE
(
wCRC
=
buf
[ buf[2] + 3 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ buf[2] + 4 ] ) )

293 
mp_ag
 = 1;

299 i
buf
[1] == 0x5 || buf[1] == 0x6 || buf[1] == 0xf || buf[1] == 0x10 )

301 if
MsgRegieAndDa
[0] =
buf
[2] && MsgRegisteAndData[1] == buf[3] &&

302 
MsgRegieAndDa
[2] =
buf
[4] && MsgRegisteAndData[3] == buf[5] )

304 
wCRC
 = 
	`GCrc

buf
, 6 );

305 if
	`HIBYTE
(
wCRC
=
buf
[ 6 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ 7 ] ) )

307 
mp_ag
 = 1;

313 if
buf
[1] =
modbus_cf
[
pos_ag
].
func
 | 0x80 ) )

315 
wCRC
 = 
	`GCrc

buf
, 3 );

316 if
	`HIBYTE
(
wCRC
=
buf
[ 3 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ 4 ] ) )

318 
modbus_cf
[
pos_ag
].
ty
)

321 
yk_ag
 = 0;

324 
bufr
[100] = "";

325 
	`rtf
(
bufr
,"fun%xnnum:%d\n",
buf
[1],buf[2]);

326 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
bufr
, 
	`
(buffer),3);

330 if
modbus_cf
[
pos_ag
].
YkSFg
 =1 && 
buf
[1] =0x10 && modbus_cf[pos_ag].
func
 == 0x05 )

332 if
buf
[2] == 0x40 && buf[3] == 0x59 && buf[4] == 0x00 && buf[5] == 0x03 )

334 
wCRC
 = 
	`GCrc

buf
, 6 );

335 if
	`HIBYTE
(
wCRC
=
buf
[ 6 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ 7 ] ) )

337 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
YkNo
 , 
YkV
 );

338  
TRUE
 ;

342 if
modbus_cf
[
pos_ag
].
SFg
 =2 && ( 
buf
[1] == 0x02 || buf[1] == 0x03 || buf[1] == 0x0c) )

344 
wCRC
 = 
	`GCrc

buf
, buf[2] + 3 );

345 if
	`HIBYTE
(
wCRC
=
buf
[ buf[2] + 3 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ buf[2] + 4 ] ) )

347 
mp_ag
 = 1;

353 
buf
 = buf + 1 ;

354 
bufr
[100] = "the message changed!";

355 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
bufr
, 
	`
(buffer),3);

356 
n
--;

358 if
mp_ag
 == 1 )

360 
modbus_cf
[
pos_ag
].
ty
)

363 
	`ModBusYxDl
(
buf
,
modbus_cf
[
pos_ag
]);

366 
	`ModBusYcDl
(
buf
,
modbus_cf
[
pos_ag
]);

369 
	`ModBusYkDl
(
buf
,
modbus_cf
[
pos_ag
] );

372 
	`ModBusYmDl
(
buf
,
modbus_cf
[
pos_ag
]);

375 
	`ModBusRdV
(
buf
,
modbus_cf
[
pos_ag
]);

378 
	`ModBusWreV
(
buf
,
modbus_cf
[
pos_ag
]);

381 
	`ModBusSTime
(
buf
,
modbus_cf
[
pos_ag
]);

384 
	`ModBusSDl
(
buf
,
modbus_cf
[
pos_ag
]);

386 : 
FALSE
;

389 if
mp_ag
 == 0 )

391 
bufr
[100] = "the message is wrong!";

392 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
bufr
, 
	`
(buffer),3);

393  
FALSE
;

395 if
MsgEFg
 =
MSGERROR
 )

397 
MsgEFg
 = 
MSGTRUE
;

398 
bufr
[100] = "the config is wrong!";

399 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
bufr
, 
	`
(buffer),3);

400  
FALSE
;

402 
m_wETim
 = 0;

403  
TRUE
 ;

404 
	}
}

406 
BOOL
 
	gCModBusRTU
::
	$In

BYTE
 
byLeNo
 )

409 
szFeName
[256] = "";

410 
	`rtf

szFeName
, "%s%s", 
MODBUSRTUPREFIXFILENAME
, 
m_sTemePh
);

411 
le
 = 
	`RdCf
(
szFeName
);

413 if
le
 <= 0 )

416 
	`tf
("d'found %s\n",
szFeName
);

417 
MODBUSCONF
 
mc
;

418 
	`DeuVCfig
(&
mc
);

419 
modbus_cf
.
	`push_back

mc
 );

420 
le
 = 1;

422  
TRUE
 ;

423 
	}
}

426 
	gCModBusRTU
::
	$TimProc
()

428 
time_t
 
mp_time
;

429 
	`time
(&
mp_time
);

430 
timeag
 = ()
mp_time
 - 
ϡ_ime
 );

432 if
m_wETim
 > 
ERROR_CONST
 )

436 
m_byPtStus
 = 
COMSTATUS_FAULT
;

446 
m_byPtStus
 = 
COMSTATUS_ONLINE
;

449 
	}
}

452 
BOOL
 
	gCModBusRTU
::
	$GYKBufr

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

454 
i
 = 0;

455 
YK_DATA
 *
yk_da
;

456 
yk_da
 = (
YK_DATA
 *)
pBusMsg
->
pDa
;

460 if
pBusMsg
 =
NULL
 ) && ( 
yk_pos_num
 == 0 ) )

461  
FALSE
 ;

462 
bySrcBusNo
 = 
pBusMsg
->
SrcInfo
.
byBusNo
;

463 
wSrcDevAddr
 = 
pBusMsg
->
SrcInfo
.
wDevNo
;

465 if
pBusMsg
->
dwDaTy
 =
YK_SEL
 ||BusMsg->dwDaTy =
YK_CANCEL
 )

467  
i
=0 ; i<
yk_pos_num
 ; i++ )

469 if
yk_da
->
wP
 =
yk_fo
[
i
].
t_num
 )

472 if
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 == 2 ) ||

473 
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 =
yk_da
->
byV
 ) )

475 if
pBusMsg
->
dwDaTy
 =
YK_SEL
 )

477 
yk_ag
 = 0;

478  
modbus_cf
[
yk_fo
[
i
].
pos
].
YkSFg
 )

481 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
yk_da
->
wP
 , yk_da->
byV
 );

484 
YkNo
 = 
yk_da
->
wP
;

485 if
yk_da
->
byV
 =0 && 
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 == 2 )

486 
YkV
 = 0;

488 
YkV
 = 1;

489 
	`YkPtSdBuf

modbus_cf
[
yk_fo
[
i
].
pos
] , 
yk_da
 , 
buf
 , &
n
 );

490 
pos_ag
 = 
yk_fo
[
i
].
pos
;

491  
TRUE
 ;

492 : 
FALSE
 ;

498 
yk_ag
 = 0;

499 
m_pMhod
->
	`SYkClR

this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
yk_da
->
wP
 , yk_da->
byV
 );

501  
TRUE
 ;

505 
yk_da
->
byV
 = 
YK_ERROR
;

506 
yk_ag
 = 0;

507 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
yk_da
->
wP
 , yk_da->
byV
 );

508  
TRUE
 ;

510 if
pBusMsg
->
dwDaTy
 =
YK_EXCT
 )

513  
i
=0 ; i<
yk_pos_num
 ; i++ )

515 if
yk_da
->
wP
 =
yk_fo
[
i
].
t_num
 )

518 if
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 == 2 ) ||

519 
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 =
yk_da
->
byV
 ) )

521  
modbus_cf
[
yk_fo
[
i
].
pos
].
YkExFg
 )

524 
	`YkSdBuf

modbus_cf
[
yk_fo
[
i
].
pos
] , 
yk_da
 , 
buf
 , &
n
 );

527 
	`YkJ05SdBuf

modbus_cf
[
yk_fo
[
i
].
pos
] , 
yk_da
 , 
buf
 , &
n
 );

529 : 
FALSE
;

532 
YkNo
 = 
yk_da
->
wP
;

533 
pos_ag
 = 
yk_fo
[
i
].
pos
;

534  
TRUE
 ;

539 
yk_da
->
byV
 = 
YK_ERROR
;

540 
yk_ag
 = 0;

541 
m_pMhod
->
	`SYkExeR

this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
yk_da
->
wP
 , yk_da->
byV
 );

542  
TRUE
 ;

544 if
pBusMsg
->
dwDaTy
 =
YK_CANCEL
 )

545 
	`tf
( "YK_CANCEL \n" );

547  
TRUE
 ;

548 
	}
}

551 
	gCModBusRTU
::
	$Atoh
(*
buf
)

553 
BYTE
 
i
 = 0;

554 
UINT
 
mpvue
 = 0;

555 
UINT
 
vue
 = 0;

556 
BYTE
 
n
 = 
	`
(
buf
);

558 
i
=0;i<
n
;i++)

560 if(
buf
[
i
]>='A') && (buf[i]<='F') )

562 
mpvue
 = 
buf
[
i
]-'A'+10;

564 if(
buf
[
i
]>='a') && (buf[i]<='f') )

566 
mpvue
 = 
buf
[
i
]-'a'+10;

568 if(
buf
[
i
]>='0') && (buf[i]<='9') )

570 
mpvue
 = 
buf
[
i
]-'0';

572 
vue
 = vue*16+
mpvue
;

574  
vue
;

575 
	}
}

578 
	gCModBusRTU
::
	$DeuVCfig
(
MODBUSCONF
 * 
mc
)

580 
mc
->
ty
 = 1;

581 
mc
->
func
 = 2;

582 
mc
->
gie
 = 0x0064;

583 
mc
->
gie_num
 = 0;

584 
mc
->
skew_by
 = 3;

585 
mc
->
g_num
 = 0;

586 
mc
->
t_num
 = 0;

587 
mc
->
da_n
 = 1;

588 
mc
->
mask_code
 = 0xffffffff;

589 
mc
->
da_fm
 = 0;

590 
mc
->
sign
 = 0;

591 
mc
->
yk_fm
 = 2;

592 
mc
->
c_ag
 = 1;

593 
	}
}

596 
	gCModBusRTU
::
	$RdCf
(*
fame
)

598 
FILE
 *
hFe
;

599 
szText
[160];

600 *
mp
;

601 
num
 = 0;

602 
BYTE
 
i
 = 0;

603 
BYTE
 
cag
 = 0;

604 
MODBUSCONF
 
mc
;

606 
INFO
 
yk
;

610 
hFe
 = 
	`fݒ
(
fame
, "r");

612 if(
hFe
 =
NULL
)

619  
	`fgs
(
szText
, (szText), 
hFe
!
NULL
 )

621 
	`rim
(
szText
);

622 if
szText
[0]=='#' || szText[0]==';' )

624 
i
 = 0;

625 
cag
 = 0;

626 
	`memt
(&
mc
,0,(mc));

628 
mp
 = 
	`ok
(
szText
,",");

629 if(
mp
 =
NULL
)

631 if
	`oi
(
mp
) > 0 ) && (toi(temp) < 10 ) )

632 
mc
.
ty
 = 
	`oi
(
mp
);

635 
cag
 = 1;

636 
	`DeuVCfig
(&
mc
);

638  ( 
mp
 = 
	`ok
(
NULL
,",") ) )

640 ++
i
)

643 if
	`Atoh
(
mp
) > 0 ) && ( Atoh(temp) <= 7 ) ) || ( Atoh(temp) == 0x0f )

644 || ( 
	`Atoh
(
mp
) == 0x10 ) || ( Atoh(temp) == 0x55 ) || ( Atoh(temp) == 0x0c ) )

645 
mc
.
func
 = 
	`Atoh
(
mp
);

647 
cag
 = 1;

650 if
	`Atoh
(
mp
) >= 0 ) && ( Atoh(temp) <= 0xffff ) )

651 
mc
.
gie
 = 
	`Atoh
(
mp
);

653 
cag
 = 1;

656 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

657 
mc
.
gie_num
 = 
	`oi
(
mp
);

659 
cag
 = 1;

663 if
	`oi
(
mp
) >= 0 &&toi(emp ) <= 258 )

664 
mc
.
skew_by
 = 
	`oi
(
mp
);

666 
cag
 = 1;

669 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

670 
mc
.
g_num
 = 
	`oi
(
mp
);

672 
cag
 = 1;

675 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

676 
mc
.
t_num
 = 
	`oi
(
mp
);

678 
cag
 = 1;

681 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 4 ) )

682 
mc
.
da_n
 = 
	`oi
(
mp
);

684 
cag
 = 1;

687 if
	`Atoh
(
mp
) >= 0 ) && ( Atoh(temp) <= 0xffffffff ) )

688 
mc
.
mask_code
 = 
	`Atoh
(
mp
);

690 
cag
 = 1;

693 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 5 ) )

694 
mc
.
da_fm
 = 
	`oi
(
mp
);

696 
cag
 = 1;

699 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 4 ) )

700 
mc
.
sign
 = 
	`oi
(
mp
);

702 
cag
 = 1;

705 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

706 
mc
.
yk_fm
 = 
	`oi
(
mp
);

708 
cag
 = 1;

711 if
	`oi
(
mp
) == 0 ) || (toi(temp) == 1 ) )

713 
mc
.
c_ag
 = 
	`oi
(
mp
);

714 if
mc
.
c_ag
 == 1 )

715 
DevCFg
 = 
TRUE
;

718 
cag
 = 1;

721 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

722 
mc
.
YkClo

	`Atoh
(
mp
);

724 
cag
 = 1;

727 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

728 
mc
.
YkOn

	`Atoh
(
mp
);

730 
cag
 = 1;

733 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

734 
mc
.
STimeFg
 = 
	`oi
(
mp
);

736 
cag
 = 1;

739 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

740 
mc
.
SFg
 = 
	`oi
(
mp
);

742 
cag
 = 1;

745 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

746 
mc
.
YkSFg
 = 
	`oi
(
mp
);

748 
cag
 = 1;

751 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

752 
mc
.
YkExFg
 = 
	`oi
(
mp
);

754 
cag
 = 1;

757 
cag
 = 1;

758 
	`tf
("\n\n\n%d > 18\n\n\n",
i
+1);

761 if
cag
 == 1 )

763 
cag
 = 1;

764 
	`tf
("ModBus config filerror:\n");

769 if
cag
 == 1 )

771 
	`tf
("%num i%d %d\n\n\n",
fame
,
num
+1,
i
+1);

772 
	`DeuVCfig
(&
mc
);

774 if
i
 < 18)

776  
i
 + 1 )

778 13:
mc
.
YkClo
= 0xff00;

779 14:
mc
.
YkOn
= 0x0000;

780 15:
mc
.
STimeFg
 = 0;

781 16:
mc
.
SFg
 = 0;

782 17:
mc
.
YkSFg
 = 0;

783 18:
mc
.
YkExFg
 = 0;;

790 
modbus_cf
.
	`push_back

mc
 );

791 
num
++;

793 
u
 = 
	`fo
(
hFe
);

794 if
u
 )

795 
	`
("fclose");

799 
i
=0;i<
num
;i++)

801 if
modbus_cf
[
i
].
ty
 == 3 )

803 
yk
.
pos
 = 
i
;

804 
yk
.
t_num
 = 
modbus_cf
[
i
].start_num;

805 
yk
.
g_num
 = 
modbus_cf
[
i
].get_num;

808 
yk_fo
.
	`push_back

yk
 );

809 
yk_pos_num
++;

811 if
modbus_cf
[
i
].
ty
 == 5 )

819 
adv_pos_num
++;

821 if
modbus_cf
[
i
].
ty
 == 6 )

829 
wrev_pos_num
++;

831 if
modbus_cf
[
i
].
ty
 == 8 )

833 
ime_pos
 = 
i
;

836  
num
;

837 
	}
}

839 
	gCModBusRTU
::
	$TimePackMcBigEdn
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
,
tm
 *
p
,
WORD
 
mc
)

841 
bufr
[
i
++] = 
modbuscf
.
gie_num
*2;

842 
bufr
[
i
++] = (
p
->
tm_yr
)-100;

843 
bufr
[
i
++] = 1+(
p
->
tm_m
);

844 
bufr
[
i
++] = 
p
->
tm_mday
;

845 
bufr
[
i
++] = 
p
->
tm_hour
;

846 
bufr
[
i
++] = 
p
->
tm_m
;

847 
bufr
[
i
++] = 
p
->
tm_c
;

848 
bufr
[
i
++] = 
mc
 >> 8;

849 
bufr
[
i
++] = 
mc
 ;

850  
i
;

851 
	}
}

853 
	gCModBusRTU
::
	$TimePackMcLeEdn
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
,
tm
 *
p
,
WORD
 
mc
)

855 
bufr
[
i
++] = 
modbuscf
.
gie_num
*2;

856 
bufr
[
i
++] = (
p
->
tm_yr
)-100;

857 
bufr
[
i
++] = 1+(
p
->
tm_m
);

858 
bufr
[
i
++] = 
p
->
tm_mday
;

859 
bufr
[
i
++] = 
p
->
tm_hour
;

860 
bufr
[
i
++] = 
p
->
tm_m
;

861 
bufr
[
i
++] = 
p
->
tm_c
;

862 
bufr
[
i
++] = 
mc
;

863 
bufr
[
i
++] = 
mc
 >> 8;

864  
i
;

865 
	}
}

868 
	gCModBusRTU
::
	$SysLolTime
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
)

870 
timev
 
tv
;

871 
timeze
 
tz
;

874 
tm
 
p
;

876 
	`gtimeofday
&
tv
 , &
tz
 );

879 
	`loime_r
&
tv
.
tv_c
 , &
p
 );

881 
uc
[10] = "";

882 
	`rtf

uc
, "%06ld", 
tv
.
tv_uc
);

883  
	`
(
uc
) )

886 
uc
[1] = '\0';

889 
uc
[2] = '\0';

892 
uc
[3] = '\0';

895 
	`memt

uc
 , 0 , (usec) );

898 
WORD
 
mc
 = 
	`oi
(
uc
);

900  
modbuscf
.
STimeFg
 )

903 
i
 = 
	`TimePackMcBigEdn
(
modbuscf
,
bufr
,i,&
p
,
mc
);

906 
i
 = 
	`TimePackMcLeEdn
(
modbuscf
,
bufr
,i,&
p
,
mc
);

909 
i
 = 
	`TimePackMcBigEdn
(
modbuscf
,
bufr
,i,&
p
,
mc
);

914  
i
;

915 
	}
}

917 
	gCModBusRTU
::
	$E411SSdBuf
(
BYTE
 * 
buf
 ,*
n
)

919 
BYTE
 
dex
 = 0;

921 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

922 
buf
[ 
dex
++ ] = 0x0c;

923 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

924 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

925 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

926 *
n
 = 
dex
;

927 
	}
}

930 
	gCModBusRTU
::
	$SdBuf

MODBUSCONF
 
modbuscf
, 
BYTE
 * 
buf
 ,*
n
 )

932 
BYTE
 
dex
 = 0;

934 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

935 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

936 if
modbuscf
.
ty
 =9 && modbuscf.
SFg
 == 0 )

942 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

943 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 ;

944 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 >> 8;

945 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 ;

964 if
modbuscf
.
ty
 == 8 )

966 
dex
 = 
	`SysLolTime
(
modbuscf
,
buf
,index);

969 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

970 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

971 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

972 *
n
 = 
dex
;

973 
	}
}

976 
	gCModBusRTU
::
	$YkPtSdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
 )

978 
BYTE
 
dex
 = 0;

979 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

980 
buf
[ 
dex
++ ] = 0x10;

981 
buf
[ 
dex
++ ] = 0x40;

982 
buf
[ 
dex
++ ] = 0x59;

983 
buf
[ 
dex
++ ] = 0x00;

984 
buf
[ 
dex
++ ] = 0x03;

985 
buf
[ 
dex
++ ] = 0x06;

986 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

987 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

988 
buf
[ 
dex
++ ] = ( 
modbuscf
.
gie
 << 8 ) >> 8;

991 if
yk_da
->
byV
 =0 && 
modbuscf
.
yk_fm
 ==2 )

993 
buf
[ 
dex
++ ] = 0x00;

994 
buf
[ 
dex
++ ] = 0x00;

998 
buf
[ 
dex
++ ] = 0xff;

999 
buf
[ 
dex
++ ] = 0x00;

1001 
buf
[ 
dex
++ ] = 0xff;

1002 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1003 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1004 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1005 *
n
 = 
dex
;

1006 
	}
}

1009 
	gCModBusRTU
::
	$YkJ05SdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
 )

1012 
BYTE
 
dex
 = 0;

1013 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1014 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1015 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1016 
buf
[ 
dex
++ ] = ( 
modbuscf
.
gie
 << 8 ) >> 8;

1017 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 >> 8;

1018 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 ;

1019 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 ;

1021 if(
yk_da
->
byV
 =0 && 
modbuscf
.
yk_fm
 ==2)

1023 
buf
[ 
dex
++ ] = 0x00;

1027 
buf
[ 
dex
++ ] = 0x01;

1029 
YkV
 = 
buf
[ 
dex
 - 1 ];

1030 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1031 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1032 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1033 *
n
 = 
dex
;

1034 
	}
}

1037 
	gCModBusRTU
::
	$YkSdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
 )

1040 
BYTE
 
dex
 = 0;

1041 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1042 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1043 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1044 
buf
[ 
dex
++ ] = ( 
modbuscf
.
gie
 << 8 ) >> 8;

1046 if(
yk_da
->
byV
 =0 && 
modbuscf
.
yk_fm
 ==2)

1048 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
modbuscf
.
YkOn
);

1049 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
modbuscf
.
YkOn
);

1053 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
modbuscf
.
YkClo
);

1054 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
modbuscf
.
YkClo
);

1056 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1057 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1058 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1059 *
n
 = 
dex
;

1060 
	}
}

1062 
	gCModBusRTU
::
	$RdvSdBuf

MODBUSCONF
 
modbuscf
 , 
BYTE
 * 
buf
 ,*
n
 )

1064 
BYTE
 
dex
 = 0;

1065 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1066 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1067 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1068 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
;

1069 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 >> 8;

1070 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
;

1071 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1072 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1073 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1074 *
n
 = 
dex
;

1075 
	}
}

1077 
	gCModBusRTU
::
	$WrevSdBuf

MODBUSCONF
 
modbuscf
 , * 
v
 , 
BYTE
 * 
buf
 ,*
n
 )

1079 
dex
 = 0;

1080 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1081 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1082 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1083 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
;

1084 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 >> 8;

1085 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 ;

1086 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
*2 ;

1087 
i
 = 0;

1088 
da_n
 = 
modbuscf
.data_len;

1089 
wre_num
 = (2*
modbuscf
.
gie_num
)/modbuscf.
da_n
;

1090  
wre_num
-- )

1092  
da_n
-- )

1094 
buf
[ 
dex
++ ] = 
v
[
i
] >> ( 8 * 
da_n
 ) ;

1096 
da_n
 = 
modbuscf
.data_len;

1097 
i
++;

1099 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1100 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1101 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1102 *
n
 = 
dex
;

1103 
	}
}

1106 
	gCModBusRTU
::
	$TwoByVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
)

1108 
v
 = 0;

1109 
buf
[2] = "";

1116 
buf
[0] = 
bufr
[
a
];

1117 
buf
[1] = 
bufr
[
a
+1];

1118 
modbuscf
.
da_fm
)

1121 
v
 = (
buf
[0]<<8 | buf[1]);

1124 
v
 = (
buf
[0] | buf[1]<<8);

1127 
MsgEFg
 = 
MSGERROR
;

1130  
v
;

1131 
	}
}

1134 
	gCModBusRTU
::
	$FourByVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
)

1136 
v
 = 0;

1138 
buf
[4] = "";

1146 
buf
[0] = 
bufr
[
a
];

1147 
buf
[1] = 
bufr
[
a
+1];

1148 
buf
[2] = 
bufr
[
a
+2];

1149 
buf
[3] = 
bufr
[
a
+3];

1150 
modbuscf
.
da_fm
)

1153 
v
 = (
buf
[0]<<24 | buf[1]<<16 | buf[2]<<8 | buf[3]);

1156 
v
 = (
buf
[0]<<16 | buf[1]<<24 | buf[2] | buf[3]<<8);

1159 
v
 = (
buf
[0]<<8 | buf[1] | buf[2]<<24 | buf[3]<<16);

1162 
v
 = (
buf
[0] | buf[1]<<8 | buf[2]<<16 | buf[3]<<24);

1165 
MsgEFg
 = 
MSGERROR
;

1168  
v
;

1169 
	}
}

1172 
	gCModBusRTU
::
	$FltVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
)

1174 
v
 = 0;

1175 
t_buf
[4] = "";

1177 
buf
[4] = "";

1179 
mp_mask
 = 
modbuscf
.
mask_code
;

1180 
buf
[0] = 
bufr
[
a
] & (
mp_mask
>>24);

1181 
buf
[1] = 
bufr
[
a
+1] & ((
mp_mask
<<8)>>24);

1182 
buf
[2] = 
bufr
[
a
+2] & ((
mp_mask
<<16)>>24);

1183 
buf
[3] = 
bufr
[
a
+3] & ((
mp_mask
<<24)>>24);

1184 
modbuscf
.
da_fm
)

1187 
t_buf
[3] = 
buf
[0];

1188 
t_buf
[2] = 
buf
[1];

1189 
t_buf
[1] = 
buf
[2];

1190 
t_buf
[0] = 
buf
[3];

1193 
t_buf
[2] = 
buf
[0];

1194 
t_buf
[3] = 
buf
[1];

1195 
t_buf
[0] = 
buf
[2];

1196 
t_buf
[1] = 
buf
[3];

1199 
t_buf
[1] = 
buf
[0];

1200 
t_buf
[0] = 
buf
[1];

1201 
t_buf
[3] = 
buf
[2];

1202 
t_buf
[2] = 
buf
[3];

1205 
t_buf
[0] = 
buf
[0];

1206 
t_buf
[1] = 
buf
[1];

1207 
t_buf
[2] = 
buf
[2];

1208 
t_buf
[3] = 
buf
[3];

1211 
MsgEFg
 = 
MSGERROR
;

1214 
v
 = *(*)
t_buf
;

1215  
v
;

1216 
	}
}

1219 
	gCModBusRTU
::
	$ModBusVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
)

1221 
vue_f
 = 0;

1222 
vue_i
 = 0;

1223 
vue_ui
 = 0;

1224 
vue_s
 = 0;

1225 
vue_us
 = 0;

1226 
modbuscf
.
sign
)

1230 if(
modbuscf
.
da_n
 == 2)

1232 
vue_us
 = ()
	`TwoByVue
(
bufr
,
a
,
modbuscf
);

1233  ()
vue_us
;

1235 if(
modbuscf
.
da_n
 == 4)

1237 
vue_ui
 = ()
	`FourByVue
(
bufr
,
a
,
modbuscf
);

1238  ()
vue_ui
;

1243 if(
modbuscf
.
da_n
 == 2)

1245 
vue_s
 = 
	`TwoByVue
(
bufr
,
a
,
modbuscf
);

1246 if
vue_s
 < 0 )

1247 
vue_s
 = ( (~value_s) | 0x8000 ) + 1;

1248  ()
vue_s
;

1250 if(
modbuscf
.
da_n
 == 4)

1252 
vue_i
 = 
	`FourByVue
(
bufr
,
a
,
modbuscf
);

1253 if
vue_i
 < 0 )

1254 
vue_i
 = ( (~value_i) | 0x80000000 ) + 1;

1255  ()
vue_i
;

1260 if(
modbuscf
.
da_n
 == 2)

1262 
vue_s
 = 
	`TwoByVue
(
bufr
,
a
,
modbuscf
);

1263  ()
vue_s
;

1265 if(
modbuscf
.
da_n
 == 4)

1267 
vue_i
 = 
	`FourByVue
(
bufr
,
a
,
modbuscf
);

1268  ()
vue_i
;

1273 
vue_f
 = 
	`FltVue
(
bufr
,
a
,
modbuscf
);

1274  
vue_f
;

1277 
vue_f
 = 
	`FltVue
(
bufr
,
a
,
modbuscf
);

1278  
	`bs
(
vue_f
);

1281 
MsgEFg
 = 
MSGERROR
;

1284  
vue_f
;

1285 
	}
}

1288 
	gCModBusRTU
::
	$ModBusYxDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1290 if
modbuscf
.
SFg
 == 2 )

1292 
	`ModBusR_411YxYcDl

bufr
 , 
modbuscf
 );

1299 
	`ModBusYxBDl
(
bufr
,
modbuscf
);

1305 
	}
}

1307 
UINT
 
	gCModBusRTU
::
	$ModBusYXTempVue
(*
bufr
, 
pos
, 
MODBUSCONF
 
modbuscf
)

1309 
vue_i
 = 0;

1310 
vue_ui
 = 0;

1311 
vue_s
 = 0;

1312 
vue_us
 = 0;

1313 
BYTE
 
vue_b
;

1315 if(
modbuscf
.
da_n
 == 1)

1317 
vue_b
 = 
bufr
[
pos
] ;

1318  (
UINT
)
vue_b
;

1320 if(
modbuscf
.
da_n
 == 2)

1322 
vue_s
 = ()
	`TwoByVue
(
bufr
,
pos
,
modbuscf
);

1323 
	`memy
&
vue_us
 , &
vue_s
 , 2 );

1324  (
UINT
)
vue_us
;

1326 if(
modbuscf
.
da_n
 == 4)

1328 
vue_i
 = ()
	`FourByVue
(
bufr
,
pos
,
modbuscf
);

1329 
	`memy
&
vue_ui
 , &
vue_i
 , 4 );

1330  
vue_ui
;

1334 
MsgEFg
 = 
MSGERROR
;

1337 
	}
}

1340 
	gCModBusRTU
::
	$ModBusYxBDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1342 
WORD
 
i
 = 0;

1343 
WORD
 
j
 = 0;

1344 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1345 
UINT
 
mp_buf
 = 
bufr
[
pos
];

1346 
UINT
 
mp_mask
 = 
modbuscf
.
mask_code
;

1347 
WORD
 
g_num
 = 
modbuscf
.get_num;

1348 
WORD
 
t_num
 = 
modbuscf
.start_num;

1349 
BYTE
 
da_n
 = 
modbuscf
.data_len;

1350 
WORD
 
_g_num
 = 
bufr
[2] * 8;

1352 
WORD
 
num
 = 0;

1353 
WORD
 
wV
 = 0;

1354 
UINT
 
_mp_mask
 =0;

1356 if
modbuscf
.
SFg
 == 2 )

1358 
g_num
 = 25;

1361 if
_g_num
 < 
g_num
 )

1363 
g_num
 = 
_g_num
;

1366 
i
=0;i<((
_g_num
-1/ (8*
da_n
) )+1);i++)

1368  
da_n
 )

1371 
_mp_mask
 = 
	`ModBusYXTempVue
(*)&
mp_mask
 , 3 , 
modbuscf
 );

1374 
_mp_mask
 = 
	`ModBusYXTempVue
(*)&
mp_mask
 , 2 , 
modbuscf
 );

1377 
_mp_mask
 = 
	`ModBusYXTempVue
(*)&
mp_mask
 , 0 , 
modbuscf
 );

1380 
MsgEFg
 = 
MSGERROR
;

1384 
mp_buf
 = 
	`ModBusYXTempVue

bufr
 , 
pos
 , 
modbuscf
 );

1386 
pos
 +
da_n
;

1388 
j
=0;j<
da_n
*8;j++)

1390 if
num
 >
modbuscf
.
g_num
 )

1394 if(
_mp_mask
%2)

1396 
wV
 = 
mp_buf
%2;

1398 
m_pMhod
->
	`SYxDa
 ( 
m_SlNo
 , 
num
+
t_num
 , 
wV
 );

1402 
num
++;

1404 
_mp_mask
 /= 2;

1405 
mp_buf
 /= 2;

1408 
	}
}

1410 
	gCModBusRTU
::
	$ModBusYxByDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1411 {
	}
}

1413 
	gCModBusRTU
::
	$ModBusR_411YxYcDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1415 
BYTE
 
Fun

bufr
[1];

1416  
Fun
 )

1419 
	`ModBusYxBDl

bufr
 , 
modbuscf
 );

1420 
ESL411SOEFg
 = ( 
bufr
[5] & 0x04 )/4 ;

1423 
	`ModBusYcDl

bufr
 , 
modbuscf
 );

1426 
	`ModBusE_411SDl

bufr
 , 
modbuscf
 );

1431 
	}
}

1434 
	gCModBusRTU
::
	$ModBusYcDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1436 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1437 
WORD
 
g_num
 = 
modbuscf
.get_num;

1438 
WORD
 
t_num
 = 
modbuscf
.start_num;

1439 
WORD
 
_g_num
 = 
bufr
[2] / 
modbuscf
.
da_n
;

1441 
WORD
 
i
 = 0;

1442 
wV
 = 0 ;

1443 
i
=0;i<
g_num
;i++)

1445 
wV
 = 0 ;

1446 if
i
 < 
_g_num
 )

1447 
wV
 = 
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1448 if
MsgEFg
 =
MSGERROR
 )

1452 
pos
 +
modbuscf
.
da_n
;

1453 
m_pMhod
->
	`SYcDa

m_SlNo
 , 
i
+
t_num
 , 
wV
 );

1458 
	}
}

1460 
	gCModBusRTU
::
	$ModBusJ05YkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
 )

1462 
m_pMhod
->
	`SYkExeR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
YkNo
 , 
YkV
 );

1466 
	}
}

1469 
	gCModBusRTU
::
	$ModBusRtuYkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
 )

1471 
WORD
 
i
 = 0;

1472 
BYTE
 
ykV
= 2;

1473 
BYTE
 
pos
 = 
modbuscf
.
skew_by
 ;

1474 
UINT
 
g_num
 = 
modbuscf
.get_num;

1475 
UINT
 
t_num
 = 
modbuscf
.start_num;

1476 
UINT
 
gie
 = 
modbuscf
.registe;

1478 
cv_buf
[
g_num
];

1479 
	`memt
(
cv_buf
,0,
g_num
);

1481 
yk_ag
 = 0;

1483 
i
=0;i<
g_num
;i++)

1485 
cv_buf
[
i
] = ()
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1486 if
MsgEFg
 =
MSGERROR
 )

1490 
pos
 +
modbuscf
.
da_n
;

1493 if
gie
 + 
YkNo
 - 
t_num
 ) =
cv_buf
[0] )

1495 if
modbuscf
.
YkClo
 =
cv_buf
[1] )

1496 
ykV
 = 1;

1497 if
modbuscf
.
YkOn
 =
cv_buf
[1] )

1498 
ykV
 = 0;

1499 
m_pMhod
->
	`SYkExeR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
YkNo
 , 
ykV
 );

1504 
	}
}

1506 
	gCModBusRTU
::
	$ModBusYkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
 )

1508  
modbuscf
.
YkExFg
 )

1511 
	`ModBusRtuYkDl

bufr
 , 
modbuscf
 );

1514 
	`ModBusJ05YkDl

bufr
 , 
modbuscf
 );

1517 
MsgEFg
 = 
MSGERROR
;

1520 
	}
}

1523 
	gCModBusRTU
::
	$ModBusYmDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1525 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1526 
WORD
 
g_num
 = 
modbuscf
.get_num;

1527 
WORD
 
t_num
 = 
modbuscf
.start_num;

1528 
WORD
 
_g_num
 = 
bufr
[2] / 
modbuscf
.
da_n
;

1530 
WORD
 
i
 = 0;

1531 
wV
 = 0 ;

1533 
i
=0;i<
g_num
;i++)

1535 
wV
 = 0;

1536 if
i
 < 
_g_num
 )

1537 
wV
 = 
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1538 if
MsgEFg
 =
MSGERROR
 )

1542 
pos
 +
modbuscf
.
da_n
;

1543 
m_pMhod
->
	`SYmDa
 ( 
m_SlNo
, 
i
+
t_num
, 
wV
 );

1548 
	}
}

1551 
	gCModBusRTU
::
	$ModBusSTime
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1553 
BYTE
 
pos
 = 
modbuscf
.
skew_by
 ;

1554 
WORD
 
g_num
 = 
modbuscf
.get_num;

1558 
cv_buf
[
g_num
];

1559 
	`memt
(
cv_buf
,0,
g_num
);

1561 
WORD
 
i
 = 0;

1563 
i
=0;i<
g_num
;i++)

1565 
cv_buf
[
i
] = ()
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1566 
pos
 +
modbuscf
.
da_n
;

1572 
	}
}

1574 
	gCModBusRTU
::
	$ModBusRtuSDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1576 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1578 
i
 = 0;

1579 
BYTE
 
sag
 = 0;

1580 
TIMEDATA
 
mDa
;

1582 
i
=1;i<
bufr
[
pos
-1];i+=8)

1584 if0x0 =
bufr
[
i
+
pos
] & 0xc0 ) )

1586 
sag
 = 1;

1588 if0xc0 =
bufr
[
i
+
pos
] & 0xc0 ) )

1590 
sag
 = 0;

1597 
mDa
.
MiSec
(
bufr
[
i
+
pos
+6] & 0xc0) << 2 ) | buffer[i+pos+7];

1598 
mDa
.
Secd

bufr
[
i
+
pos
+6] & 0x3f;

1599 
mDa
.
Mu

bufr
[
i
+
pos
+5];

1600 
mDa
.
Hour
 = 
bufr
[
i
+
pos
+4];

1601 
mDa
.
Day
 = 
bufr
[
i
+
pos
+3];

1602 
mDa
.
Mth
 = 
bufr
[
i
+
pos
+2];

1603 
mDa
.
Yr
 = 
bufr
[
i
+
pos
+1];

1605 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
bufr
[
i
+
pos
] & 0x3f, 
sag
, &
mDa
 );

1612 
	}
}

1614 
	gCModBusRTU
::
	$ModBusYZ202SDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1616 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1619 
WORD
 
wP
 = 0;

1620 
BYTE
 
sag
 = 0;

1621 
TIMEDATA
 
mDa
;

1623 if
bufr
[
pos
+1] & 0x02 ) == 0x02 )

1624 
sag
 = 1;

1625 if
bufr
[
pos
+1] & 0x02 ) == 0x00 )

1626 
sag
 = 0;

1628  
bufr
[
pos
] )

1630 4:
wP
 = 0;;

1631 8:
wP
 = 1;;

1632 9:
wP
 = 2;;

1634 
sag
 = 1;

1635  
bufr
[
pos
+10] )

1637 0x00:
wP
 = 3;;

1638 0x01:
wP
 = 4;;

1639 0x02:
wP
 = 5;;

1640 0x03:
wP
 = 6;;

1642  
bufr
[
pos
+11] )

1644 0x33:
wP
 = 7;
sag
 = 0;;

1645 0x55:
wP
 = 7;;

1647 
MsgEFg
 = 
MSGERROR
;

1652  
bufr
[
pos
+11] )

1654 0x33:
wP
 = 8;
sag
 = 0;;

1655 0x55:
wP
 = 8;;

1657 
MsgEFg
 = 
MSGERROR
;

1662 
MsgEFg
 = 
MSGERROR
;

1666 17:
wP
 = 9;;

1667 18:
wP
 = 10;;

1668 19:
wP
 = 11;;

1669 21:
wP
 = 12;;

1670 22:
wP
 = 13;;

1671 23:
wP
 = 14;;

1672 24:
wP
 = 15;;

1673 25:
wP
 = 16;;

1674 26:
wP
 = 17;;

1675 27:
wP
 = 18;;

1676 28:
wP
 = 19;;

1677 31:
wP
 = 20;;

1678 35:
wP
 = 21;;

1679 37:
wP
 = 22;;

1680 38:
wP
 = 23;;

1681 39:
wP
 = 24;;

1682 42:
wP
 = 25;;

1684 
MsgEFg
 = 
MSGERROR
;

1690 
mDa
.
MiSec

bufr
[
pos
+8] | (buffer[pos+9] << 8);

1691 
mDa
.
Secd

bufr
[
pos
+7];

1692 
mDa
.
Mu

bufr
[
pos
+6];

1693 
mDa
.
Hour
 = 
bufr
[
pos
+5];

1694 
mDa
.
Day
 = 
bufr
[
pos
+4];

1695 
mDa
.
Mth
 = 
bufr
[
pos
+3];

1696 
mDa
.
Yr
 = 
bufr
[
pos
+2];

1698 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
wP
, 
sag
, &
mDa
 );

1705 
	}
}

1707 
	gCModBusRTU
::
	$ModBusE_411SDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1709 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1710 
WORD
 
wP
 = 0;

1711 
BYTE
 
sag
 = 0;

1712 
BYTE
 
SAribu
 = 0;

1713 
BYTE
 
dex
 = 0;

1714 
TIMEDATA
 
mDa
;

1716 if
bufr
[
pos
-1] == 0 )

1718 
ESL411SOEFg
 = 0;

1721 if
bufr
[
pos
-1] == 0x0f )

1723 
ESL411SOEFg
 = 1;

1727 
mDa
.
MiSec

bufr
[
pos
+1] | (buffer[pos] << 8);

1728 
mDa
.
Secd

bufr
[
pos
+2];

1729 
mDa
.
Mu

bufr
[
pos
+3];

1730 
mDa
.
Hour
 = 
bufr
[
pos
+4];

1731 
mDa
.
Day
 = 
bufr
[
pos
+5];

1732 
mDa
.
Mth
 = 
bufr
[
pos
+6];

1733 
mDa
.
Yr
 = 
bufr
[
pos
+7];

1735 
SAribu
 = 
bufr
[
pos
+8];

1736 
dex
 = 
bufr
[
pos
+9];

1737 if
dex
 > 31 )

1740  
SAribu
 )

1743 
wP
 = 
dex
;

1746 
wP
 = 
dex
 + 32;

1749 
wP
 = 
dex
 + 64;

1755  
bufr
[
pos
+10] )

1758 
sag
 = 1;

1761 
sag
 = 0;

1767 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
wP
, 
sag
, &
mDa
 );

1768 
buf
[100] = "";

1769 
	`rtf
(
buf
,"SOE m_byLineNo:%d m_wDevAddr%dum:%d val:%dime:%d.%d.%d-%d:%d:%d.%d\n",

1770 
m_byLeNo
, 
m_wDevAddr
 , 
wP
 , 
sag
 ,

1771 
mDa
.
Yr
,mDa.
Mth
,mDa.
Day
,mDa.
Hour
,mDa.
Mu
,mDa.
Secd
,mDa.
MiSec
);

1772 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
buf
, 
	`
(buf),3);

1774 
	}
}

1777 
	gCModBusRTU
::
	$ModBusSDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1779  
modbuscf
.
SFg
 )

1782 
	`ModBusRtuSDl

bufr
 , 
modbuscf
 );

1785 
	`ModBusYZ202SDl

bufr
 , 
modbuscf
 );

1788 
MsgEFg
 = 
MSGERROR
;

1791 
	}
}

1793 
	gCModBusRTU
::
	$ModBusRdV
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1795 
pos
 = 
modbuscf
.
skew_by
;

1796 
g_num
 = 
modbuscf
.get_num;

1797 
i
 = 0;

1799 
i
=0;i<
g_num
;i++)

1803 
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1805 
pos
 +
modbuscf
.
da_n
;

1808 
	}
}

1810 
	gCModBusRTU
::
	$ModBusWreV
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1812 
pos
 = 
modbuscf
.
skew_by
;

1813 
g_num
 = 
modbuscf
.get_num;

1817 
cv_buf
[
g_num
];

1818 
	`memt
(
cv_buf
,0,
g_num
);

1820 
i
 = 0;

1822 
i
=0;i<
modbuscf
.
g_num
;i++)

1824 
cv_buf
[
i
] = ()
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1825 
pos
 +
modbuscf
.
da_n
;

1832 
	}
}

1834 
BOOL
 
	gCModBusRTU
::
	$GDevCommS
( )

1836 if(
m_byPtStus
 =
COMSTATUS_ONLINE
)

1838  
COM_DEV_NORMAL
 ;

1842  
COM_DEV_ABNORMAL
 ;

1844 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/ModBusRTU.h

5 #i!
defed
(
AFX_MODBUSRTU_H__B73038B4_D223_4CF3_BB34_5F1A02A9777E__INCLUDED_
)

6 
	#AFX_MODBUSRTU_H__B73038B4_D223_4CF3_BB34_5F1A02A9777E__INCLUDED_


	)

7 
	#MSGERROR
 (1)

	)

8 
	#MSGTRUE
 (0)

	)

11 #i
_MSC_VER
 > 1000

12 #agm



14 
	~<sys/time.h
>

15 
	~"CProc_ModBus.h
"

16 
	~"../../she/rdbFun.h
"

17 
	~"../../she/gDaTy.h
"

20 
	~<ve
>

21 
usg
 
mea
 
	gd
;

23 #agm
ck
(1)

27 
BYTE
 
	mty
;

28 
BYTE
 
	mfunc
;

29 
WORD
 
	mgie
;

30 
WORD
 
	mgie_num
;

31 
BYTE
 
	mskew_by
;

32 
WORD
 
	mg_num
;

33 
WORD
 
	mt_num
;

34 
BYTE
 
	mda_n
;

35 
UINT
 
	mmask_code
;

36 
BYTE
 
	mda_fm
;

37 
BYTE
 
	msign
;

38 
BYTE
 
	myk_fm
;

39 
BYTE
 
	mc_ag
;

40 
WORD
 
	mYkClo
;

41 
WORD
 
	mYkOn
;

42 
BYTE
 
	mSTimeFg
;

43 
BYTE
 
	mSFg
;

44 
BYTE
 
	mYkSFg
;

45 
BYTE
 
	mYkExFg
;

46 }
	tMODBUSCONF
;

50 
BYTE
 
	mpos
;

51 
WORD
 
	mt_num
;

52 
WORD
 
	mg_num
;

53 }
	tINFO
;

55 as
	cCModBusRTU
 : 
public
 
CProc_ModBus


57 
public
:

58 
CModBusRTU
();

59 
	mvtu
 ~
CModBusRTU
();

61 
	me_buf
[2][128];

62 
	mpos_ag
;

63 
	mle
;

64 
	myk_ag
;

65 
	madv_ag
;

66 
	mwrev_ag
;

67 
	mv_ag
;

68 
	mpos
;

69 
	mime_pos
;

70 
	myk_pos_num
;

71 
	madv_pos_num
;

72 
	mwrev_pos_num
;

73 
	mϡ_ime
;

74 
	mm_wETim
;

75 
	mm_byPtStus
;

76 
	mtimeag
;

77 
BYTE
 
	mbySrcBusNo
;

78 
WORD
 
	mwSrcDevAddr
;

79 
	mYkNo
;

80 
BYTE
 
	mYkV
;

81 
BYTE
 
	mYkBuf
[256];

82 
	mYkL
;

83 
BYTE
 
	mMsgEFg
;

84 
BYTE
 
	mMsgRegieAndDa
[4];

86 
BYTE
 
	mESL411SOEFg
;

87 
BOOL
 
	mDevCFg
;

90 
CSemObj
 
	mm_hSem
;

92 
	mve
 < 
	mINFO
 > 
	myk_fo
;

95 
	mve
 < 
	mMODBUSCONF
 > 
	mmodbus_cf
;

97 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

98 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

99 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

100 
BOOL
 
GYKBufr

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 );

101 
vtu
 
TimProc
();

103 
DeuVCfig
(
MODBUSCONF
 * 
mc
);

105 
Atoh
(*
buf
);

108 
RdCf
(*
fame
);

110 
TimePackMcBigEdn
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
,
tm
 *
p
,
WORD
 
mc
);

112 
TimePackMcLeEdn
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
,
tm
 *
p
,
WORD
 
mc
);

114 
SysLolTime
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
);

117 
SdBuf

MODBUSCONF
 
modbuscf
 , 
BYTE
 * 
buf
 ,*
n
);

120 
YkPtSdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
 );

123 
YkJ05SdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
);

126 
YkSdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
);

129 
RdvSdBuf

MODBUSCONF
 
modbuscf
 , 
BYTE
 * 
buf
 ,*
n
 );

132 
WrevSdBuf

MODBUSCONF
 
modbuscf
 , * 
v
 , 
BYTE
 * 
buf
 ,*
n
 );

135 
E411SSdBuf
(
BYTE
 * 
buf
 ,*
n
);

137 
TwoByVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
);

139 
FourByVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
);

141 
FltVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
);

144 
ModBusVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
);

147 
ModBusYxDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

150 
UINT
 
ModBusYXTempVue
(*
bufr
, 
pos
, 
MODBUSCONF
 
modbuscf
);

153 
ModBusYxBDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

156 
ModBusYxByDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

158 
ModBusR_411YxYcDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

161 
ModBusYcDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

164 
ModBusJ05YkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

166 
ModBusRtuYkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

168 
ModBusYkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

171 
ModBusYmDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

174 
ModBusSTime
(*
bufr
,
MODBUSCONF
 
modbuscf
);

177 
ModBusRtuSDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

180 
ModBusYZ202SDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

184 
ModBusE_411SDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

187 
ModBusSDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

190 
ModBusRdV
(*
bufr
,
MODBUSCONF
 
modbuscf
);

193 
ModBusWreV
(*
bufr
,
MODBUSCONF
 
modbuscf
);

196 
RecvBuf
(
MODBUSCONF
 
modbuscf
);

199 
BOOL
 
YK_MsgPss

YK_DATA
 * 
pYkDa
 ) ;

202 
vtu
 
BOOL
 
GDevCommS
( ) ;

205 #agm
ck
( )

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_ModBus.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

12 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

14 
CProc
 * 
pProc
 = 
NULL
 ;

15 
pProc
 = 
w
 
CProc_ModBus
 ;

16 if
pProc
 )

18 
pProc
->
m_pMhod
 = 
pMhod
 ;

22  
pProc
 ;

23 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/CProtocol_ModBusMaster.cpp

1 
	~"CProc_ModBusMa.h
"

2 
	~"ModBusWKgyi.h
"

3 
	~"ModBusCڌ.h
"

4 
	~"ModBusEPS.h
"

5 
	~"ModBusDSE7320FDJ.h
"

6 
	~"ModBusXoDnLiu.h
"

7 
	~"ModBusXoHuMCU.h
"

8 
	~"ModBusLekuThmom.h
"

10 
	~"PMC_530.h
"

11 
	~"ModBusSD96E3.h
"

14 
	#MODULE_CONTROL
 1

15 
	#MODULE_WENKONGYI
 2

	)

16 
	#MODULE_EPS
 3

	)

17 
	#MODULE_DSE7320FDJ
 4

	)

18 
	#MODULE_XDL
 5

	)

19 
	#MODULE_XHMCU
 6

	)

20 
	#MODULE_LEKUTHERMOMETER
 7

	)

22 cڡ 
	g_PMC_530
 = 8;

23 
	#MODULE_SD96E3
 9

	)

28 
	gAuchCRCHi
[256] = {

57 
	gAuchCRCLo
[256] = {

86 
	gCProc_ModBusMa
::
	$CProc_ModBusMa
()

89 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

91 
	}
}

93 
	gCProc_ModBusMa
::~
	$CProc_ModBusMa
()

96 
size
 = 
m_modu
.
	`size
() ;

97  
i
 = 0 ; i < 
size
 ; i++ )

99 
de
 
m_modu
[ 
i
 ] ;

101 
m_modu
.
	`r
() ;

102 
	`tf
( "Delete All CProtocol_ModBus OK . \n" );

103 
	}
}

105 
BOOL
 
	gCProc_ModBusMa
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

107  
FALSE
 ;

108 
	}
}

110 
BOOL
 
	gCProc_ModBusMa
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

112  
FALSE
 ;

113 
	}
}

115 
BOOL
 
	gCProc_ModBusMa
::
	$In

BYTE
 
byLeNo
 )

119 
m_byLeNo
 = 
byLeNo
 ;

121 
m_ProTy
 = 
PROTOCO_GATHER
 ;

123  
	`GDevDa
( ) ;

124 
	}
}

126 
BOOL
 
	gCProc_ModBusMa
::
	$GDevDa
( )

128 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

129 
	`rtf

m_sDevPh
 , "%s/ModBusMa/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

130 
CProfe
 
	`ofe

m_sDevPh
 ) ;

132  
	`ProssFeDa

ofe
 ) ;

133 
	}
}

135 
BOOL
 
	gCProc_ModBusMa
::
	$ProssFeDa

CProfe
 &
ofe
 )

137 
BOOL
 
bR
 = 
FALSE
;

138 if!
ofe
.
	`IsVid
() )

140 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

141  
FALSE
 ;

144 
sSe
[ 200 ] = "DEVNUM" ;

145 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

147 
WORD
 
wModu
 = 0 ;

148 
ro
=1 ;

149 
WORD
 
addr
 =3 ;

150 
sName
[ 50 ] = { 0 };

151 
eme
[ 200 ] = { 0 };

152 
iNum
 = 0 ;

154 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

155 if
iNum
 == 0 )

157 
	`tf
( "Get DEVNUM Failed ! \n " );

158  
FALSE
 ;

161  
i
 = 0 ; i < 
iNum
 ; i++ )

163 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

165 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

166 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

167 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

168 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

169 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

172 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

173 i!
bR
 )

175 
	`tf
 ( "CModBuModu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

177  
FALSE
;

181  
TRUE
 ;

182 
	}
}

184 
BOOL
 
	gCProc_ModBusMa
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

186 
CProc_ModBusMa
 * 
pProc
 = 
NULL
 ;

188  
iModu
 )

190 
MODULE_CONTROL
:

192 
pProc
 = 
w
 
CModBusCڌ
;

193 
pProc
->
m_byLeNo
 = m_byLineNo ;

194 
pProc
->
m_wModuTy
 = 
iModu
 ;

195 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

196 
pProc
->
m_SlNo
 = 
iSlNo
 ;

198 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

199 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

200 
pProc
->
m_pMhod
 = m_pMethod ;

201 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

203 if!
pProc
->
	`In

m_byLeNo
 ) )

204  
FALSE
 ;

205 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

209 
MODULE_WENKONGYI
:

211 
pProc
 = 
w
 
CModbusWKgYi
;

212 
pProc
->
m_byLeNo
 = m_byLineNo ;

213 
pProc
->
m_wModuTy
 = 
iModu
 ;

214 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

215 
pProc
->
m_SlNo
 = 
iSlNo
 ;

217 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

218 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

219 
pProc
->
m_pMhod
 = m_pMethod ;

220 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

222 if!
pProc
->
	`In

m_byLeNo
 ) )

223  
FALSE
 ;

224 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

228 
MODULE_EPS
:

230 
pProc
 = 
w
 
CModbusEPS
;

231 
pProc
->
m_byLeNo
 = m_byLineNo ;

232 
pProc
->
m_wModuTy
 = 
iModu
 ;

233 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

234 
pProc
->
m_SlNo
 = 
iSlNo
 ;

236 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

237 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

238 
pProc
->
m_pMhod
 = m_pMethod ;

239 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

241 if!
pProc
->
	`In

m_byLeNo
 ) )

242  
FALSE
 ;

243 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

247 
MODULE_DSE7320FDJ
:

248 
pProc
 = 
w
 
CModbusDSE7320FDJ
;

249 
pProc
->
m_byLeNo
 = m_byLineNo ;

250 
pProc
->
m_wModuTy
 = 
iModu
 ;

251 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

252 
pProc
->
m_SlNo
 = 
iSlNo
 ;

254 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

255 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

256 
pProc
->
m_pMhod
 = m_pMethod ;

257 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

259 if!
pProc
->
	`In

m_byLeNo
 ) )

260  
FALSE
 ;

261 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

264 
MODULE_XDL
:

265 
pProc
 = 
w
 
CModBusXDL
;

266 
pProc
->
m_byLeNo
 = m_byLineNo ;

267 
pProc
->
m_wModuTy
 = 
iModu
 ;

268 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

269 
pProc
->
m_SlNo
 = 
iSlNo
 ;

271 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

272 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

273 
pProc
->
m_pMhod
 = m_pMethod ;

274 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

276 if!
pProc
->
	`In

m_byLeNo
 ) )

277  
FALSE
 ;

278 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

281 
MODULE_XHMCU
:

282 
pProc
 = 
w
 
CModBusXHMCU
;

283 
pProc
->
m_byLeNo
 = m_byLineNo ;

284 
pProc
->
m_wModuTy
 = 
iModu
 ;

285 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

286 
pProc
->
m_SlNo
 = 
iSlNo
 ;

288 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

289 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

290 
pProc
->
m_pMhod
 = m_pMethod ;

291 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

293 if!
pProc
->
	`In

m_byLeNo
 ) )

294  
FALSE
 ;

295 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

298 
MODULE_LEKUTHERMOMETER
:

299 
pProc
 = 
w
 
ModBusLekuThmom
;

300 
pProc
->
m_byLeNo
 = m_byLineNo ;

301 
pProc
->
m_wModuTy
 = 
iModu
 ;

302 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

303 
pProc
->
m_SlNo
 = 
iSlNo
 ;

305 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

306 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

307 
pProc
->
m_pMhod
 = m_pMethod ;

308 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

310 if!
pProc
->
	`In

m_byLeNo
 ) )

311  
FALSE
 ;

312 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

315 
_PMC_530
:

316 
pProc
 = 
w
 
PMC_530
;

317 
pProc
->
m_byLeNo
 = m_byLineNo ;

318 
pProc
->
m_wModuTy
 = 
iModu
 ;

319 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

320 
pProc
->
m_SlNo
 = 
iSlNo
 ;

322 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

323 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

324 
pProc
->
m_pMhod
 = m_pMethod ;

325 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

327 if!
pProc
->
	`In

m_byLeNo
 ) )

328  
FALSE
 ;

329 
	`tf
"- Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

332 
MODULE_SD96E3
:

334 
pProc
 = 
w
 
CModBusSD96E3
;

335 
pProc
->
m_byLeNo
 = m_byLineNo ;

336 
pProc
->
m_wModuTy
 = 
iModu
 ;

337 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

338 
pProc
->
m_SlNo
 = 
iSlNo
 ;

340 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

341 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

342 
pProc
->
m_pMhod
 = m_pMethod ;

343 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

345 if!
pProc
->
	`In

m_byLeNo
 ) )

346  
FALSE
 ;

347 
	`tf
" Add bu%d Add%d s%d MODULE_SD96E3\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

353 
	`tf
( "ModBus don't containhis module Failed .\n" );

354  
FALSE
 ;

357 
m_modu
.
	`push_back

pProc
 ) ;

359  
TRUE
 ;

360 
	}
}

362 
WORD
 
	gCProc_ModBusMa
::
	$GCrc

BYTE
 * 
pBuf
 , 
n
 )

364 
uchCRCHi
 = 0xFF;

365 
uchCRCLo
 = 0xFF;

366 
uIndex
;

368  
n
-- )

370 
uIndex
 = 
uchCRCHi
 ^ *
pBuf
++ ;

371 
uchCRCHi
 = 
uchCRCLo
 ^ 
AuchCRCHi
[
uIndex
];

372 
uchCRCLo
 = 
AuchCRCLo
[
uIndex
] ;

374  (
uchCRCHi
 << 8 | 
uchCRCLo
) ;

375 
	}
}

377 
BOOL
 
	gCProc_ModBusMa
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

380 
dex
 = 0 ;

381 
buf
[ 
dex
++ ] = 0xFF ;

382 
buf
[ 
dex
++ ] = 0x02 ;

383 
buf
[ 
dex
++ ] = 0x03 ;

384 
buf
[ 
dex
++ ] = 0x04 ;

386 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

387 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

388 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

390 
n
 = 
dex
 ;

392 
	`tf
( "\n CProtocol_ModBus TestBroadCast \n " ) ;

393  
TRUE
 ;

394 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/CProtocol_ModBusMaster.h

1 #ide
CPROTOCOL_MODBUS_H


2 
	#CPROTOCOL_MODBUS_H


	)

4 
	~"../../she/CProc.h
"

5 
	~"../../she/CMhod.h
"

7 as
	cCProc_ModBusMa
 : 
public
 
CProc


9 
public
:

10 
CProc_ModBusMa
();

11 
	mvtu
 ~
CProc_ModBusMa
();

12 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

13 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

14 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

15 
vtu
 
WORD
 
GCrc

BYTE
 * 
pBuf
 , 
n
 );

16 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 ) ;

17 
vtu
 
	$TimProc
(){ ; }

18 
eed
:

19 
BOOL
 
	`GDevDa
( ) ;

20 
eed
:

21 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

22 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

24 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusControl.cpp

1 
	~"ModBusCڌ.h
"

2 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

3 
	#ERROR_CONST
 5

	)

4 
	#COMSTATUS_ONLINE
 1

	)

5 
	#COMSTATUS_FAULT
 0

	)

6 
	gCModBusCڌ
::
	$CModBusCڌ
()

8 
m_byPtStus
 = 0;

9 
m_wETim
 = 0;

10 
	}
}

12 
	gCModBusCڌ
::~
	$CModBusCڌ
()

15 
	}
}

17 
BOOL
 
CModBusCڌ
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

19 
m_wETim
++;

20 if
m_wETim
 > 60000 )

21 
m_wETim
 = 
ERROR_CONST
 + 1 ;

23 
n
 = 0;

24 
buf
[
n
++] = 
m_wDevAddr
;

25 
buf
[
n
++] = 0x01;

26 
buf
[
n
++] = 0x5D;

28 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
n
 );

29 
buf
[ 
n
++ ] = 
	`HIBYTE
(
wCRC
);

30 
buf
[ 
n
++ ] = 
	`LOBYTE
(
wCRC
);

32  
TRUE
;

33 
	}
}

35 
BOOL
 
	gCModBusCڌ
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

40 if
n
 >= 98 )

42 if
buf
[0] =
m_wDevAddr
 && buf[1] == 01 && buf[2] == 0x5d )

44 
WORD
 
wCRC
 = 
	`GCrc

buf
, 96 );

45 if
buf
[96]=
	`HIBYTE
(
wCRC
&& buf[97]=
	`LOBYTE
(wCRC) )

47 
	`DlRecvMsg

buf
 , 
n
 );

48 
m_wETim
 = 0 ;

49  
TRUE
 ;

55 
	`OutBusDebug

m_byLeNo
,(
BYTE
 *)"control msgrr", 100, 2 );

56  
FALSE
;

58 
buf
++;

59 
n
--;

61 
	}
}

63 
BOOL
 
	gCModBusCڌ
::
	$In

BYTE
 
byLeNo
 )

65  
TRUE
 ;

66 
	}
}

68 
BOOL
 
	gCModBusCڌ
::
	$DlRecvMsg

BYTE
 * 
buf
 , 
n
 )

71 
wYcV
;

72 
fYcV
;

73 
BYTE
 
YC_hmic
[36] ;

74 
YM
[2] ;

75 
BYTE
 
YX
[24] ;

76 
BYTE
 
i
 = 0;

78  
i
=0 ; i< 23 ; i++ )

81 if
buf
[2*
i
+4] & 0x80 )

83 
wYcV
 = (
buf
[2*
i
+3] | buf[2*i+4]<<8);

84 
fYcV
 = ~
wYcV
 + 1;

86 
fYcV
 = fYcVal * -1.0;

92 
fYcV
 = (
buf
[2*
i
+3] | buf[2*i+4]<<8);

95 
m_pMhod
->
	`SYcDa

m_SlNo
 , 
i
 , 
fYcV
 );

98  
i
=0 ; i< 36 ; i++ )

100 
YC_hmic
[
i
] = 
buf
[49+i];

101 
m_pMhod
->
	`SYcDa

m_SlNo
 , 
i
+23 , ()
YC_hmic
[i] );

104  
i
=0 ; i< 2 ; i++ )

106 
	`memy

YM
+
i
 , 
buf
+85+4*i , 4 );

107 
m_pMhod
->
	`SYmDa
 ( 
m_SlNo
, 
i
, 
YM
[i] );

110  
i
=0 ; i< 24 ; i++ )

112 
BYTE
 
b
 = (
i
%8);

113 
BYTE
 
yxby

buf
[93+
i
/8];

114  
b
-- )

116 
yxby
 /= 2;

118 
YX
[
i
] = 
yxby
%2;

119 
m_pMhod
->
	`SYxDa
 ( 
m_SlNo
 , 
i
 , 
YX
[i] );

124  
TRUE
;

125 
	}
}

127 
	gCModBusCڌ
::
	$TimProc
()

129 if
m_wETim
 > 
ERROR_CONST
 )

131 
m_byPtStus
 = 
COMSTATUS_FAULT
;

135 
m_byPtStus
 = 
COMSTATUS_ONLINE
;

138 
	}
}

140 
BOOL
 
	gCModBusCڌ
::
	$GDevCommS
( )

142 if(
m_byPtStus
 =
COMSTATUS_ONLINE
)

144  
COM_DEV_NORMAL
 ;

148  
COM_DEV_ABNORMAL
 ;

150 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusControl.h

1 #i!
defed
(
ModBusMa_
)

2 
	#ModBusMa_


	)

4 
	#ModBusMaMSGFALSE
 (1)

	)

5 
	#ModBusMaMSGTRUE
 (0)

	)

8 
	~"CProc_ModBusMa.h
"

10 as
	cCModBusCڌ
 : 
public
 
CProc_ModBusMa


12 
public
:

13 
CModBusCڌ
();

14 
	mvtu
 ~
CModBusCڌ
();

16 
BYTE
 
	mm_byPtStus
;

17 
	mm_wETim
;

19 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

20 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

21 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

23 
vtu
 
TimProc
() ;

25 
vtu
 
BOOL
 
GDevCommS
( ) ;

27 
BOOL
 
DlRecvMsg

BYTE
 * 
buf
 , 
n
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusDSE7320FDJ.cpp

19 
	~"ModBusDSE7320FDJ.h
"

20 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

22 
	$t

BYTE
 
byBusNo
, *
buf
 )

24 
	`OutBusDebug

byBusNo
, (
BYTE
 *)
buf
, 
	`
(buf) , 2);

25 
	}
}

33 
	gCModbusDSE7320FDJ
::
	$CModbusDSE7320FDJ
 ()

35 
m_bLkStus
 = 
FALSE
;

36 
m_bySdCou
 = 0;

37 
m_byRecvCou
 = 0;

38 
m_bySdPos
 = 0;

39 
m_byDaTy
 = 0;

40 
m_byYcDlFg
 = 0;

41 
m_byYxDlFg
 = 0;

42 
	}
}

51 
	gCModbusDSE7320FDJ
::~
	$CModbusDSE7320FDJ
 ()

53 
	}
}

65 
BOOL
 
CModbusDSE7320FDJ
::
	$GSdBuf
 ( 
BYTE
 *
buf
, &
n
 )

67 
n
 =0;

68 
BYTE
 
byRegiNum
 = 0;

69 
WORD
 
wSRegu
 = 0;

70 
m_byYcDlFg
 = 0;

71 
m_byYxDlFg
 = 0;

73 
buf
[
n
++] = 
m_wDevAddr
;

74 
buf
[
n
++] = 0x03;

76  
m_bySdPos
 )

79 
wSRegu
 = 1024;

80 
byRegiNum
 = 7;

81 
m_byYcDlFg
 = 1;

85 
wSRegu
 = 1032;

86 
byRegiNum
 = 26;

87 
m_byYcDlFg
 = 2;

91 
wSRegu
 = 1059;

92 
byRegiNum
 = 1;

93 
m_byYcDlFg
 = 3;

97 
wSRegu
 = 1060;

98 
byRegiNum
 = 12;

99 
m_byYcDlFg
 = 4;

103 
wSRegu
 = 1536;

104 
byRegiNum
 = 18;

105 
m_byYcDlFg
 = 5;

109 
wSRegu
 = 1554;

110 
byRegiNum
 = 4;

111 
m_byYcDlFg
 = 6;

115 
wSRegu
 = 39425;

116 
byRegiNum
 = 1;

117 
m_byYxDlFg
 = 1;

121 
wSRegu
 = 48648;

122 
byRegiNum
 = 4;

123 
m_byYxDlFg
 = 2;

127 
	`t

m_byLeNo
, (*)"sendposrr!!!" );

130 
buf
[
n
++] = 
	`HIBYTE

wSRegu
 );

131 
buf
[
n
++] = 
	`LOBYTE

wSRegu
 );

133 
buf
[
n
++] = 0x00;

134 
buf
[
n
++] = 
byRegiNum
;

136 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
n
 );

137 
buf
[ 
n
++ ] = 
	`HIBYTE
(
wCRC
);

138 
buf
[ 
n
++ ] = 
	`LOBYTE
(
wCRC
);

140  
TRUE
;

141 
	}
}

152 
BOOL
 
	gCModbusDSE7320FDJ
::
	$WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 )

154 
BYTE
 *
por
 = 
buf
;

155 
WORD
 
wCrc
;

156 
szBuf
[256];

157 
pos
 = 0;

159  
n
 >= 4 )

162 i*
por
 !
m_wDevAddr
 )

164 
	`rtf

szBuf
, "ModBusDSE7320FDJecvddcvAddr=%d LolAddr=%d\n", *
por
, 
m_wDevAddr
 );

165 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
( szBuf ), 2 );

166 
DEFAULT
;

170 i*
por
 + 1 ) != 0x03 )

172 
	`rtf

szBuf
, "ModBusDSE7320FDJecv funcodcv fuccode=%d\n", *
por
 + 1 ) );

173 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
( szBuf ), 2 );

174 
DEFAULT
;

178 if*
por
 + 2 ) > 
n
 - 3 )

180 
	`rtf

szBuf
, "ModBusDSE7320FDJecvecv=%d\n", *
por
 + 2 ) );

181 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
( szBuf ), 2 );

182 
DEFAULT
;

186 
wCrc
 = 
	`GCrc

por
, ( *(ointer + 2 ) + 3 ) );

187 if*
por
 + ( *po+ 2 ) + 3 ) ) !
	`HIBYTE
(
wCrc
)

188 || *
por
 + ( *po+ 2 ) + 4 ) ) !
	`LOBYTE
(
wCrc
))

190 
	`rtf

szBuf
, "ModBusDSE7320FDJecv crcrrecvcrc=%.2x%.2x,ocalcrc=%.2x%.2x\n",

191 *
por
 + ( *(ointer + 2 ) + 3 ) ), *(ointer + ( *(ointer + 2 ) + 4 ) ),

192 
	`HIBYTE
(
wCrc
), 
	`LOBYTE
(wCrc)) ;

193 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
( szBuf ), 2 );

194 
DEFAULT
;

197 
buf
 = bu+ 
pos
;

198 
n
 = *(
por
 + 2) + 5;

199  
TRUE
;

200 
DEFAULT
:

201 
por
 ++;

202 
n
 --;

203 
pos
 ++;

205  
FALSE
 ;

206 
	}
}

217 
BOOL
 
	gCModbusDSE7320FDJ
::
	$ProssYxBuf
 ( 
BYTE
 *
buf
, 
n
 )

219  
m_byYxDlFg
 )

223 if
n
 != 7 )

225 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"yxenrr", 20, 2 );

226  
FALSE
;

229 
WORD
 
wYxV
 = 
	`MAKEWORD

buf
[4], buf[3] );

230 
BYTE
 
byTmp
;

231  
i
=2; i>-1; i-- )

233 
byTmp
 = (
wYxV
 >> ((
i
+1) * 4)) & 0x0f;

234 
BYTE
 
byYxag
 = 0;

235 
szBuf
[256];

237  
byTmp
 )

240 
byYxag
 = 1;

244 
byYxag
 = 2;

248 
byYxag
 = 3;

252 
byYxag
 = 4;

256 
byYxag
 = 1;

260  
k
=0; k<4;k++ )

262 if
k
 =
byYxag
 - 1 )

264 
m_pMhod
->
	`SYxDa

m_SlNo
, 
i
*4+
k
, 1 );

265 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yx%d = 1", 
i
*4+
k
 );

269 
m_pMhod
->
	`SYxDa

m_SlNo
, 
i
*4+
k
, 0 );

270 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yx%d = 0", 
i
*4+
k
 );

272 
	`t

m_byLeNo
, 
szBuf
 );

280 if
n
 != 13 )

282 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"yxenrr", 20, 2 );

283  
FALSE
;

285 
WORD
 
wP
 = 12;

286  
i
=0; i<4; i++)

288 
szBuf
[256];

289 
WORD
 
wTmp
 = 
	`MAKEWORD

buf
[4+2*
i
], buf[3+2*i]);

290 if1 =
wTmp
 )

292 
m_pMhod
->
	`SYxDa

m_SlNo
, 
i
+
wP
, 1 );

293 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yx%d = 1", 
i
+
wP
 );

297 
m_pMhod
->
	`SYxDa

m_SlNo
, 
i
+
wP
, 0 );

298 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yx%d = 0", 
i
+
wP
 );

300 
	`t

m_byLeNo
, 
szBuf
 );

306 
	`t

m_byLeNo
, (*)"can't find ycdatatype" );

310  
TRUE
;

311 
	}
}

322 
BOOL
 
	gCModbusDSE7320FDJ
::
	$ProssYcBuf
 ( 
BYTE
 *
buf
, 
n
 )

324 
WORD
 
wP
;

325 
BYTE
 
byDaNum
;

326  
m_byYcDlFg
 )

329 if19 !
n
 )

331 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"ycenrr!!!", 20, 2 );

332  
FALSE
;

334 
wP
 = 0;

335 
byDaNum
 = 7;

336  
i
=0; i<
byDaNum
; i++ )

338 
WORD
 
wYcV
;

339 
fYcV
;

340 
wYcV
 = 
	`MAKEWORD

buf
[4+
i
*2] , buf[3+i*2] );

341 
fYcV
 = ()
wYcV
;

342 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
+
i
, 
fYcV
 );

343 
szBuf
[256];

344 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yc%d = %f", 
wP
+
i
, 
fYcV
 );

345 
	`t

m_byLeNo
, 
szBuf
 );

350 if57 !
n
 )

352 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"ycenrr!!!", 20, 2 );

353  
FALSE
;

355 
wP
 = 7;

356 
byDaNum
 = 13;

357  
i
=0; i<
byDaNum
; i++ )

359 
WORD
 
wHiYcV
;

360 
WORD
 
wLoYcV
;

361 
DWORD
 
dwYcV
;

362 
fYcV
;

363 
wHiYcV
 = 
	`MAKEWORD

buf
[4+
i
*4] , buf[3+i*4] );

364 
wLoYcV
 = 
	`MAKEWORD

buf
[6+
i
*4] , buf[5+i*4] );

365 
dwYcV
 = 
	`MAKELONG

wLoYcV
, 
wHiYcV
 );

366 
fYcV
 = ()
dwYcV
;

368 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
+
i
, 
fYcV
 );

369 
szBuf
[256];

370 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yc%d = %f", 
wP
+
i
, 
fYcV
 );

371 
	`t

m_byLeNo
, 
szBuf
 );

376 if7 !
n
 )

378 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"ycenrr!!!", 20, 2 );

379  
FALSE
;

381 
wP
 = 20;

382 
byDaNum
 = 1;

383  
i
=0; i<
byDaNum
; i++ )

385 
WORD
 
wYcV
;

386 
fYcV
;

387 
wYcV
 = 
	`MAKEWORD

buf
[4+
i
*2] , buf[3+i*2] );

388 
fYcV
 = ()
wYcV
;

389 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
+
i
, 
fYcV
 );

390 
szBuf
[256];

391 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yc%d = %f", 
wP
+
i
, 
fYcV
 );

392 
	`t

m_byLeNo
, 
szBuf
 );

397 if29 !
n
 )

399 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"ycenrr!!!", 20, 2 );

400  
FALSE
;

402 
wP
 = 21;

403 
byDaNum
 = 6;

404  
i
=0; i<
byDaNum
; i++ )

406 
WORD
 
wHiYcV
;

407 
WORD
 
wLoYcV
;

408 
DWORD
 
dwYcV
;

409 
fYcV
;

410 
wHiYcV
 = 
	`MAKEWORD

buf
[4+
i
*4] , buf[3+i*4] );

411 
wLoYcV
 = 
	`MAKEWORD

buf
[6+
i
*4] , buf[5+i*4] );

412 
dwYcV
 = 
	`MAKELONG

wLoYcV
, 
wHiYcV
 );

413 
fYcV
 = ()
dwYcV
;

415 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
+
i
, 
fYcV
 );

416 
szBuf
[256];

417 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yc%d = %f", 
wP
+
i
, 
fYcV
 );

418 
	`t

m_byLeNo
, 
szBuf
 );

423 if41 !
n
 )

425 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"ycenrr!!!", 20, 2 );

426  
FALSE
;

428 
wP
 = 27;

429 
byDaNum
 = 9;

430  
i
=0; i<
byDaNum
; i++ )

432 
WORD
 
wHiYcV
;

433 
WORD
 
wLoYcV
;

434 
DWORD
 
dwYcV
;

435 
fYcV
;

436 
wHiYcV
 = 
	`MAKEWORD

buf
[4+
i
*4] , buf[3+i*4] );

437 
wLoYcV
 = 
	`MAKEWORD

buf
[6+
i
*4] , buf[5+i*4] );

438 
dwYcV
 = 
	`MAKELONG

wLoYcV
, 
wHiYcV
 );

439 if
dwYcV
 & 0x80 )

441 
iYcV
 = ()
dwYcV
;

442 
fYcV
 = ~
iYcV
 + 1;

443 
fYcV
 *= -1.0;

447 
fYcV
 = ()
dwYcV
;

450 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
+
i
, 
fYcV
 );

451 
szBuf
[256];

452 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yc%d = %f", 
wP
+
i
, 
fYcV
 );

453 
	`t

m_byLeNo
, 
szBuf
 );

458 if13 !
n
 )

460 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"ycenrr!!!", 20, 2 );

461  
FALSE
;

463 
wP
 = 36;

464 
byDaNum
 = 4;

465  
i
=0; i<
byDaNum
; i++ )

467 
WORD
 
wYcV
;

468 
fYcV
;

469 
wYcV
 = 
	`MAKEWORD

buf
[4+
i
*2] , buf[3+i*2] );

470 
fYcV
 = ()
wYcV
;

471 
m_pMhod
->
	`SYcDa

m_SlNo
, 
wP
+
i
, 
fYcV
 );

472 
szBuf
[256];

473 
	`rtf

szBuf
, "CModbusDSE7320FDJ:yc%d = %f", 
wP
+
i
, 
fYcV
 );

474 
	`t

m_byLeNo
, 
szBuf
 );

479 
	`t

m_byLeNo
, (*)"can't find ycdatatype" );

482  
TRUE
;

483 
	}
}

495 
BOOL
 
	gCModbusDSE7320FDJ
::
	$ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 )

500 
	`GSdPos
( );

503 if
m_byYxDlFg
 > 0)

505  
	`ProssYxBuf

buf
, 
n
 );

507 if
m_byYcDlFg
 > 0 )

509  
	`ProssYcBuf

buf
, 
n
 );

512  
FALSE
;

513 
	}
}

525 
BYTE
 
	gCModbusDSE7320FDJ
::
	$GSdPos
 ( )

527  ( 
m_bySdPos
 % 
MODBUSMASTER_DSE7320FDJ_MAX_POS
 );

528 
	}
}

540 
	gCModbusDSE7320FDJ
::
	$ChgeSdPos
 ( )

542 
m_bySdPos
 = m_bySdPos++ % 
MODBUSMASTER_DSE7320FDJ_MAX_POS
;

544 if
m_bySdPos
 >
MODBUSMASTER_DSE7320FDJ_MAX_POS
 ) )

546 
m_bySdPos
 = 0;

549 
	}
}

561 
BOOL
 
	gCModbusDSE7320FDJ
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

563 if
pBusMsg
 !
NULL
 )

565  
FALSE
;

568 
	`ChgeSdPos
( );

570 
	`GSdBuf

buf
, 
n
 );

571 
m_bySdCou
 ++;

573  
TRUE
;

574 
	}
}

586 
BOOL
 
	gCModbusDSE7320FDJ
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

589 i!
	`WhhBufVue

buf
, 
n
 ) )

591 
szBuf
[256] = "";

592 
	`rtf

szBuf
, "%s", "ModBusDSE7320FDJecv bufrr !!!\n" );

593 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
( szBuf ), 2 );

595 
m_byRecvCou
 ++;

596  
FALSE
;

599 
	`ProssRecvBuf

buf
, 
n
 );

601 
m_bLkStus
 = 
TRUE
;

602 
m_bySdCou
 = 0;

603 
m_byRecvCou
 = 0;

605  
TRUE
;

606 
	}
}

617 
BOOL
 
	gCModbusDSE7320FDJ
::
	$In
 ( 
BYTE
 
byLeNo
 )

619  
TRUE
;

620 
	}
}

632 
	gCModbusDSE7320FDJ
::
	$TimProc
 ( )

634 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

636 
m_bySdCou
 = 0;

637 
m_byRecvCou
 = 0;

639 if
m_bLkStus
 )

641 
m_bLkStus
 = 
FALSE
;

642 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"CModbusDSE7320FDJ:unlink\n", 30, 2 );

645 
	}
}

657 
BOOL
 
	gCModbusDSE7320FDJ
::
	$GDevCommS
 ( )

659 i
m_bLkStus
 )

661  
COM_DEV_NORMAL
;

665  
COM_DEV_ABNORMAL
;

667 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusDSE7320FDJ.h

22 #ide 
MODBUSDSE7320FDJ_INC


23 
	#MODBUSDSE7320FDJ_INC


	)

26 
	~"CProc_ModBusMa.h
"

29 
	#MODBUSMASTER_DSE7320FDJ_MAX_POS
 8

	)

30 
	#MODBUSMASTER_DSE7320FDJ_YX_DATATYPE
 1

	)

31 
	#MODBUSMASTER_DSE7320FDJ_YC_DATATYPE
 2

	)

39 as
	cCModbusDSE7320FDJ
 : 
public
 
CProc_ModBusMa


41 
public
:

43 
CModbusDSE7320FDJ
 ();

44 ~
CModbusDSE7320FDJ
 ();

46 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

47 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

48 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

50 
vtu
 
TimProc
() ;

52 
vtu
 
BOOL
 
GDevCommS
( ) ;

54 
	meed
:

57 
ive
:

59 
BOOL
 
WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 );

61 
BOOL
 
ProssYxBuf

BYTE
 *
buf
, 
n
 );

63 
BOOL
 
ProssYcBuf

BYTE
 *
buf
, 
n
 );

65 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 );

68 
BOOL
 
GSdBuf

BYTE
 *
buf
, &
n
 );

70 
	mive
:

72 
ChgeSdPos
( );

74 
BYTE
 
GSdPos
( );

75 
	mive
:

77 
BOOL
 
m_bLkStus
;

78 
BYTE
 
	mm_bySdCou
;

79 
BYTE
 
	mm_byRecvCou
;

80 
BYTE
 
	mm_bySdPos
;

82 
BYTE
 
	mm_byDaTy
;

83 
BYTE
 
	mm_byYcDlFg
;

84 
BYTE
 
	mm_byYxDlFg
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusEPS.cpp

205 
	~<dio.h
>

207 
	~"ModBusEPS.h
"

208 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

218 
	gCModbusEPS
::
	$CModbusEPS
 ()

220 
m_bLkStus
 = 
FALSE
;

221 
m_bySdCou
 = 0;

222 
m_byRecvCou
 = 0;

223 
m_bySdPos
 = 0;

224 
	}
}

233 
	gCModbusEPS
::~
	$CModbusEPS
 ()

235 
	}
}

246 
BOOL
 
CModbusEPS
::
	$WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 )

248 
BYTE
 *
por
 = 
buf
;

249 
WORD
 
wCrc
;

250 
pos
 = 0;

252  
n
 >= 4 )

255 i*
por
 !
m_wDevAddr
 )

257 
DEFAULT
;

261 i*
por
 + 1 ) != 0x03 )

263 
DEFAULT
;

267 
wCrc
 = 
	`GCrc

por
, ( *(ointer + 2 ) + 3 ) );

268 if*
por
 + ( *po+ 2 ) + 3 ) ) !
	`HIBYTE
(
wCrc
)

269 || *
por
 + ( *po+ 2 ) + 4 ) ) !
	`LOBYTE
(
wCrc
))

271 
DEFAULT
;

274 
buf
 = bu+ 
pos
;

275 
n
 = *(
por
 + 2) + 5;

276  
TRUE
;

277 
DEFAULT
:

278 
por
 ++;

279 
n
 --;

280 
pos
 ++;

282  
FALSE
 ;

283 
	}
}

294 
BOOL
 
	gCModbusEPS
::
	$ProssYxBuf
 ( 
BYTE
 *
buf
, 
n
 )

296 
WORD
 
wP
 = 0;

297 
BYTE
 
byYxVue
 = 0;

298 
BYTE
 
byTemp
;

299 
i
;

300 
szBuf
[256];

303 
byTemp
 = 
buf
[5] & 0x0f;

304  
i
 = 0; i < 14; i++)

306 if
byTemp
 >= 14)

308 
	`rtf

szBuf
, "yx updpot=0 v=%d", 
byYxVue
 );

309 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

310 
m_pMhod
->
	`SYxDa

m_SlNo
, 0, 1 );

311 
wP
 ++;

314 if
byTemp
 =
i
 )

316 
byYxVue
 = 1;

320 
byYxVue
 = 0;

323 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

324 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

326 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

327 
wP
 ++;

330 
byTemp
 = ( 
buf
[5] >> 4 ) & 0x03;

331  
i
=0; i<4; i++)

333 if
byTemp
 >= 4)

335 
	`rtf

szBuf
, "yx updpot=14 v=%d", 
byYxVue
 );

336 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

337 
m_pMhod
->
	`SYxDa

m_SlNo
, 14, 1 );

338 
wP
 ++;

341 if
byTemp
 =
i
 )

343 
byYxVue
 = 1;

347 
byYxVue
 = 0;

350 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

351 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

353 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

354 
wP
 ++;

358 
byTemp
 = ( 
buf
[5] >> 6 ) & 0x03;

359  
i
=0; i<4; i++)

361 if
byTemp
 >= 4)

363 
	`rtf

szBuf
, "yx updpot=18 v=%d", 
byYxVue
 );

364 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

365 
m_pMhod
->
	`SYxDa

m_SlNo
, 18, 1 );

366 
wP
 ++;

369 if
byTemp
 =
i
 )

371 
byYxVue
 = 1;

375 
byYxVue
 = 0;

378 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

379 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

381 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

382 
wP
 ++;

387 
byTemp
 = 
buf
[6] & 0x03;

388  
i
=0; i<4; i++)

390 if
byTemp
 >= 4)

392 
	`rtf

szBuf
, "yx updpot=22 v=%d", 
byYxVue
 );

393 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

394 
m_pMhod
->
	`SYxDa

m_SlNo
, 22, 1 );

395 
wP
 ++;

398 if
byTemp
 =
i
 )

400 
byYxVue
 = 1;

404 
byYxVue
 = 0;

407 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

408 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

409 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

410 
wP
 ++;

414 
byTemp
 = (
buf
[6] >> 2) & 0x03;

415  
i
=0; i<4; i++)

417 if
byTemp
 >= 4)

419 
	`rtf

szBuf
, "yx updpot=26 v=%d", 
byYxVue
 );

420 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

421 
m_pMhod
->
	`SYxDa

m_SlNo
, 26, 1 );

422 
wP
 ++;

425 if
byTemp
 =
i
 )

427 
byYxVue
 = 1;

431 
byYxVue
 = 0;

434 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

435 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

436 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

437 
wP
 ++;

441 
byTemp
 = (
buf
[6] >> 4) & 0x03;

442  
i
=0; i<2; i++)

444 if
byTemp
 >= 2)

446 
	`rtf

szBuf
, "yx updateoint=30 val=1" );

447 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

448 
m_pMhod
->
	`SYxDa

m_SlNo
, 30, 1 );

449 
wP
 ++;

452 if
byTemp
 =
i
 )

454 
byYxVue
 = 1;

458 
byYxVue
 = 0;

461 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

462 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

463 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

464 
wP
 ++;

468 
byTemp
 = (
buf
[6] >> 6) & 0x03;

469  
i
=0; i<3; i++)

471 if
byTemp
 >= 3)

473 
	`rtf

szBuf
, "yx updpot=32 v=%d", 
byYxVue
 );

474 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

475 
m_pMhod
->
	`SYxDa

m_SlNo
, 32, 1 );

476 
wP
 ++;

479 if
byTemp
 =
i
 )

481 
byYxVue
 = 1;

485 
byYxVue
 = 0;

488 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

489 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

490 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

491 
wP
 ++;

496 
byTemp
 = ( 
buf
[3] ) & 0x03;

497  
i
=0; i<3; i++)

499 if
byTemp
 >= 3)

501 
	`rtf

szBuf
, "yx updpot=35 v=%d", 
byYxVue
 );

502 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

503 
m_pMhod
->
	`SYxDa

m_SlNo
, 35, 1 );

504 
wP
 ++;

507 if
byTemp
 =
i
 )

509 
byYxVue
 = 1;

513 
byYxVue
 = 0;

516 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

517 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

518 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

519 
wP
 ++;

523 
byTemp
 = (
buf
[3] >> 2) & 0x03;

524  
i
=0; i<2; i++)

526 if
byTemp
 >= 2)

528 
	`rtf

szBuf
, "yx updpot=38 v=%d", 
byYxVue
 );

529 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

530 
m_pMhod
->
	`SYxDa

m_SlNo
, 38, 1 );

531 
wP
 ++;

534 if
byTemp
 =
i
 )

536 
byYxVue
 = 1;

540 
byYxVue
 = 0;

543 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

544 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

545 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

546 
wP
 ++;

551  
i
=0; i<4; i++)

553 
byTemp
 = ( 
buf
[4] >> (4 + 
i
) ) ;

554 if
byTemp
 & 0x01 )

556 
byYxVue
 = 1;

560 
byYxVue
 = 0;

563 
	`rtf

szBuf
, "yx updpot=%d v=%d", 
wP
, 
byYxVue
 );

564 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

565 
m_pMhod
->
	`SYxDa

m_SlNo
, 
wP
, 
byYxVue
 );

566 
wP
 ++;

569  
TRUE
;

570 
	}
}

582 
BOOL
 
	gCModbusEPS
::
	$ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 )

584 
BYTE
 
byPos
;

586 if
n
 != 9 )

588  
FALSE
;

591 
byPos
 = 
	`GSdPos
( );

594 if0 =
byPos
)

597  
	`ProssYxBuf

buf
, 
n
 );

601 
WORD
 
wLWd
;

602 
WORD
 
wHWd
;

603 
DWORD
 
dwYcV
;

604 
fYcV
;

606 
wHWd
 = 
	`MAKEWORD

buf
[6], buf[5] );

607 
wLWd
 = 
	`MAKEWORD

buf
[4], buf[3] );

608 
dwYcV
 = 
	`MAKELONG

wLWd
, 
wHWd
 );

609 
fYcV
 = ()
dwYcV
;

610 
fYcV
 = fYcVal * 0.001;

612 if
fYcV
 > 100000 )

614  
TRUE
;

617 
szBuf
[256];

618 
	`rtf

szBuf
, "yupdpot=%d v=%f", 
byPos
-1, 
fYcV
 );

619 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
(szBuf), 2 );

621 
m_pMhod
->
	`SYcDa

m_SlNo
, 
byPos
-1, 
fYcV
 );

624  
TRUE
;

625 
	}
}

637 
BYTE
 
	gCModbusEPS
::
	$GSdPos
 ( )

639  ( 
m_bySdPos
 % 
MODBUSMASTER_EPS_MAX_POS
 );

640 
	}
}

652 
	gCModbusEPS
::
	$ChgeSdPos
 ( )

654 
m_bySdPos
 = m_bySdPos++ % 
MODBUSMASTER_EPS_MAX_POS
;

656 if
m_bySdPos
 >
MODBUSMASTER_EPS_MAX_POS
 ) )

658 
m_bySdPos
 = 0;

661 
	}
}

673 
BOOL
 
	gCModbusEPS
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

675 if
pBusMsg
 !
NULL
 )

677  
FALSE
;

680 
	`ChgeSdPos
( );

682 
n
 = 0;

684 
buf
[
n
++] = 
m_wDevAddr
;

685 
buf
[
n
++] = 0x03;

687 
buf
[
n
++] = 0x00;

688 
buf
[
n
++] = 
m_bySdPos
;

689 
buf
[
n
++] = 0x00;

690 
buf
[
n
++] = 0x04;

692 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
n
 );

693 
buf
[ 
n
++ ] = 
	`HIBYTE
(
wCRC
);

694 
buf
[ 
n
++ ] = 
	`LOBYTE
(
wCRC
);

696 
m_bySdCou
 ++;

698  
TRUE
;

699 
	}
}

711 
BOOL
 
	gCModbusEPS
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

713 i!
	`WhhBufVue

buf
, 
n
 ) )

715 
szBuf
[256] = "";

716 
	`rtf

szBuf
, "%s", "ModBusEPSecv bufrr !!!\n" );

717 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
( szBuf ), 2 );

719 
m_byRecvCou
 ++;

720  
FALSE
;

723 
	`ProssRecvBuf

buf
, 
n
 );

725 
m_bLkStus
 = 
TRUE
;

726 
m_bySdCou
 = 0;

727 
m_byRecvCou
 = 0;

729  
TRUE
;

730 
	}
}

741 
BOOL
 
	gCModbusEPS
::
	$In
 ( 
BYTE
 
byLeNo
 )

743  
TRUE
;

744 
	}
}

756 
	gCModbusEPS
::
	$TimProc
 ( )

758 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

760 
m_bySdCou
 = 0;

761 
m_byRecvCou
 = 0;

763 if
m_bLkStus
 )

765 
m_bLkStus
 = 
FALSE
;

766 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"CModbusEPS:unlink\n", 30, 2 );

769 
	}
}

781 
BOOL
 
	gCModbusEPS
::
	$GDevCommS
 ( )

783 i
m_bLkStus
 )

785  
COM_DEV_NORMAL
;

789  
COM_DEV_ABNORMAL
;

791 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusEPS.h

21 #ide 
MODBUSEPS_INC


22 
	#MODBUSEPS_INC


	)

24 
	~"CProc_ModBusMa.h
"

27 
	#MODBUSMASTER_EPS_MAX_POS
 30

	)

35 as
	cCModbusEPS
 : 
public
 
CProc_ModBusMa


37 
public
:

39 
CModbusEPS
 ();

40 ~
CModbusEPS
 ();

42 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

43 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

44 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

46 
vtu
 
TimProc
() ;

48 
vtu
 
BOOL
 
GDevCommS
( ) ;

50 
	meed
:

53 
ive
:

55 
BOOL
 
WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 );

57 
BOOL
 
ProssYxBuf

BYTE
 *
buf
, 
n
 );

59 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 );

61 
	mive
:

63 
ChgeSdPos
( );

65 
BYTE
 
GSdPos
( );

66 
	mive
:

68 
BOOL
 
m_bLkStus
;

69 
BYTE
 
	mm_bySdCou
;

70 
BYTE
 
	mm_byRecvCou
;

71 
BYTE
 
	mm_bySdPos
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusLekuThermometer.cpp

82 
	~"ModBusLekuThmom.h
"

83 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

93 
	gModBusLekuThmom
::
	$ModBusLekuThmom
 ()

95 
m_bLkStus
 = 
FALSE
;

96 
m_bySdCou
 = 0;

97 
m_byRecvCou
 = 0;

98 
	}
}

107 
	gModBusLekuThmom
::~
	$ModBusLekuThmom
 ()

109 
	}
}

120 
ModBusLekuThmom
::
	$t
 ( *
buf
 ) const

123 #ifde 
XHMCU_PRINT


124 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
buf
, 
	`
( buf ), 2 );

126 
	}
}

139 
BOOL
 
	gModBusLekuThmom
::
	$WhhBufVue
 ( 
BYTE
 *
buf
, &
n
, &
pos
 )

141 
BYTE
 *
por
 = 
buf
;

142 
pos
 = 0;

144  
n
 >= 17 )

147 if
m_wDevAddr
 !*
por


148 || 0x03 !*
por
 + 1 )

149 || 0x0!*
por
 + 2 ) )

151 
	`t
( (*)"ͷ" );

152 
por
 ++;

153 
n
 --;

154 
pos
 ++;

158 
WORD
 
wCRC
 = 
	`GCrc

buf
, buf[2] + 3 );

159 if
	`HIBYTE
(
wCRC
=
buf
[ buf[2] + 3 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ buf[2] + 4 ] ) )

161  
TRUE
;

165 
	`t
( (*)"Уδͨ" );

166 
por
 ++;

167 
n
 --;

168 
pos
 ++;

173 
	`t
( (*) "CModBusXHMCU WhetherBufValueot findight buf ");

175  
FALSE
 ;

176 
	}
}

188 
BOOL
 
	gModBusLekuThmom
::
	$ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 )

190 
BYTE
 
i
;

191 
BYTE
 
Temp_Yx
 = 
buf
[4];

192 
WORD
 
wV
;

193  
i
=0;i<8;i++ )

195 
wV
 = 
Temp_Yx
%2;

196 
m_pMhod
->
	`SYxDa
 ( 
m_SlNo
 , 
i
 , 
wV
 );

197 
Temp_Yx
 /= 2;

199  
i
=0;i<5;i++ )

201 
wV
 = (
buf
[5+(
i
*2)]<<8 | buf[6+(i*2)]);

202 
m_pMhod
->
	`SYcDa

m_SlNo
 , 
i
 , ()
wV
 );

205  
TRUE
;

206 
	}
}

218 
BOOL
 
	gModBusLekuThmom
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

220 if
pBusMsg
 !
NULL
 )

222  
FALSE
;

225 
n
 = 0;

228 
buf
[
n
++] = 
m_wDevAddr
;

229 
buf
[
n
++] = 0x03;

230 
buf
[
n
++] = 0x00;

231 
buf
[
n
++] = 0x00;

232 
buf
[
n
++] = 0x00;

233 
buf
[
n
++] = 0x06;

235 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
n
 );

236 
buf
[ 
n
++ ] = 
	`HIBYTE
(
wCRC
);

237 
buf
[ 
n
++ ] = 
	`LOBYTE
(
wCRC
);

238 
m_bySdCou
 ++;

240  
TRUE
;

241 
	}
}

253 
BOOL
 
	gModBusLekuThmom
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

255 
pos
 = 0;

256 i!
	`WhhBufVue

buf
, 
n
, 
pos
 ) )

258 
szBuf
[256] = "";

259 
	`rtf

szBuf
, "%s", "ModBusLekuThermometerecv bufrr !!!\n" );

260 
	`t

szBuf
 );

261 
m_byRecvCou
 ++;

262  
FALSE
;

265 
	`ProssRecvBuf

buf
 + 
pos
, 
n
 );

267 
m_bLkStus
 = 
TRUE
;

268 
m_bySdCou
 = 0;

269 
m_byRecvCou
 = 0;

271  
TRUE
;

272 
	}
}

283 
BOOL
 
	gModBusLekuThmom
::
	$In
 ( 
BYTE
 
byLeNo
 )

285  
TRUE
;

286 
	}
}

298 
	gModBusLekuThmom
::
	$TimProc
 ( )

300 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

302 
m_bySdCou
 = 0;

303 
m_byRecvCou
 = 0;

304 if
m_bLkStus
 )

306 
m_bLkStus
 = 
FALSE
;

307 
	`t
( (*) "CModBusXHMCU:unlink\n");

310 
	}
}

322 
BOOL
 
	gModBusLekuThmom
::
	$GDevCommS
 ( )

324 i
m_bLkStus
 )

326  
COM_DEV_NORMAL
;

330  
COM_DEV_ABNORMAL
;

332 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusLekuThermometer.h

23 #ide 
MODULE_LEKUTHERMOMETER_INC


24 
	#MODULE_LEKUTHERMOMETER_INC


	)

26 
	~"CProc_ModBusMa.h
"

34 as
	cModBusLekuThmom
 : 
public
 
CProc_ModBusMa


36 
public
:

38 
ModBusLekuThmom
 ();

39 ~
ModBusLekuThmom
 ();

41 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

42 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

43 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

45 
vtu
 
TimProc
() ;

47 
vtu
 
BOOL
 
GDevCommS
( ) ;

50 
	meed
:

53 
ive
:

55 
BOOL
 
WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 ,&
pos
);

57 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 );

59 
	$t
*
buf
 ) const;

60 
ive
:

62 
BOOL
 
m_bLkStus
;

63 
BYTE
 
m_bySdCou
;

64 
BYTE
 
m_byRecvCou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusLiuLiangJi.cpp

44 
	~"ModBusLiuLngJi.h
"

45 
	~<mh.h
>

47 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

57 
	gModBusLiuLngJi
::
	$ModBusLiuLngJi
 ()

59 
m_bLkStus
 = 
FALSE
;

60 
m_bySdCou
 = 0;

61 
m_byRecvCou
 = 0;

62 
	}
}

71 
	gModBusLiuLngJi
::~
	$ModBusLiuLngJi
 ()

73 
	}
}

84 
ModBusLiuLngJi
::
	$t
 ( *
buf
 ) const

87 #ifde 
XHMCU_PRINT


88 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
buf
, 
	`
( buf ), 2 );

90 
	}
}

103 
BOOL
 
	gModBusLiuLngJi
::
	$WhhBufVue
 ( 
BYTE
 *
buf
, &
n
, &
pos
 )

105 
BYTE
 *
por
 = 
buf
;

106 
pos
 = 0;

108  
n
 >= 17 )

111 if
m_wDevAddr
 !*
por


112 || 0x01 !*
por
 + 1 )

113 || 0x11 !*
por
 + 2 ) )

115 
	`t
( (*)"ͷ" );

116 
por
 ++;

117 
n
 --;

118 
pos
 ++;

122 
WORD
 
wCRC
 = 
	`GCrc

buf
, buf[2] + 3 );

123 if
	`HIBYTE
(
wCRC
=
buf
[ buf[2] + 3 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ buf[2] + 4 ] ) )

125  
TRUE
;

129 
	`t
( (*)"Уδͨ" );

130 
por
 ++;

131 
n
 --;

132 
pos
 ++;

137 
	`t
( (*) "ModBusLiuLiangJi WhetherBufValueot findight buf ");

139  
FALSE
 ;

140 
	}
}

152 
BOOL
 
	gModBusLiuLngJi
::
	$ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 )

154 
BYTE
 
i
;

155 
wV
;

157 
m_pMhod
->
	`SYcDa
 ( 
m_SlNo
 , 0 , ()
buf
[3] );

158  
i
=1;i<5;i++ )

160 
wV
 = (()(
buf
[4+((
i
-1)*3)]<<8 & buf[5+((i-1)*3)])/()0x8000)*
	`pow
( 2 , buf[6+((i-1)*3)] );

161 
m_pMhod
->
	`SYcDa
 ( 
m_SlNo
 , 
i
 , 
wV
 );

164 
wV
 = (
buf
[16]>>4)*1000000 + (buf[16]&0x0F)*100000 + (buf[17]>>4)*10000 + (buf[17]&0x0F)*1000 /

165 (
buf
[18]>>4)*100 + (buf[18]&0x0F)*10 + (buf[19]>>4) + ()(buf[19]&0x0F)*0.1;

166 
m_pMhod
->
	`SYmDa

m_SlNo
 , 5 , 
wV
 );

169  
TRUE
;

170 
	}
}

182 
BOOL
 
	gModBusLiuLngJi
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

184 if
pBusMsg
 !
NULL
 )

186  
FALSE
;

189 
n
 = 0;

192 
buf
[
n
++] = 
m_wDevAddr
;

193 
buf
[
n
++] = 0x01;

194 
buf
[
n
++] = 0x00;

195 
buf
[
n
++] = 0x00;

196 
buf
[
n
++] = 0x00;

197 
buf
[
n
++] = 0x11;

199 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
n
 );

200 
buf
[ 
n
++ ] = 
	`HIBYTE
(
wCRC
);

201 
buf
[ 
n
++ ] = 
	`LOBYTE
(
wCRC
);

202 
m_bySdCou
 ++;

204  
TRUE
;

205 
	}
}

217 
BOOL
 
	gModBusLiuLngJi
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

219 
pos
 = 0;

220 i!
	`WhhBufVue

buf
, 
n
, 
pos
 ) )

222 
szBuf
[256] = "";

223 
	`rtf

szBuf
, "%s", "ModBusLiuLiangJiecv bufrr !!!\n" );

224 
	`t

szBuf
 );

225 
m_byRecvCou
 ++;

226  
FALSE
;

229 
	`ProssRecvBuf

buf
 + 
pos
, 
n
 );

231 
m_bLkStus
 = 
TRUE
;

232 
m_bySdCou
 = 0;

233 
m_byRecvCou
 = 0;

235  
TRUE
;

236 
	}
}

247 
BOOL
 
	gModBusLiuLngJi
::
	$In
 ( 
BYTE
 
byLeNo
 )

249  
TRUE
;

250 
	}
}

262 
	gModBusLiuLngJi
::
	$TimProc
 ( )

264 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

266 
m_bySdCou
 = 0;

267 
m_byRecvCou
 = 0;

268 if
m_bLkStus
 )

270 
m_bLkStus
 = 
FALSE
;

271 
	`t
( (*) "ModBusLiuLiangJi:unlink\n");

274 
	}
}

286 
BOOL
 
	gModBusLiuLngJi
::
	$GDevCommS
 ( )

288 i
m_bLkStus
 )

290  
COM_DEV_NORMAL
;

294  
COM_DEV_ABNORMAL
;

296 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusLiuLiangJi.h

22 #ide 
MODULE_LIULIANGJI_INC


23 
	#MODULE_LIULIANGJI_INC


	)

25 
	~"CProc_ModBusMa.h
"

33 as
	cModBusLiuLngJi
 : 
public
 
CProc_ModBusMa


35 
public
:

37 
ModBusLiuLngJi
 ();

38 ~
ModBusLiuLngJi
 ();

40 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

41 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

42 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

44 
vtu
 
TimProc
() ;

46 
vtu
 
BOOL
 
GDevCommS
( ) ;

49 
	meed
:

52 
ive
:

54 
BOOL
 
WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 ,&
pos
);

56 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 );

58 
	$t
*
buf
 ) const;

59 
ive
:

61 
BOOL
 
m_bLkStus
;

62 
BYTE
 
m_bySdCou
;

63 
BYTE
 
m_byRecvCou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusSD96E3.cpp

124 
	~<mh.h
>

125 
	~"ModBusSD96E3.h
"

126 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

136 
	gCModBusSD96E3
::
	$CModBusSD96E3
 ()

138 
m_bLkStus
 = 
FALSE
;

139 
m_bySdCou
 = 0;

140 
m_byRecvCou
 = 0;

141 
	}
}

150 
	gCModBusSD96E3
::~
	$CModBusSD96E3
 ()

152 
	}
}

163 
BOOL
 
CModBusSD96E3
::
	$WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 )

165 
BYTE
 *
por
 = 
buf
;

166 
WORD
 
wCrc
;

167 
pos
 = 0;

169  
n
 >= 4 )

172 i*
por
 !
m_wDevAddr
 )

174 
DEFAULT
;

178 i*
por
 + 1 ) != 0x03 )

180 
DEFAULT
;

184 
wCrc
 = 
	`GCrc

por
, ( *(ointer + 2 ) + 3 ) );

185 if*
por
 + ( *po+ 2 ) + 3 ) ) !
	`HIBYTE
(
wCrc
)

186 || *
por
 + ( *po+ 2 ) + 4 ) ) !
	`LOBYTE
(
wCrc
))

188 
DEFAULT
;

191 
buf
 = bu+ 
pos
;

192 
n
 = *(
por
 + 2) + 5;

193  
TRUE
;

194 
DEFAULT
:

195 
por
 ++;

196 
n
 --;

197 
pos
 ++;

199  
FALSE
 ;

200 
	}
}

212 
BOOL
 
	gCModBusSD96E3
::
	$ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 )

214 if
n
 < 15 )

216  
FALSE
;

218 
BYTE
 
IPow
=0 , 
UPow
=0 , 
FPow
=0 , 
FSignB
=0;

219 
IPow
 = 
buf
[23];

220 
UPow
 = 
buf
[24];

221 
FSignB
 = 
buf
[25];

222 
FPow
 = 
buf
[26];

224  
i
=0; i<10; i++ )

226 
fYcVue
 = 0.0;

227 
fYcVue
 = ()
	`MAKEWORD

buf
[4 + 2 * 
i
], buf[ 3 + 2 * i ] ) );

228 if
i
 < 3 )

229 
fYcVue
 = (fYcVue/10000)*
	`pow
(10,
UPow
);

230 if
i
 > 2 && i < 6 )

231 
fYcVue
 = (fYcVue/10000)*
	`pow
(10,
IPow
);

232 if
i
 > 5 && i < 8 )

234 
fYcVue
 = (fYcVue/10000)*
	`pow
(10,
FPow
)/1000;

235  
FSignB
 )

240 if
i
 == 6 )

241 
fYcVue
 = -fYcValue;

244 if
i
 == 7 )

245 
fYcVue
 = -fYcValue;

248 
fYcVue
 = -fYcValue;

252 if
i
 == 8 )

253 
fYcVue
 = fYcValue*0.001;

254 if
i
 == 9 )

255 
fYcVue
 = fYcValue*0.01;

257 
m_pMhod
->
	`SYcDa

m_SlNo
, 
i
, 
fYcVue
 );

261  
i
=0; i<2; i++ )

263 
fYmVue
 = 0.0;

264 
fYmVue
 = *(*)(
buf
+35 + 4*
i
 );

265 
fYmVue
 = fYmValue/10000;

267 
m_pMhod
->
	`SYmDa

m_SlNo
, 
i
, 
fYmVue
 );

271  
TRUE
;

272 
	}
}

284 
BOOL
 
	gCModBusSD96E3
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

286 if
pBusMsg
 !
NULL
 )

288  
FALSE
;

291 
n
 = 0;

293 
buf
[
n
++] = 
m_wDevAddr
;

294 
buf
[
n
++] = 0x03;

296 
buf
[
n
++] = 0x00;

297 
buf
[
n
++] = 0x00;

298 
buf
[
n
++] = 0x00;

299 
buf
[
n
++] = 0x14;

301 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
n
 );

302 
buf
[ 
n
++ ] = 
	`HIBYTE
(
wCRC
);

303 
buf
[ 
n
++ ] = 
	`LOBYTE
(
wCRC
);

305 
m_bySdCou
 ++;

307  
TRUE
;

308 
	}
}

320 
BOOL
 
	gCModBusSD96E3
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

322 i!
	`WhhBufVue

buf
, 
n
 ) )

324 
szBuf
[256] = "";

325 
	`rtf

szBuf
, "%s", "CModBusSD96E3ecv bufrr !!!\n" );

326 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
( szBuf ), 2 );

328 
m_byRecvCou
 ++;

329  
FALSE
;

331 
	`ProssRecvBuf

buf
, 
n
 );

333 
m_bLkStus
 = 
TRUE
;

334 
m_bySdCou
 = 0;

335 
m_byRecvCou
 = 0;

337  
TRUE
;

338 
	}
}

349 
BOOL
 
	gCModBusSD96E3
::
	$In
 ( 
BYTE
 
byLeNo
 )

351  
TRUE
;

352 
	}
}

364 
	gCModBusSD96E3
::
	$TimProc
 ( )

366 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

368 
m_bySdCou
 = 0;

369 
m_byRecvCou
 = 0;

370 if
m_bLkStus
 )

372 
m_bLkStus
 = 
FALSE
;

373 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"CModBusSD96E3:unlink\n", 30, 2 );

376 
	}
}

388 
BOOL
 
	gCModBusSD96E3
::
	$GDevCommS
 ( )

390 i
m_bLkStus
 )

392  
COM_DEV_NORMAL
;

396  
COM_DEV_ABNORMAL
;

398 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusSD96E3.h

22 #ide 
MODBUSSD96E3_INC


23 
	#MODBUSSD96E3_INC


	)

25 
	~"CProc_ModBusMa.h
"

34 as
	cCModBusSD96E3
 : 
public
 
CProc_ModBusMa


36 
public
:

38 
CModBusSD96E3
 ();

39 ~
CModBusSD96E3
 ();

41 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

42 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

43 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

45 
vtu
 
TimProc
() ;

47 
vtu
 
BOOL
 
GDevCommS
( ) ;

49 
	meed
:

52 
ive
:

54 
BOOL
 
WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 );

56 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 );

57 
	mive
:

59 
BOOL
 
m_bLkStus
;

60 
BYTE
 
	mm_bySdCou
;

61 
BYTE
 
	mm_byRecvCou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusWenKongyi.cpp

58 
	~"ModBusWKgyi.h
"

59 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

69 
	gCModbusWKgYi
::
	$CModbusWKgYi
 ()

71 
m_bLkStus
 = 
FALSE
;

72 
m_bySdCou
 = 0;

73 
m_byRecvCou
 = 0;

74 
	}
}

83 
	gCModbusWKgYi
::~
	$CModbusWKgYi
 ()

85 
	}
}

96 
BOOL
 
CModbusWKgYi
::
	$WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 )

98 
BYTE
 *
por
 = 
buf
;

99 
WORD
 
wCrc
;

100 
pos
 = 0;

102  
n
 >= 4 )

105 i*
por
 !
m_wDevAddr
 )

107 
DEFAULT
;

111 i*
por
 + 1 ) != 0x03 )

113 
DEFAULT
;

117 
wCrc
 = 
	`GCrc

por
, ( *(ointer + 2 ) + 3 ) );

118 if*
por
 + ( *po+ 2 ) + 3 ) ) !
	`HIBYTE
(
wCrc
)

119 || *
por
 + ( *po+ 2 ) + 4 ) ) !
	`LOBYTE
(
wCrc
))

121 
DEFAULT
;

124 
buf
 = bu+ 
pos
;

125 
n
 = *(
por
 + 2) + 5;

126  
TRUE
;

127 
DEFAULT
:

128 
por
 ++;

129 
n
 --;

130 
pos
 ++;

132  
FALSE
 ;

133 
	}
}

145 
BOOL
 
	gCModbusWKgYi
::
	$ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 )

147 if
n
 < 15 )

149  
FALSE
;

152  
i
=0; i<4; i++)

154 
BYTE
 
byYxVue
 = 0;

155 
BYTE
 
byYxB
 = 0;

156 
byYxB
 = ( 
buf
[4] >> ( 2 * 
i
 ) ) & 0x03 ;

157 i
byYxB
 == 0x03 )

159 
byYxVue
 = 1;

163 
byYxVue
 = 0;

166 
m_pMhod
->
	`SYxDa

m_SlNo
, 
i
, 
byYxVue
 );

170  
i
=0; i<4; i++)

172 
fYcVue
;

173 
fYcVue
 = ()
	`MAKEWORD

buf
[6 + 2 * 
i
], buf[ 5 + 2 * i ] ) );

175 
m_pMhod
->
	`SYcDa

m_SlNo
, 
i
, 
fYcVue
 );

179  
TRUE
;

180 
	}
}

192 
BOOL
 
	gCModbusWKgYi
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

194 if
pBusMsg
 !
NULL
 )

196  
FALSE
;

199 
n
 = 0;

201 
buf
[
n
++] = 
m_wDevAddr
;

202 
buf
[
n
++] = 0x03;

204 
buf
[
n
++] = 0x00;

205 
buf
[
n
++] = 0x00;

206 
buf
[
n
++] = 0x00;

207 
buf
[
n
++] = 0x05;

209 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
n
 );

210 
buf
[ 
n
++ ] = 
	`HIBYTE
(
wCRC
);

211 
buf
[ 
n
++ ] = 
	`LOBYTE
(
wCRC
);

213 
m_bySdCou
 ++;

215  
TRUE
;

216 
	}
}

228 
BOOL
 
	gCModbusWKgYi
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

230 i!
	`WhhBufVue

buf
, 
n
 ) )

232 
szBuf
[256] = "";

233 
	`rtf

szBuf
, "%s", "ModBusWenKongyiecv bufrr !!!\n" );

234 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
szBuf
, 
	`
( szBuf ), 2 );

236 
m_byRecvCou
 ++;

237  
FALSE
;

240 
	`ProssRecvBuf

buf
, 
n
 );

242 
m_bLkStus
 = 
TRUE
;

243 
m_bySdCou
 = 0;

244 
m_byRecvCou
 = 0;

246  
TRUE
;

247 
	}
}

258 
BOOL
 
	gCModbusWKgYi
::
	$In
 ( 
BYTE
 
byLeNo
 )

260  
TRUE
;

261 
	}
}

273 
	gCModbusWKgYi
::
	$TimProc
 ( )

275 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

277 
m_bySdCou
 = 0;

278 
m_byRecvCou
 = 0;

279 if
m_bLkStus
 )

281 
m_bLkStus
 = 
FALSE
;

282 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"CModbusWenKongYi:unlink\n", 30, 2 );

285 
	}
}

297 
BOOL
 
	gCModbusWKgYi
::
	$GDevCommS
 ( )

299 i
m_bLkStus
 )

301  
COM_DEV_NORMAL
;

305  
COM_DEV_ABNORMAL
;

307 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusWenKongyi.h

22 #ide 
MODBUSWENKONGYI_INC


23 
	#MODBUSWENKONGYI_INC


	)

25 
	~"CProc_ModBusMa.h
"

34 as
	cCModbusWKgYi
 : 
public
 
CProc_ModBusMa


36 
public
:

38 
CModbusWKgYi
 ();

39 ~
CModbusWKgYi
 ();

41 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

42 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

43 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

45 
vtu
 
TimProc
() ;

47 
vtu
 
BOOL
 
GDevCommS
( ) ;

49 
	meed
:

52 
ive
:

54 
BOOL
 
WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 );

56 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 );

57 
	mive
:

59 
BOOL
 
m_bLkStus
;

60 
BYTE
 
	mm_bySdCou
;

61 
BYTE
 
	mm_byRecvCou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusXiaoDianLiu.cpp

67 
	~"ModBusXoDnLiu.h
"

68 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

78 
	gCModBusXDL
::
	$CModBusXDL
 ()

80 
m_bLkStus
 = 
FALSE
;

81 
m_bySdCou
 = 0;

82 
m_byRecvCou
 = 0;

83 
	}
}

92 
	gCModBusXDL
::~
	$CModBusXDL
 ()

94 
	}
}

106 
CModBusXDL
::
	$t
 ( *
buf
 )

108 #ifde 
XDL_PRINT


109 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
buf
, 
	`
( buf ), 2 );

111 
	}
}

123 
BOOL
 
	gCModBusXDL
::
	$WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 ,&
pos
)

125 
BYTE
 *
por
 = 
buf
;

126 
WORD
 
wCrc
;

127 
pos
 = 0;

129  
n
 >= 77 )

132 i*
por
 !
m_wDevAddr
 )

134 
	`t
( (*)"CModBusXDL WhetherBufValueddrrror" );

135 
DEFAULT
;

139 i*
por
 + 1 ) != 0x04 )

141 
	`t
( (*)"CModBusXDL WhetherBufValue coderror" );

142 
DEFAULT
;

146 
wCrc
 = 
	`GCrc

por
, ( *(ointer + 2 ) + 3 ) );

147 if*
por
 + ( *po+ 2 ) + 3 ) ) !
	`HIBYTE
(
wCrc
)

148 || *
por
 + ( *po+ 2 ) + 4 ) ) !
	`LOBYTE
(
wCrc
))

150 
	`t
( (*)"CModBusXDL WhetherBufValue crcrror" );

151 
DEFAULT
;

154 
buf
 = bu+ 
pos
;

155 
n
 = *(
por
 + 2) + 5;

156  
TRUE
;

157 
DEFAULT
:

158 
por
 ++;

159 
n
 --;

160 
pos
 ++;

163 
	`t
( (*) "CModBusXDL WhetherBufValueot findight buf ");

165  
FALSE
 ;

166 
	}
}

178 
BOOL
 
	gCModBusXDL
::
	$ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 )

180 
szBuf
[256];

181 if
n
 < 77 )

183  
FALSE
;

186  
i
=0; i<4; i++)

188 
BYTE
 
byYxVue
 = 0;

189 
BYTE
 
byYxBy
 = 0;

190 
BYTE
 
byYxP
;

192 
byYxP
 = 
i
*3;

193 
byYxBy
 = 
buf
[2 + 
i
 * 18 + 6];

195 if0 =
byYxBy
 )

197 
byYxVue
 = 0;

198 
m_pMhod
->
	`SYxDa

m_SlNo
, 
byYxP
, 
byYxVue
 );

199 
	`rtf

szBuf
,"yx %d vue=%d", 
byYxP
 , 
byYxVue
 );

200 
	`t

szBuf
 );

201 
m_pMhod
->
	`SYxDa

m_SlNo
, 
byYxP
 + 1, 
byYxVue
 );

202 
	`rtf

szBuf
,"yx %d vue=%d", 
byYxP
 + 1, 
byYxVue
 );

203 
	`t

szBuf
 );

204 
m_pMhod
->
	`SYxDa

m_SlNo
, 
byYxP
 + 2, 
byYxVue
 );

205 
	`rtf

szBuf
,"yx %d vue=%d", 
byYxP
 + 2, 
byYxVue
 );

206 
	`t

szBuf
 );

208 if
byYxBy
 > 0 && byYxByte < 4 )

210 
byYxP
 = 
i
 * 3 + 
byYxBy
 - 1 ;

211 
byYxVue
 = 1;

213 
m_pMhod
->
	`SYxDa

m_SlNo
, 
byYxP
, 
byYxVue
 );

214 
	`rtf

szBuf
,"yx %d vue=%d", 
byYxP
, 
byYxVue
 );

215 
	`t

szBuf
 );

219 
szBuf
[256] = "";

220 
	`rtf

szBuf
, "ModBusXoDnLiu ProssRecvBu!!!ty > %d \n", 
byYxBy
 );

221 
	`t

szBuf
 );

222  
FALSE
;

228  
TRUE
;

229 
	}
}

241 
BOOL
 
	gCModBusXDL
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

243 if
pBusMsg
 !
NULL
 )

245  
FALSE
;

248 
n
 = 0;

250 
buf
[
n
++] = 
m_wDevAddr
;

251 
buf
[
n
++] = 0x04;

253 
buf
[
n
++] = 0x00;

254 
buf
[
n
++] = 0x00;

255 
buf
[
n
++] = 0x00;

256 
buf
[
n
++] = 0x36;

258 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
n
 );

259 
buf
[ 
n
++ ] = 
	`HIBYTE
(
wCRC
);

260 
buf
[ 
n
++ ] = 
	`LOBYTE
(
wCRC
);

262 
m_bySdCou
 ++;

264  
TRUE
;

265 
	}
}

277 
BOOL
 
	gCModBusXDL
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

279 
pos
 = 0;

280 i!
	`WhhBufVue

buf
, 
n
, 
pos
 ) )

282 
szBuf
[256] = "";

283 
	`rtf

szBuf
, "%s", "ModBusXiaoDianLiuecv bufrr !!!\n" );

284 
	`t

szBuf
 );

286 
m_byRecvCou
 ++;

287  
FALSE
;

290 
	`ProssRecvBuf

buf
+
pos
, 
n
 );

292 
m_bLkStus
 = 
TRUE
;

293 
m_bySdCou
 = 0;

294 
m_byRecvCou
 = 0;

296  
TRUE
;

297 
	}
}

308 
BOOL
 
	gCModBusXDL
::
	$In
 ( 
BYTE
 
byLeNo
 )

310  
TRUE
;

311 
	}
}

323 
	gCModBusXDL
::
	$TimProc
 ( )

325 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

327 
m_bySdCou
 = 0;

328 
m_byRecvCou
 = 0;

329 if
m_bLkStus
 )

331 
m_bLkStus
 = 
FALSE
;

332 
	`t
( ( * ) "CModBusXDL:unlink\n");

335 
	}
}

347 
BOOL
 
	gCModBusXDL
::
	$GDevCommS
 ( )

349 i
m_bLkStus
 )

351  
COM_DEV_NORMAL
;

355  
COM_DEV_ABNORMAL
;

357 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusXiaoDianLiu.h

22 #ide 
MODBUSXIAODIANLIU_INC


23 
	#MODBUSXIAODIANLIU_INC


	)

25 
	~"CProc_ModBusMa.h
"

27 
	#XDL_PRINT
 1

	)

35 as
	cCModBusXDL
 : 
public
 
CProc_ModBusMa


37 
public
:

39 
CModBusXDL
 ();

40 ~
CModBusXDL
 ();

42 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

43 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

44 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

46 
vtu
 
TimProc
() ;

48 
vtu
 
BOOL
 
GDevCommS
( ) ;

50 
	meed
:

53 
ive
:

55 
BOOL
 
WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 , &
pos
);

57 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 );

59 
t
*
buf
 );

60 
	mive
:

62 
BOOL
 
m_bLkStus
;

63 
BYTE
 
	mm_bySdCou
;

64 
BYTE
 
	mm_byRecvCou
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusXiaoHuMCU.cpp

113 
	~"ModBusXoHuMCU.h
"

114 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

124 
	gCModBusXHMCU
::
	$CModBusXHMCU
 ()

126 
m_bLkStus
 = 
FALSE
;

127 
m_bySdCou
 = 0;

128 
m_byRecvCou
 = 0;

129 
m_bySrcAddr
 = 1;

130 
m_byDaTy
 = 0;

131 
	}
}

140 
	gCModBusXHMCU
::~
	$CModBusXHMCU
 ()

142 
	}
}

153 
CModBusXHMCU
::
	$t
 ( *
buf
 ) const

156 #ifde 
XHMCU_PRINT


157 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)
buf
, 
	`
( buf ), 2 );

159 
	}
}

172 
WORD
 
	gCModBusXHMCU
::
	$GWdSumCheck
 ( 
BYTE
 *
pBuf
, 
n
 )

174 
WORD
 
sum
 = 0;

176  
i
=0; i<
n
; i++ )

178 
sum
 +
pBuf
[
i
];

181  
sum
;

182 
	}
}

194 
BYTE
 
	gCModBusXHMCU
::
	$GSumCheck
 ( 
BYTE
 *
pBuf
, 
n
 )

196  
	`LOBYTE

	`GWdSumCheck

pBuf
, 
n
 ) );

197 
	}
}

208 
BOOL
 
	gCModBusXHMCU
::
	$WhhBufVue
 ( 
BYTE
 *
buf
, &
n
, &
pos
 )

210 
BYTE
 *
por
 = 
buf
;

211 
pos
 = 0;

213  
n
 >= 18 )

216 if0xEB !*
por


217 || 0x90 !*
por
 + 1 )

218 || 0xEB !*
por
 + 2)

219 || 0x90 !*
por
 + 3 ) )

221 
	`t
( (*)"ִͬ" );

222 
DEFAULT
;

225 i*
por
 + 4 ) !
m_bySrcAddr


226 || *
por
 + 5 ) !
m_wDevAddr
)

228 
	`t
( (*)"ַ" );

229 
DEFAULT
;

233 if0x55 =*
por
 + 16 ) && 0xAA == *(ointer + 17 ))

236 if2 !*
por
 + 13 ) )

238 
	`t
( (*)"ĳȴ" );

239 
DEFAULT
;

242 if0x50 !*
por
 + 14 ) )

244 
	`t
( (*)"" );

245 
DEFAULT
;

249 if
	`GSumCheck

por
 + 13, 2 ) != *(ointer + 15 ) )

251 
	`t
( (*)"У" );

252 
DEFAULT
;

255 
buf
 = bu+ 
pos
;

256 
n
 = 18;

257 
m_byDaTy
 = 
XHMCU_NONE_TROUBLE_DATATYPE
;

258  
TRUE
;

261 if0x55 =*
por
 + 18 ) && 0xAA == *(ointer + 19 ) )

263 
WORD
 
c
;

265 if9 !*
por
 + 14 ) )

267 
	`t
( (*)"ĳȴ" );

268 
DEFAULT
;

271 if0x50 !*
por
 + 15 ) )

273 
	`t
( (*)"" );

274 
DEFAULT
;

277 
c
 = 
	`GWdSumCheck

por
 + 6, 10 );

278 if*
por
 + 16!
	`LOBYTE

c
 )

279 || *
por
 + 17!
	`HIBYTE

c
 ))

281 
	`t
( (*)"ʹ" );

282 
DEFAULT
;

284 
buf
 = bu+ 
pos
;

285 
n
 = 20;

286 
m_byDaTy
 = 
XHMCU_TROUBLE_DATATYPE
;

287  
TRUE
;

292 
m_byDaTy
 = 0;

293 
	`t
( (*)"" );

296 
DEFAULT
:

297 
por
 ++;

298 
n
 --;

299 
pos
 ++;

302 
	`t
( (*) "CModBusXHMCU WhetherBufValueot findight buf ");

304  
FALSE
 ;

305 
	}
}

316 
BOOL
 
	gCModBusXHMCU
::
	$ProssNeTroubDa
 ( 
BYTE
 *
buf
, 
n
 )

318 
BYTE
 
byYxBy
;

319 
BYTE
 
byYxVue
;

320 
fYcVue
;

321 
i
;

322 
szBuf
[256];

323 if
n
 != 18 )

325  
FALSE
;

329 
byYxBy
 = 
buf
[6];

332  
i
=0; i<6; i++ )

334 
byYxVue
 = ( 
byYxBy
 >> ( 
i
 ) ) & 0x01;

335 
m_pMhod
->
	`SYxDa

m_SlNo
, ( 
WORD
 )
i
, 
byYxVue
 );

336 
	`rtf

szBuf
, "yx=%d v=%d", (
WORD
)
i
, 
byYxVue
 );

337 
	`t

szBuf
 );

341 if0x01 =
byYxBy
 >> 6 ) & 0x03 ) )

343 
byYxVue
 = 1;

344 
m_pMhod
->
	`SYxDa

m_SlNo
, (
WORD
)
i
, 
byYxVue
 );

346 i0x00 =
byYxBy
 >> 6 ) & 0x03 ) )

348 
byYxVue
 = 0;

349 
m_pMhod
->
	`SYxDa

m_SlNo
, (
WORD
)
i
, 
byYxVue
 );

353 
	`t
( (*)"Ͷ˱" );

354  
FALSE
;

357 
	`rtf

szBuf
, "yx=%d v=%d", 
i
, 
byYxVue
 );

358 
	`t

szBuf
 );

360  
i
=7; i<21; i++ )

362 
byYxVue
 = 0;

363 
m_pMhod
->
	`SYxDa

m_SlNo
, (
WORD
)
i
, 
byYxVue
 );

364 
	`rtf

szBuf
, "yx=%d v=%d", (
WORD
)
i
, 
byYxVue
 );

365 
	`t

szBuf
 );

370  
i
=0; i<6; i++ )

372 
fYcVue
 = ( )
buf
[7 + 
i
];

373 
m_pMhod
->
	`SYcDa

m_SlNo
, ( 
WORD
 )
i
, 
fYcVue
 );

374 
	`rtf

szBuf
, "yt=%d v=%f", ( 
WORD
 )
i
, 
fYcVue
 );

375 
	`t

szBuf
 );

378  
TRUE
;

379 
	}
}

391 
BOOL
 
	gCModBusXHMCU
::
	$ProssTroubDa
 ( 
BYTE
 *
buf
, 
n
 )

393 
BYTE
 
byYxBy
;

394 
BYTE
 
byYxVue
;

395 
WORD
 
wP
 = 0;

396 
szBuf
[256];

397 
TIMEDATA
 
mDa
;

398 
i
;

399 if
n
 != 20 )

401  
FALSE
;

405 
byYxBy
 = 
buf
[7];

408  
i
=0; i<6; i++ )

410 
byYxVue
 = ( 
byYxBy
 >> ( 
i
 ) ) & 0x01;

411 
m_pMhod
->
	`SYxDa

m_SlNo
, ( 
WORD
 )
i
, 
byYxVue
 );

412 
	`rtf

szBuf
, "yx=%d v=%d", 
i
, 
byYxVue
 );

413 
	`t

szBuf
 );

417 if0x01 =
byYxBy
>>6 ) & 0x03 ) )

419 
byYxVue
 = 1;

420 
m_pMhod
->
	`SYxDa

m_SlNo
, ( 
WORD
 )
i
, 
byYxVue
 );

422 i0x00 =
byYxBy
 >> 6 ) & 0x03 ) )

424 
byYxVue
 = 0;

425 
m_pMhod
->
	`SYxDa

m_SlNo
, (
WORD
)
i
, 
byYxVue
 );

429 
	`t
( (*)"Ͷ˱" );

430  
FALSE
;

433 
	`rtf

szBuf
, "yx=%d v=%d", 
i
, 
byYxVue
 );

434 
	`t

szBuf
 );

437  
buf
[6] )

440 
wP
 = 7;

444 
wP
 = 8;

448 
wP
 = 9;

452 
wP
 = 10;

456 
wP
 = 11;

460 
wP
 = 12;

464 
wP
 = 13;

468 
wP
 = 14;

472 
wP
 = 15;

476 
wP
 = 16;

480 
wP
 = 17;

484 
wP
 = 18;

488 
wP
 = 19;

492 
wP
 = 20;

496 
	`t
 ( (*)"" );

497  
FALSE
;

501 if!
m_pMhod
->
	`IsSTime
( 0,

502 
buf
[13],

503 
buf
[12],

504 
buf
[11],

505 
buf
[10],

506 
buf
[9],

507 
buf
[8]+2000) )

509 
	`rtf

szBuf
, "ERROR:soeimerr!!!%d-%d-%d %d:%d:%d",

510 
buf
[8]+2000, buf[9], buf[10] ,

511 
buf
[11], buf[12], buf[13]);

512 
	`t

szBuf
 );

513  
FALSE
;

515 
mDa
.
Yr
 = 
buf
[8] + 100;

516 
mDa
.
Mth
 = 
buf
[9];

517 
mDa
.
Day
 = 
buf
[10];

518 
mDa
.
Hour
 = 
buf
[11];

519 
mDa
.
Mu
 = 
buf
[12];

520 
mDa
.
Secd
 = 
buf
[13];

523 if0 !
wP
 )

525 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
wP
, (
BYTE
)1, &
mDa
 );

526 
	`rtf

szBuf
, "yx soent=%d val=%dime = %d-%d-%d %d:%d:%d",

527 
wP
, 1, 
mDa
.
Yr
 + 1900,tmDa.
Mth
,mDa.
Day
 ,

528 
mDa
.
Hour
,tmDa.
Mu
,tmDa.
Secd
);

529 
	`t

szBuf
 );

532  
TRUE
;

533 
	}
}

544 
BOOL
 
	gCModBusXHMCU
::
	$ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 )

546 
BOOL
 
bR
 = 
FALSE
;

548  
m_byDaTy
 )

550 
XHMCU_NONE_TROUBLE_DATATYPE
:

551 
bR
 = 
	`ProssNeTroubDa

buf
, 
n
 );

554 
XHMCU_TROUBLE_DATATYPE
:

555 
bR
 = 
	`ProssTroubDa

buf
, 
n
 );

562 
m_byDaTy
 = 0;

564  
bR
;

565 
	}
}

577 
BOOL
 
	gCModBusXHMCU
::
	$GProcBuf
 ( 
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
 )

579 if
pBusMsg
 !
NULL
 )

581  
FALSE
;

584 
n
 = 0;

587 
buf
[
n
++] = 0xEB;

588 
buf
[
n
++] = 0x90;

589 
buf
[
n
++] = 0xEB;

590 
buf
[
n
++] = 0x90;

592 
buf
[
n
++] = 
m_wDevAddr
;

593 
buf
[
n
++] = 
m_bySrcAddr
;

595 
buf
[
n
++] = 0x00;

596 
buf
[
n
++] = 0x02;

597 
buf
[
n
++] = 0x55;

598 
buf
[
n
++] = 
	`GSumCheck
( &buf[6], 3 );

601 
buf
[ 
n
++ ] = 0x55;

602 
buf
[ 
n
++ ] = 0xAA;

604 
m_bySdCou
 ++;

606  
TRUE
;

607 
	}
}

619 
BOOL
 
	gCModBusXHMCU
::
	$ProssProcBuf
 ( 
BYTE
 *
buf
, 
n
 )

621 
pos
 = 0;

622 i!
	`WhhBufVue

buf
, 
n
, 
pos
 ) )

624 
szBuf
[256] = "";

625 
	`rtf

szBuf
, "%s", "ModBusXiaoHuMCUecv bufrr !!!\n" );

626 
	`t

szBuf
 );

627 
m_byRecvCou
 ++;

628  
FALSE
;

631 
	`ProssRecvBuf

buf
 + 
pos
, 
n
 );

633 
m_bLkStus
 = 
TRUE
;

634 
m_bySdCou
 = 0;

635 
m_byRecvCou
 = 0;

637  
TRUE
;

638 
	}
}

649 
BOOL
 
	gCModBusXHMCU
::
	$In
 ( 
BYTE
 
byLeNo
 )

651  
TRUE
;

652 
	}
}

664 
	gCModBusXHMCU
::
	$TimProc
 ( )

666 if
m_bySdCou
 > 3 || 
m_byRecvCou
 > 3)

668 
m_bySdCou
 = 0;

669 
m_byRecvCou
 = 0;

670 if
m_bLkStus
 )

672 
m_bLkStus
 = 
FALSE
;

673 
	`t
( (*) "CModBusXHMCU:unlink\n");

676 
	}
}

688 
BOOL
 
	gCModBusXHMCU
::
	$GDevCommS
 ( )

690 i
m_bLkStus
 )

692  
COM_DEV_NORMAL
;

696  
COM_DEV_ABNORMAL
;

698 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusXiaoHuMCU.h

22 #ide 
MODBUSXIAOHUMCU_INC


23 
	#MODBUSXIAOHUMCU_INC


	)

25 
	~"CProc_ModBusMa.h
"

27 
	#XHMCU_NONE_TROUBLE_DATATYPE
 1

	)

28 
	#XHMCU_TROUBLE_DATATYPE
 2

	)

32 
	#XHMCU_PRINT
 1

	)

40 as
	cCModBusXHMCU
 : 
public
 
CProc_ModBusMa


42 
public
:

44 
CModBusXHMCU
 ();

45 ~
CModBusXHMCU
 ();

47 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

48 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

49 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

51 
vtu
 
TimProc
() ;

53 
vtu
 
BOOL
 
GDevCommS
( ) ;

56 
	meed
:

59 
ive
:

61 
BOOL
 
WhhBufVue
 ( 
BYTE
 *
buf
, &
n
 ,&
pos
);

63 
BOOL
 
ProssRecvBuf
 ( 
BYTE
 *
buf
, 
n
 );

65 
WORD
 
GWdSumCheck
 ( 
BYTE
 *
pBuf
, 
n
 );

66 
BYTE
 
GSumCheck
BYTE * 
pBuf
 , 
n
 );

68 
BOOL
 
ProssTroubDa

BYTE
 *
buf
, 
n
 );

70 
BOOL
 
ProssNeTroubDa

BYTE
 *
buf
, 
n
 );

72 
	$t
*
buf
 ) const;

73 
ive
:

75 
BOOL
 
m_bLkStus
;

76 
BYTE
 
m_bySdCou
;

77 
BYTE
 
m_byRecvCou
;

78 
BYTE
 
m_bySrcAddr
;

79 
BYTE
 
m_byDaTy
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/PMC_530.cpp

1 
	~"PMC_530.h
"

2 
	~<mh.h
>

3 
	~<unid.h
>

4 
	~<time.h
>

6 
	gPMC_530
::
	$PMC_530
():
	`TEST
(1<<31),
	`TEST0
(1<<15),
	`ERROR_CONST
(5),
	`COMSTATUS_ONLINE
(1),
	$COMSTATUS_FAULT
(0)

8 
m_wETim
 = 0;

9 
loag
 = 0;

10 
m_byPtStus
 = 0;

11 
ykty
 = 0;

12 
yk_da
 = 
NULL
;

13 
byBusNo
 = 0;

14 
wDevNo
 = 0;

15 
wP
 = 0;

16 
byV
 = 0;

17 
	}
}

19 
	gPMC_530
::~
	$PMC_530
()

20 {
	}
}

22 
BOOL
 
PMC_530
::
	$GYKBufr
(
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
)

27 
buf
[
n
++] = 
m_wDevAddr
;

28 
buf
[
n
++] = 0x05;

29 
buf
[
n
++] = 0xEA;

31 if(
wP
 == 0x00){

32 if((
pBusMsg
->
dwDaTy
 =
YK_SEL
&& (
byV
 == 0x01))

33 
buf
[
n
++] = 0xA0;

34 if((
pBusMsg
->
dwDaTy
 =
YK_SEL
&& (
byV
 == 0x00))

35 
buf
[
n
++] = 0xA4;

36 if((
pBusMsg
->
dwDaTy
 =
YK_EXCT
&& (
byV
 == 0x01))

37 
buf
[
n
++] = 0xA1;

38 if((
pBusMsg
->
dwDaTy
 =
YK_EXCT
&& (
byV
 == 0x00))

39 
buf
[
n
++] = 0xA5;

41  
FALSE
;

44  
FALSE
;

45 
buf
[
n
++] = 0xFF;

46 
buf
[
n
++] = 0x00;

48 
WORD
 
wCRC
 = 
	`GCrc
(
buf
, 
n
);

49 
buf
[
n
++] = 
	`HIBYTE
(
wCRC
);

50 
buf
[
n
++] = 
	`LOBYTE
(
wCRC
);

52  
TRUE
;

53 
	}
}

55 
BOOL
 
	gPMC_530
::
	$GProcBuf
(
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
)

58 
n
 = 0;

59 if(
pBusMsg
 !
NULL
){

60 if(
pBusMsg
->
byMsgTy
 =
YK_PROTO
){

61 
yk_da
 = (
YK_DATA
 *)
pBusMsg
->
pDa
;

62 
ykty
 = 
pBusMsg
->
dwDaTy
;

63 
byBusNo
 = 
pBusMsg
->
SrcInfo
.byBusNo;

64 
wDevNo
 = 
pBusMsg
->
SrcInfo
.wDevNo;

65 
wP
 = 
yk_da
->wPnt;

66 
byV
 = 
yk_da
->byVal;

67 if(
	`GYKBufr
(
buf
, 
n
, 
pBusMsg
)){

68 if
m_wETim
 > 60000 )

69 
m_wETim
 = 
ERROR_CONST
 + 1;

70 
m_wETim
++;

71  
TRUE
;

76 
buf
[
n
++] = 
m_wDevAddr
;

77 
buf
[
n
++] = 0x03;

78 if(
loag
 == 0){

79 
buf
[
n
++] = 0x9C;

80 
buf
[
n
++] = 0xA4;

81 
buf
[
n
++] = 0x00;

82 
buf
[
n
++] = 0x08;

84 if(
loag
 == 1){

85 
buf
[
n
++] = 0x9C;

86 
buf
[
n
++] = 0x40;

87 
buf
[
n
++] = 0x00;

88 
buf
[
n
++] = 0x35;

90 if(
loag
 == 2){

91 
buf
[
n
++] = 0x9C;

92 
buf
[
n
++] = 0xA1;

93 
buf
[
n
++] = 0x00;

94 
buf
[
n
++] = 0x01;

97  
FALSE
;

99 
WORD
 
wCRC
 = 
	`GCrc
(
buf
, 
n
);

100 
buf
[
n
++] = 
	`HIBYTE
(
wCRC
);

101 
buf
[
n
++] = 
	`LOBYTE
(
wCRC
);

102 
loag
++;

103 
loag
 = (loopflag % 3);

105 
m_wETim
++;

106 if(
m_wETim
 > 60000)

107 
m_wETim
 = 
ERROR_CONST
 + 1;

108  
TRUE
;

109 
	}
}

111 
BOOL
 
	gPMC_530
::
	$ResvYkFme
(
BYTE
 *
buf
, &
n
)

113 
WORD
 
vue
 = 0;

114 
WORD
 
wCRC
 = 
	`GCrc
(
buf
, 
n
 - 2);

115 if(
buf
[1] == 0x05){

116 if((
buf
[0] =
m_wDevAddr
&& (buf[6] =
	`HIBYTE
(
wCRC
)&& (buf[7] =
	`LOBYTE
(wCRC))){

117 if((
buf
[2] =0xEA&& (buf[3] =0xA0&& (
ykty
 =
YK_SEL
)){

118 
vue
 = 
buf
[4];

119 
vue
 = vu<< 8 | 
buf
[5];

120 if(
vue
 == 0xFF00)

121 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

123  
FALSE
;

126 if((
buf
[2] =0xEA&& (buf[3] =0xA4&& (
ykty
 =
YK_SEL
)){

127 
vue
 = 
buf
[4];

128 
vue
 = 
buf
[5] | value << 8;

129 if(
vue
 == 0xFF00)

130 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

132  
FALSE
;

135 if((
buf
[2] =0xEA&& (buf[3] =0xA1&& (
ykty
=
YK_EXCT
){

136 
vue
 = 
buf
[4];

137 
vue
 = vu<< 8 | 
buf
[5];

138 if(
vue
 == 0xFF00)

139 
m_pMhod
->
	`SYkExeR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

141  
FALSE
;

144 if((
buf
[2] =0xEA&& (buf[3] =0xA5&& (
ykty
=
YK_EXCT
){

145 
vue
 = 
buf
[4];

146 
vue
 = vu<< 8 | 
buf
[5];

147 if(
vue
 == 0xFF00)

148 
m_pMhod
->
	`SYkExeR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

150  
FALSE
;

154 
m_pMhod
->
	`SYkExeR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
YK_ERROR
);

155  
FALSE
;

160 
m_pMhod
->
	`SYkExeR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
YK_ERROR
);

161  
FALSE
;

163 
m_wETim
 = 0;

164  
TRUE
;

165 
	}
}

167 
	gPMC_530
::
	$ResvYcFme
(
BYTE
 *
buf
)

170 
vue
;

171 
vuemp
[32] = {0};

172 
vuebridge
[20] = {0};

174 
i
=0; i<24; i++){

175 
vue
 = 
buf
[3 + 4*
i
];

176 
j
=4*(
i
+1); j<(7+4*i); j++){

177 
vue
 = (vu<< 8| 
buf
[
j
];

179 
vuemp
[
i
] = 
vue
;

181 
i
=0; i<5; i++){

182 
vue
 = 
buf
[99 + 
i
*2];

183 
vue
 = (vu<< 8| 
buf
[100 + 2*
i
];

184 
vuemp
[24 + 
i
] = 
vue
;

187 
i
 = 0; i < 11; i++)

188 
vuebridge
[
i
] = ()
vuemp
[i];

189 if(
vuemp
[15] & 
TEST
)

190 
vuebridge
[11] = -()((~(
vuemp
[15] - 
TEST
 - 1)) - TEST);

192 
vuebridge
[11] = ()
vuemp
[15];

193 if(
vuemp
[19] & 
TEST
)

194 
vuebridge
[12] = -()((~(
vuemp
[19] - 
TEST
 - 1)) - TEST);

196 
vuebridge
[12] = ()
vuemp
[19];

197 if(
vuemp
[23] & 
TEST
)

198 
vuebridge
[13] = -()((~(
vuemp
[23] - 
TEST
 - 1)) - TEST);

200 
vuebridge
[13] = ()
vuemp
[23];

201 if(
vuemp
[27] & 
TEST0
)

202 
vuebridge
[14] = -()((~(
vuemp
[27] - 
TEST0
 - 1)) - TEST0);

204 
vuebridge
[14] = ()
vuemp
[27];

205 
vuebridge
[15] = ()
vuemp
[28];

206 
vuebridge
[16] = ()
vuemp
[11];

207 
vuebridge
[17] = ()
vuemp
[12];

208 
vuebridge
[18] = ()
vuemp
[13];

209 
vuebridge
[19] = ()
vuemp
[14];

212 
vuebridge
[25] = {0};

213 
vuemp
[32] = {0};

214 
i
 = 0; i < 24; i++)

215 
vuemp
[
i
] = (
buf
[3 + 4*i] << 24) | (buf[4 + 4*i] << 16) | (buf[5 + 4*i] << 8) | buf[6 + 4*i];

216 
i
=0; i < 5; i++)

217 
vuemp
[
i
 + 24] = (
buf
[99 + 2*i] << 8) | buf[100 + 2*i];

218 
i
 = 0; i < 11; i++)

219 
vuebridge
[
i
] = 
vuemp
[i];

221 
vuebridge
[11] = 
vuemp
[15];

222 
vuebridge
[12] = (
vuemp
[19] & 
TEST
) ? -()(~(valuetemp[19] - 1)) : valuetemp[19];

223 
vuebridge
[13] = (
vuemp
[23] & 
TEST
) ? -()(~(valuetemp[19] - 1)) : valuetemp[23];

224 
vuebridge
[14] = (
vuemp
[27] & 0x8000) ? -()((~(valuetemp[27] - 1)) & 0xFFFF) : valuetemp[27];

225 
vuebridge
[15] = 
vuemp
[28];

226 
vuebridge
[16] = 
vuemp
[11];

227 
vuebridge
[17] = 
vuemp
[12];

228 
vuebridge
[18] = 
vuemp
[13];

229 
vuebridge
[19] = 
vuemp
[14];

230 
i
=0; i<20; i++)

231 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
i
, 
vuebridge
[i]);

233 
	}
}

235 
	gPMC_530
::
	$ResvYxFme
(
BYTE
 *
buf
)

237 
WORD
 
vue
 = 
buf
[3];

238 
vue
 = vu<< 8 | 
buf
[4];

239 
vuebridge
[4] = {0};

240 
vuebridge
[0] = 
vue
 & 0x01;

241 if(
vue
 & 0x02)

242 
vuebridge
[1] = 0x01;

243 if(
vue
 & 0x04)

244 
vuebridge
[2] = 0x01;

245 
i
=0; i < 3; i++)

246 
m_pMhod
->
	`SYxDa
(
m_SlNo
, 
i
, 
vuebridge
[i]);

247 
	}
}

249 
	gPMC_530
::
	$ResvYmFme
(
BYTE
 *
buf
)

251 
vue
;

252 
vuebridge
[4];

253 
i
 = 0; i < 4; i++){

254 
vue
 = 
buf
[3 + 
i
*4];

255 
j
 = 4*(
i
 + 1); j < (7 + i*4); j++)

256 
vue
 = (vu<< 8| 
buf
[
j
];

257 
vuebridge
[
i
] = ()
vue
;

259 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 0, 
vuebridge
[0]);

260 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 1, 
vuebridge
[3]);

261 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 2, 
vuebridge
[1]);

262 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 3, 
vuebridge
[2]);

263 
	}
}

265 
BOOL
 
	gPMC_530
::
	$ProssProcBuf
(
BYTE
 *
buf
, 
n
)

268 if((
buf
[1] == 0x05) || (buf[1] == 0x85)){

269 if(
	`ResvYkFme
(
buf
, 
n
))

270  
TRUE
;

272  
FALSE
;

275 
WORD
 
wCRC
 = 
	`GCrc
(
buf
, 
n
 - 2);

276 if((
buf
[
n
-2] !
	`HIBYTE
(
wCRC
)|| (buf[n-1] !
	`LOBYTE
(wCRC)))

277  
FALSE
;

278 
loag
){

280 if(
n
 == 7)

281 
	`ResvYxFme
(
buf
);

283  
FALSE
;

287 if(
n
 == 21)

288 
	`ResvYmFme
(
buf
);

290  
FALSE
;

294 if(
n
 == 111)

295 
	`ResvYcFme
(
buf
);

297  
FALSE
;

301  
FALSE
;

303 
m_wETim
 = 0;

305  
TRUE
;

306 
	}
}

308 
BOOL
 
	gPMC_530
::
	$In
(
BYTE
 
byLeNo
)

310  
TRUE
;

311 
	}
}

313 
	gPMC_530
::
	$TimProc
()

315 if(
m_wETim
 > 
ERROR_CONST
)

316 
m_byPtStus
 = 
COMSTATUS_FAULT
;

318 
m_byPtStus
 = 
COMSTATUS_ONLINE
;

320 
	}
}

322 
BOOL
 
	gPMC_530
::
	$GDevCommS
()

324 if(
m_byPtStus
 =
COMSTATUS_ONLINE
)

325  
COM_DEV_NORMAL
;

327  
COM_DEV_ABNORMAL
;

328 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/PMC_530.h

11 #ide
PMC_530_H


12 
	#PMC_530_H


	)

14 
	~"CProc_ModBusMa.h
"

15 
	tUINT
;

16 
	tUSHORT
;

18 as
	cPMC_530
 : 
public
 
CProc_ModBusMa
{

19 
public
:

20 
PMC_530
();

21 
	mvtu
 ~
PMC_530
();

23 
BYTE
 
	mm_byPtStus
;

24 
	mm_wETim
;

25 
	mloag
;

26 cڡ 
UINT
 
	mTEST
;

27 cڡ 
USHORT
 
	mTEST0
;

28 cڡ 
	mERROR_CONST
;

29 cڡ 
	mCOMSTATUS_ONLINE
;

30 cڡ 
	mCOMSTATUS_FAULT
;

31 
DWORD
 
	mykty
;

32 
YK_DATA
 *
	myk_da
;

33 
BYTE
 
	mbyBusNo
;

34 
WORD
 
	mwDevNo
;

35 
WORD
 
	mwP
;

36 
BYTE
 
	mbyV
;

38 
vtu
 
BOOL
 
GProcBuf
(
BYTE
*, &, 
PBUSMSG
 
pBusMsg
 = 
NULL
);

39 
vtu
 
BOOL
 
ProssProcBuf
(
BYTE
 *, );

40 
vtu
 
BOOL
 
In
(
BYTE
);

42 
vtu
 
TimProc
();

43 
vtu
 
BOOL
 
GDevCommS
();

44 
vtu
 
BOOL
 
ResvYkFme
(
BYTE
 *, &);

45 
vtu
 
ResvYcFme
(
BYTE
 *);

46 
vtu
 
ResvYxFme
(
BYTE
 *);

47 
vtu
 
ResvYmFme
(
BYTE
 *);

48 
vtu
 
BOOL
 
GYKBufr
(
BYTE
 *, &, 
PBUSMSG
);

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_ModBusMa.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

12 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

14 
CProc
 * 
pProc
 = 
NULL
 ;

15 
pProc
 = 
w
 
CProc_ModBusMa
 ;

16 if
pProc
 )

18 
pProc
->
m_pMhod
 = 
pMhod
 ;

19 
	`tf
( "ModBusMaster DLL OK.\n " ) ;

22  
pProc
 ;

23 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/CProtocol_ModBus.cpp

1 
	~"CProc_ModBus.h
"

2 
	~"ModBusRTU.h
"

4 
	#MODULE_RTU
 1

	)

9 
	gAuchCRCHi
[256] = {

38 
	gAuchCRCLo
[256] = {

67 
	gCProc_ModBus
::
	$CProc_ModBus
()

70 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

72 
	}
}

74 
	gCProc_ModBus
::~
	$CProc_ModBus
()

77 
size
 = 
m_modu
.
	`size
() ;

78  
i
 = 0 ; i < 
size
 ; i++ )

80 
de
 
m_modu
[ 
i
 ] ;

82 
m_modu
.
	`r
() ;

83 
	`tf
( "Delete All CProtocol_ModBus OK . \n" );

84 
	}
}

86 
BOOL
 
	gCProc_ModBus
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

88  
FALSE
 ;

89 
	}
}

91 
BOOL
 
	gCProc_ModBus
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

93  
FALSE
 ;

94 
	}
}

96 
BOOL
 
	gCProc_ModBus
::
	$In

BYTE
 
byLeNo
 )

100 
m_byLeNo
 = 
byLeNo
 ;

102 
m_ProTy
 = 
PROTOCO_GATHER
 ;

104  
	`GDevDa
( ) ;

105 
	}
}

107 
BOOL
 
	gCProc_ModBus
::
	$GDevDa
( )

109 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

110 
	`rtf

m_sDevPh
 , "%s/ModBus/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

111 
CProfe
 
	`ofe

m_sDevPh
 ) ;

113  
	`ProssFeDa

ofe
 ) ;

114 
	}
}

116 
BOOL
 
	gCProc_ModBus
::
	$ProssFeDa

CProfe
 &
ofe
 )

118 
BOOL
 
bR
 = 
FALSE
;

119 if!
ofe
.
	`IsVid
() )

121 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

122  
FALSE
 ;

125 
sSe
[ 200 ] = "DEVNUM" ;

126 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

128 
WORD
 
wModu
 = 0 ;

129 
ro
=1 ;

130 
WORD
 
addr
 =3 ;

131 
sName
[ 50 ] = { 0 };

132 
eme
[ 200 ] = { 0 };

133 
iNum
 = 0 ;

135 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

136 if
iNum
 == 0 )

138 
	`tf
( "Get DEVNUM Failed ! \n " );

139  
FALSE
 ;

142  
i
 = 0 ; i < 
iNum
 ; i++ )

144 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

146 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

147 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

148 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

149 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

150 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

153 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

154 i!
bR
 )

156 
	`tf
 ( "CModBuModu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

158  
FALSE
;

162  
TRUE
 ;

163 
	}
}

165 
BOOL
 
	gCProc_ModBus
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

167 
CProc_ModBus
 * 
pProc
 = 
NULL
 ;

168 
BOOL
 
bR
 = 
FALSE
;

169  
iModu
 )

171 
MODULE_RTU
:

173 
pProc
 = 
w
 
CModBusRTU
 ;

174 
pProc
->
m_byLeNo
 = m_byLineNo ;

175 
pProc
->
m_wModuTy
 = 
iModu
 ;

176 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

177 
pProc
->
m_SlNo
 = 
iSlNo
 ;

179 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

180 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

181 
pProc
->
m_pMhod
 = m_pMethod ;

182 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

184 
bR
 = 
pProc
->
	`In

m_byLeNo
 ) ;

185 i!
bR
 )

187 
	`tf
 ( "Init Error \n");

188  
FALSE
;

190 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

195 
	`tf
( "ModBus don't containhis module Failed .\n" );

196  
FALSE
 ;

199 
m_modu
.
	`push_back

pProc
 ) ;

201  
TRUE
 ;

202 
	}
}

204 
WORD
 
	gCProc_ModBus
::
	$GCrc

BYTE
 * 
pBuf
 , 
n
 )

206 
uchCRCHi
 = 0xFF;

207 
uchCRCLo
 = 0xFF;

208 
uIndex
;

210  
n
-- )

212 
uIndex
 = 
uchCRCHi
 ^ *
pBuf
++ ;

213 
uchCRCHi
 = 
uchCRCLo
 ^ 
AuchCRCHi
[
uIndex
];

214 
uchCRCLo
 = 
AuchCRCLo
[
uIndex
] ;

216  (
uchCRCHi
 << 8 | 
uchCRCLo
) ;

217 
	}
}

219 
BOOL
 
	gCProc_ModBus
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

222 
dex
 = 0 ;

223 
buf
[ 
dex
++ ] = 0xFF ;

224 
buf
[ 
dex
++ ] = 0x02 ;

225 
buf
[ 
dex
++ ] = 0x03 ;

226 
buf
[ 
dex
++ ] = 0x04 ;

228 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

229 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

230 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

232 
n
 = 
dex
 ;

234 
	`tf
( "\n CProtocol_ModBus TestBroadCast \n " ) ;

235  
TRUE
 ;

236 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/CProtocol_ModBus.h

1 #ide
CPROTOCOL_MODBUS_H


2 
	#CPROTOCOL_MODBUS_H


	)

4 
	~"../../she/CProc.h
"

5 
	~"../../she/CMhod.h
"

7 as
	cCProc_ModBus
 : 
public
 
CProc


9 
public
:

10 
CProc_ModBus
();

11 
	mvtu
 ~
CProc_ModBus
();

12 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

13 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

14 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

15 
vtu
 
WORD
 
GCrc

BYTE
 * 
pBuf
 , 
n
 );

16 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 ) ;

17 
vtu
 
	$TimProc
(){ ; }

18 
eed
:

19 
BOOL
 
	`GDevDa
( ) ;

20 
eed
:

21 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

22 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

24 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/ModBusRTU.cpp

5 
	~"ModBusRTU.h
"

9 
	~<dio.h
>

10 
	~<time.h
>

11 
	~<sigl.h
>

12 
	~<ve
>

13 
	~<mh.h
>

16 
	#MODBUSRTUPREFIXFILENAME
 "/mynd/cfig/ModBus/me/"

	)

20 
	#TIME
 300

	)

21 
	#ERROR_CONST
 5

	)

22 
	#COMSTATUS_ONLINE
 1

	)

23 
	#COMSTATUS_FAULT
 0

	)

25 
	#MASK
 0xffffffff

	)

29 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

30 "C" 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
);

31 
usg
 
mea
 
	gd
;

36 
	gCModBusRTU
::
	$CModBusRTU
()

38 
pos_ag
 = -1;

39 
pos
 = 0;

40 
ime_pos
 = 0;

41 
yk_pos_num
 = 0;

42 
yk_ag
 = 0;

43 
adv_ag
 = -1;

44 
wrev_ag
 = -1;

45 
ϡ_ime
 = 0;

46 
timeag
 = 0;

47 
YkNo
 = 0;

48 
MsgEFg
 = 0;

49 
ESL411SOEFg
 = 0;

50 
	`memt
(
e_buf
,0,(store_buf));

52 
m_wETim
 = 
ERROR_CONST
+1;

53 
m_byPtStus
 = 
COMSTATUS_FAULT
;

54 
DevCFg
 = 
FALSE
;

55 
modbus_cf
.
	`rve
(100);

58 
	`memt
(&
yc_cf
, 0, (
MODBUSCONF
));

59 
	`memt
(&
ym_cf
, 0, (
MODBUSCONF
));

60 
	`memt
(&
yx_cf
, 0, (
MODBUSCONF
));

62 
	}
}

64 
	gCModBusRTU
::~
	$CModBusRTU
()

66 
	`tf
"DCModBusRTU bu%d , Add%d \n" , 
m_byLeNo
 , 
m_wDevAddr
 );

67 
yk_fo
.
	`r
();

70 
modbus_cf
.
	`r
() ;

72 
	}
}

74 
BOOL
 
	gCModBusRTU
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

80 if
modbus_cf
.
	`size
() <= 0 )

81  
FALSE
;

85 if
pBusMsg
 !
NULL
 )

87 if
pBusMsg
->
byMsgTy
 =
YK_PROTO
 )

89 if
TRUE
 =
	`GYKBufr

buf
 , 
n
 , 
pBusMsg
 ) )

91 if
pBusMsg
->
dwDaTy
 =
YK_EXCT
 || (BusMsg->dwDaTy =
YK_SEL
 && 
modbus_cf
[
pos_ag
].
YkSFg
 == 1 ) )

93 
m_wETim
++;

94 if
m_wETim
 > 60000 )

95 
m_wETim
 = 
ERROR_CONST
 + 1 ;

96 
MsgRegieAndDa
[0] = 
buf
[2];

97 
MsgRegieAndDa
[1] = 
buf
[3];

98 
MsgRegieAndDa
[2] = 
buf
[4];

99 
MsgRegieAndDa
[3] = 
buf
[5];

101  
TRUE
;

105  
FALSE
;

109 if
yk_ag
 > 0 )

111 
yk_ag
++;

112 if
yk_ag
 >= 3 )

114 
yk_ag
 = 0;

116 
	`memy

buf
 , 
YkBuf
 , 
YkL
 );

117 
n
 = 
YkL
;

121 if
DevCFg
 =
FALSE
 )

122  
FALSE
;

177 if
modbus_cf
[
pos
].
c_ag
 == 0 ) )

179 
pos
 = (pos+1)%
le
;

182 if
modbus_cf
[
pos
].
ty
 == 8 ) )

184 if
timeag
 > 
TIME
 )

186 
timeag
 = 0;

187 
	`SdBuf

modbus_cf
[
ime_pos
] , 
buf
 , &
n
 );

188 
pos_ag
 = 
ime_pos
;

189 
	`time
(&
ϡ_ime
);

190 
pos
 = (pos+1)%
le
;

195 
pos
 = (pos+1)%
le
;

199 if
modbus_cf
[
pos
].
ty
 == 3 ) )

201 
pos
 = (pos+1)%
le
;

205 
	`SdBuf

modbus_cf
[
pos
] , 
buf
 , &
n
 );

206 
pos_ag
 = 
pos
;

207 
pos
 = (pos+1)%
le
;

210 if
ESL411SOEFg
 == 1 )

212 
	`E411SSdBuf

buf
 , &
n
 );

216 
m_wETim
++;

217 if
m_wETim
 > 60000 )

218 
m_wETim
 = 
ERROR_CONST
 + 1 ;

219 
MsgRegieAndDa
[0] = 
buf
[2];

220 
MsgRegieAndDa
[1] = 
buf
[3];

221 
MsgRegieAndDa
[2] = 
buf
[4];

222 
MsgRegieAndDa
[3] = 
buf
[5];

223  
TRUE
 ;

224 
	}
}

226 
BOOL
 
	gCModBusRTU
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

230 
BYTE
 
mp_ag
 = 0;

231 
BYTE
 
CRC_ag
 = 0;

232 
WORD
 
wCRC
 = 0 ;

235  
n
 > 4 )

237 if
buf
[0] =
m_wDevAddr
 )

239 if
buf
[1] =
modbus_cf
[
pos_ag
].
func
 )

241 if
buf
[1] > 0 ) && ( buf[1] < 5 ) || buf[1] == 0x55 )

243 if
buf
[2] + 5 ) <
n
 )

265 if
modbus_cf
[
pos_ag
].
ty
 == 1 )

267 if
modbus_cf
[
pos_ag
].
gie_num
%8 !0&& ( 
buf
[2] == 1 + modbus_conf[pos_flag].registe_num/8 ) )

269 
CRC_ag
 = 1;

271 if
modbus_cf
[
pos_ag
].
gie_num
%8 =0&& ( 
buf
[2] == modbus_conf[pos_flag].registe_num/8 ) )

273 
CRC_ag
 = 1;

276 i
buf
[2] =
modbus_cf
[
pos_ag
].
gie_num
*2 + modbus_cf[pos_ag].
giumc
 * 2 + modbus_cf[pos_ag].
giumthi
 * 2 )

278 
CRC_ag
 = 1;

283 if
buf
[1] == 0x55 )

285 
CRC_ag
 = 1;

287 i
buf
[2] =
modbus_cf
[
pos_ag
].
gie_num
*2 + modbus_cf[pos_ag].
giumc
 * 2 + modbus_cf[pos_ag].
giumthi
 * 2)

289 
CRC_ag
 = 1;

295 if
CRC_ag
 == 1 )

297 
wCRC
 = 
	`GCrc

buf
, buf[2] + 3 );

298 if
	`HIBYTE
(
wCRC
=
buf
[ buf[2] + 3 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ buf[2] + 4 ] ) )

300 
mp_ag
 = 1;

306 i
buf
[1] == 0x5 || buf[1] == 0x6 || buf[1] == 0xf || buf[1] == 0x10 )

308 if
MsgRegieAndDa
[0] =
buf
[2] && MsgRegisteAndData[1] == buf[3] &&

309 
MsgRegieAndDa
[2] =
buf
[4] && MsgRegisteAndData[3] == buf[5] )

311 
wCRC
 = 
	`GCrc

buf
, 6 );

312 if
	`HIBYTE
(
wCRC
=
buf
[ 6 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ 7 ] ) )

314 
mp_ag
 = 1;

320 if
buf
[1] =
modbus_cf
[
pos_ag
].
func
 | 0x80 ) )

322 
wCRC
 = 
	`GCrc

buf
, 3 );

323 if
	`HIBYTE
(
wCRC
=
buf
[ 3 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ 4 ] ) )

325 
modbus_cf
[
pos_ag
].
ty
)

328 
yk_ag
 = 0;

331 
bufr
[100] = "";

332 
	`rtf
(
bufr
,"fun%xnnum:%d\n",
buf
[1],buf[2]);

333 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
bufr
, 
	`
(buffer),3);

337 if
modbus_cf
[
pos_ag
].
YkSFg
 =1 && 
buf
[1] =0x10 && modbus_cf[pos_ag].
func
 == 0x05 )

339 if
buf
[2] == 0x40 && buf[3] == 0x59 && buf[4] == 0x00 && buf[5] == 0x03 )

341 
wCRC
 = 
	`GCrc

buf
, 6 );

342 if
	`HIBYTE
(
wCRC
=
buf
[ 6 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ 7 ] ) )

344 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
YkNo
 , 
YkV
 );

345  
TRUE
 ;

349 if
modbus_cf
[
pos_ag
].
SFg
 =2 && ( 
buf
[1] == 0x02 || buf[1] == 0x03 || buf[1] == 0x0c) )

351 
wCRC
 = 
	`GCrc

buf
, buf[2] + 3 );

352 if
	`HIBYTE
(
wCRC
=
buf
[ buf[2] + 3 ] ) && ( 
	`LOBYTE
(wCRC) == buf[ buf[2] + 4 ] ) )

354 
mp_ag
 = 1;

360 
buf
 = buf + 1 ;

361 
bufr
[100] = "the message changed!";

362 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
bufr
, 
	`
(buffer),3);

363 
n
--;

365 if
mp_ag
 == 1 )

367 
modbus_cf
[
pos_ag
].
ty
)

370 
	`ModBusYxDl
(
buf
,
modbus_cf
[
pos_ag
]);

373 
	`ModBusYcDl
(
buf
,
modbus_cf
[
pos_ag
]);

376 
	`ModBusYkDl
(
buf
,
modbus_cf
[
pos_ag
] );

379 
	`ModBusYmDl
(
buf
,
modbus_cf
[
pos_ag
]);

382 
	`ModBusRdV
(
buf
,
modbus_cf
[
pos_ag
]);

385 
	`ModBusWreV
(
buf
,
modbus_cf
[
pos_ag
]);

388 
	`ModBusSTime
(
buf
,
modbus_cf
[
pos_ag
]);

391 
	`ModBusSDl
(
buf
,
modbus_cf
[
pos_ag
]);

393 : 
FALSE
;

396 if
mp_ag
 == 0 )

398 
bufr
[100] = "the message is wrong!";

399 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
bufr
, 
	`
(buffer),3);

400  
FALSE
;

402 if
MsgEFg
 =
MSGERROR
 )

404 
MsgEFg
 = 
MSGTRUE
;

405 
bufr
[100] = "the config is wrong!";

406 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
bufr
, 
	`
(buffer),3);

407  
FALSE
;

409 
m_wETim
 = 0;

410  
TRUE
 ;

411 
	}
}

413 
BOOL
 
	gCModBusRTU
::
	$In

BYTE
 
byLeNo
 )

416 
szFeName
[256] = "";

417 
	`rtf

szFeName
, "%s%s", 
MODBUSRTUPREFIXFILENAME
, 
m_sTemePh
);

418 
le
 = 
	`RdCf
(
szFeName
);

420 if
le
 <= 0 )

423 
	`tf
("d'found %s\n",
szFeName
);

424 
MODBUSCONF
 
mc
;

425 
	`DeuVCfig
(&
mc
);

426 
modbus_cf
.
	`push_back

mc
 );

427 
le
 = 1;

429  
TRUE
 ;

430 
	}
}

433 
	gCModBusRTU
::
	$TimProc
()

435 
time_t
 
mp_time
;

436 
	`time
(&
mp_time
);

437 
timeag
 = ()
mp_time
 - 
ϡ_ime
 );

439 if
m_wETim
 > 
ERROR_CONST
 )

443 
m_byPtStus
 = 
COMSTATUS_FAULT
;

453 
m_byPtStus
 = 
COMSTATUS_ONLINE
;

456 
	}
}

459 
BOOL
 
	gCModBusRTU
::
	$GYKBufr

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

461 
i
 = 0;

462 
YK_DATA
 *
yk_da
;

463 
yk_da
 = (
YK_DATA
 *)
pBusMsg
->
pDa
;

467 if
pBusMsg
 =
NULL
 ) && ( 
yk_pos_num
 == 0 ) )

468  
FALSE
 ;

469 
bySrcBusNo
 = 
pBusMsg
->
SrcInfo
.
byBusNo
;

470 
wSrcDevAddr
 = 
pBusMsg
->
SrcInfo
.
wDevNo
;

472 if
pBusMsg
->
dwDaTy
 =
YK_SEL
 ||BusMsg->dwDaTy =
YK_CANCEL
 )

474  
i
=0 ; i<
yk_pos_num
 ; i++ )

476 if
yk_da
->
wP
 =
yk_fo
[
i
].
t_num
 )

479 if
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 == 2 ) ||

480 
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 =
yk_da
->
byV
 ) )

482 if
pBusMsg
->
dwDaTy
 =
YK_SEL
 )

484 
yk_ag
 = 0;

485  
modbus_cf
[
yk_fo
[
i
].
pos
].
YkSFg
 )

488 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
yk_da
->
wP
 , yk_da->
byV
 );

491 
YkNo
 = 
yk_da
->
wP
;

492 if
yk_da
->
byV
 =0 && 
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 == 2 )

493 
YkV
 = 0;

495 
YkV
 = 1;

496 
	`YkPtSdBuf

modbus_cf
[
yk_fo
[
i
].
pos
] , 
yk_da
 , 
buf
 , &
n
 );

497 
pos_ag
 = 
yk_fo
[
i
].
pos
;

498  
TRUE
 ;

499 : 
FALSE
 ;

505 
yk_ag
 = 0;

506 
m_pMhod
->
	`SYkClR

this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
yk_da
->
wP
 , yk_da->
byV
 );

508  
TRUE
 ;

512 
yk_da
->
byV
 = 
YK_ERROR
;

513 
yk_ag
 = 0;

514 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
yk_da
->
wP
 , yk_da->
byV
 );

515  
TRUE
 ;

517 if
pBusMsg
->
dwDaTy
 =
YK_EXCT
 )

520  
i
=0 ; i<
yk_pos_num
 ; i++ )

522 if
yk_da
->
wP
 =
yk_fo
[
i
].
t_num
 )

525 if
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 == 2 ) ||

526 
modbus_cf
[
yk_fo
[
i
].
pos
].
yk_fm
 =
yk_da
->
byV
 ) )

528  
modbus_cf
[
yk_fo
[
i
].
pos
].
YkExFg
 )

531 
	`YkSdBuf

modbus_cf
[
yk_fo
[
i
].
pos
] , 
yk_da
 , 
buf
 , &
n
 );

534 
	`YkJ05SdBuf

modbus_cf
[
yk_fo
[
i
].
pos
] , 
yk_da
 , 
buf
 , &
n
 );

536 : 
FALSE
;

539 
YkNo
 = 
yk_da
->
wP
;

540 
pos_ag
 = 
yk_fo
[
i
].
pos
;

541  
TRUE
 ;

546 
yk_da
->
byV
 = 
YK_ERROR
;

547 
yk_ag
 = 0;

548 
m_pMhod
->
	`SYkExeR

this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
yk_da
->
wP
 , yk_da->
byV
 );

549  
TRUE
 ;

551 if
pBusMsg
->
dwDaTy
 =
YK_CANCEL
 )

552 
	`tf
( "YK_CANCEL \n" );

554  
TRUE
 ;

555 
	}
}

558 
	gCModBusRTU
::
	$Atoh
(*
buf
)

560 
BYTE
 
i
 = 0;

561 
UINT
 
mpvue
 = 0;

562 
UINT
 
vue
 = 0;

563 
BYTE
 
n
 = 
	`
(
buf
);

565 
i
=0;i<
n
;i++)

567 if(
buf
[
i
]>='A') && (buf[i]<='F') )

569 
mpvue
 = 
buf
[
i
]-'A'+10;

571 if(
buf
[
i
]>='a') && (buf[i]<='f') )

573 
mpvue
 = 
buf
[
i
]-'a'+10;

575 if(
buf
[
i
]>='0') && (buf[i]<='9') )

577 
mpvue
 = 
buf
[
i
]-'0';

579 
vue
 = vue*16+
mpvue
;

581  
vue
;

582 
	}
}

585 
	gCModBusRTU
::
	$DeuVCfig
(
MODBUSCONF
 * 
mc
)

587 
mc
->
ty
 = 1;

588 
mc
->
func
 = 2;

589 
mc
->
gie
 = 0x0064;

590 
mc
->
gie_num
 = 0;

591 
mc
->
skew_by
 = 3;

592 
mc
->
g_num
 = 0;

593 
mc
->
t_num
 = 0;

594 
mc
->
da_n
 = 1;

595 
mc
->
mask_code
 = 0xffffffff;

596 
mc
->
da_fm
 = 0;

597 
mc
->
sign
 = 0;

598 
mc
->
yk_fm
 = 2;

599 
mc
->
c_ag
 = 1;

600 
	}
}

603 
	gCModBusRTU
::
	$RdCf
(*
fame
)

605 
FILE
 *
hFe
;

606 
szText
[160];

607 *
mp
;

608 
num
 = 0;

609 
BYTE
 
i
 = 0;

610 
BYTE
 
cag
 = 0;

611 
MODBUSCONF
 
mc
;

612 
INFO
 
yk
,
adv
,
wrev
;

616 
hFe
 = 
	`fݒ
(
fame
, "r");

618 if(
hFe
 =
NULL
)

625  
	`fgs
(
szText
, (szText), 
hFe
!
NULL
 )

627 
	`rim
(
szText
);

628 if
szText
[0]=='#' || szText[0]==';' )

630 
i
 = 0;

631 
cag
 = 0;

632 
	`memt
(&
mc
,0,(mc));

634 
mp
 = 
	`ok
(
szText
,",");

635 if(
mp
 =
NULL
)

637 if
	`oi
(
mp
) > 0 ) && (toi(temp) < 10 ) )

638 
mc
.
ty
 = 
	`oi
(
mp
);

641 
cag
 = 1;

642 
	`DeuVCfig
(&
mc
);

644  ( 
mp
 = 
	`ok
(
NULL
,",") ) )

646 ++
i
)

649 if
	`Atoh
(
mp
) > 0 ) && ( Atoh(temp) <= 7 ) ) || ( Atoh(temp) == 0x0f )

650 || ( 
	`Atoh
(
mp
) == 0x10 ) || ( Atoh(temp) == 0x55 ) || ( Atoh(temp) == 0x0c ) )

651 
mc
.
func
 = 
	`Atoh
(
mp
);

653 
cag
 = 1;

656 if
	`Atoh
(
mp
) >= 0 ) && ( Atoh(temp) <= 0xffff ) )

657 
mc
.
gie
 = 
	`Atoh
(
mp
);

659 
cag
 = 1;

662 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

663 
mc
.
gie_num
 = 
	`oi
(
mp
);

665 
cag
 = 1;

669 if
	`oi
(
mp
) >= 0 &&toi(emp ) <= 258 )

670 
mc
.
skew_by
 = 
	`oi
(
mp
);

672 
cag
 = 1;

675 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

676 
mc
.
g_num
 = 
	`oi
(
mp
);

678 
cag
 = 1;

681 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

682 
mc
.
t_num
 = 
	`oi
(
mp
);

684 
cag
 = 1;

687 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 4 ) )

688 
mc
.
da_n
 = 
	`oi
(
mp
);

690 
cag
 = 1;

693 if
	`Atoh
(
mp
) >= 0 ) && ( Atoh(temp) <= 0xffffffff ) )

694 
mc
.
mask_code
 = 
	`Atoh
(
mp
);

696 
cag
 = 1;

699 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 5 ) )

700 
mc
.
da_fm
 = 
	`oi
(
mp
);

702 
cag
 = 1;

705 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 4 ) )

706 
mc
.
sign
 = 
	`oi
(
mp
);

708 
cag
 = 1;

711 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

712 
mc
.
yk_fm
 = 
	`oi
(
mp
);

714 
cag
 = 1;

717 if
	`oi
(
mp
) == 0 ) || (toi(temp) == 1 ) )

719 
mc
.
c_ag
 = 
	`oi
(
mp
);

720 if
mc
.
c_ag
 == 1 )

721 
DevCFg
 = 
TRUE
;

724 
cag
 = 1;

729 if((
	`oi
(
mp
) >= 0) && (atoi(temp) <= 0xFF))

730 
mc
.
tyc
 = 
	`oi
(
mp
);

732 
cag
 = 1;

735 if((
	`oi
(
mp
) >= 0) && (atoi(temp) <= 0xFF))

736 
mc
.
giumc
 = 
	`oi
(
mp
);

738 
cag
 = 1;

741 if((
	`oi
(
mp
) >= 0) && (atoi(temp) <= 0xFFFF))

742 
mc
.
gnumc
 = 
	`oi
(
mp
);

744 
cag
 = 1;

747 if((
	`oi
(
mp
) >= 0) && (atoi(temp) <= 0xFFFF))

748 
mc
.
osc
 = 
	`oi
(
mp
);

750 
cag
 = 1;

753 if((
	`oi
(
mp
) >= 0) && (atoi(temp) <= 0xFF))

754 
mc
.
tythi
 = 
	`oi
(
mp
);

756 
cag
 = 1;

759 if((
	`oi
(
mp
) >= 0) && (atoi(temp) <= 0xFF))

760 
mc
.
giumthi
 = 
	`oi
(
mp
);

762 
cag
 = 1;

765 if((
	`oi
(
mp
) >= 0) && (atoi(temp) <= 0xFFFF))

766 
mc
.
gnumthi
 = 
	`oi
(
mp
);

768 
cag
 = 1;

771 if((
	`oi
(
mp
) >= 0) && (atoi(temp) <= 0xFFFF))

772 
mc
.
ohi
 = 
	`oi
(
mp
);

774 
cag
 = 1;

779 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

780 
mc
.
YkClo

	`Atoh
(
mp
);

782 
cag
 = 1;

785 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 0xffff ) )

786 
mc
.
YkOn

	`Atoh
(
mp
);

788 
cag
 = 1;

791 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

792 
mc
.
STimeFg
 = 
	`oi
(
mp
);

794 
cag
 = 1;

797 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

798 
mc
.
SFg
 = 
	`oi
(
mp
);

800 
cag
 = 1;

803 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

804 
mc
.
YkSFg
 = 
	`oi
(
mp
);

806 
cag
 = 1;

809 if
	`oi
(
mp
) >= 0 ) && (toi(temp) <= 2 ) )

810 
mc
.
YkExFg
 = 
	`oi
(
mp
);

812 
cag
 = 1;

815 
cag
 = 1;

816 
	`tf
("\n\n\n%d > 18\n\n\n",
i
+1);

819 if
cag
 == 1 )

821 
cag
 = 1;

822 
	`tf
("ModBus config filerror:\n");

827 if
cag
 == 1 )

829 
	`tf
("%num i%d %d\n\n\n",
fame
,
num
+1,
i
+1);

830 
	`DeuVCfig
(&
mc
);

832 if
i
 < 26)

834  
i
 + 1 )

836 13:
mc
.
tyc
 = 0;

837 14:
mc
.
giumc
 = 0;

838 15:
mc
.
gnumc
 = 0;

839 16:
mc
.
osc
 = 0;

840 17:
mc
.
tythi
 = 0;

841 18:
mc
.
giumthi
 = 0;

842 19:
mc
.
gnumthi
 = 0;

843 20:
mc
.
ohi
 = 0;

844 21:
mc
.
YkClo
= 0xff00;

845 22:
mc
.
YkOn
= 0x0000;

846 23:
mc
.
STimeFg
 = 0;

847 24:
mc
.
SFg
 = 0;

848 25:
mc
.
YkSFg
 = 0;

849 26:
mc
.
YkExFg
 = 0;;

856 if((
yx_cf
.
ty
 !1&& (
mc
.type == 1))

857 
yx_cf
 = 
mc
;

858 if((
yc_cf
.
ty
 !2&& (
mc
.type == 2))

859 
yc_cf
 = 
mc
;

860 if((
ym_cf
.
ty
 !4&& (
mc
.type == 4))

861 
ym_cf
 = 
mc
;

862 
modbus_cf
.
	`push_back

mc
 );

863 
num
++;

865 
u
 = 
	`fo
(
hFe
);

866 if
u
 )

867 
	`
("fclose");

871 
i
=0;i<
num
;i++)

873 if
modbus_cf
[
i
].
ty
 == 3 )

875 
yk
.
pos
 = 
i
;

876 
yk
.
t_num
 = 
modbus_cf
[
i
].start_num;

877 
yk
.
g_num
 = 
modbus_cf
[
i
].get_num;

880 
yk_fo
.
	`push_back

yk
 );

881 
yk_pos_num
++;

883 if
modbus_cf
[
i
].
ty
 == 5 )

885 
adv
.
pos
 = 
i
;

886 
adv
.
t_num
 = 
modbus_cf
[
i
].start_num;

887 
adv
.
g_num
 = 
modbus_cf
[
i
].get_num;

891 
adv_pos_num
++;

893 if
modbus_cf
[
i
].
ty
 == 6 )

895 
wrev
.
pos
 = 
i
;

896 
wrev
.
t_num
 = 
modbus_cf
[
i
].start_num;

897 
wrev
.
g_num
 = 
modbus_cf
[
i
].get_num;

901 
wrev_pos_num
++;

903 if
modbus_cf
[
i
].
ty
 == 8 )

905 
ime_pos
 = 
i
;

908  
num
;

909 
	}
}

911 
	gCModBusRTU
::
	$TimePackMcBigEdn
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
,
tm
 *
p
,
WORD
 
mc
)

913 
bufr
[
i
++] = 
modbuscf
.
gie_num
*2;

914 
bufr
[
i
++] = (
p
->
tm_yr
)-100;

915 
bufr
[
i
++] = 1+(
p
->
tm_m
);

916 
bufr
[
i
++] = 
p
->
tm_mday
;

917 
bufr
[
i
++] = 
p
->
tm_hour
;

918 
bufr
[
i
++] = 
p
->
tm_m
;

919 
bufr
[
i
++] = 
p
->
tm_c
;

920 
bufr
[
i
++] = 
mc
 >> 8;

921 
bufr
[
i
++] = 
mc
 ;

922  
i
;

923 
	}
}

925 
	gCModBusRTU
::
	$TimePackMcLeEdn
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
,
tm
 *
p
,
WORD
 
mc
)

927 
bufr
[
i
++] = 
modbuscf
.
gie_num
*2;

928 
bufr
[
i
++] = (
p
->
tm_yr
)-100;

929 
bufr
[
i
++] = 1+(
p
->
tm_m
);

930 
bufr
[
i
++] = 
p
->
tm_mday
;

931 
bufr
[
i
++] = 
p
->
tm_hour
;

932 
bufr
[
i
++] = 
p
->
tm_m
;

933 
bufr
[
i
++] = 
p
->
tm_c
;

934 
bufr
[
i
++] = 
mc
;

935 
bufr
[
i
++] = 
mc
 >> 8;

936  
i
;

937 
	}
}

940 
	gCModBusRTU
::
	$SysLolTime
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
)

942 
timev
 
tv
;

943 
timeze
 
tz
;

946 
tm
 
p
;

948 
	`gtimeofday
&
tv
 , &
tz
 );

951 
	`loime_r
&
tv
.
tv_c
 , &
p
 );

953 
uc
[10] = "";

954 
	`rtf

uc
, "%06ld", 
tv
.
tv_uc
);

955  
	`
(
uc
) )

958 
uc
[1] = '\0';

961 
uc
[2] = '\0';

964 
uc
[3] = '\0';

967 
	`memt

uc
 , 0 , (usec) );

970 
WORD
 
mc
 = 
	`oi
(
uc
);

972  
modbuscf
.
STimeFg
 )

975 
i
 = 
	`TimePackMcBigEdn
(
modbuscf
,
bufr
,i,&
p
,
mc
);

978 
i
 = 
	`TimePackMcLeEdn
(
modbuscf
,
bufr
,i,&
p
,
mc
);

981 
i
 = 
	`TimePackMcBigEdn
(
modbuscf
,
bufr
,i,&
p
,
mc
);

986  
i
;

987 
	}
}

989 
	gCModBusRTU
::
	$E411SSdBuf
(
BYTE
 * 
buf
 ,*
n
)

991 
BYTE
 
dex
 = 0;

993 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

994 
buf
[ 
dex
++ ] = 0x0c;

995 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

996 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

997 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

998 *
n
 = 
dex
;

999 
	}
}

1002 
	gCModBusRTU
::
	$SdBuf

MODBUSCONF
 
modbuscf
, 
BYTE
 * 
buf
 ,*
n
 )

1004 
BYTE
 
dex
 = 0;

1006 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1007 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1008 if
modbuscf
.
ty
 =9 && modbuscf.
SFg
 == 0 )

1014 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1015 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 ;

1016 
buf
[ 
dex
++ ] = (
modbuscf
.
gie_num
 >> 8+ (modbuscf.
giumc
 >> 8+ (modbuscf.
giumthi
 >> 8) + (modbusconf.registe_num + modbusconf.registenumsec + modbusconf.registenumthi) / 256;

1017 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 + modbuscf.
giumc
 + modbuscf.
giumthi
;

1036 if
modbuscf
.
ty
 == 8 )

1038 
dex
 = 
	`SysLolTime
(
modbuscf
,
buf
,index);

1041 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1042 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1043 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1044 *
n
 = 
dex
;

1045 
	}
}

1048 
	gCModBusRTU
::
	$YkPtSdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
 )

1050 
BYTE
 
dex
 = 0;

1051 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1052 
buf
[ 
dex
++ ] = 0x10;

1053 
buf
[ 
dex
++ ] = 0x40;

1054 
buf
[ 
dex
++ ] = 0x59;

1055 
buf
[ 
dex
++ ] = 0x00;

1056 
buf
[ 
dex
++ ] = 0x03;

1057 
buf
[ 
dex
++ ] = 0x06;

1058 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1059 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1060 
buf
[ 
dex
++ ] = ( 
modbuscf
.
gie
 << 8 ) >> 8;

1063 if
yk_da
->
byV
 =0 && 
modbuscf
.
yk_fm
 ==2 )

1065 
buf
[ 
dex
++ ] = 0x00;

1066 
buf
[ 
dex
++ ] = 0x00;

1070 
buf
[ 
dex
++ ] = 0xff;

1071 
buf
[ 
dex
++ ] = 0x00;

1073 
buf
[ 
dex
++ ] = 0xff;

1074 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1075 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1076 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1077 *
n
 = 
dex
;

1078 
	}
}

1081 
	gCModBusRTU
::
	$YkJ05SdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
 )

1084 
BYTE
 
dex
 = 0;

1085 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1086 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1087 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1088 
buf
[ 
dex
++ ] = ( 
modbuscf
.
gie
 << 8 ) >> 8;

1089 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 >> 8;

1090 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 ;

1091 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 ;

1093 if(
yk_da
->
byV
 =0 && 
modbuscf
.
yk_fm
 ==2)

1095 
buf
[ 
dex
++ ] = 0x00;

1099 
buf
[ 
dex
++ ] = 0x01;

1101 
YkV
 = 
buf
[ 
dex
 - 1 ];

1102 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1103 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1104 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1105 *
n
 = 
dex
;

1106 
	}
}

1109 
	gCModBusRTU
::
	$YkSdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
 )

1112 
BYTE
 
dex
 = 0;

1113 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1114 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1115 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1116 
buf
[ 
dex
++ ] = ( 
modbuscf
.
gie
 << 8 ) >> 8;

1118 if(
yk_da
->
byV
 =0 && 
modbuscf
.
yk_fm
 ==2)

1120 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
modbuscf
.
YkOn
);

1121 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
modbuscf
.
YkOn
);

1125 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
modbuscf
.
YkClo
);

1126 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
modbuscf
.
YkClo
);

1128 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1129 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1130 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1131 *
n
 = 
dex
;

1132 
	}
}

1134 
	gCModBusRTU
::
	$RdvSdBuf

MODBUSCONF
 
modbuscf
 , 
BYTE
 * 
buf
 ,*
n
 )

1136 
BYTE
 
dex
 = 0;

1137 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1138 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1139 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1140 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
;

1141 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 >> 8;

1142 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
;

1143 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1144 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1145 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1146 *
n
 = 
dex
;

1147 
	}
}

1149 
	gCModBusRTU
::
	$WrevSdBuf

MODBUSCONF
 
modbuscf
 , * 
v
 , 
BYTE
 * 
buf
 ,*
n
 )

1151 
dex
 = 0;

1152 
buf
[ 
dex
++ ] = 
m_wDevAddr
;

1153 
buf
[ 
dex
++ ] = 
modbuscf
.
func
;

1154 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
 >> 8;

1155 
buf
[ 
dex
++ ] = 
modbuscf
.
gie
;

1156 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 >> 8;

1157 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
 ;

1158 
buf
[ 
dex
++ ] = 
modbuscf
.
gie_num
*2 ;

1159 
i
 = 0;

1160 
da_n
 = 
modbuscf
.data_len;

1161 
wre_num
 = (2*
modbuscf
.
gie_num
)/modbuscf.
da_n
;

1162  
wre_num
-- )

1164  
da_n
-- )

1166 
buf
[ 
dex
++ ] = 
v
[
i
] >> ( 8 * 
da_n
 ) ;

1168 
da_n
 = 
modbuscf
.data_len;

1169 
i
++;

1171 
WORD
 
wCRC
 = 
	`GCrc

buf
, 
dex
 );

1172 
buf
[ 
dex
++ ] = 
	`HIBYTE
(
wCRC
);

1173 
buf
[ 
dex
++ ] = 
	`LOBYTE
(
wCRC
);

1174 *
n
 = 
dex
;

1175 
	}
}

1178 
	gCModBusRTU
::
	$TwoByVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
)

1180 
v
 = 0;

1181 
buf
[2] = "";

1188 
buf
[0] = 
bufr
[
a
];

1189 
buf
[1] = 
bufr
[
a
+1];

1190 
modbuscf
.
da_fm
)

1193 
v
 = (
buf
[0]<<8 | buf[1]);

1196 
v
 = (
buf
[0] | buf[1]<<8);

1199 
MsgEFg
 = 
MSGERROR
;

1202  
v
;

1203 
	}
}

1206 
	gCModBusRTU
::
	$FourByVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
)

1208 
v
 = 0;

1210 
buf
[4] = "";

1218 
buf
[0] = 
bufr
[
a
];

1219 
buf
[1] = 
bufr
[
a
+1];

1220 
buf
[2] = 
bufr
[
a
+2];

1221 
buf
[3] = 
bufr
[
a
+3];

1222 
modbuscf
.
da_fm
)

1225 
v
 = (
buf
[0]<<24 | buf[1]<<16 | buf[2]<<8 | buf[3]);

1228 
v
 = (
buf
[0]<<16 | buf[1]<<24 | buf[2] | buf[3]<<8);

1231 
v
 = (
buf
[0]<<8 | buf[1] | buf[2]<<24 | buf[3]<<16);

1234 
v
 = (
buf
[0] | buf[1]<<8 | buf[2]<<16 | buf[3]<<24);

1237 
MsgEFg
 = 
MSGERROR
;

1240  
v
;

1241 
	}
}

1244 
	gCModBusRTU
::
	$FltVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
)

1246 
v
 = 0;

1247 
t_buf
[4] = "";

1249 
buf
[4] = "";

1251 
mp_mask
 = 
modbuscf
.
mask_code
;

1252 
buf
[0] = 
bufr
[
a
] & (
mp_mask
>>24);

1253 
buf
[1] = 
bufr
[
a
+1] & ((
mp_mask
<<8)>>24);

1254 
buf
[2] = 
bufr
[
a
+2] & ((
mp_mask
<<16)>>24);

1255 
buf
[3] = 
bufr
[
a
+3] & ((
mp_mask
<<24)>>24);

1256 
modbuscf
.
da_fm
)

1259 
t_buf
[3] = 
buf
[0];

1260 
t_buf
[2] = 
buf
[1];

1261 
t_buf
[1] = 
buf
[2];

1262 
t_buf
[0] = 
buf
[3];

1265 
t_buf
[2] = 
buf
[0];

1266 
t_buf
[3] = 
buf
[1];

1267 
t_buf
[0] = 
buf
[2];

1268 
t_buf
[1] = 
buf
[3];

1271 
t_buf
[1] = 
buf
[0];

1272 
t_buf
[0] = 
buf
[1];

1273 
t_buf
[3] = 
buf
[2];

1274 
t_buf
[2] = 
buf
[3];

1277 
t_buf
[0] = 
buf
[0];

1278 
t_buf
[1] = 
buf
[1];

1279 
t_buf
[2] = 
buf
[2];

1280 
t_buf
[3] = 
buf
[3];

1283 
MsgEFg
 = 
MSGERROR
;

1286 
v
 = *(*)
t_buf
;

1287  
v
;

1288 
	}
}

1291 
	gCModBusRTU
::
	$ModBusVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
)

1293 
vue_f
 = 0;

1294 
vue_i
 = 0;

1295 
vue_ui
 = 0;

1296 
vue_s
 = 0;

1297 
vue_us
 = 0;

1298 
modbuscf
.
sign
)

1302 if(
modbuscf
.
da_n
 == 2)

1304 
vue_us
 = ()
	`TwoByVue
(
bufr
,
a
,
modbuscf
);

1305  ()
vue_us
;

1307 if(
modbuscf
.
da_n
 == 4)

1309 
vue_ui
 = ()
	`FourByVue
(
bufr
,
a
,
modbuscf
);

1310  ()
vue_ui
;

1315 if(
modbuscf
.
da_n
 == 2)

1317 
vue_s
 = 
	`TwoByVue
(
bufr
,
a
,
modbuscf
);

1318 if
vue_s
 < 0 )

1319 
vue_s
 = ( (~value_s) | 0x8000 ) + 1;

1320  ()
vue_s
;

1322 if(
modbuscf
.
da_n
 == 4)

1324 
vue_i
 = 
	`FourByVue
(
bufr
,
a
,
modbuscf
);

1325 if
vue_i
 < 0 )

1326 
vue_i
 = ( (~value_i) | 0x80000000 ) + 1;

1327  ()
vue_i
;

1332 if(
modbuscf
.
da_n
 == 2)

1334 
vue_s
 = 
	`TwoByVue
(
bufr
,
a
,
modbuscf
);

1335  ()
vue_s
;

1337 if(
modbuscf
.
da_n
 == 4)

1339 
vue_i
 = 
	`FourByVue
(
bufr
,
a
,
modbuscf
);

1340  ()
vue_i
;

1345 
vue_f
 = 
	`FltVue
(
bufr
,
a
,
modbuscf
);

1346  
vue_f
;

1349 
vue_f
 = 
	`FltVue
(
bufr
,
a
,
modbuscf
);

1350  
	`bs
(
vue_f
);

1353 
MsgEFg
 = 
MSGERROR
;

1356  
vue_f
;

1357 
	}
}

1360 
	gCModBusRTU
::
	$ModBusYxDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1362 if
modbuscf
.
SFg
 == 2 )

1364 
	`ModBusR_411YxYcDl

bufr
 , 
modbuscf
 );

1371 
	`ModBusYxBDl
(
bufr
,
modbuscf
);

1377 
	}
}

1379 
UINT
 
	gCModBusRTU
::
	$ModBusYXTempVue
(*
bufr
, 
pos
, 
MODBUSCONF
 
modbuscf
)

1381 
vue_i
 = 0;

1382 
vue_ui
 = 0;

1383 
vue_s
 = 0;

1384 
vue_us
 = 0;

1385 
BYTE
 
vue_b
;

1387 if(
modbuscf
.
da_n
 == 1)

1389 
vue_b
 = 
bufr
[
pos
] ;

1390  (
UINT
)
vue_b
;

1392 if(
modbuscf
.
da_n
 == 2)

1394 
vue_s
 = ()
	`TwoByVue
(
bufr
,
pos
,
modbuscf
);

1395 
	`memy
&
vue_us
 , &
vue_s
 , 2 );

1396  (
UINT
)
vue_us
;

1398 if(
modbuscf
.
da_n
 == 4)

1400 
vue_i
 = ()
	`FourByVue
(
bufr
,
pos
,
modbuscf
);

1401 
	`memy
&
vue_ui
 , &
vue_i
 , 4 );

1402  
vue_ui
;

1406 
MsgEFg
 = 
MSGERROR
;

1409 
	}
}

1412 
	gCModBusRTU
::
	$ModBusYxBDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1414 
WORD
 
i
 = 0;

1415 
WORD
 
j
 = 0;

1416 
BYTE
 
pos
 = 0;

1417 
BYTE
 
da_n
 = 0;

1418 
WORD
 
g_num
 = 0;

1419 
WORD
 
t_num
 = 0;

1420 
WORD
 
_g_num
 = 0;

1421 
UINT
 
mp_buf
 = 0;

1422 
UINT
 
mp_mask
 = 0;

1423 if(
modbuscf
.
ty
 == 1){

1424 
pos
 = 
modbuscf
.
skew_by
;

1425 
mp_buf
 = 
bufr
[
pos
];

1426 
mp_mask
 = 
modbuscf
.
mask_code
;

1427 
g_num
 = 
modbuscf
.get_num;

1428 
t_num
 = 
modbuscf
.start_num;

1429 
da_n
 = 
modbuscf
.data_len;

1430 
_g_num
 = 
modbuscf
.
gie_num
 * 16;

1431 }if(
modbuscf
.
tyc
 == 1){

1432 
pos
 = 0;

1433 
mp_buf
 = 
bufr
[
pos
];

1434 
mp_mask
 = 
modbuscf
.
mask_code
;

1435 
g_num
 = 
modbuscf
.
gnumc
;

1436 
t_num
 = 
modbuscf
.
osc
;

1437 
da_n
 = 
yx_cf
.data_len;

1438 
_g_num
 = 
modbuscf
.
giumc
 * 16;

1439 }if(
modbuscf
.
tythi
 == 1){

1440 
pos
 = 0;

1441 
mp_buf
 = 
bufr
[
pos
];

1442 
mp_mask
 = 
modbuscf
.
mask_code
;

1443 
g_num
 = 
modbuscf
.
gnumthi
;

1444 
t_num
 = 
modbuscf
.
ohi
;

1445 
da_n
 = 
yx_cf
.data_len;

1446 
_g_num
 = 
modbuscf
.
giumthi
 * 16;

1449 
WORD
 
num
 = 0;

1450 
WORD
 
wV
 = 0;

1451 
UINT
 
_mp_mask
 =0;

1453 if
modbuscf
.
SFg
 == 2 )

1455 
g_num
 = 25;

1458 if
_g_num
 < 
g_num
 )

1460 
g_num
 = 
_g_num
;

1463 
i
 = 0; i < ((
_g_num
-1/ (8*
da_n
) )+1); i++)

1465  
da_n
 )

1468 
_mp_mask
 = 
	`ModBusYXTempVue
(*)&
mp_mask
 , 3 , (
modbuscf
.
ty
 =1? modbusc: 
yx_cf
);

1471 
_mp_mask
 = 
	`ModBusYXTempVue
(*)&
mp_mask
 , 2 , (
modbuscf
.
ty
 =1? modbusc: 
yx_cf
);

1474 
_mp_mask
 = 
	`ModBusYXTempVue
(*)&
mp_mask
 , 0 , (
modbuscf
.
ty
 =1? modbusc: 
yx_cf
);

1477 
MsgEFg
 = 
MSGERROR
;

1481 
mp_buf
 = 
	`ModBusYXTempVue

bufr
 , 
pos
 , (
modbuscf
.
ty
 =1? modbusc: 
yx_cf
);

1482 
pos
 +
da_n
;

1484 
j
=0;j<
da_n
*8;j++)

1486 if
num
 >((
modbuscf
.
ty
 =1? modbuscf.
g_num
 : ((modbuscf.
tyc
 =1? modbuscf.
gnumc
 : modbuscf.
gnumthi
)))

1488 if(
modbuscf
.
ty
 == 1)

1493 if(
_mp_mask
%2)

1495 
wV
 = 
mp_buf
%2;

1496 
m_pMhod
->
	`SYxDa
 ( 
m_SlNo
 , 
num
+
t_num
 , 
wV
 );

1500 
num
++;

1502 
_mp_mask
 /= 2;

1503 
mp_buf
 /= 2;

1506 if(
modbuscf
.
ty
 == 1){

1507 if(
modbuscf
.
tyc
 == 2)

1508 
	`ModBusYcDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2, modbusconf);

1509 if(
modbuscf
.
tyc
 == 4)

1510 
	`ModBusYmDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2, modbusconf);

1511 if(
modbuscf
.
tythi
 == 2)

1512 
	`ModBusYcDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2 + modbuscf.
giumc
 * 2, modbusconf);

1513 if(
modbuscf
.
tythi
 == 4)

1514 
	`ModBusYmDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2 + modbuscf.
giumc
 * 2, modbusconf);

1516 
	}
}

1518 
	gCModBusRTU
::
	$ModBusYxByDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1519 {
	}
}

1521 
	gCModBusRTU
::
	$ModBusR_411YxYcDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1523 
BYTE
 
Fun

bufr
[1];

1524  
Fun
 )

1527 
	`ModBusYxBDl

bufr
 , 
modbuscf
 );

1528 
ESL411SOEFg
 = ( 
bufr
[5] & 0x04 )/4 ;

1531 
	`ModBusYcDl

bufr
 , 
modbuscf
 );

1534 
	`ModBusE_411SDl

bufr
 , 
modbuscf
 );

1539 
	}
}

1542 
	gCModBusRTU
::
	$ModBusYcDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1544 
BYTE
 
pos
 = 0;

1545 
WORD
 
g_num
 = 0;

1546 
WORD
 
t_num
 = 0;

1547 
WORD
 
_g_num
 = 0;

1548 if(
modbuscf
.
ty
 == 2){

1549 
pos
 = 
modbuscf
.
skew_by
;

1550 
g_num
 = 
modbuscf
.get_num;

1551 
t_num
 = 
modbuscf
.start_num;

1552 
_g_num
 = 
modbuscf
.
gie_num
 * 2 / modbuscf.
da_n
;

1553 }if(
modbuscf
.
tyc
 == 2){

1554 
pos
 = 0;

1555 
g_num
 = 
modbuscf
.
gnumc
;

1556 
t_num
 = 
modbuscf
.
osc
;

1557 
_g_num
 = 
modbuscf
.
giumc
 * 2 / 
yc_cf
.
da_n
;

1558 }if(
modbuscf
.
tythi
 == 2){

1559 
pos
 = 0;

1560 
g_num
 = 
modbuscf
.
gnumthi
;

1561 
t_num
 = 
modbuscf
.
ohi
;

1562 
_g_num
 = 
modbuscf
.
giumc
 * 2 / 
yc_cf
.
da_n
;

1565 
WORD
 
i
 = 0;

1566 
wV
 = 0 ;

1567 
i
=0;i<
g_num
;i++)

1569 
wV
 = 0 ;

1570 if
i
 < 
_g_num
 )

1571 
wV
 = 
	`ModBusVue
(
bufr
,
pos
,(
modbuscf
.
ty
 =2? modbusc: 
yc_cf
);

1572 if
MsgEFg
 =
MSGERROR
 )

1576 
pos
 +(
modbuscf
.
ty
 =1? modbuscf.
da_n
 : 
yc_cf
.data_len;

1577 
m_pMhod
->
	`SYcDa

m_SlNo
 , 
i
+
t_num
 , 
wV
 );

1583 if(
modbuscf
.
ty
 == 2){

1584 if(
modbuscf
.
tyc
 == 1)

1585 
	`ModBusYxDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2, modbusconf);

1586 if(
modbuscf
.
tyc
 == 4)

1587 
	`ModBusYmDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2, modbusconf);

1588 if(
modbuscf
.
tythi
 == 1)

1589 
	`ModBusYxDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2 + modbuscf.
giumc
 * 2, modbusconf);

1590 if(
modbuscf
.
tythi
 == 4)

1591 
	`ModBusYmDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2 + modbuscf.
giumc
 * 2, modbusconf);

1593 
	}
}

1595 
	gCModBusRTU
::
	$ModBusJ05YkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
 )

1597 
m_pMhod
->
	`SYkExeR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
YkNo
 , 
YkV
 );

1601 
	}
}

1604 
	gCModBusRTU
::
	$ModBusRtuYkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
 )

1606 
WORD
 
i
 = 0;

1607 
BYTE
 
ykV
= 2;

1608 
BYTE
 
pos
 = 
modbuscf
.
skew_by
 ;

1609 
UINT
 
g_num
 = 
modbuscf
.get_num;

1610 
UINT
 
t_num
 = 
modbuscf
.start_num;

1611 
UINT
 
gie
 = 
modbuscf
.registe;

1613 
cv_buf
[
g_num
];

1614 
	`memt
(
cv_buf
,0,
g_num
);

1616 
yk_ag
 = 0;

1618 
i
=0;i<
g_num
;i++)

1620 
cv_buf
[
i
] = ()
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1621 if
MsgEFg
 =
MSGERROR
 )

1625 
pos
 +
modbuscf
.
da_n
;

1628 if
gie
 + 
YkNo
 - 
t_num
 ) =
cv_buf
[0] )

1630 if
modbuscf
.
YkClo
 =
cv_buf
[1] )

1631 
ykV
 = 1;

1632 if
modbuscf
.
YkOn
 =
cv_buf
[1] )

1633 
ykV
 = 0;

1634 
m_pMhod
->
	`SYkExeR
 ( 
this
 , 
bySrcBusNo
, 
wSrcDevAddr
 , 
YkNo
 , 
ykV
 );

1639 
	}
}

1641 
	gCModBusRTU
::
	$ModBusYkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
 )

1643  
modbuscf
.
YkExFg
 )

1646 
	`ModBusRtuYkDl

bufr
 , 
modbuscf
 );

1649 
	`ModBusJ05YkDl

bufr
 , 
modbuscf
 );

1652 
MsgEFg
 = 
MSGERROR
;

1655 
	}
}

1658 
	gCModBusRTU
::
	$ModBusYmDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1660 
BYTE
 
pos
 = 0;

1661 
WORD
 
g_num
 = 0;

1662 
WORD
 
t_num
 = 0;

1663 
WORD
 
_g_num
 = 0;

1665 if(
modbuscf
.
ty
 == 4){

1666 
pos
 = 
modbuscf
.
skew_by
;

1667 
g_num
 = 
modbuscf
.get_num;

1668 
t_num
 = 
modbuscf
.start_num;

1670 
_g_num
 = 
modbuscf
.
gie_num
 * 2 / modbuscf.
da_n
;

1671 }if(
modbuscf
.
tyc
 == 4){

1672 
pos
 = 0;

1673 
g_num
 = 
modbuscf
.
gnumc
;

1674 
t_num
 = 
modbuscf
.
osc
;

1675 
_g_num
 = 
modbuscf
.
giumc
 * 2 / 
ym_cf
.
da_n
;

1676 }if(
modbuscf
.
tythi
 == 4){

1677 
pos
 = 0;

1678 
g_num
 = 
modbuscf
.
gnumthi
;

1679 
t_num
 = 
modbuscf
.
ohi
;

1680 
_g_num
 = 
modbuscf
.
giumthi
 * 2 / 
ym_cf
.
da_n
;

1683 
WORD
 
i
 = 0;

1684 
wV
 = 0 ;

1686 
i
=0;i<
g_num
;i++)

1688 
wV
 = 0;

1689 if
i
 < 
_g_num
 )

1690 
wV
 = 
	`ModBusVue
(
bufr
,
pos
,(
modbuscf
.
ty
 =4? modbusc: 
ym_cf
);

1691 if
MsgEFg
 =
MSGERROR
 )

1695 
pos
 +(
modbuscf
.
ty
 =4? modbuscf.
da_n
 : 
ym_cf
.data_len;

1696 
m_pMhod
->
	`SYmDa
 ( 
m_SlNo
, 
i
+
t_num
, 
wV
 );

1702 if(
modbuscf
.
ty
 == 4){

1703 if(
modbuscf
.
tyc
 == 1)

1704 
	`ModBusYxDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2, modbusconf);

1705 if(
modbuscf
.
tyc
 == 2)

1706 
	`ModBusYcDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2, modbusconf);

1707 if(
modbuscf
.
tythi
 == 1)

1708 
	`ModBusYxDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2 + modbuscf.
giumc
 * 2, modbusconf);

1709 if(
modbuscf
.
tythi
 == 2)

1710 
	`ModBusYcDl
(
bufr
 + 
modbuscf
.
skew_by
 + modbuscf.
gie_num
 * 2 + modbuscf.
giumc
 * 2, modbusconf);

1712 
	}
}

1715 
	gCModBusRTU
::
	$ModBusSTime
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1717 
BYTE
 
pos
 = 
modbuscf
.
skew_by
 ;

1718 
WORD
 
g_num
 = 
modbuscf
.get_num;

1722 
cv_buf
[
g_num
];

1723 
	`memt
(
cv_buf
,0,
g_num
);

1725 
WORD
 
i
 = 0;

1727 
i
=0;i<
g_num
;i++)

1729 
cv_buf
[
i
] = ()
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1730 
pos
 +
modbuscf
.
da_n
;

1736 
	}
}

1738 
	gCModBusRTU
::
	$ModBusRtuSDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1740 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1742 
i
 = 0;

1743 
BYTE
 
sag
 = 0;

1744 
TIMEDATA
 
mDa
;

1746 
i
=1;i<
bufr
[
pos
-1];i+=8)

1748 if0x0 =
bufr
[
i
+
pos
] & 0xc0 ) )

1750 
sag
 = 1;

1752 if0xc0 =
bufr
[
i
+
pos
] & 0xc0 ) )

1754 
sag
 = 0;

1761 
mDa
.
MiSec
(
bufr
[
i
+
pos
+6] & 0xc0) << 2 ) | buffer[i+pos+7];

1762 
mDa
.
Secd

bufr
[
i
+
pos
+6] & 0x3f;

1763 
mDa
.
Mu

bufr
[
i
+
pos
+5];

1764 
mDa
.
Hour
 = 
bufr
[
i
+
pos
+4];

1765 
mDa
.
Day
 = 
bufr
[
i
+
pos
+3];

1766 
mDa
.
Mth
 = 
bufr
[
i
+
pos
+2];

1767 
mDa
.
Yr
 = 
bufr
[
i
+
pos
+1];

1769 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
bufr
[
i
+
pos
] & 0x3f, 
sag
, &
mDa
 );

1776 
	}
}

1778 
	gCModBusRTU
::
	$ModBusYZ202SDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1780 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1783 
WORD
 
wP
 = 0;

1784 
BYTE
 
sag
 = 0;

1785 
TIMEDATA
 
mDa
;

1787 if
bufr
[
pos
+1] & 0x02 ) == 0x02 )

1788 
sag
 = 1;

1789 if
bufr
[
pos
+1] & 0x02 ) == 0x00 )

1790 
sag
 = 0;

1792  
bufr
[
pos
] )

1794 4:
wP
 = 0;;

1795 8:
wP
 = 1;;

1796 9:
wP
 = 2;;

1798 
sag
 = 1;

1799  
bufr
[
pos
+10] )

1801 0x00:
wP
 = 3;;

1802 0x01:
wP
 = 4;;

1803 0x02:
wP
 = 5;;

1804 0x03:
wP
 = 6;;

1806  
bufr
[
pos
+11] )

1808 0x33:
wP
 = 7;
sag
 = 0;;

1809 0x55:
wP
 = 7;;

1811 
MsgEFg
 = 
MSGERROR
;

1816  
bufr
[
pos
+11] )

1818 0x33:
wP
 = 8;
sag
 = 0;;

1819 0x55:
wP
 = 8;;

1821 
MsgEFg
 = 
MSGERROR
;

1826 
MsgEFg
 = 
MSGERROR
;

1830 17:
wP
 = 9;;

1831 18:
wP
 = 10;;

1832 19:
wP
 = 11;;

1833 21:
wP
 = 12;;

1834 22:
wP
 = 13;;

1835 23:
wP
 = 14;;

1836 24:
wP
 = 15;;

1837 25:
wP
 = 16;;

1838 26:
wP
 = 17;;

1839 27:
wP
 = 18;;

1840 28:
wP
 = 19;;

1841 31:
wP
 = 20;;

1842 35:
wP
 = 21;;

1843 37:
wP
 = 22;;

1844 38:
wP
 = 23;;

1845 39:
wP
 = 24;;

1846 42:
wP
 = 25;;

1848 
MsgEFg
 = 
MSGERROR
;

1854 
mDa
.
MiSec

bufr
[
pos
+8] | (buffer[pos+9] << 8);

1855 
mDa
.
Secd

bufr
[
pos
+7];

1856 
mDa
.
Mu

bufr
[
pos
+6];

1857 
mDa
.
Hour
 = 
bufr
[
pos
+5];

1858 
mDa
.
Day
 = 
bufr
[
pos
+4];

1859 
mDa
.
Mth
 = 
bufr
[
pos
+3];

1860 
mDa
.
Yr
 = 
bufr
[
pos
+2];

1862 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
wP
, 
sag
, &
mDa
 );

1869 
	}
}

1871 
	gCModBusRTU
::
	$ModBusE_411SDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1873 
BYTE
 
pos
 = 
modbuscf
.
skew_by
;

1874 
WORD
 
wP
 = 0;

1875 
BYTE
 
sag
 = 0;

1876 
BYTE
 
SAribu
 = 0;

1877 
BYTE
 
dex
 = 0;

1878 
TIMEDATA
 
mDa
;

1880 if
bufr
[
pos
-1] == 0 )

1882 
ESL411SOEFg
 = 0;

1885 if
bufr
[
pos
-1] == 0x0f )

1887 
ESL411SOEFg
 = 1;

1891 
mDa
.
MiSec

bufr
[
pos
+1] | (buffer[pos] << 8);

1892 
mDa
.
Secd

bufr
[
pos
+2];

1893 
mDa
.
Mu

bufr
[
pos
+3];

1894 
mDa
.
Hour
 = 
bufr
[
pos
+4];

1895 
mDa
.
Day
 = 
bufr
[
pos
+5];

1896 
mDa
.
Mth
 = 
bufr
[
pos
+6];

1897 
mDa
.
Yr
 = 
bufr
[
pos
+7];

1899 
SAribu
 = 
bufr
[
pos
+8];

1900 
dex
 = 
bufr
[
pos
+9];

1901 if
dex
 > 31 )

1904  
SAribu
 )

1907 
wP
 = 
dex
;

1910 
wP
 = 
dex
 + 32;

1913 
wP
 = 
dex
 + 64;

1919  
bufr
[
pos
+10] )

1922 
sag
 = 1;

1925 
sag
 = 0;

1931 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
wP
, 
sag
, &
mDa
 );

1932 
buf
[100] = "";

1933 
	`rtf
(
buf
,"SOE m_byLineNo:%d m_wDevAddr%dum:%d val:%dime:%d.%d.%d-%d:%d:%d.%d\n",

1934 
m_byLeNo
, 
m_wDevAddr
 , 
wP
 , 
sag
 ,

1935 
mDa
.
Yr
,mDa.
Mth
,mDa.
Day
,mDa.
Hour
,mDa.
Mu
,mDa.
Secd
,mDa.
MiSec
);

1936 
	`OutBusDebug
(
m_byLeNo
, (
BYTE
 *)
buf
, 
	`
(buf),3);

1938 
	}
}

1941 
	gCModBusRTU
::
	$ModBusSDl
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1943  
modbuscf
.
SFg
 )

1946 
	`ModBusRtuSDl

bufr
 , 
modbuscf
 );

1949 
	`ModBusYZ202SDl

bufr
 , 
modbuscf
 );

1952 
MsgEFg
 = 
MSGERROR
;

1955 
	}
}

1957 
	gCModBusRTU
::
	$ModBusRdV
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1959 
pos
 = 
modbuscf
.
skew_by
;

1960 
g_num
 = 
modbuscf
.get_num;

1961 
i
 = 0;

1963 
i
=0;i<
g_num
;i++)

1965 
wV
 = 0 ;

1966 
wV
 = 
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1968 
pos
 +
modbuscf
.
da_n
;

1971 
	}
}

1973 
	gCModBusRTU
::
	$ModBusWreV
(*
bufr
,
MODBUSCONF
 
modbuscf
)

1975 
pos
 = 
modbuscf
.
skew_by
;

1976 
g_num
 = 
modbuscf
.get_num;

1980 
cv_buf
[
g_num
];

1981 
	`memt
(
cv_buf
,0,
g_num
);

1983 
i
 = 0;

1985 
i
=0;i<
modbuscf
.
g_num
;i++)

1987 
cv_buf
[
i
] = ()
	`ModBusVue
(
bufr
,
pos
,
modbuscf
);

1988 
pos
 +
modbuscf
.
da_n
;

1995 
	}
}

1997 
BOOL
 
	gCModBusRTU
::
	$GDevCommS
( )

1999 if(
m_byPtStus
 =
COMSTATUS_ONLINE
)

2001  
COM_DEV_NORMAL
 ;

2005  
COM_DEV_ABNORMAL
 ;

2007 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/ModBusRTU.h

5 #i!
defed
(
AFX_MODBUSRTU_H__B73038B4_D223_4CF3_BB34_5F1A02A9777E__INCLUDED_
)

6 
	#AFX_MODBUSRTU_H__B73038B4_D223_4CF3_BB34_5F1A02A9777E__INCLUDED_


	)

7 
	#MSGERROR
 (1)

	)

8 
	#MSGTRUE
 (0)

	)

11 #i
_MSC_VER
 > 1000

12 #agm



14 
	~<sys/time.h
>

15 
	~"CProc_ModBus.h
"

16 
	~"../../she/rdbFun.h
"

17 
	~"../../she/gDaTy.h
"

20 
	~<ve
>

21 
usg
 
mea
 
	gd
;

23 #agm
ck
(1)

27 
BYTE
 
	mty
;

28 
BYTE
 
	mfunc
;

29 
WORD
 
	mgie
;

30 
WORD
 
	mgie_num
;

31 
BYTE
 
	mskew_by
;

32 
WORD
 
	mg_num
;

33 
WORD
 
	mt_num
;

34 
BYTE
 
	mda_n
;

35 
UINT
 
	mmask_code
;

36 
BYTE
 
	mda_fm
;

37 
BYTE
 
	msign
;

38 
BYTE
 
	myk_fm
;

39 
BYTE
 
	mc_ag
;

40 
WORD
 
	mYkClo
;

41 
WORD
 
	mYkOn
;

42 
BYTE
 
	mSTimeFg
;

43 
BYTE
 
	mSFg
;

44 
BYTE
 
	mYkSFg
;

45 
BYTE
 
	mYkExFg
;

49 
BYTE
 
	mtyc
;

50 
BYTE
 
	mgiumc
;

51 
WORD
 
	mgnumc
;

52 
WORD
 
	mosc
;

53 
BYTE
 
	mtythi
;

54 
BYTE
 
	mgiumthi
;

55 
WORD
 
	mgnumthi
;

56 
WORD
 
	mohi
;

57 }
	tMODBUSCONF
;

61 
BYTE
 
	mpos
;

62 
WORD
 
	mt_num
;

63 
WORD
 
	mg_num
;

64 }
	tINFO
;

66 as
	cCModBusRTU
 : 
public
 
CProc_ModBus


68 
public
:

69 
CModBusRTU
();

70 
	mvtu
 ~
CModBusRTU
();

72 
	me_buf
[2][128];

73 
	mpos_ag
;

74 
	mle
;

75 
	myk_ag
;

76 
	madv_ag
;

77 
	mwrev_ag
;

78 
	mv_ag
;

79 
	mpos
;

80 
	mime_pos
;

81 
	myk_pos_num
;

82 
	madv_pos_num
;

83 
	mwrev_pos_num
;

84 
	mϡ_ime
;

85 
	mm_wETim
;

86 
	mm_byPtStus
;

87 
	mtimeag
;

88 
BYTE
 
	mbySrcBusNo
;

89 
WORD
 
	mwSrcDevAddr
;

90 
	mYkNo
;

91 
BYTE
 
	mYkV
;

92 
BYTE
 
	mYkBuf
[256];

93 
	mYkL
;

94 
BYTE
 
	mMsgEFg
;

95 
BYTE
 
	mMsgRegieAndDa
[4];

97 
BYTE
 
	mESL411SOEFg
;

98 
BOOL
 
	mDevCFg
;

101 
CSemObj
 
	mm_hSem
;

103 
	mve
 < 
	mINFO
 > 
	myk_fo
;

106 
	mve
 < 
	mMODBUSCONF
 > 
	mmodbus_cf
;

110 
WORD
 
	mSumOfYc
;

111 
WORD
 
	mSumOfYm
;

112 
WORD
 
	mSumOfYx
;

115 
MODBUSCONF
 
	myc_cf
;

116 
MODBUSCONF
 
	mym_cf
;

117 
MODBUSCONF
 
	myx_cf
;

119 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

120 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

121 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

122 
BOOL
 
GYKBufr

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 );

123 
vtu
 
TimProc
();

125 
DeuVCfig
(
MODBUSCONF
 * 
mc
);

127 
Atoh
(*
buf
);

130 
RdCf
(*
fame
);

132 
TimePackMcBigEdn
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
,
tm
 *
p
,
WORD
 
mc
);

134 
TimePackMcLeEdn
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
,
tm
 *
p
,
WORD
 
mc
);

136 
SysLolTime
(
MODBUSCONF
 
modbuscf
,*
bufr
,
i
);

139 
SdBuf

MODBUSCONF
 
modbuscf
 , 
BYTE
 * 
buf
 ,*
n
);

142 
YkPtSdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
 );

145 
YkJ05SdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
);

148 
YkSdBuf

MODBUSCONF
 
modbuscf
 , 
YK_DATA
 *
yk_da
 , 
BYTE
 * 
buf
 ,*
n
);

151 
RdvSdBuf

MODBUSCONF
 
modbuscf
 , 
BYTE
 * 
buf
 ,*
n
 );

154 
WrevSdBuf

MODBUSCONF
 
modbuscf
 , * 
v
 , 
BYTE
 * 
buf
 ,*
n
 );

157 
E411SSdBuf
(
BYTE
 * 
buf
 ,*
n
);

159 
TwoByVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
);

161 
FourByVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
);

163 
FltVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
);

166 
ModBusVue
(*
bufr
, 
a
, 
MODBUSCONF
 
modbuscf
);

169 
ModBusYxDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

172 
UINT
 
ModBusYXTempVue
(*
bufr
, 
pos
, 
MODBUSCONF
 
modbuscf
);

175 
ModBusYxBDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

178 
ModBusYxByDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

180 
ModBusR_411YxYcDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

183 
ModBusYcDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

186 
ModBusJ05YkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

188 
ModBusRtuYkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

190 
ModBusYkDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

193 
ModBusYmDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

196 
ModBusSTime
(*
bufr
,
MODBUSCONF
 
modbuscf
);

199 
ModBusRtuSDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

202 
ModBusYZ202SDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

206 
ModBusE_411SDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

209 
ModBusSDl
(*
bufr
,
MODBUSCONF
 
modbuscf
);

212 
ModBusRdV
(*
bufr
,
MODBUSCONF
 
modbuscf
);

215 
ModBusWreV
(*
bufr
,
MODBUSCONF
 
modbuscf
);

218 
RecvBuf
(
MODBUSCONF
 
modbuscf
);

221 
BOOL
 
YK_MsgPss

YK_DATA
 * 
pYkDa
 ) ;

224 
vtu
 
BOOL
 
GDevCommS
( ) ;

227 #agm
ck
( )

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/main.cpp

2 
	~<dio.h
>

3 
	~"CProc_ModBus.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

12 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

14 
CProc
 * 
pProc
 = 
NULL
 ;

15 
pProc
 = 
w
 
CProc_ModBus
 ;

16 if
pProc
 )

18 
pProc
->
m_pMhod
 = 
pMhod
 ;

22  
pProc
 ;

23 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_ESD_ModBusSlave.cpp

5 
	~"Proc_ESD_ModBusSve.h
"

6 
	~"../../BayLay/ma.h
"

8 
	#MAXLINE
 22

	)

9 
	#MODBUSSLAVE_PATH
 "/mynd/cfig/ModBusSve/"

	)

14 
	#ERR_FUNC
 0x01

	)

15 
	#ERR_ADDR
 0x02

	)

16 
	#ERR_DATA
 0x03

	)

18 
	#MBS_YX_COUNT
 20001

	)

19 
	#MBS_YC_COUNT
 36801

	)

20 
	#MBS_YK_COUNT
 10000

	)

21 
	#MBS_YM_COUNT
 37825

	)

22 
	#MBS_YX_DEVSTATE_COUNT
 21001

	)

23 
	#MBS_BUS_RSADDR
 50000

24 

	)

25 
	#CLOSE_STATE
 1

	)

27 
	#SETYX
 0x0001

	)

28 
	#SETYC
 0x0002

	)

29 
	#SETYM
 0x0004

	)

30 
	#SETYK
 0x0008

	)

31 
	#SET_DEVSTATE_YX
 0x0010

32 
	#SET_BUS_COUNT
 0x0020

33 
	#SETADDR
 0x0100

	)

34 
	#SETDATA
 0x0200

	)

35 
	#SETFUC
 0x0400

	)

37 um { 
	mYC
 , 
	mYX
 , 
	mYM
 , 
	mYK
 };

39 
	gCProc_ESD_ModBusSve
::
	$CProc_ESD_ModBusSve
()

41 
	}
}

43 
CProc_ESD_ModBusSve
::~
	$CProc_ESD_ModBusSve
()

45 
size
 = 
m_busDevSAay
.
	`size
() ;

46  
i
 = 0 ; i < 
size
 ; i++ )

48 
PMBS_BUSDEV
 
pS
 = 
m_busDevSAay
[ 
i
 ] ;

49 if
pS
 )

50 
de
 
pS
 ;

52 
m_busDevSAay
.
	`r
() ;

53 
	}
}

55 
	gCProc_ESD_ModBusSve
::
	$GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
)

57 
BYTE
 
byVue
 = 0 ;

58 
byTy
)

60 
YC
:

62 if
wP
 >
MSMAX_YC_LEN
 )

63  
FALSE
 ;

65 
fV
 = 0.0f ;

66 if
m_pAIMTab
[ 
wP
 ].
wS
>0 && m_pAIMTab[ wP ].
wPNum
>0 )

67 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[ 
wP
 ].
wS
, m_pAIMTab[ wP ].
wPNum
, 
m_wYcBuf
[ wPnt ] );

69  
FALSE
 ;

71 
	`memy
(
v
, &
fV
 , ());

74 
YX
:

76 if
wP
 >
MSMAX_YX_LEN
 )

77  
FALSE
 ;

79 if
m_pDIMTab
[ 
wP
 ].
wS
>0 && m_pDIMTab[ wP ].
wPNum
>0 )

81 if
m_byYxBuf
[ 
wP
 ] ==0 )

82 
byVue
 = 0;

84 
byVue
 = 1;

86 
	`memy
(
v
, &
byVue
, (
BYTE
));

89  
FALSE
 ;

92 
YM
:

94 if
wP
 >
MSMAX_YM_LEN
 )

95  
FALSE
 ;

97 
WORD
 
wS
 = 
m_pPIMTab
[ 
wP
 ].wStn ;

98 
WORD
 
wPNum
 = 
m_pPIMTab
[ 
wP
 ].wPntNum ;

99 
DWORD
 
dwV
 = 0 ;

100 if
wS
 >0 && 
wP
 >0 )

101 
m_pMhod
->
	`GYmDa

wPNum
 - 1 , wPNum - 1 , 
dwV
 ) ;

103  
FALSE
 ;

105 
	`memy
(
v
, &
dwV
 , (
DWORD
));

109  
FALSE
 ;

111  
TRUE
 ;

112 
	}
}

114 
	gCProc_ESD_ModBusSve
::
	$TimProc
()

116 
	`RdChgDa
();

118 
	}
}

120 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$WreAIV
(
WORD
 
wSlNo
, WORD 
wP
, 
fV
 )

122 if(
m_pwAITns
==
NULL
 
FALSE
;

123 
WORD
 
wNum
 = 
m_pwAITns
[
wP
];

124 if(
wNum
>
m_wAISum
 
FALSE
;

125 if(
wNum
<
MSMAX_YC_LEN
)

127 
nDt
 = 
fV
 - 
m_wYcBuf
[
wNum
];

128 if(
	`abs
()
nDt
)>=
m_wDdV
)

130 
m_wYcBuf
[
wNum
] = 
fV
;

133  
TRUE
 ;

134 
	}
}

136 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$WreDIV
(
WORD
 
wSlNo
, WORD 
wP
, WORD 
wV
)

138 if(
m_pwDITns
==
NULL
 
FALSE
;

139 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

140 if(
wNum
>
m_wDISum
 
FALSE
;

141 if
wNum
<
MSMAX_YX_LEN
)

143 if
m_byYxBuf
[ 
wNum
 ] !
wV
 )

145 
m_byYxBuf
[ 
wNum
 ] = 
wV
 ;

148  
TRUE
 ;

149 
	}
}

151 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$In

BYTE
 
byLeNo
 )

153 
m_byLeNo
 = 
byLeNo
 ;

154 
	`rtf

m_szObjName
, "%s", 
m_sDevName
 );

155 
m_wRtuAddr
 = 
m_wDevAddr
 ;

156 
szFeName
[256] = "";

158 
	`rtf

szFeName
, "%s%s", 
MODBUSSLAVE_PATH
, 
m_sTemePh
 );

160 
	`RdMCfig

szFeName
 );

163 
	`InRtuBa
() ;

164  
TRUE
 ;

165 
	}
}

168 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$InDevS
( )

170 if
m_pMhod
 =
NULL
 )

171  
FALSE
 ;

173 
BYTE
 
size
 = 22 ;

174 
WORD
 
wAddr
 = 0 ;

175 
BYTE
 
byIndex
 = 0 ;

176  
BYTE
 
i
 = 0 ; i < 
size
 ; i++ )

178 
wAddr
 = 0 ;

179 
byIndex
 = 0 ;

180 if
m_pMhod
->
	`GSgGhDevCou

i
 , 
byIndex
++ , &
wAddr
 ) )

182 
PMBS_BUSDEV
 
pS
 = 
w
 
MBS_BUSDEV
 ;

183 
pS
->
busNo
 = 
i
 ;

184 
pS
->
wAddr
 = wAddr ;

185 
m_busDevSAay
.
	`push_back

pS
 ) ;

189  
TRUE
 ;

190 
	}
}

192 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$InRtuBa
()

194 
BOOL
 
bOk
 = 
FALSE
;

196 
	`CeTnsTab
();

199 
m_pMhod
->
	`RdAYcDa
(&
m_wYcBuf
[0]);

200 
m_pMhod
->
	`RdAYxDa
&
m_byYxBuf
[ 0 ] ) ;

202  
bOk
;

203 
	}
}

205 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$GProcBuf

BYTE
 * 
pBuf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

207 if!
	`IsCSd
( ) )

208  
FALSE
 ;

210 
BOOL
 
bV
 = 
FALSE
 ;

211 
DWORD
 
dwFg
 = 0 ;

213 if
	`GFg

SETYK
 ) && 
pBusMsg
 )

215 
bV
 = 
	`ykMesge

m_wDevAddr
 , 
pBuf
 , 
n
 , 
pBusMsg
 ) ;

216 
dwFg
 = 
SETYK
 ;

218 if
	`GFg

SETYC
 ) )

220 
bV
 = 
	`ycMesge

m_wDevAddr
 , 
pBuf
 , 
n
 ) ;

221 
dwFg
 = 
SETYC
;

223 if
	`GFg

SETYX
 ) )

225 
bV
 = 
	`yxMesge

m_wDevAddr
 , 
pBuf
 , 
n
 ) ;

226 
dwFg
 = 
SETYX
;

228 if
	`GFg

SETYM
 ) )

230 
bV
 = 
	`ymMesge

m_wDevAddr
 , 
pBuf
 , 
n
 ) ;

231 
dwFg
 = 
SETYM
 ;

233 if
	`GFg

SETFUC
 ) )

235 
bV
 = 
	`EMesge

m_wDevAddr
 , 
m_FuncE
 , 
ERR_FUNC
 , 
pBuf
 , 
n
 );

236 
dwFg

SETFUC
 ;

238 if
	`GFg

SETADDR
 ) )

240 
bV
 = 
	`EMesge

m_wDevAddr
 , 
m_FuncE
 , 
ERR_ADDR
 , 
pBuf
 , 
n
 );

241 
dwFg
 = 
SETADDR
 ;

243 if
	`GFg

SETDATA
 ) )

245 
bV
 = 
	`EMesge

m_wDevAddr
 , 
m_FuncE
 , 
ERR_DATA
 , 
pBuf
 , 
n
 );

246 
dwFg
 = 
SETDATA
 ;

248 if
	`GFg

SET_DEVSTATE_YX
 ) )

250 
bV
 = 
	`yxDevS

m_wDevAddr
 , 
pBuf
 , 
n
 ) ;

251 
dwFg
 = 
SET_DEVSTATE_YX
 ;

253 if
	`GFg
(
SET_BUS_COUNT
 ) )

255 
bV
 = 
	`busRSMesge

m_wDevAddr
 , 
pBuf
 , 
n
 ) ;

256 
dwFg
 = 
SET_BUS_COUNT
 ;

259  
FALSE
 ;

261 
	`SFg

dwFg
 , 
FALSE
 ) ;

263 
WORD
 
wCrc
 = 
	`GCRC

pBuf
 , 
n
 ) ;

264 
pBuf
[ 
n
++ ] = 
	`LOBYTE

wCrc
 ) ;

265 
pBuf
[ 
n
++ ] = 
	`HIBYTE

wCrc
 ) ;

267  
bV
 ;

268 
	}
}

270 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$GDevS

WORD
 
wYxNo
 , 
BYTE
 *
byV
 )

272 
CMhod
 * 
pMhod
 = 
m_pMhod
 ;

273 if
pMhod
 =
NULL
 )

274  
FALSE
 ;

276 
WORD
 
wCou
 = 
pMhod
->
	`GGhDevCou
() ;

277 if
wYxNo
 >
wCou
 )

278  
FALSE
 ;

280 
size
 = 
m_busDevSAay
.
	`size
() ;

281 if
size
 !
wCou
 )

282  
FALSE
 ;

284 
PMBS_BUSDEV
 
pBusS
 = 
m_busDevSAay
[ 
wYxNo
 ] ;

285 if
pBusS
 =
NULL
 )

286  
FALSE
 ;

288 *
byV
 = 
m_pMhod
->
	`GDevCommS

pBusS
->
busNo
 ,BusS->
wAddr
 ) ;

289 if*
byV
 =
COM_DEV_ABNORMAL
 )

290 *
byV
 = 
FALSE
 ;

292 *
byV
 = 
TRUE
 ;

294  
TRUE
 ;

295 
	}
}

297 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$yxDevS

BYTE
 
byAddr
 , BYTE * 
buf
 , &
n
 )

299 if
buf
 =
NULL
 )

300  
FALSE
 ;

302 
nBy
 = 0 , 
i
 = 0 ;

303 
WORD
 
wYxNo
 = 0 ;

304 
WORD
 
wRegNum
 = 
m_wRegNum
 ;

305 
WORD
 
wRegAddr
 = 
m_wRegAddr
 ;

306 
BYTE
 
byDa
 = 0 ;

308 
buf
[
nBy
++]
byAddr
 ;

309 
buf
[
nBy
++]
m_FucCode
 ;

310 
buf
[
nBy
++]=0x00;

312 
wYxNo
 = 
wRegAddr
 - 20001 ;

313 
BYTE
 
byV
 = 0 ;

314  
wRegNum
 > 8 )

316 
byDa
=0;

317 
i
=0;i<8;i++)

319 
byV
 = 0 ;

320 if!
	`GDevS

wYxNo
++ , &
byV
 ) )

322 
	`EMesge

byAddr
 , 0x02 , 
ERR_ADDR
 , 
buf
 , 
n
 ) ;

323  
TRUE
;

326 if
byV
 =
CLOSE_STATE
)

327 
byDa
 |=1 << 
i
 );

330 
buf
[
nBy
++]=
byDa
;

331 
wRegNum
-=8;

334 
byDa
=0;

335 
byV
 = 0 ;

336 
i
=0;i<
wRegNum
;i++)

338 if!
	`GDevS

wYxNo
++ , &
byV
 ) )

340 
	`EMesge

byAddr
 , 0x02 , 
ERR_ADDR
 , 
buf
 , 
n
 ) ;

341  
TRUE
;

344 if
byV
 =
CLOSE_STATE
)

345 
byDa
 |=1 << 
i
);

348 
buf
[
nBy
++]=
byDa
;

349 
buf
[2]=
nBy
 - 3 ;

351 
n
 = 
nBy
 ;

352  
TRUE
 ;

353 
	}
}

355 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$ProssProcBuf

BYTE
 * 
pBuf
 , 
n
 )

357 if
n
 < 5 )

358  
FALSE
 ;

360 
BYTE
 * 

 = &
pBuf
[0];

361 
WORD
 
c
 = 
	`GCRC


, 
n
-2);

362 if!
	`LOBYTE
(
c
=*(

+
n
-2&& 
	`HIBYTE
(crc) == *(pt+len-1)) )

363  
FALSE
 ;

365 
BYTE
 
byFuncCode
;

366 if
pBuf
[ 0 ] !
m_wDevAddr
 )

367  
FALSE
 ;

369 
byFuncCode
 = 
pBuf
[ 1 ];

371 
BOOL
 
bV
 = 
FALSE
 ;

372 
DWORD
 
dwFg
 = 0 ;

373  
byFuncCode
 )

376 
bV
 = 
	`yxDaPross

m_wDevAddr
 , 
pBuf
 , 
n
 );

380 
bV
 = 
	`daPross

m_wDevAddr
 , 
pBuf
 , 
n
 ) ;

383 
bV
 = 
	`ykPross

m_wDevAddr
 , 
pBuf
 , 
n
 );

384 
dwFg
 = 
SETYK
 ;

387 
bV
 = 
	`SEMsg

byFuncCode
 , 
ERR_DATA
 ) ;

388 
dwFg
 = 
SETDATA
 ;

391 
bV
 = 
	`SEMsg

byFuncCode
 , 
ERR_FUNC
 ) ;

392 
dwFg
 = 
SETFUC
 ;

397 if
bV
 )

398 
	`SFg

dwFg
 ) ;

400  
TRUE
;

401 
	}
}

403 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$yxDaPross

BYTE
 
byAddr
 , BYTE *
pBuf
 , 
WORD
 
n
 )

405 
WORD
 
wRegAddr
;

408 if(
n
<8)

409  
FALSE
;

411 
wRegAddr
=
	`MAKEWORD
(
pBuf
[3],pBuf[2]);

414 
BOOL
 
bFg
 = 
FALSE
 ;

415 if
wRegAddr
 >10001 && wRegAdd< 
MBS_YX_COUNT
 )

417 
bFg
 = 
	`yxPross

byAddr
 , 
pBuf
 , 
n
 );

418 if
bFg
 )

419 
	`SFg

SETYX
 ) ;

421  
bFg
 ;

424 if
wRegAddr
 >
MBS_YX_COUNT
 && wRegAdd<
MBS_YX_DEVSTATE_COUNT
 )

426 
bFg
 = 
	`yxDevSPross

byAddr
 , 
pBuf
 , 
n
 ) ;

427 if
bFg
 )

428 
	`SFg

SET_DEVSTATE_YX
 ) ;

431  
FALSE
 ;

433  
TRUE
 ;

434 
	}
}

436 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$yxDevSPross

BYTE
 
byAddr
 ,BYTE *
pBuf
 , 
WORD
 
n
 )

438 
WORD
 
wRegAddr
;

439 
WORD
 
wRegNum
;

440 
WORD
 
wYxNo
 = 0 ;

441 
BYTE
 *
pDa
=
NULL
;

442 
pDa
=
pBuf
+2;

443 if
n
 < 8 )

444  
FALSE
;

446 
wYxTٮCou
 = 
m_pMhod
->
	`GGhDevCou
() ;

448 
wRegAddr
=
	`MAKEWORD
(
pDa
[1],pData[0]);

449 
wRegNum
=
	`MAKEWORD
(
pDa
[3],pData[2]);

451 
wYxNo
 = 
wRegAddr
 - 20001 ;

453 if
wRegAddr
 < 20001 || wRegAdd>
MBS_YX_DEVSTATE_COUNT
 )

455 
	`SEMsg
0x02 , 
ERR_ADDR
 ) ;

456  
FALSE
 ;

459 if
wRegNum
<=0 || wRegNum > 1024 )

461 
	`SEMsg
0x02 , 
ERR_DATA
 ) ;

462  
FALSE
 ;

464 if
wYxNo
 + 
wRegNum
 ) > ( 
WORD
 )
wYxTٮCou
 )

466 
	`SEMsg
0x02 , 
ERR_ADDR
 ) ;

467  
FALSE
 ;

471 
m_wRegAddr
 = 
wRegAddr
 ;

472 
m_wRegNum
 = 
wRegNum
 ;

473 
m_FucCode
 = 
pBuf
[ 1 ] ;

476  
TRUE
 ;

477 
	}
}

479 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$daPross

BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
 )

481 
WORD
 
wRegAddr
;

484 if(
n
<8)

485  
FALSE
;

487 
wRegAddr
=
	`MAKEWORD
(
pBuf
[3],pBuf[2]);

490 
BOOL
 
bFg
 = 
FALSE
 ;

491 if
wRegAddr
 >30001 && wRegAdd< 
MBS_YC_COUNT
 )

493 
bFg
 = 
	`ycPross

byAddr
 , 
pBuf
 , 
n
 );

494 if
bFg
 )

495 
	`SFg

SETYC
 ) ;

497  
bFg
 ;

500 if
wRegAddr
 >36801 && wRegAdd<
MBS_YM_COUNT
 )

502 
bFg
 = 
	`ymPross

byAddr
 , 
pBuf
 , 
n
 ) ;

503 if
bFg
 )

504 
	`SFg

SETYM
 ) ;

507 if
wRegAddr
 >
MBS_BUS_RSADDR
 && wRegAdd<MBS_BUS_RSADDR + 
MAXLINE
 * 2 )

509 
bFg
 = 
	`busRSPross

byAddr
 , 
pBuf
 , 
n
 ) ;

510 if
bFg
 )

511 
	`SFg

SET_BUS_COUNT
 ) ;

514  
FALSE
 ;

516  
TRUE
 ;

517 
	}
}

519 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$busRSMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 )

521 if
pbuf
 =
NULL
 )

522  
FALSE
 ;

524 
nBy
=0;

525 
WORD
 
wYcNo
 = 0 ;

526 
WORD
 
wRegNum
 = 
m_wRegNum
 ;

528 
BYTE
 *
buf
 = 
pbuf
 ;

530 
buf
[
nBy
++]=
byAddr
;

531 
buf
[
nBy
++]=
m_FucCode
 ;

532 
buf
[
nBy
++]=0x00;

534 
wYcNo
 = 
m_wRegAddr
 - 
MBS_BUS_RSADDR
 ;

535 
WORD
 
wRx
 = 0 , 
wTx
 = 0 ;

536  
wRegNum
 > 0 )

538 
PBUSMANAGER
 
pBus
 = 
m_pMhod
->
	`GBus

wYcNo
++ ) ;

539 if!
pBus
 )

541 
	`EMesge

byAddr
 , 
m_FucCode
 , 
ERR_ADDR
 , 
buf
 , 
n
 ) ;

542  
TRUE
;

545 
wRx
 = 
pBus
->
m_Rx
 ;

546 
wTx
 = 
pBus
->
m_Tx
 ;

548 
buf
[ 
nBy
++ ]=
	`HIBYTE

wRx
 );

549 
buf
[ 
nBy
++ ]=
	`LOBYTE

wRx
 );

550 
buf
[ 
nBy
++ ] = 
	`HIBYTE

wTx
 ) ;

551 
buf
[ 
nBy
++ ] = 
	`LOBYTE

wTx
 ) ;

552 
wRegNum
 -= 2 ;

555 
buf
[2]=
nBy
 - 3;

557 
n
 = 
nBy
 ;

558  
TRUE
 ;

559 
	}
}

561 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$busRSPross

BYTE
 
byAddr
 , BYTE * 
pBuf
 , 
WORD
 
n
 )

563 
WORD
 
wRegAddr
;

564 
WORD
 
wRegNum
;

565 
WORD
 
wNo
;

566 if
n
 < 8 )

567  
FALSE
;

569 
BYTE
 *
pDa
=
NULL
;

570 
pDa
=
pBuf
+2;

571 
BYTE
 
byFunc
 = 
pBuf
[ 1 ] ;

572 
wBusTٮCou
 = 
MAXLINE
 * 2 ;

574 
wRegAddr
=
	`MAKEWORD
(
pDa
[1],pData[0]);

575 
wRegNum
=
	`MAKEWORD
(
pDa
[3],pData[2]);

577 
wNo
=
wRegAddr
-
MBS_BUS_RSADDR
;

578 
WORD
 
wMaxL
 = 
MBS_BUS_RSADDR
 + 
MAXLINE
 * 2;

579 if
wRegAddr
 < 
MBS_BUS_RSADDR
 ) || ( wRegAdd> 
wMaxL
) || ( wRegAddr % 2 ) )

581 
	`SEMsg

byFunc
 , 
ERR_ADDR
 ) ;

582  
FALSE
 ;

584 if(
wRegNum
<=0 || wRegNum> 
wBusTٮCou
 || ( wRegNum % 2 != 0 ) )

586 
	`SEMsg

byFunc
 , 
ERR_DATA
 ) ;

587  
FALSE
 ;

589 if(
wNo
+
wRegNum
> 
MAXLINE
 * 2 )

591 
	`SEMsg

byFunc
 , 
ERR_DATA
 ) ;

592  
FALSE
 ;

596 
m_wRegAddr
 = 
wRegAddr
 ;

597 
m_wRegNum
 = 
wRegNum
 ;

598 
m_FucCode
 = 
pBuf
[ 1 ] ;

602  
TRUE
 ;

603 
	}
}

605 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$ymMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 )

607 if
pbuf
 =
NULL
 )

608  
FALSE
 ;

610 
DWORD
 
dwDa
;

611 
nBy
=0;

612 
WORD
 
wYcNo
 = 0 ;

613 
WORD
 
wRegNum
 = 
m_wRegNum
 ;

615 
BYTE
 *
buf
 = 
pbuf
 ;

617 
buf
[
nBy
++]=
byAddr
;

618 
buf
[
nBy
++]=
m_FucCode
 ;

619 
buf
[
nBy
++]=0x00;

621 
wYcNo
 = 
m_wRegAddr
 - 36801 ;

622 
WORD
 
hV
 = 0 ,
lV
 = 0 ;

623  
wRegNum
 > 0 )

625 if!
	`GRlV

YM
 , 
wYcNo
++ , &
dwDa
 ) )

627 
	`EMesge

byAddr
 , 
m_FucCode
 , 
ERR_ADDR
 , 
buf
 , 
n
 ) ;

628  
TRUE
;

630 
hV
 = 
	`HIWORD

dwDa
 ) ;

631 
lV
 = 
	`LOWORD

dwDa
 ) ;

633 
buf
[ 
nBy
++ ] = 
	`HIBYTE

hV
 ) ;

634 
buf
[ 
nBy
++ ] = 
	`LOBYTE

hV
 ) ;

635 
buf
[ 
nBy
++ ]=
	`HIBYTE

lV
 );

636 
buf
[ 
nBy
++ ]=
	`LOBYTE

lV
 );

638 
wRegNum
 -= 2 ;

641 
buf
[2]=
nBy
 - 3;

643 
n
 = 
nBy
 ;

644  
TRUE
 ;

645 
	}
}

647 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$ymPross

BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
 )

649 
WORD
 
wRegAddr
;

650 
WORD
 
wRegNum
;

651 
WORD
 
wYmNo
;

652 if
n
 < 8 )

653  
FALSE
;

655 
BYTE
 *
pDa
=
NULL
;

656 
pDa
=
pBuf
+2;

657 
BYTE
 
byFunc
 = 
pBuf
[ 1 ] ;

659 
wYmTٮCou
 = 
MSMAX_YM_LEN
 ;

661 
wRegAddr
=
	`MAKEWORD
(
pDa
[1],pData[0]);

662 
wRegNum
=
	`MAKEWORD
(
pDa
[3],pData[2]);

664 
wYmNo
=
wRegAddr
-36801;

666 if
wRegAddr
 < 36801 ) || ( wRegAdd> 
MBS_YM_COUNT
 ) || ( wRegAddr % 2 == 0 ) )

668 
	`SEMsg
0x02 , 
ERR_ADDR
 ) ;

669  
FALSE
 ;

671 if(
wRegNum
<=0 || wRegNum>16 || ( wRegNum % 2 != 0 ) )

673 
	`SEMsg

byFunc
 , 
ERR_DATA
 ) ;

674  
FALSE
 ;

676 if(
wYmNo
+
wRegNum
> 
wYmTٮCou
 )

678 
	`SEMsg

byFunc
 , 
ERR_DATA
 ) ;

679  
FALSE
 ;

683 
m_wRegAddr
 = 
wRegAddr
 ;

684 
m_wRegNum
 = 
wRegNum
 ;

685 
m_FucCode
 = 
pBuf
[ 1 ] ;

689  
TRUE
 ;

690 
	}
}

692 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$yxPross

BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
 )

694 
WORD
 
wRegAddr
;

695 
WORD
 
wRegNum
;

696 
WORD
 
wYxNo
 = 0 ;

697 
BYTE
 *
pDa
=
NULL
;

698 
pDa
=
pBuf
+2;

699 if
n
 < 8 )

700  
FALSE
;

703 
wYxTٮCou
 = 
MSMAX_YX_LEN
 ;

705 
wRegAddr
=
	`MAKEWORD
(
pDa
[1],pData[0]);

706 
wRegNum
=
	`MAKEWORD
(
pDa
[3],pData[2]);

708 
wYxNo
 = 
wRegAddr
 - 10001 ;

710 if
wRegAddr
 < 10001 || wRegAdd>
MBS_YX_COUNT
 )

712 
	`SEMsg
0x02 , 
ERR_ADDR
 ) ;

713  
FALSE
 ;

716 if
wRegNum
<=0 || wRegNum > 1024 )

718 
	`SEMsg
0x02 , 
ERR_DATA
 ) ;

719  
FALSE
 ;

721 if
wYxNo
 + 
wRegNum
 ) > ( 
WORD
 )
wYxTٮCou
 )

723 
	`SEMsg
0x02 , 
ERR_ADDR
 ) ;

724  
FALSE
 ;

728 
m_wRegAddr
 = 
wRegAddr
 ;

729 
m_wRegNum
 = 
wRegNum
 ;

730 
m_FucCode
 = 
pBuf
[ 1 ] ;

733  
TRUE
 ;

734 
	}
}

736 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$ycPross

BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
 )

738 
WORD
 
wRegAddr
;

739 
WORD
 
wRegNum
;

740 
WORD
 
wYcNo
;

741 if
n
 < 8 )

742  
FALSE
;

744 
BYTE
 *
pDa
=
NULL
;

745 
pDa
=
pBuf
+2;

746 
BYTE
 
byFunc
 = 
pBuf
[ 1 ] ;

748 
wYcTٮCou
 = 
MSMAX_YC_LEN
 ;

750 
wRegAddr
=
	`MAKEWORD
(
pDa
[1],pData[0]);

751 
wRegNum
=
	`MAKEWORD
(
pDa
[3],pData[2]);

752 
wYcNo
=
wRegAddr
-30001;

754 if
wRegAddr
 < 30001 || wRegAdd>
MBS_YC_COUNT
 )

756 
	`SEMsg

byFunc
 , 
ERR_ADDR
 ) ;

757  
FALSE
 ;

760 if(
wRegNum
<=0 || wRegNum>120 )

762 
	`SEMsg

byFunc
 , 
ERR_DATA
 ) ;

763  
FALSE
 ;

765 if
wYcNo
 + 
wRegNum
 ) >
wYcTٮCou
 )

767 
	`SEMsg

byFunc
 , 
ERR_ADDR
 ) ;

768  
FALSE
 ;

772 
m_wRegAddr
 = 
wRegAddr
 ;

773 
m_wRegNum
 = 
wRegNum
 ;

774 
m_FucCode
 = 
byFunc
 ;

777  
TRUE
 ;

778 
	}
}

780 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$ykPross
(
BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
)

782 
WORD
 
wRegAddr
;

783 
WORD
 
wOrd
;

784 
WORD
 
wYkNo
;

785 
BYTE
 
byYkAi
;

787 if
n
 < 8 )

788  
FALSE
;

790 
wYkTٮCou
 = 
MSMAX_YK_LEN
 ;

792 
BYTE
 *
pDa
=
NULL
;

793 
pDa
=
pBuf
+2;

794 
wRegAddr
=
	`MAKEWORD
(
pDa
[1],pData[0]);

795 
wOrd
=
	`MAKEWORD
(
pDa
[3],pData[2]);

796 
wYkNo
=
wRegAddr
-1;

798 if
wRegAddr
 < 1 || wRegAdd>
MBS_YK_COUNT
 )

800 
	`SEMsg
0x05,
ERR_ADDR
 );

801  
FALSE
;

804 if
wYkNo
 >
wYkTٮCou
 )

805  
FALSE
 ;

807 
wOrd
)

810 
byYkAi
= 1;

813 
byYkAi
= 0;

816 
	`SEMsg
0x05,
ERR_DATA
 );

817  
FALSE
;

820 
m_wYkAddr
 = 
wRegAddr
 ;

821 
m_wYkNum
 = 
wOrd
 ;

823 
WORD
 
wS
 = 
m_pDOMTab
[ 
wYkNo
].wStn - 1 ;

824 
WORD
 
wP
 = 
m_pDOMTab
[ 
wYkNo
].
wPNum
 - 1 ;

825 
BYTE
 
byBusNo
 = 0 ;

826 
WORD
 
wDevAddr
 = 0 ;

828 if(
m_pMhod
->
	`GBusLeAndAddr
(
wS
, 
byBusNo
, 
wDevAddr
))

829 
m_pMhod
->
	`SYkExe
(
this
, 
byBusNo
, 
wDevAddr
, 
wP
 , 
byYkAi
 );

831 
	`tf
("[ModBusSlave]:Serialnorror!!!\n");

833  
TRUE
;

834 
	}
}

836 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$EMesge

BYTE
 
byAddr
, BYTE 
byFuncCode
, BYTE 
byECode
, BYTE * 
pBuf
 , &
n
 )

838 if
pBuf
 =
NULL
 )

839  
FALSE
 ;

841 
nBy
 = 0 ;

842 
BYTE
 * 
buf
 = 
pBuf
 ;

844 
buf
[
nBy
++]
byAddr
 ;

845 
buf
[
nBy
++]
byFuncCode
 | 0x80 ;

846 
buf
[
nBy
++]=
byECode
 ;

848 
n
 = 
nBy
 ;

850  
TRUE
 ;

851 
	}
}

853 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$yxMesge

BYTE
 
byAddr
 , BYTE * 
buf
 , &
n
 )

855 if
buf
 =
NULL
 )

856  
FALSE
 ;

858 
nBy
 = 0 , 
i
 = 0 ;

859 
WORD
 
wYxNo
 = 0 ;

860 
WORD
 
wRegNum
 = 
m_wRegNum
 ;

861 
WORD
 
wRegAddr
 = 
m_wRegAddr
 ;

862 
BYTE
 
byDa
 = 0 ;

864 
buf
[
nBy
++]
byAddr
 ;

865 
buf
[
nBy
++]
m_FucCode
 ;

866 
buf
[
nBy
++]=0x00;

868 
wYxNo
 = 
wRegAddr
 - 10001 ;

869 
BYTE
 
byV
 = 0 ;

870  
wRegNum
 > 8 )

872 
byDa
=0;

873 
byV
 = 0 ;

874 
i
=0;i<8;i++)

876 if!
	`GRlV

YX
 , 
wYxNo
++, &
byV
 ) )

878 
	`EMesge

byAddr
 , 0x02 , 
ERR_ADDR
 , 
buf
 , 
n
 ) ;

879  
TRUE
;

882 if
byV
 =
CLOSE_STATE
)

883 
byDa
 |=1 << 
i
 );

886 
buf
[
nBy
++]=
byDa
;

887 
wRegNum
-=8;

890 
byDa
=0;

891 
byV
 = 0 ;

892 
i
=0;i<
wRegNum
;i++)

894 if!
	`GRlV

YX
 , 
wYxNo
++, &
byV
 ) )

896 
	`EMesge

byAddr
 , 0x02 , 
ERR_ADDR
 , 
buf
 , 
n
 ) ;

897  
TRUE
;

900 if
byV
 =
CLOSE_STATE
)

901 
byDa
 |=1 << 
i
);

904 
buf
[
nBy
++]=
byDa
;

905 
buf
[2]=
nBy
 - 3 ;

907 
n
 = 
nBy
 ;

908  
TRUE
 ;

909 
	}
}

911 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$ycMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 )

913 if
pbuf
 =
NULL
 )

914  
FALSE
 ;

916 
WORD
 
wYcDa
;

917 
tDa
;

918 
nBy
=0;

919 
WORD
 
wYcNo
 = 0 ;

920 
WORD
 
wRegNum
 = 
m_wRegNum
 ;

922 
BYTE
 *
buf
 = 
pbuf
 ;

924 
buf
[
nBy
++]=
byAddr
;

925 
buf
[
nBy
++]=
m_FucCode
 ;

926 
buf
[
nBy
++]=0x00;

928 
wYcNo
 = 
m_wRegAddr
 - 30001 ;

929  
wRegNum
 > 0 )

931 if!
	`GRlV

YC
 , 
wYcNo
++ , &
tDa
 ) )

933 
	`EMesge

byAddr
 , 
m_FucCode
 , 
ERR_ADDR
 , 
buf
 , 
n
 ) ;

934  
TRUE
;

937 if(
tDa
<0)

939 
wYcDa
=(
WORD
)-
tDa
;

940 
wYcDa
= ~wYcData + 1 ;

943 
wYcDa
 = ( 
WORD
 )
tDa
;

945 
buf
[
nBy
++]=
	`HIBYTE
(
wYcDa
);

946 
buf
[
nBy
++]=
	`LOBYTE
(
wYcDa
);

947 
wRegNum
--;

950 
buf
[2]=
nBy
 - 3;

952 
n
 = 
nBy
 ;

954  
TRUE
 ;

955 
	}
}

957 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$SEMsg

BYTE
 
byFuncCode
, BYTE 
byECode
 )

959  
byECode
 )

961 
ERR_ADDR
:

962 
	`SFg

SETADDR
 ) ;

965 
ERR_DATA
:

966 
	`SFg

SETDATA
 );

969 
ERR_FUNC
:

970 
	`SFg

SETFUC
 ) ;

974 
m_FuncE
 = 
byFuncCode
 ;

976  
TRUE
 ;

977 
	}
}

979 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$ykMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

981 if
pBusMsg
 =
NULL
 )

982  
FALSE
 ;

984 if
pBusMsg
->
byMsgTy
 !
YK_PROTO
 )

985  
FALSE
 ;

987 if
pBusMsg
->
dwDaTy
 !
YK_EXCT_RTN
 )

988  
FALSE
 ;

990 if
pBusMsg
->
DaNum
 !1 ) || (BusMsg->
DaL
 !(
YK_DATA
) ) )

992 
	`tf
("ModBusSlave Yk DataNumrr\n");

996 
YK_DATA
 *
pDa
 = (YK_DATA *)(
pBusMsg
->pData);

998 
BOOL
 
bRu
 = 
FALSE
 ;

999 
nBy
=0;

1000 
WORD
 
wRegNum
 = 
m_wYkNum
 ;

1001 
WORD
 
wRegAddr
 = 
m_wYkAddr
 ;

1002 
BYTE
 *
buf
 = 
pbuf
 ;

1004 if
pDa
->
byV
 =
YK_ERROR
 )

1005 
bRu
 = 
FALSE
 ;

1007 
bRu
 = 
TRUE
 ;

1009 
buf
[
nBy
++]=
byAddr
;

1010 if
bRu
 )

1011 
buf
[
nBy
++]= 0x05 ;

1013 
buf
[ 
nBy
++ ] = 0x85 ;

1015 
buf
[
nBy
++]=
	`HIBYTE

wRegAddr
 );

1016 
buf
[
nBy
++]=
	`LOBYTE

wRegAddr
 );

1017 
buf
[
nBy
++]=
	`HIBYTE

wRegNum
 );

1018 
buf
[
nBy
++]=
	`LOBYTE

wRegNum
 );

1020 
n
 = 
nBy
 ;

1021  
TRUE
 ;

1022 
	}
}

1024 
	gCProc_ESD_ModBusSve
::
	$SFg

DWORD
 
dwV
 , 
BOOL
 
bFg
 )

1026 if
bFg
 )

1027 
m_dwSdFg
 |
dwV
 ;

1029 
m_dwSdFg
 = m_dwSdFg & ( ~
dwV
 ) ;

1030 
	}
}

1032 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$GFg

DWORD
 
dwV
 )

1034 
BOOL
 
bFg
 = ( 
m_dwSdFg
 & 
dwV
 ) ?1:0 ;

1035  
bFg
 ;

1036 
	}
}

1038 
BOOL
 
	gCProc_ESD_ModBusSve
::
	$IsCSd
( )

1040  
m_dwSdFg
 ? 1:0 ;

1041 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_ESD_ModBusSlave.h

5 #i!
defed
(
AFX_PROTOCOL_ESD_MODBUSSLAVE_H__5F0D50B1_834A_44A4_AA42_D89ACB8F03E3__INCLUDED_
)

6 
	#AFX_PROTOCOL_ESD_MODBUSSLAVE_H__5F0D50B1_834A_44A4_AA42_D89ACB8F03E3__INCLUDED_


	)

8 #i
_MSC_VER
 > 1000

9 #agm



12 
	~"Proc_ModBusSve.h
"

13 
	~<ve
>

14 
	#MS_TX_BUF_SIZE
 1024

	)

15 
	#MS_RX_BUF_SIZE
 1024

	)

17 
	#MSMAX_YC_LEN
 6800

	)

18 
	#MSMAX_YX_LEN
 10000

	)

19 
	#MSMAX_YM_LEN
 1024

	)

20 
	#MSMAX_YK_LEN
 10000

	)

22 
	s_MBS_BUSDEV


24 
BYTE
 
	mbusNo
 ;

25 
WORD
 
	mwAddr
 ;

26 
_MBS_BUSDEV
( )

28 
	mbusNo
 = 0 ;

29 
	mwAddr
 = 0 ;

31 }
	tMBS_BUSDEV
 , *
	tPMBS_BUSDEV
 ;

33 as
	cCProc_ESD_ModBusSve
 : 
public
 
CProc_ModBusSve


35 
public
:

36 
CProc_ESD_ModBusSve
();

37 
	mvtu
 ~
CProc_ESD_ModBusSve
();

38 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

39 
vtu
 
BOOL
 
InRtuBa
() ;

40 
BOOL
 
WreAIV
(
WORD
 
wSlNo
, WORD 
wP
, 
fV
 );

41 
BOOL
 
WreDIV
(
WORD
 
wSlNo
, WORD 
wP
, WORD 
wV
);

42 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 );

43 
BOOL
 
ProssProcBuf

BYTE
 * 
pbuf
 , 
n
 );

44 
TimProc
();

45 
BOOL
 
yxPross

BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
) ;

46 
BOOL
 
ycPross

BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
 );

47 
BOOL
 
EMesge

BYTE
 
byAddr
, BYTE 
byFuncCode
, BYTE 
byECode
, BYTE * 
pBuf
 , &
n
 );

48 
BOOL
 
yxMesge

BYTE
 
byAddr
 , BYTE * 
buf
 , &
n
 );

49 
BOOL
 
ycMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 );

50 
BOOL
 
SEMsg

BYTE
 
byFuncCode
, BYTE 
byECode
 );

51 
GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
);

52 
BOOL
 
ymMesge

BYTE
 
byAddr
 , BYTE * 
buf
 , &
n
 );

53 
BOOL
 
ymPross

BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
 );

54 
BOOL
 
daPross

BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
 );

55 
SFg

DWORD
 
dwV
 , 
BOOL
 
bFg
 = 
TRUE
 ) ;

56 
BOOL
 
GFg

DWORD
 
dwV
 );

57 
BOOL
 
IsCSd
( );

58 
BOOL
 
yxDaPross

BYTE
 
byAddr
 , BYTE *
pBuf
 , 
WORD
 
n
 );

59 
BOOL
 
InDevS
( );

60 
BOOL
 
yxDevSPross

BYTE
 
byAddr
 ,BYTE *
pBuf
 , 
WORD
 
n
 ) ;

61 
BOOL
 
yxDevS

BYTE
 
byAddr
 , BYTE * 
buf
 , &
n
 );

62 
BOOL
 
busRSPross

BYTE
 
byAddr
 , BYTE * 
pbuf
 , 
WORD
 
n
 );

64 
BOOL
 
GDevS

WORD
 
wYxNo
 , 
BYTE
 *
byV
 );

65 
vtu
 
BOOL
 
ykPross
(
BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
) ;

66 
vtu
 
BOOL
 
ykMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 );

67 
BOOL
 
busRSMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 ) ;

69 
	mpublic
:

70 
BYTE
 
m_RlTy
 ;

71 
WORD
 
	mm_wRegAddr
;

72 
WORD
 
	mm_wRegNum
;

73 
WORD
 
	mm_wYkAddr
 ;

74 
WORD
 
	mm_wYkNum
 ;

75 
WORD
 
	mm_Ai
 ;

76 
BYTE
 
	mm_FucCode
 ;

77 
BYTE
 
	mm_FuncE
 ;

78 
DWORD
 
	mm_dwSdFg
 ;

80 
	mm_wYcBuf
[
MSMAX_YC_LEN
];

81 
BYTE
 
	mm_byYxBuf
[ 
MSMAX_YX_LEN
 ] ;

82 
	md
::
ve
< 
PMBS_BUSDEV
 > 
m_busDevSAay
 ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_ModBusSlave.cpp

5 
	~"Proc_ModBusSve.h
"

6 
	~"Proc_ESD_ModBusSve.h
"

7 
	~"Proc_SuɪModBusSve.h
"

9 
	#MODULE_ESD_MODBUS_SLAVE
 1

10 
	#MODULE_SULTAN_MODBUS_SLAVE
 2

11 

	)

12 
	gCProc_ModBusSve
::
	$CProc_ModBusSve
()

15 
	}
}

17 
CProc_ModBusSve
::~
	$CProc_ModBusSve
()

20 
	}
}

22 
BOOL
 
CProc_ModBusSve
::
	$In

BYTE
 
byLeNo
 )

24 
m_byLeNo
 = 
byLeNo
 ;

25 
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

28  
	`GDevDa
( ) ;

29 
	}
}

31 
BOOL
 
	gCProc_ModBusSve
::
	$GDevDa
( )

33 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

34 
	`rtf

m_sDevPh
 , "%s/ModBusSve/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

35 
CProfe
 
	`ofe

m_sDevPh
 ) ;

37  
	`ProssFeDa

ofe
 ) ;

38 
	}
}

40 
BOOL
 
	gCProc_ModBusSve
::
	$ProssFeDa

CProfe
 &
ofe
 )

42 if!
ofe
.
	`IsVid
() )

44 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

45  
FALSE
 ;

48 
sSe
[ 200 ] = "DEVNUM" ;

49 
sKey
[ 20 ][ 50 ]={ "module" , "addr" , "name" , "masteraddr" , "template" , "ycdead" , "ycProperty" , "timing"} ;

51 
BOOL
 
bR
;

52 
WORD
 
wModu
 = 0 ;

54 
WORD
 
addr
 =0 ;

55 
sName
[ 50 ] = { 0 };

56 
eme
[ 200 ] = { 0 };

57 
iNum
 = 0 ;

58 
sMaAddr
[ 200 ] = { 0 } ;

60 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

61 if
iNum
 == 0 )

63 
	`tf
( "Get DEVNUM Failed ! \n " );

64  
FALSE
 ;

67 
BYTE
 
byIndex
 = 0 ;

68  
i
 = 0 ; i < 
iNum
 ; i++ )

70 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

72 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 
byIndex
++ ] , 0 ) ;

73 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 
byIndex
++ ] , 0 ) ;

75 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

76 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
sMaAddr
 , 
eme
 ) ) ;

77 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 
byIndex
++ ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

80 
bR
 = 
	`CeModu

wModu
 ,
sMaAddr
 , 
addr
 , 
sName
 , 
eme
 ) ;

81 i!
bR
 )

83 
	`tf
 ( "CIEC104 Modu=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
addr
, 
sName
, 
eme
 );

85  
FALSE
;

89  
TRUE
 ;

90 
	}
}

92 
BOOL
 
	gCProc_ModBusSve
::
	$CeModu

iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

94 
CProc_ModBusSve
 * 
pProc
 = 
NULL
 ;

96  
iModu
 )

98 
MODULE_ESD_MODBUS_SLAVE
:

99 
pProc
 = 
w
 
CProc_ESD_ModBusSve
 ;

101 
MODULE_SULTAN_MODBUS_SLAVE
:

102 
pProc
 = 
w
 
CProc_SuɪModBusSve
 ;

106 
	`tf
( "%s don't containhis module Failed .\n" , "ModBusSlave" );

107  
FALSE
 ;

111 if!
	`InMS_Modu

pProc
 , 
iModu
 , 
sMaAddr
 , 
iAddr
 , 
sName
 , 
ePh
 ) )

112  
FALSE
 ;

114 
m_modu
.
	`push_back

pProc
 ) ;

115  
TRUE
 ;

116 
	}
}

118 
BOOL
 
	gCProc_ModBusSve
::
	$InMS_Modu

CProc_ModBusSve
 * 
pProc
 , 
iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

120 if
pProc
 =
NULL
 )

121  
FALSE
 ;

123 
pProc
->
m_byLeNo
 = m_byLineNo ;

124 
pProc
->
m_wModuTy
 = 
iModu
 ;

125 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

126 
	`tf
("iddr=%d m_byLeNo=%d\n", 
iAddr
, 
m_byLeNo
);

127 
	`ry

pProc
->
m_sDevName
 , 
sName
 ) ;

128 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

130 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

131 
pProc
->
m_pMhod
 = m_pMethod ;

132 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

134 if!
pProc
->
	`In

m_byLeNo
 ) )

135  
FALSE
 ;

136 
	`tf
" Add bu%d Add%d ProcNam%\n" , 
m_byLeNo
 , 
iAddr
 , 
sName
 ) ;

138  
TRUE
 ;

139 
	}
}

141 
WORD
 
	gCProc_ModBusSve
::
	$GCRC
(
BYTE
 *
pBuf
,
WORD
 
nL
)

143 
WORD
 
Gpy
=0xA001;

144 
WORD
 
CRC
=0xFFFF;

145 
WORD
 
dex
;

146 
nL
--)

148 
CRC
=CRC^(
WORD
)*
pBuf
++;

149 
dex
=0;index<8;index++)

151 if((
CRC
 & 0x0001)==1)

152 
CRC
=(CRC>>1)^
Gpy
;

154 
CRC
=CRC>>1;

157  
CRC
;

158 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_ModBusSlave.h

5 #i!
defed
(
AFX_PROTOCOL_MODBUSSLAVE_H__74F71703_47F3_48C8_A555_4BB7B115F202__INCLUDED_
)

6 
	#AFX_PROTOCOL_MODBUSSLAVE_H__74F71703_47F3_48C8_A555_4BB7B115F202__INCLUDED_


	)

7 #agm
ck
( 1 )

8 
	~"../../she/Rtu.h
"

9 
	~"../../she/CMhod.h
"

11 as
	cCProc_ModBusSve
 : 
public
 
CRtuBa


13 
public
:

14 
CProc_ModBusSve
();

15 
	mvtu
 ~
CProc_ModBusSve
();

16 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

17 
BOOL
 
GDevDa
( ) ;

18 
BOOL
 
ProssFeDa

CProfe
 &
ofe
 );

19 
BOOL
 
CeModu

iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 );

21 
BOOL
 
InMS_Modu

CProc_ModBusSve
 * 
pProc
 , 
iModu
 , * 
sMaAddr
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

22 
WORD
 
GCRC
(
BYTE
 *
pBuf
,WORD 
nL
);

24 #agm
ck
( )

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_SultanModBusSlave.cpp

5 
	~"Proc_SuɪModBusSve.h
"

6 
	#ERR_FUNC
 0x01

	)

7 
	#ERR_ADDR
 0x02

	)

8 
	#ERR_DATA
 0x03

	)

10 
	#MBS_YK_COUNT
 10000

	)

16 
	gCProc_SuɪModBusSve
::
	$CProc_SuɪModBusSve
()

19 
	}
}

21 
CProc_SuɪModBusSve
::~
	$CProc_SuɪModBusSve
()

24 
	}
}

26 
BOOL
 
CProc_SuɪModBusSve
::
	$ykPross
(
BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
)

28 
WORD
 
wRegAddr
;

29 
WORD
 
wOrd
;

30 
WORD
 
wYkNo
;

31 
BYTE
 
byYkAi
;

33 if
n
 < 8 )

34  
FALSE
;

36 
wYkTٮCou
 = 
MSMAX_YK_LEN
 ;

38 
BYTE
 *
pDa
=
NULL
;

39 
pDa
=
pBuf
+2;

40 
wRegAddr
=
	`MAKEWORD
(
pDa
[1],pData[0]);

41 
wOrd
=
	`MAKEWORD
(
pDa
[3],pData[2]);

42 
wYkNo
=
wRegAddr
-1;

44 if
wOrd
 == 0 )

45  
FALSE
 ;

47 
WORD
 
wS
 = 
m_pDOMTab
[ 
wYkNo
].wStn ;

48 
WORD
 
wP
 = 
m_pDOMTab
[ 
wYkNo
].
wPNum
 ;

49 if
wS
 =0 || 
wP
 == 0 )

50  
FALSE
 ;

52 if
wRegAddr
 < 1 || wRegAdd>
MBS_YK_COUNT
 )

54 
	`SEMsg
0x05,
ERR_ADDR
 );

55  
FALSE
;

58 if
wYkNo
 >
wYkTٮCou
 )

59  
FALSE
 ;

61 
wOrd
)

64 
byYkAi
= 1;

67 
	`SEMsg
0x05,
ERR_DATA
 );

68  
FALSE
;

71 
wS
 = wStn - 1 ;

72 
wP
 = wPnt - 1 ;

74 
BYTE
 
byBusNo
 = 0 ;

75 
WORD
 
wDevAddr
 = 0 ;

76 
m_wYkAddr
 = 
wRegAddr
 ;

77 
m_wYkNum
 = 
wOrd
 ;

79 if(
m_pMhod
->
	`GBusLeAndAddr
(
wS
, 
byBusNo
, 
wDevAddr
))

80 
m_pMhod
->
	`SYkExe
(
this
, 
byBusNo
, 
wDevAddr
, 
wP
 , 
byYkAi
 );

82 
	`tf
("[ModBusSlave]:Serialnorror!!!\n");

84  
TRUE
 ;

85 
	}
}

87 
BOOL
 
	gCProc_SuɪModBusSve
::
	$ykMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

89 if
pBusMsg
 =
NULL
 )

90  
FALSE
 ;

92 if
pBusMsg
->
byMsgTy
 !
YK_PROTO
 )

93  
FALSE
 ;

95 if
pBusMsg
->
dwDaTy
 !
YK_EXCT_RTN
 )

96  
FALSE
 ;

98 if
pBusMsg
->
DaNum
 !1 ) || (BusMsg->
DaL
 !(
YK_DATA
) ) )

100 
	`tf
("ModBusSlave Yk DataNumrr\n");

104 
YK_DATA
 *
pDa
 = (YK_DATA *)(
pBusMsg
->pData);

106 
BOOL
 
bRu
 = 
FALSE
 ;

107 
nBy
=0;

108 
WORD
 
wRegNum
 = 
m_wYkNum
 ;

109 
WORD
 
wRegAddr
 = 
m_wYkAddr
 ;

110 
BYTE
 *
buf
 = 
pbuf
 ;

112 if
pDa
->
byV
 =
YK_ERROR
 )

113 
bRu
 = 
FALSE
 ;

115 
bRu
 = 
TRUE
 ;

117 
buf
[
nBy
++]=
byAddr
;

118 if
bRu
 )

119 
buf
[
nBy
++]= 0x05 ;

121 
buf
[ 
nBy
++ ] = 0x85 ;

123 
buf
[
nBy
++]=
	`HIBYTE

wRegAddr
 );

124 
buf
[
nBy
++]=
	`LOBYTE

wRegAddr
 );

125 
buf
[
nBy
++]=
	`HIBYTE

wRegNum
 );

126 
buf
[
nBy
++]=
	`LOBYTE

wRegNum
 );

128 
n
 = 
nBy
 ;

129  
TRUE
 ;

130 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_SultanModBusSlave.h

5 #i!
defed
(
AFX_SULTANMODBUSSLAVE_H__26C2CB04_A9B7_4BF6_82DD_21BE65F20664__INCLUDED_
)

6 
	#AFX_SULTANMODBUSSLAVE_H__26C2CB04_A9B7_4BF6_82DD_21BE65F20664__INCLUDED_


	)

8 #i
_MSC_VER
 > 1000

9 #agm



11 
	~"Proc_ESD_ModBusSve.h
"

13 as
	cCProc_SuɪModBusSve
 : 
public
 
CProc_ESD_ModBusSve


15 
public
:

16 
CProc_SuɪModBusSve
();

17 
	mvtu
 ~
CProc_SuɪModBusSve
();

19 
vtu
 
BOOL
 
ykPross
(
BYTE
 
byAddr
, BYTE *
pBuf
, 
WORD
 
n
) ;

20 
vtu
 
BOOL
 
ykMesge

BYTE
 
byAddr
 , BYTE * 
pbuf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/main.cpp

2 
	~"Proc_ModBusSve.h
"

6 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

9 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

11 
CProc
 * 
pProc
 = 
NULL
 ;

12 
pProc
 = 
w
 
CProc_ModBusSve
 ;

13 if
pProc
 )

15 
pProc
->
m_pMhod
 = 
pMhod
 ;

16 
	`tf
( "ModBusSlave DLL OK.\n " ) ;

19  
pProc
 ;

20 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/CProtocol_ModBusTcp.cpp

5 
	~"CProc_ModBusT.h
"

6 
	~"ModBusT.h
"

12 
	gCProc_ModBusT
::
	$CProc_ModBusT
()

14 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

15 
	}
}

17 
	gCProc_ModBusT
::~
	$CProc_ModBusT
()

19 
size
 = 
m_modu
.
	`size
() ;

20  
i
 = 0 ; i < 
size
 ; i++ )

22 
de
 
m_modu
[ 
i
 ] ;

24 
m_modu
.
	`r
() ;

25 
	`tf
( "Delete All CProtocol_ModBusTcp OK . \n" );

26 
	}
}

30 
BOOL
 
	gCProc_ModBusT
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

32  
TRUE
;

33 
	}
}

35 
BOOL
 
	gCProc_ModBusT
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

37  
FALSE
 ;

38 
	}
}

40 
BOOL
 
	gCProc_ModBusT
::
	$In

BYTE
 
byLeNo
 )

44 
m_byLeNo
 = 
byLeNo
 ;

46 
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

47  
	`GDevDa
( ) ;

48 
	}
}

50 
BOOL
 
	gCProc_ModBusT
::
	$GDevDa
( )

52 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

53 
	`rtf

m_sDevPh
 , "%s/ModBusT/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

54 
CProfe
 
	`ofe

m_sDevPh
 ) ;

55  
	`ProssFeDa

ofe
 ) ;

56 
	}
}

58 
BOOL
 
	gCProc_ModBusT
::
	$ProssFeDa

CProfe
 &
ofe
 )

60 
BOOL
 
bR
 = 
FALSE
;

61 if!
ofe
.
	`IsVid
() )

63 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

64  
FALSE
 ;

67 
sSe
[ 200 ] = "DEVNUM" ;

68 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

70 
WORD
 
wModu
 = 0 ;

71 
ro
=1 ;

72 
WORD
 
addr
 =3 ;

73 
sName
[ 50 ] = { 0 };

74 
eme
[ 200 ] = { 0 };

75 
iNum
 = 0 ;

77 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

78 if
iNum
 == 0 )

80 
	`tf
( "Get DEVNUM Failed ! \n " );

81  
FALSE
 ;

84  
i
 = 0 ; i < 
iNum
 ; i++ )

86 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

88 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

89 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

90 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

91 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

92 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

95 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

96 i!
bR
 )

98 
	`tf
 ( "Create ModBusTcp Module=%d serialno=%dddr=%d sName=%s stemplate=%s \

99 
E
 \
n
", wModule, serialno,ddr, sName, stemplate );

100  
FALSE
;

103  
TRUE
 ;

104 
	}
}

106 
BOOL
 
	gCProc_ModBusT
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

108 
CProc_ModBusT
 * 
pProc
 = 
NULL
 ;

110 
pProc
 = 
w
 
ModBusT
;

111 
pProc
->
m_byLeNo
 = m_byLineNo ;

112 
pProc
->
m_wModuTy
 = 
iModu
 ;

113 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

114 
pProc
->
m_SlNo
 = 
iSlNo
 ;

116 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

117 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

118 
pProc
->
m_pMhod
 = m_pMethod ;

119 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

122 if!
pProc
->
	`In

m_byLeNo
 ) )

123  
FALSE
 ;

124 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

127 
m_modu
.
	`push_back

pProc
 ) ;

129  
TRUE
 ;

130 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/CProtocol_ModBusTcp.h

5 #i!
defed
(
AFX_CPROTOCOL_MODBUSTCP_H__DB4E4A83_510B_4232_A294_B1B4EE1AF4FD__INCLUDED_
)

6 
	#AFX_CPROTOCOL_MODBUSTCP_H__DB4E4A83_510B_4232_A294_B1B4EE1AF4FD__INCLUDED_


	)

10 
	~"../../she/Rtu.h
"

11 
	~"../../she/CMhod.h
"

12 
	#MODBUSTCPPREFIXFILENAME
 "/mynd/cfig/ModBusT/"

	)

14 as
	cCProc_ModBusT
 : 
public
 
CRtuBa


16 
public
:

17 
CProc_ModBusT
();

18 
	mvtu
 ~
CProc_ModBusT
();

20 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

21 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

23 
BOOL
 
UPSQuySPack

BYTE
 * 
buf
 , &
n
 );

25 
BOOL
 
UPSQuySDl

BYTE
 * 
buf
 , 
n
 );

27 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

29 
	meed
:

30 
BOOL
 
GDevDa
( ) ;

31 
	meed
:

32 
BOOL
 
ProssFeDa

CProfe
 &
ofe
 );

33 
BOOL
 
CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

35 
	mmt_sMaAddr
[ 24 ] ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/ModBusTcp.cpp

1 
	~"ModBusT.h
"

4 
	#ERROR_CONST
 5

	)

5 
	#COMSTATUS_ONLINE
 1

	)

6 
	#COMSTATUS_FAULT
 0

	)

8 
	#ERROR_FUN
 1

	)

9 
	#ERROR_REGISTER
 2

	)

10 
	#ERROR_DATA
 3

	)

11 
	#ERROR_CONFIG
 4

	)

13 
	gModBusT
::
	$ModBusT
()

15 
SdFg
 = 0;

16 
MsgFg
 = 0;

17 
FunNum
 = 0;

18 
m_wETim
 = 0;

19 
m_byPtStus
 = 0;

20 
EFg
 = 0;

21 
yk_cv_ag
 = 
FALSE
;

22 
time_ag
 = 0;

23 
Yk_FunNum
 = 0x05;

24 
	`memt
(
yk_bufSl
,0,(yk_bufSerial));

25 
	`memt
(
mt_sMaAddr
, 0, (mt_sMasterAddr));

26 
	}
}

28 
	gModBusT
::~
	$ModBusT
()

31 
	}
}

33 
BOOL
 
ModBusT
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

36 if
buf
 =
NULL
 )

37  
FALSE
 ;

39 
m_wETim
++;

40 if
m_wETim
 > 
ERROR_CONST
 )

42 
m_wETim
 = 
ERROR_CONST
 + 1 ;

43 
m_byPtStus
 = 
COMSTATUS_FAULT
;

47 
m_byPtStus
 = 
COMSTATUS_ONLINE
;

50 if
pBusMsg
 )

52 
	`DlBusMsgInfo

pBusMsg
);

57 if
MsgFg
 == 2 )

59  
FALSE
;

61 
MsgFg
 = 2;

62 
	`memy

buf
 , 
MsgBuf
 , 
MsgL
 );

63 
n
 = 
MsgL
;

64 
	`memt

MsgBuf
 , 0 , 
MsgL
);

65 
MsgL
 = 0;

66 
yk_cv_ag
 = 
FALSE
;

67  
TRUE
;

69 
	}
}

71 
BOOL
 
	gModBusT
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

74 
BOOL
 
R
 = 
FALSE
;

75 if
n
 =0 || 
buf
 =
NULL
 )

76  
FALSE
 ;

78 if(
yk_cv_ag
){

79 
time_t
 
t
;

80 
t
 = 
	`time
(
NULL
);

81 if((
t
 - 
time_ag
) < 5)

82  
FALSE
;

85 if(
buf
[7] == 0x05){

86 
yk_cv_ag
 = 
TRUE
;

87 
time_t
 
t
;

88 
t
 = 
	`time
(
NULL
);

89 
time_ag
 = 
t
;

92 if
buf
[2]==0 && buf[3]==0 && buf[4]==0

93 && (
buf
[5]+6)==
n
 && buf[6]=
m_wRtuAddr
 )

95 
FunNum
 = 
buf
[7];

96 
MsgFg
 = 0;

97  
FunNum
 )

100 
R
 = 
	`YXPack

buf
 , 
n
 );

103 
R
 = 
	`YcYmPack

buf
 , 
n
 );

106 
R
 = 
	`YcYmPack

buf
 , 
n
 );

109 
R
 = 
	`YKMsg

buf
 , 
n
 );

112 
	`EPack

buf
 , 
ERROR_FUN
 );

115 if
R
 =
TRUE
 )

117 
m_wETim
 = 0;

119  
TRUE
 ;

121  
FALSE
 ;

122 
	}
}

124 
BOOL
 
	gModBusT
::
	$In

BYTE
 
byLeNo
 )

126 
m_byLeNo
 = 
byLeNo
 ;

127 
m_byProID
 = 4;

128 
m_byEb
 = 1;

129 
m_wObjNum
 = 1;

130 
	`rtf

m_szObjName
, "%s", 
m_sDevName
 );

131 
	`rtf

m_ComCl1
, "%s", 
mt_sMaAddr
 );

132 
m_wRtuAddr
 = 
m_wDevAddr
 ;

133 
szFeName
[256] = "";

135 
	`rtf

szFeName
, "%s%s", 
MODBUSTCPPREFIXFILENAME
, 
m_sTemePh
 );

137 
	`RdMCfig

szFeName
 );

140 
	`InRtuBa
() ;

144  
TRUE
 ;

145 
	}
}

147 
BOOL
 
	gModBusT
::
	$InRtuBa
( )

149 
UINT
 
uPt
;

150 
BOOL
 
bOk
 = 
FALSE
;

151 
szCl
[32];

155 
CBaPt
::
	`GCommArib
(
m_ComCl1
, 
szCl
, 
uPt
);

157 
m_wPtNum
 = (
WORD
)
uPt
 ;

160 
	`CeTnsTab
();

163 
m_pMhod
->
	`RdAYcDa
(&
m_wYCBuf
[0]);

164 
m_pMhod
->
	`RdAYmDa
(&
m_dwYMBuf
[0]);

165 
m_pMhod
->
	`RdAYxDa
&
m_byYXbuf
[ 0 ] ) ;

167 
m_bTaskRun
 = 
TRUE
;

168  
bOk
;

169 
	}
}

171 
BOOL
 
	gModBusT
::
	$DlBusMsgInfo

PBUSMSG
 
pBusMsg
 )

173 
DeviNo
 = 0;

174 
YK_DATA
 *
pDa
 = (YK_DATA *)(
pBusMsg
->pData);

176  
pBusMsg
->
byMsgTy
 )

178 
YK_PROTO
:

179  
pBusMsg
->
dwDaTy
 )

182 
YK_EXCT_RTN
:

184 if
pBusMsg
->
DaNum
 != 1

185 || 
pBusMsg
->
DaL
 !(
YK_DATA
) )

187 
	`tf
("ModBusTcp Yk DataNumrr\n");

191 
DeviNo
 = 
m_pMhod
->
	`GSlNo
(
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
);

192 if
DeviNo
 == -1 )

196 
	`YKPack

m_wRayNum
 , 
pDa
->
byV
 );

197 
MsgFg
 = 0;

198 if
pDa
->
byV
 =
YK_ERROR
 && 
DeviNo
 > 10000 )

200 if
DeviNo
 > 10000 )

201 
	`EPack

yk_bufSl
, 
ERROR_REGISTER
 );

202 if
pDa
->
byV
 =
YK_ERROR
 )

203 
	`EPack

yk_bufSl
, 
ERROR_DATA
 );

208 
	`tf
("ModBusT c'fdhYK_DATATYPE %d\n", ()
pBusMsg
->
dwDaTy
);

216  
TRUE
;

217 
	}
}

220 
	gModBusT
::
	$RayEchoProc
(
BYTE
 
byCommd
, 
WORD
 
wIndex
, BYTE 
byResu
)

223 
	}
}

225 
BOOL
 
	gModBusT
::
	$YXPack

BYTE
 * 
buf
 , 
n
 )

227 
WORD
 
dex
 = 0;

228 
WORD
 
mt_gi
 = 256 * 
buf
[8] + buf[9];

229 
WORD
 
ginum
 = 256 * 
buf
[10] + buf[11];

231 
WORD
 
ModBusByL
 = ((
ginum
-1)/8)+1;

232 
WORD
 
ModBusTByL
 = 3+
ModBusByL
;

234 if
mt_gi
 > 9999 || mt_gi =0 ) || ( 
ginum
 > 9999 ||egisternum == 0 ) )

236 if
mt_gi
 > 9999 || mt_register == 0 )

237 
	`EPack

buf
 , 
ERROR_REGISTER
 );

238  
FALSE
;

240 
MsgBuf
[
dex
++] = 
buf
[0];

241 
MsgBuf
[
dex
++] = 
buf
[1];

242 
MsgBuf
[
dex
++] = 0;

243 
MsgBuf
[
dex
++] = 0;

244 
MsgBuf
[
dex
++] = 
ModBusTByL
 >> 8;

245 
MsgBuf
[
dex
++] = 
ModBusTByL
;

246 
MsgBuf
[
dex
++] = 
m_wRtuAddr
;

247 
MsgBuf
[
dex
++] = 
FunNum
;

248 
MsgBuf
[
dex
++] = 
ModBusByL
;

249 
j
 = 0;

250  
j
=0; j<
ModBusByL
; j++ )

253 
BYTE
 
i
 = 0;

254 
BYTE
 
ByYXV
 = 0;

255  
i
=0; i<8; i++ )

257 if
j
==
ModBusByL
-1 && 
i
 =
ginum
%8 && 0 !=egisternum%8)

260 if
m_pDIMTab
[
mt_gi
-1+(8*
j
+
i
)].
wS
 > 0 && m_pDIMTab[mt_gi-1+(8*j+i)].
wPNum
 > 0 )

261 
ByYXV
 |
m_byYXbuf
[
mt_gi
-1+(8*
j
+
i
)]<<i;

264 
	`EPack

buf
 , 
ERROR_REGISTER
 );

265  
FALSE
;

268 
MsgBuf
[
dex
++] = 
ByYXV
;

271 
MsgL
 = 
dex
;

272  
TRUE
;

273 
	}
}

275 
BOOL
 
	gModBusT
::
	$YcYmPack

BYTE
 * 
buf
 , 
n
 )

277 
BOOL
 
ag
 ;

278 
DWORD
 
ymv
 ;

279 
WORD
 
dex
 = 0,
wV
 = 0;;

280 
fV
 = 0.0f ;

281 
WORD
 
mt_gi
 = 256 * 
buf
[8] + buf[9];

282 
WORD
 
ginum
 = 256 * 
buf
[10] + buf[11];

284 
WORD
 
ModBusByL
 = 2*
ginum
;

285 
WORD
 
ModBusTByL
 = 3+
ModBusByL
;

287 if
mt_gi
 > 9999 || mt_gi =0 ) || ( 
ginum
 > 9999 ||egisternum == 0 )

288 || ( 
mt_gi
 <6800 && mt_gi+
ginum
 > 6800 ) )

290 
	`EPack

buf
 , 
ERROR_REGISTER
 );

291  
FALSE
;

293 
MsgBuf
[
dex
++] = 
buf
[0];

294 
MsgBuf
[
dex
++] = 
buf
[1];

295 
MsgBuf
[
dex
++] = 0;

296 
MsgBuf
[
dex
++] = 0;

297 
MsgBuf
[
dex
++] = 
ModBusTByL
 >> 8;

298 
MsgBuf
[
dex
++] = 
ModBusTByL
;

299 
MsgBuf
[
dex
++] = 
m_wRtuAddr
;

300 
MsgBuf
[
dex
++] = 
FunNum
;

301 
MsgBuf
[
dex
++] = 
ModBusByL
;

302 
j
 = 0;

303  
j
=0; j<
ginum
; j++ )

306 if
mt_gi
 >= 1 && mt_register <= 6800 )

308 if
m_pAIMTab
[
mt_gi
-1+
j
].
wS
 > 0 && m_pAIMTab[mt_gi-1+j].
wPNum
 > 0 )

310 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
mt_gi
-1+
j
].
wS
, m_pAIMTab[mt_gi-1+j].
wPNum
, 
m_wYCBuf
[mt_register-1+j]);

311 
wV
 = ( 
WORD
 )
fV
 ;

312 
MsgBuf
[
dex
++] = 
	`HIBYTE
(
wV
);

313 
MsgBuf
[
dex
++] = 
	`LOBYTE
(
wV
);

317 
	`EPack

buf
 , 
ERROR_REGISTER
 );

318  
FALSE
;

321 if
mt_gi
 >= 6801 && mt_register <= 9999 )

323 if
mt_gi
-6801 )%2 =1 ) || ( 
ginum
%2 == 1 ) )

325 
	`EPack

buf
 , 
ERROR_REGISTER
 );

326  
FALSE
;

330 if
j
%2 == 0 )

332 if
m_pPIMTab
[(
mt_gi
-6801)/2+
j
/2].
wS
 > 0 && m_pPIMTab[(mt_gi-6801)/2+j/2].
wPNum
 > 0 )

334 
ymv
 = 
	`GPulDa
 ( 
m_pPIMTab
[(
mt_gi
-6801)/2+
j
/2].
wS
,

335 
m_pPIMTab
[(
mt_gi
-6801)/2+
j
/2].
wPNum
, &
ag
 );

336 if!
ag
 )

338 
	`EPack

buf
 , 
ERROR_DATA
 );

339  
FALSE
;

341 
MsgBuf
[
dex
++] = 
	`HIBYTE
(
	`HIWORD
(
ymv
));

342 
MsgBuf
[
dex
++] = 
	`LOBYTE
(
	`HIWORD
(
ymv
));

343 
MsgBuf
[
dex
++] = 
	`HIBYTE
(
	`LOWORD
(
ymv
));

344 
MsgBuf
[
dex
++] = 
	`LOBYTE
(
	`LOWORD
(
ymv
));

348 
	`EPack

buf
 , 
ERROR_REGISTER
 );

349  
FALSE
;

355 
MsgL
 = 
dex
;

356  
TRUE
;

357 
	}
}

359 
BOOL
 
	gModBusT
::
	$YKMsg

BYTE
 * 
buf
 , 
n
 )

361 
WORD
 
mt_gi
 = 256 * 
buf
[8] + buf[9];

363 if
mt_gi
 > 10000 || mt_register == 0 ) ||

364 !
buf
[10] == 0xff || buf[10] == 0x00 ) && buf[11] == 0x00 ) )

366 if
mt_gi
 > 10000 || mt_register == 0 )

367 
	`EPack

buf
 , 
ERROR_REGISTER
 );

368 if!
buf
[10] == 0xff || buf[10] == 0x00 ) && buf[11] == 0x00 ) )

369 
	`EPack

buf
 , 
ERROR_DATA
 );

370  
FALSE
;

372 
BYTE
 
byBusNo
;

373 
WORD
 
byS
;

374 
BYTE
 
byStus
;

375 
WORD
 
wDevAddr
;

376 
WORD
 
wP
;

378  
buf
[10] )

381 
byStus
 = 1;

384 
byStus
 = 0;

388 
byS
 = 
m_pDOMTab
[
mt_gi
-1].
wS
 - 1 ;

389 
wP
 = 
m_pDOMTab
[
mt_gi
-1].
wPNum
 - 1 ;

390 if
m_pDOMTab
[
mt_gi
-1].
wS
 > 0 && m_pDOMTab[mt_gi-1].
wPNum
 > 0 )

392 
yk_bufSl
[0]=
buf
[0];

393 
yk_bufSl
[1]=
buf
[1];

394 
Yk_FunNum
 = 
buf
[7];

395 if(
m_pMhod
->
	`GBusLeAndAddr
(
byS
, 
byBusNo
, 
wDevAddr
))

397 
m_pMhod
->
	`SYkExe
(
this
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byStus
);

399 
m_wRayNum
 = 
mt_gi
;

400  
TRUE
;

404 
	`EPack

buf
 , 
ERROR_REGISTER
 );

405  
FALSE
;

407 
	}
}

409 
BOOL
 
	gModBusT
::
	$YKPack

yk_gi
 , 
v
 )

412 
WORD
 
dex
 = 0;

413 
WORD
 
ModBusTByL
 = 6;

415 if
yk_gi
 > 10000 || yk_register == 0 )

417 
	`EPack

yk_bufSl
 , 
ERROR_REGISTER
 );

418  
FALSE
;

420 
MsgBuf
[
dex
++] = 
yk_bufSl
[0];

421 
MsgBuf
[
dex
++] = 
yk_bufSl
[1];

422 
MsgBuf
[
dex
++] = 0;

423 
MsgBuf
[
dex
++] = 0;

424 
MsgBuf
[
dex
++] = 
ModBusTByL
 >> 8;

425 
MsgBuf
[
dex
++] = 
ModBusTByL
;

426 
MsgBuf
[
dex
++] = 
m_wRtuAddr
;

428 
MsgBuf
[
dex
++] = 
Yk_FunNum
;

430 
MsgBuf
[
dex
++] = 
yk_gi
>>8;

431 
MsgBuf
[
dex
++] = 
yk_gi
;

433 if
v
==1 )

434 
MsgBuf
[
dex
++] = 0xff;

435 if
v
==0 )

436 
MsgBuf
[
dex
++] = 0x00;

439 
	`EPack

yk_bufSl
 , 
ERROR_DATA
 );

440  
TRUE
;

443 
MsgBuf
[
dex
++] = 0x00;

445 
MsgL
 = 
dex
;

446  
TRUE
;

447 
	}
}

449 
BOOL
 
	gModBusT
::
	$EPack
(
BYTE
 * 
buf
,BYTE 
rag
)

451 
MsgFg
 = 1;

453 
BYTE
 
dex
 = 0;

455 
MsgBuf
[
dex
++] = 
buf
[0];

456 
MsgBuf
[
dex
++] = 
buf
[1];

457 
MsgBuf
[
dex
++] = 0;

458 
MsgBuf
[
dex
++] = 0;

459 
MsgBuf
[
dex
++] = 0;

460 
MsgBuf
[
dex
++] = 3;

461 
MsgBuf
[
dex
++] = 
m_wRtuAddr
;

462 
MsgBuf
[
dex
++] = 
FunNum
 | 0x80;;

463 
MsgBuf
[
dex
++] = 
rag
;

465 
MsgL
 = 
dex
;

466  
TRUE
;

467 
	}
}

469 
BOOL
 
	gModBusT
::
	$WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
wV
)

471 if(
m_pwAITns
==
NULL
 
FALSE
;

472 
WORD
 
wNum
 = 
m_pwAITns
[
wP
];

473 if(
wNum
>
m_wAISum
 
FALSE
;

474 if(
wNum
<
MODBUSTCPMAX_AI_LEN
)

476 
nDt
 = 
wV
 - 
m_wYCBuf
[
wNum
];

477 if(
	`abs
(
nDt
)>=
m_wDdV
)

479 
m_wYCBuf
[
wNum
] = 
wV
;

480 
	`AddAlogEvt

wSlNo
 , 
wNum
 , 
wV
 );

483  
TRUE
 ;

484 
	}
}

486 
BOOL
 
	gModBusT
::
	$WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
)

488 if(
m_pwDITns
==
NULL
 
FALSE
;

489 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

490 if(
wNum
>
m_wDISum
 
FALSE
;

491 if
wNum
<
MODBUSTCPMAX_DI_LEN
)

493 if
m_byYXbuf
[ 
wNum
 ] !
wV
 )

495 
m_byYXbuf
[ 
wNum
 ] = 
wV
 ;

497 
	`AddDigEvt

wSlNo
 , 
wNum
 , 
wV
 );

500  
TRUE
 ;

501 
	}
}

502 
BOOL
 
	gModBusT
::
	$WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
)

504 if(
m_pwPITns
==
NULL
 
FALSE
;

505 
WORD
 
wNum
 = 
m_pwPITns
[
wP
];

506 if(
wNum
>
m_wPISum
 
FALSE
;

507 if(
wNum
<
MODBUSTCPMAX_PI_LEN
)

509 
m_dwYMBuf
[
wNum
] = 
dwV
;

511  
TRUE
 ;

512 
	}
}

514 
BOOL
 
	gModBusT
::
	$WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

516 if(
m_pwDITns
==
NULL
 
FALSE
;

517 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

518 if(
wNum
>=
m_wDISum
 
FALSE
;

519 if(
wNum
<
MODBUSTCPMAX_DI_LEN
)

521 
	`AddSOEInfo
(
wSlNo
 , 
wNum
, 
wV
, 
lTime
, 
wMiSecd
);

523  
TRUE
 ;

524 
	}
}

526 
	gModBusT
::
	$TimProc
()

529 
	`RdChgDa
();

531 
	}
}

533 
BOOL
 
	gModBusT
::
	$GDevCommS
( )

535 if(
m_byPtStus
 =
COMSTATUS_ONLINE
)

537  
COM_DEV_NORMAL
 ;

541  
COM_DEV_ABNORMAL
 ;

543 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/ModBusTcp.h

1 #i!
defed
(
MODBUSTCP_
)

2 
	#MODBUSTCP_


	)

7 
	~"CProc_ModBusT.h
"

9 
	#MODBUSTCPMAX_AI_LEN
 (6800)

	)

10 
	#MODBUSTCPMAX_PI_LEN
 (1599)

	)

11 
	#MODBUSTCPMAX_DI_LEN
 (9999)

	)

13 
	#MODBUSTCPMAX_MSG_LEN
 (1024)

	)

15 as
	cModBusT
 : 
public
 
CProc_ModBusT


17 
public
:

18 
ModBusT
();

19 
	mvtu
 ~
ModBusT
();

21 
BYTE
 
	mSdFg
;

22 
	mm_wYCBuf
[
MODBUSTCPMAX_AI_LEN
];

23 
DWORD
 
	mm_dwYMBuf
[
MODBUSTCPMAX_PI_LEN
];

24 
BYTE
 
	mm_byYXbuf
[
MODBUSTCPMAX_DI_LEN
 ] ;

26 
BYTE
 
	mMsgBuf
[
MODBUSTCPMAX_MSG_LEN
];

27 
WORD
 
	mMsgL
;

28 
BYTE
 
	mMsgFg
;

29 
BYTE
 
	mFunNum
;

30 
BYTE
 
	mEFg
;

31 
	mm_wETim
;

32 
	mm_byPtStus
;

33 
BYTE
 
	myk_bufSl
[2];

35 
BYTE
 
	mYk_FunNum
;

36 
BOOL
 
	myk_cv_ag
;

37 
UINT
 
	mtime_ag
;

39 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

40 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

41 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

42 
vtu
 
BOOL
 
InRtuBa
();

43 
vtu
 
BOOL
 
WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
wV
) ;

44 
vtu
 
BOOL
 
WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
) ;

45 
vtu
 
BOOL
 
WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
) ;

46 
vtu
 
BOOL
 
WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
) ;

47 
vtu
 
RayEchoProc
(
BYTE
 
byCommd
, 
WORD
 
wIndex
, BYTE 
byResu
);

50 
vtu
 
BOOL
 
GDevCommS
( ) ;

51 
vtu
 
TimProc
() ;

53 
BOOL
 
YXPack

BYTE
 * 
buf
 , 
n
 );

54 
BOOL
 
YcYmPack

BYTE
 * 
buf
 , 
n
 );

55 
BOOL
 
YKMsg

BYTE
 * 
buf
 , 
n
 );

56 
BOOL
 
YKPack

yk_gi
 , 
v
 );

58 
BOOL
 
DlBusMsgInfo

PBUSMSG
 
pBusMsg
 );

60 
BOOL
 
EPack

BYTE
 * 
buf
 , BYTE 
rag
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/main.cpp

1 
	~<dio.h
>

2 
	~"CProc_ModBusT.h
"

6 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

11 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

13 
CProc
 * 
pProc
 = 
NULL
 ;

14 
pProc
 = 
w
 
CProc_ModBusT
 ;

15 if
pProc
 )

17 
pProc
->
m_pMhod
 = 
pMhod
 ;

18 
	`tf
( "ModBusTcp DLL OK.\n " ) ;

21  
pProc
 ;

22 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/CProtocol_ModBusTcp.cpp

1 
	~"CProc_ModBusT.h
"

2 
	~"ModBusT_Gh.h
"

4 
	#MODBUSTCP_GATHER
 2

	)

8 
	gCProc_ModBusT_Gh
::
	$CProc_ModBusT_Gh
()

11 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

13 
	}
}

15 
	gCProc_ModBusT_Gh
::~
	$CProc_ModBusT_Gh
()

18 
size
 = 
m_modu
.
	`size
() ;

19  
i
 = 0 ; i < 
size
 ; i++ )

21 
de
 
m_modu
[ 
i
 ] ;

23 
m_modu
.
	`r
() ;

24 
	`tf
( "Delete All CProtocol_ModBusTcp_Gather OK . \n" );

25 
	}
}

27 
BOOL
 
	gCProc_ModBusT_Gh
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

29  
FALSE
 ;

30 
	}
}

32 
BOOL
 
	gCProc_ModBusT_Gh
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

34  
FALSE
 ;

35 
	}
}

37 
BOOL
 
	gCProc_ModBusT_Gh
::
	$In

BYTE
 
byLeNo
 )

41 
m_byLeNo
 = 
byLeNo
 ;

43 
m_ProTy
 = 
PROTOCO_GATHER
 ;

45  
	`GDevDa
( ) ;

46 
	}
}

48 
BOOL
 
	gCProc_ModBusT_Gh
::
	$GDevDa
( )

50 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

51 
	`rtf

m_sDevPh
 , "%s/MBT/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

52 
CProfe
 
	`ofe

m_sDevPh
 ) ;

54  
	`ProssFeDa

ofe
 ) ;

55 
	}
}

57 
BOOL
 
	gCProc_ModBusT_Gh
::
	$ProssFeDa

CProfe
 &
ofe
 )

59 
BOOL
 
bR
 = 
FALSE
;

60 if!
ofe
.
	`IsVid
() )

62 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

63  
FALSE
 ;

66 
sSe
[ 200 ] = "DEVNUM" ;

67 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

69 
WORD
 
wModu
 = 0 ;

70 
ro
=1 ;

71 
WORD
 
addr
 =3 ;

72 
sName
[ 50 ] = { 0 };

73 
eme
[ 200 ] = { 0 };

74 
iNum
 = 0 ;

76 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

77 if
iNum
 == 0 )

79 
	`tf
( "Get DEVNUM Failed ! \n " );

80  
FALSE
 ;

83  
i
 = 0 ; i < 
iNum
 ; i++ )

85 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

87 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

88 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

89 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

90 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

91 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

94 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

95 i!
bR
 )

97 
	`tf
 ( "CModBusT Modu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

99  
FALSE
;

103  
TRUE
 ;

104 
	}
}

105 
BOOL
 
	gCProc_ModBusT_Gh
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

107 
CProc_ModBusT_Gh
 * 
pProc
 = 
NULL
 ;

108 
BOOL
 
bR
 = 
FALSE
;

109 
	`tf
("------------------iModu:%2x-------------------\n", 
iModu
);

110  
iModu
 )

113 
MODBUSTCP_GATHER
:

114 
pProc
 = 
w
 
ModBusT_Gh
;

115 
pProc
->
m_byLeNo
 = m_byLineNo ;

116 
pProc
->
m_wModuTy
 = 
iModu
 ;

117 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

118 
pProc
->
m_SlNo
 = 
iSlNo
 ;

120 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

121 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

122 
pProc
->
m_pMhod
 = m_pMethod ;

123 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

125 
bR
 = 
pProc
->
	`In

m_byLeNo
 ) ;

126 i!
bR
 )

128 
	`tf
 ( "Init Error \n");

129  
FALSE
;

131 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

135 
	`tf
( "ModBusTcp_Gather don't containhis module Failed .\n" );

136  
FALSE
 ;

139 
m_modu
.
	`push_back

pProc
 ) ;

141  
TRUE
 ;

142 
	}
}

144 
BOOL
 
	gCProc_ModBusT_Gh
::
	$BrdCa

BYTE
 * 
buf
 , &
n
 )

147 
dex
 = 0 ;

148 
buf
[ 
dex
++ ] = 0xFF ;

149 
buf
[ 
dex
++ ] = 0x02 ;

150 
buf
[ 
dex
++ ] = 0x03 ;

151 
buf
[ 
dex
++ ] = 0x04 ;

152 
n
 = 
dex
 ;

153 
	`tf
( "\n CProtocol_ModBusTcp_Gather TestBroadCast \n " ) ;

154  
TRUE
 ;

155 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/CProtocol_ModBusTcp.h

1 #ide
CPROTOCOL_MODBUSTCP_H


2 
	#CPROTOCOL_MODBUSTCP_H


	)

4 
	~"../../she/CProc.h
"

5 
	~"../../she/CMhod.h
"

7 as
	cCProc_ModBusT_Gh
 : 
public
 
CProc


9 
public
:

10 
CProc_ModBusT_Gh
();

11 
	mvtu
 ~
CProc_ModBusT_Gh
();

12 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 );

13 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 );

14 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

15 
vtu
 
BOOL
 
BrdCa

BYTE
 * 
buf
 , &
n
 ) ;

16 
vtu
 
	$TimProc
(){ ; }

17 
eed
:

18 
BOOL
 
	`GDevDa
( ) ;

19 
eed
:

20 
BOOL
 
	`ProssFeDa

CProfe
 &
ofe
 );

21 
BOOL
 
	`CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

23 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/ModBusTcp_Gather.cpp

1 
	~"ModBusT_Gh.h
"

2 
	~<mh.h
>

3 
	~<rg.h
>

4 
	~<dlib.h
>

5 cڡ 
UINT
 
	gERROR_CONST
 = 5;

6 cڡ 
UINT
 
	gCOMSTATUS_ONLINE
 = 1;

7 cڡ 
UINT
 
	gCOMSTATUS_FAULT
 = 1;

8 
	#MODBUSTPREFIXNAME
 "/mynd/cfig/MBT/me/"

	)

10 
	gModBusT_Gh
::
	$ModBusT_Gh
()

12 
yk_da
 = 
NULL
;

13 
ykty
 = 0;

14 
byBusNo
 = 0;

15 
wDevNo
 = 0;

16 
wP
 = 0;

17 
byV
 = 0;

18 
rtimes
 = 
ERROR_CONST
 + 1;

19 
lesum
 = 0;

20 
le
 = 0;

21 
ptus
 = 
COMSTATUS_FAULT
;

22 
time_ag
 = 0;

23 
yc_sum
 = 0;

24 
ym_sum
 = 0;

25 
yx_sum
 = 0;

26 
yc_d
 = 0;

27 
ym_d
 = 0;

28 
yx_d
 = 0;

29 
	}
}

31 
	gModBusT_Gh
::~
	$ModBusT_Gh
()

32 {
	}
}

34 
BOOL
 
ModBusT_Gh
::
	$GProcBuf
(
BYTE
 *
buf
, &
n
, 
PBUSMSG
 
pBusMsg
)

36 
buf
[
n
++] = 
vec_cf
[
le
].
af
 >> 8;

37 
buf
[
n
++] = 
vec_cf
[
le
].
af
;

38 
buf
[
n
++] = 
vec_cf
[
le
].
y
 >> 8;

39 
buf
[
n
++] = 
vec_cf
[
le
].
y
;

40 
n
 += 2;

41 
buf
[
n
++] = 
m_wDevAddr
;

43 if(
pBusMsg
 !
NULL
){

44 if(
pBusMsg
->
byMsgTy
 =
YK_PROTO
){

45 if(
vec_cf
[
le
].
ty
 == 0x04){

46 
yk_da
 = (
YK_DATA
 *)
pBusMsg
->
pDa
;

47 
ykty
 = 
pBusMsg
->
dwDaTy
;

48 
byBusNo
 = 
pBusMsg
->
SrcInfo
.byBusNo;

49 
wDevNo
 = 
pBusMsg
->
SrcInfo
.wDevNo;

50 
wP
 = 
yk_da
->wPnt;

51 
byV
 = 
yk_da
->byVal;

52 
	`gykame
(
buf
, 
n
);

53 
buf
[4] = (
n
 - 6) >> 8;

54 
buf
[5] = (
n
 - 6);

55 if(
rtimes
++ > 40000)

56 
rtimes
 = 
ERROR_CONST
 + 1;

57  
TRUE
;

61 
time_t
 
now
;

62 
	`time
(&
now
);

63 if(
now
 - 
time_ag
 > 1800){

64 
	`gsyname
(
buf
, 
n
);

65 
buf
[4] = (
n
 - 6) >> 8;

66 
buf
[5] = 
n
 - 6;

67 
time_ag
 = 
now
;

68  
TRUE
;

70 
vec_cf
[
le
].
ty
){

72 
	`gycame
(
buf
, 
n
);

75 
	`gymame
(
buf
, 
n
);

78 
	`gyxame
(
buf
, 
n
);

81 
	`gsame
(
buf
, 
n
);

84  
FALSE
;

86 
buf
[4] = (
n
 - 6) >> 8;

87 
buf
[5] = 
n
 - 6;

88 if(
rtimes
++ > 40000)

89 
rtimes
 = 
ERROR_CONST
 + 1;

90 
le
 = (++le% 
lesum
;

91  
TRUE
;

92 
	}
}

94 
	gModBusT_Gh
::
	$gykame
(
BYTE
 *
buf
, &
n
)

96 
buf
[
n
++] = 
vec_cf
[
le
].
func
;

97 if((
ykty
 =
YK_SEL
&& (
byV
 == 0x01)){

98 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[0] >> 8;

99 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[0];

100 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 24;

101 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 16;

103 if((
ykty
 =
YK_SEL
&& (
byV
 == 0x00)){

104 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[1] >> 8;

105 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[1];

106 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 8;

107 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
;

109 if((
ykty
 =
YK_EXCT
&& (
byV
 == 0x01)){

110 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[2] >> 8;

111 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[2];

112 if(
vec_cf
[
le
].
func
 == 0x06){

113 
buf
[
n
++] = 
vec_cf
[
le
].
et_vue
 >> 8;

114 
buf
[
n
++] = 
vec_cf
[
le
].
et_vue
;

117 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 24;

118 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 16;

122 if((
ykty
 =
YK_EXCT
&& (
byV
 == 0x00)){

123 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[3] >> 8;

124 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[3];

125 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 8;

126 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
;

128 if((
ykty
 =
YK_CANCEL
&& (
byV
 == 0x01)){

129 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[4] >> 8;

130 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[4];

131 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 24;

132 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 16;

134 if((
ykty
 =
YK_CANCEL
&& (
byV
 == 0x00)){

135 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[5];

136 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr_yk
[5];

137 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
 >> 8;

138 
buf
[
n
++] = 
vec_cf
[
le
].
yk_rui
;

140 
	}
}

142 
	gModBusT_Gh
::
	$gycame
(
BYTE
 *
buf
, &
n
)

144 
buf
[
n
++] = 
vec_cf
[
le
].
func
;

145 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
 >> 8;

146 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
;

147 
buf
[
n
++] = 
vec_cf
[
le
].
num
 >> 8;

148 
buf
[
n
++] = 
vec_cf
[
le
].
num
;

149 
	}
}

151 
	gModBusT_Gh
::
	$gymame
(
BYTE
 *
buf
, &
n
)

153 
buf
[
n
++] = 
vec_cf
[
le
].
func
;

154 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
 >> 8;

155 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
;

156 
buf
[
n
++] = 
vec_cf
[
le
].
num
 >> 8;

157 
buf
[
n
++] = 
vec_cf
[
le
].
num
;

158 
	}
}

160 
	gModBusT_Gh
::
	$gyxame
(
BYTE
 *
buf
, &
n
)

162 
buf
[
n
++] = 
vec_cf
[
le
].
func
;

163 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
 >> 8;

164 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
;

165 
buf
[
n
++] = 
vec_cf
[
le
].
num
 >> 8;

166 
buf
[
n
++] = 
vec_cf
[
le
].
num
;

167 
	}
}

169 
	gModBusT_Gh
::
	$gsyname
(
BYTE
 *
buf
, &
n
)

171 
time_t
 
tim
;

172 
tm
 *
timeobj
;

173 
	`time
(&
tim
);

174 
timeobj
 = 
	`loime
(&
tim
);

175 
buf
[
n
++] = 0x10;

176 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
 >> 8;

177 
buf
[
n
++] = 
vec_cf
[
le
].
gi_addr
;

178 
buf
[
n
++] = 
vec_cf
[
le
].
num
 >> 8;

179 
buf
[
n
++] = 
vec_cf
[
le
].
num
;

180 
buf
[
n
++] = 
vec_cf
[
le
].
num
 * 2;

182 
buf
[
n
++] = 
timeobj
->
tm_yr
 - 100;

183 
buf
[
n
++] = 
timeobj
->
tm_m
 + 1;

184 
buf
[
n
++] = 
timeobj
->
tm_mday
;

185 
buf
[
n
++] = 
timeobj
->
tm_hour
;

186 
buf
[
n
++] = 
timeobj
->
tm_m
;

187 
buf
[
n
++] = 
timeobj
->
tm_c
;

188 
buf
[
n
++] = 0x00;

189 
buf
[
n
++] = 0x00;

190 
	}
}

192 
	gModBusT_Gh
::
	$gsame
(
BYTE
 *
buf
, &
n
)

194 
buf
[
n
++] = 
m_wDevAddr
;

195 
buf
[
n
++] = 
vec_cf
[
le
].
func
;

196 
	}
}

198 
BOOL
 
	gModBusT_Gh
::
	$ProssProcBuf
(
BYTE
 *
buf
, 
n
)

200 if((
buf
[0] !(
vec_cf
[
le
].
af
 >> 8)|| (buf[1] !(vec_cf[le].af & 0xFF)|| (buf[2] !(vec_cf[le].
y
 >> 8)) || (buf[3] != (vec_conf[line].protype & 0xFF)))

201  
FALSE
;

203 if((
buf
[4] !((
n
 - 6) & 0xFF00)) || (buf[5] != ((len - 6) & 0xFF)))

204  
FALSE
;

205 if((
vec_cf
[
le
].
func
 !
buf
[7]|| (
m_wDevAddr
 != buf[6]))

206  
FALSE
;

207 
vec_cf
[
le
].
func
){

209 if(!
	`sveyxame
(
buf
 + 8))

210  
FALSE
;

214 if(
buf
[8] !
n
 - 9)

215  
FALSE
;

216 if(
vec_cf
[
le
].
ty
 == 1){

217 if(!
	`sveymame
(
buf
 + 9, 
n
 - 9))

218  
FALSE
;

220 if(
vec_cf
[
le
].
ty
 == 0){

221 if(!
	`sveycame
(
buf
 + 9, 
n
 - 9))

222  
FALSE
;

224 if(
vec_cf
[
le
].
ty
 == 2){

225 if(!
	`sveyxame
(
buf
 + 8))

226  
FALSE
;

229  
FALSE
;

233 
	`sveykame
(
buf
 + 8);

236 if(!
	`svesame
(
buf
 + 8, 
vec_cf
[
le
]))

237  
FALSE
;

240  
FALSE
;

242 
rtimes
 = 0;

244  
TRUE
;

245 
	}
}

247 
BOOL
 
	gModBusT_Gh
::
	$sveyxame
(
BYTE
 *
buf
)

249 
UINT
 
vuemp
 = 0;

250 
i
 = 
buf
[0];

251 
k
 = 0;

252 if((
buf
[0] > 4) || (buf[0] < 1))

253  
FALSE
;

255 if(
vec_cf
[
le
].
func
 == 2)

257 
vuemp
 = vuem<< 8 | 
buf
[
i
--];

258 }
i
 > 0);

261 
vuemp
 = vuem<< 8 | 
buf
[++
k
];

262 }
k
 < 
i
);

263 
m
=0; m < 32; m++){

264 if(
vec_cf
[
le
].
yx_mask
 & (
UINT
)
	`pow
(2, 
m
)){

265 
m_pMhod
->
	`SYxDa
(
m_SlNo
, 
yx_d
++, (
vuemp
 & (
UINT
)
	`pow
(2, 
m
)) ? 1 : 0);

268 
yx_d
 = yx_d % 
yx_sum
;

269  
TRUE
;

270 
	}
}

272 
BOOL
 
	gModBusT_Gh
::
	$sveymame
(
BYTE
 *
buf
, 
n
)

274 
vue
 = 0;

275 
BYTE
 
offt
 = 0;

276 if(
vec_cf
[
le
].
da_n
 == 0x02)

278 
vue
 = (
vec_cf
[
le
].
dy
 =1? ()
	`dwoby
(
buf
 + 
offt
) : ()()dealtwobyte(buf + offset);

279 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 
ym_d
++, 
vue
);

280 
offt
 += 2;

281 }(
offt
 < 
n
&& (
ym_d
 < 
ym_sum
));

283 if((
vec_cf
[
le
].
da_n
 =0x04&& ((vec_cf[le].
dy
 == 0x00) || (vec_conf[line].datatype == 0x01)))

285 
vue
 = (
vec_cf
[
le
].
dy
 =1? ()
	`dlfourby
(
buf
 + 
offt
) : ()()dealfourbyte(buf + offset);

286 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 
ym_d
++, 
vue
);

287 
offt
 += 4;

288 }(
offt
 < 
n
&& (
ym_d
 < 
ym_sum
));

290 if((
vec_cf
[
le
].
da_n
 =0x04&& (vec_cf[le].
dy
 == 0x02))

292 
vue
 = ()
	`dltby
(
buf
 + 
offt
, 
n
);

293 
m_pMhod
->
	`SYmDa
(
m_SlNo
, 
ym_d
++, 
vue
);

294 
offt
 += 4;

295 }(
offt
 < 
n
&& (
ym_d
 < 
ym_sum
));

297  
FALSE
;

299 
ym_d
 = ym_d % 
ym_sum
;

300  
TRUE
;

301 
	}
}

303 
BOOL
 
	gModBusT_Gh
::
	$sveycame
(
BYTE
 *
buf
, 
n
)

305 
vue
 = 0;

306 
BYTE
 
offt
 = 0;

307 if(
vec_cf
[
le
].
da_n
 == 0x02)

309 
vue
 = (
vec_cf
[
le
].
dy
 =1? ()
	`dwoby
(
buf
 + 
offt
) : ()()dealtwobyte(buf + offset);

310 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
yc_d
++, 
vue
);

311 
offt
 += 2;

312 }(
offt
 < 
n
&& (
yc_d
 < 
yc_sum
));

314 if((
vec_cf
[
le
].
da_n
 =0x04&& ((vec_cf[le].
dy
 == 0x00) || (vec_conf[line].datatype == 0x01)))

316 
vue
 = (
vec_cf
[
le
].
dy
 =1? ()
	`dlfourby
(
buf
 + 
offt
) : ()()dealfourbyte(buf + offset);

317 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
yc_d
++, 
vue
);

318 
offt
 += 4;

319 }(
offt
 < 
n
&& (
yc_d
 < 
yc_sum
));

321 if((
vec_cf
[
le
].
da_n
 =0x04&& (vec_cf[le].
dy
 == 0x02))

323 
vue
 = ()
	`dltby
(
buf
 + 
offt
, 
n
);

324 
m_pMhod
->
	`SYcDa
(
m_SlNo
, 
yc_d
++, 
vue
);

325 
offt
 += 4;

326 }(
offt
 < 
n
&& (
yc_d
 < 
yc_sum
));

329  
FALSE
;

330 
yc_d
 = yc_d % 
yc_sum
;

331  
TRUE
;

332 
	}
}

334 
	gModBusT_Gh
::
	$sveykame
(
BYTE
 *
buf
)

336 if((
buf
[0] =(
vec_cf
[
le
].
gi_addr_yk
[0] >> 8)) && (buf[1] == (vec_conf[line].register_addr_yk[0] & 0xFF)))

337 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

338 if((
buf
[0] =(
vec_cf
[
le
].
gi_addr_yk
[1] >> 8)) && (buf[1] == (vec_conf[line].register_addr_yk[1] & 0xFF)))

339 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

340 if((
buf
[0] =(
vec_cf
[
le
].
gi_addr_yk
[2] >> 8)) && (buf[1] == (vec_conf[line].register_addr_yk[2] & 0xFF)))

341 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

342 if((
buf
[0] =(
vec_cf
[
le
].
gi_addr_yk
[3] >> 8)) && (buf[1] == (vec_conf[line].register_addr_yk[3] & 0xFF)))

343 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

344 if((
buf
[0] =(
vec_cf
[
le
].
gi_addr_yk
[4] >> 8)) && (buf[1] == (vec_conf[line].register_addr_yk[4] & 0xFF)))

345 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

346 if((
buf
[0] =(
vec_cf
[
le
].
gi_addr_yk
[5] >> 8)) && (buf[1] == (vec_conf[line].register_addr_yk[5] & 0xFF)))

347 
m_pMhod
->
	`SYkSR
(
this
, 
byBusNo
, 
wDevNo
, 
wP
, 
byV
);

349 
	}
}

351 
	gModBusT_Gh
::
	$svsame
(
BYTE
 *
bufr
,
ame
 
ameobj
)

353 
i
 = 0;

354 
BYTE
 
sag
 = 0;

355 
TIMEDATA
 
mDa
;

357 
i
 = 1; i < 
bufr
[0]; i += 8)

359 if0x0 =
bufr
[
i
] & 0xc0 ) )

360 
sag
 = 1;

361 if0xc0 =
bufr
[
i
] & 0xc0 ) )

362 
sag
 = 0;

366 
mDa
.
MiSec
 = ( (
bufr
[
i
+6] & 0xc0) << 2 ) | buffer[i+7];

367 
mDa
.
Secd
 = 
bufr
[
i
+6] & 0x3f;

368 
mDa
.
Mu
 = 
bufr
[
i
+5];

369 
mDa
.
Hour
 = 
bufr
[
i
+4];

370 
mDa
.
Day
 = 
bufr
[
i
+3];

371 
mDa
.
Mth
 = 
bufr
[
i
+2];

372 
mDa
.
Yr
 = 
bufr
[
i
+1];

374 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
bufr
[
i
] & 0x3f, 
sag
, &
mDa
 );

381 
	}
}

383 
	gModBusT_Gh
::
	$sveYZ202same
(
BYTE
 *
bufr
,
ame
 
ameobj
)

388 
WORD
 
wP
 = 0;

389 
BYTE
 
sag
 = 0;

390 
TIMEDATA
 
mDa
;

392 if
bufr
[2] & 0x02 ) == 0x02 )

393 
sag
 = 1;

394 if
bufr
[2] & 0x02 ) == 0x00 )

395 
sag
 = 0;

397  
bufr
[1] )

399 4:
wP
 = 0;;

400 8:
wP
 = 1;;

401 9:
wP
 = 2;;

403 
sag
 = 1;

404  
bufr
[11] )

406 0x00:
wP
 = 3;;

407 0x01:
wP
 = 4;;

408 0x02:
wP
 = 5;;

409 0x03:
wP
 = 6;;

411  
bufr
[12] )

413 0x33:
wP
 = 7;
sag
 = 0;;

414 0x55:
wP
 = 7;;

421  
bufr
[12] )

423 0x33:
wP
 = 8;
sag
 = 0;;

424 0x55:
wP
 = 8;;

435 17:
wP
 = 9;;

436 18:
wP
 = 10;;

437 19:
wP
 = 11;;

438 21:
wP
 = 12;;

439 22:
wP
 = 13;;

440 23:
wP
 = 14;;

441 24:
wP
 = 15;;

442 25:
wP
 = 16;;

443 26:
wP
 = 17;;

444 27:
wP
 = 18;;

445 28:
wP
 = 19;;

446 31:
wP
 = 20;;

447 35:
wP
 = 21;;

448 37:
wP
 = 22;;

449 38:
wP
 = 23;;

450 39:
wP
 = 24;;

451 42:
wP
 = 25;;

459 
mDa
.
MiSec

bufr
[9] | (buffer[10] << 8);

460 
mDa
.
Secd

bufr
[8];

461 
mDa
.
Mu

bufr
[7];

462 
mDa
.
Hour
 = 
bufr
[6];

463 
mDa
.
Day
 = 
bufr
[5];

464 
mDa
.
Mth
 = 
bufr
[4];

465 
mDa
.
Yr
 = 
bufr
[3];

467 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
wP
, 
sag
, &
mDa
 );

473 
	}
}

475 
	gModBusT_Gh
::
	$sveE_411same
(
BYTE
 *
bufr
,
ame
 
ameobj
)

477 
WORD
 
wP
 = 0;

478 
BYTE
 
sag
 = 0;

479 
BYTE
 
SAribu
 = 0;

480 
BYTE
 
dex
 = 0;

481 
TIMEDATA
 
mDa
;

483 if
bufr
[0] == 0 )

488 if
bufr
[0] == 0x0f )

493 
mDa
.
MiSec

bufr
[2] | (buffer[1] << 8);

494 
mDa
.
Secd

bufr
[3];

495 
mDa
.
Mu

bufr
[4];

496 
mDa
.
Hour
 = 
bufr
[5];

497 
mDa
.
Day
 = 
bufr
[6];

498 
mDa
.
Mth
 = 
bufr
[7];

499 
mDa
.
Yr
 = 
bufr
[8];

501 
SAribu
 = 
bufr
[9];

502 
dex
 = 
bufr
[10];

503 if
dex
 > 31 )

506  
SAribu
 )

509 
wP
 = 
dex
;

512 
wP
 = 
dex
 + 32;

515 
wP
 = 
dex
 + 64;

521  
bufr
[11] )

524 
sag
 = 1;

527 
sag
 = 0;

533 
m_pMhod
->
	`SYxDaWhTime
 ( 
m_SlNo
, 
wP
, 
sag
, &
mDa
 );

534 
buf
[100] = "";

535 
	`rtf
(
buf
,"SOE m_byLineNo:%d m_wDevAddr%dum:%d val:%dime:%d.%d.%d-%d:%d:%d.%d\n",

536 
m_byLeNo
, 
m_wDevAddr
 , 
wP
 , 
sag
 ,

537 
mDa
.
Yr
,mDa.
Mth
,mDa.
Day
,mDa.
Hour
,mDa.
Mu
,mDa.
Secd
,mDa.
MiSec
);

540 
	}
}

543 
BOOL
 
	gModBusT_Gh
::
	$svesame
(
BYTE
 *
bufr
,
ame
 
ameobj
)

545  
ameobj
.
sag
 )

548 
	`svsame

bufr
 , 
ameobj
 );

551 
	`sveYZ202same

bufr
 , 
ameobj
 );

554  
FALSE
;

556  
TRUE
;

557 
	}
}

559 
	gModBusT_Gh
::
	$dwoby
(
BYTE
 *
buf
)

561 
vue
 = 0;

562 
vec_cf
[
le
].
dafm
)

565 
vue
 = (
buf
[0] << 8 | buf[1]);

568 
vue
 = (
buf
[0] | buf[1] << 8);

573  
vue
;

574 
	}
}

576 
	gModBusT_Gh
::
	$dlfourby
(
BYTE
 *
buf
)

578 
v
 = 0;

579 
vec_cf
[
le
].
dafm
)

582 
v
 = (
buf
[0]<<24 | buf[1]<<16 | buf[2]<<8 | buf[3]);

585 
v
 = (
buf
[0]<<16 | buf[1]<<24 | buf[2] | buf[3]<<8);

588 
v
 = (
buf
[0]<<8 | buf[1] | buf[2]<<24 | buf[3]<<16);

591 
v
 = (
buf
[0] | buf[1]<<8 | buf[2]<<16 | buf[3]<<24);

596  
v
;

597 
	}
}

599 
	gModBusT_Gh
::
	$dltby
(
BYTE
 *
buf
, 
n
)

601 
vue
 = 0;

602 
BYTE
 
t_buf
[4] = "";

604 
vec_cf
[
le
].
dafm
)

607 
t_buf
[3] = 
buf
[0];

608 
t_buf
[2] = 
buf
[1];

609 
t_buf
[1] = 
buf
[2];

610 
t_buf
[0] = 
buf
[3];

613 
t_buf
[2] = 
buf
[0];

614 
t_buf
[3] = 
buf
[1];

615 
t_buf
[0] = 
buf
[2];

616 
t_buf
[1] = 
buf
[3];

619 
t_buf
[1] = 
buf
[0];

620 
t_buf
[0] = 
buf
[1];

621 
t_buf
[3] = 
buf
[2];

622 
t_buf
[2] = 
buf
[3];

625 
t_buf
[0] = 
buf
[0];

626 
t_buf
[1] = 
buf
[1];

627 
t_buf
[2] = 
buf
[2];

628 
t_buf
[3] = 
buf
[3];

633 
vue
 = *(*)
t_buf
;

634  
vue
;

635 
	}
}

637 
	gModBusT_Gh
::
	$addeucfig
(
ame
 *
ameobj
)

639 
ameobj
->
ty
 = 0x00;

640 
ameobj
->
af
 = 0x00;

641 
ameobj
->
y
 = 0x00;

642 
ameobj
->
func
 = 0x02;

643 
ameobj
->
gi_addr
 = 0x1003;

644 
	`memt
(
ameobj
->
gi_addr_yk
, 0, (frameobj->register_addr_yk));

645 
ameobj
->
num
 = 0x0004;

646 
ameobj
->
da_n
 = 0x04;

647 
ameobj
->
ykty
 = 0x00;

648 
ameobj
->
yk_rui
 = 0xFF000000;

649 
ameobj
->
et_vue
 = 0x00;

650 
ameobj
->
yx_mask
 = 0xFFFFFFFF;

651 
ameobj
->
dy
 = 0x00;

652 
ameobj
->
dafm
 = 0x02;

653 
	}
}

655 
BYTE
 
	gModBusT_Gh
::
	$adcf
(*
fame
)

657 
FILE
 *
hFe
;

658 
szText
[160];

659 *
mp
;

660 
num
 = 0;

661 
ULONG
 
gvue
 = 0;

662 
BYTE
 
i
 = 0;

663 
BYTE
 
cag
 = 0;

664 
ame
 
ameobj
;

665 
hFe
 = 
	`fݒ
(
fame
, "r");

667 if(
hFe
 =
NULL
)

669  
	`fgs
(
szText
, (szText), 
hFe
!
NULL
 ){

670 
	`rim
(
szText
);

671 if
szText
[0]=='#' || szText[0]==';' )

673 
i
 = 0;

674 
cag
 = 0;

675 
	`memt
(&
ameobj
,0,(frameobj));

677 
mp
 = 
	`ok
(
szText
,",");

678 if(
mp
 =
NULL
)

680 if
	`oi
(
mp
) >= 0 ) && (toi(temp) < 5 ) )

681 
ameobj
.
ty
 = 
	`oi
(
mp
);

684 
cag
 = 1;

685 
	`addeucfig
(&
ameobj
);

687  ( 
mp
 = 
	`ok
(
NULL
,",") ) )

689 
gvue
 = (
ULONG
)
	`l
(
mp
, 
NULL
, 16);

690 ++
i
)

693 if(
gvue
 <= 0xFFFF)

694 
ameobj
.
af
 = 
gvue
;

696 
cag
 = 1;

699 if(
gvue
 <= 0xFFFF)

700 
ameobj
.
y
 = 
gvue
;

702 
cag
 = 1;

705 if((
gvue
 > 0x01) && (segvalue < 7))

706 
ameobj
.
func
 = 
gvue
;

708 
cag
 = 1;

711 if(
gvue
 <= 0xFFFF)

712 
ameobj
.
gi_addr
 = 
gvue
;

714 
cag
 = 1;

717 if(
gvue
 <= 0xFFFF)

718 
ameobj
.
gi_addr_yk
[0] = 
gvue
;

720 
cag
 = 1;

723 if(
gvue
 <= 0xFFFF)

724 
ameobj
.
gi_addr_yk
[1] = 
gvue
;

726 
cag
 = 1;

729 if(
gvue
 <= 0xFFFF)

730 
ameobj
.
gi_addr_yk
[2] = 
gvue
;

732 
cag
 = 1;

735 if(
gvue
 <= 0xFFFF)

736 
ameobj
.
gi_addr_yk
[3] = 
gvue
;

738 
cag
 = 1;

741 if(
gvue
 <= 0xFFFF)

742 
ameobj
.
gi_addr_yk
[4] = 
gvue
;

744 
cag
 = 1;

747 if(
gvue
 <= 0xFFFF)

748 
ameobj
.
gi_addr_yk
[5] = 
gvue
;

750 
cag
 = 1;

753 if(
gvue
 <= 0xFFFF)

754 
ameobj
.
num
 = 
gvue
;

756 
cag
 = 1;

759 if((
gvue
 == 0x02) || (segvalue == 0x04))

760 
ameobj
.
da_n
 = 
gvue
;

762 
cag
 = 1;

765 if((
gvue
 == 0x00) || (segvalue == 0x01))

766 
ameobj
.
ykty
 = 
gvue
;

768 
cag
 = 1;

771 if((
gvue
 == 0xFF000000) || (segvalue == 0xFF00FF00))

772 
ameobj
.
yk_rui
 = 
gvue
;

774 
cag
 = 1;

777 if(
gvue
 <= 0xFFFF)

778 
ameobj
.
et_vue
 = 
gvue
;

780 
cag
 = 1;

783 if(
gvue
 <= 0xFFFFFFFF)

784 
ameobj
.
yx_mask
 = 
gvue
;

786 
cag
 = 1;

789 if((
gvue
 == 0x00) || (segvalue == 0x01) || (segvalue == 0x02))

790 
ameobj
.
dy
 = 
gvue
;

792 
cag
 = 1;

795 if(
gvue
 < 0x06)

796 
ameobj
.
dafm
 = 
gvue
;

798 
cag
 = 1;

801 if(
gvue
 <= 0xFF)

802 
ameobj
.
sag
 = 
gvue
;

804 
cag
 = 1;

807 
cag
 = 1;

808 
	`tf
("\n\n*************** i+1:%d ***************\n\n",
i
+1);

811 if
cag
 == 1 )

813 
cag
 = 1;

814 
	`tf
("MBTcp config filerror:\n");

818 if(
cag
 =1|| (
i
 < 19) )

820 
	`tf
("%num i%d %d\n\n\n",
fame
,
num
+1,
i
+1);

821 
	`addeucfig
(&
ameobj
);

824 
vec_cf
.
	`push_back
(
ameobj
);

825 
num
++;

827 
u
 = 
	`fo
(
hFe
);

828 if
u
 )

829 
	`
("fclose");

830  
num
;

831 
	}
}

833 
	gModBusT_Gh
::
	$gghnumb
()

835 
BYTE
 
i
=0; i<
lesum
; i++){

836 if(
vec_cf
[
i
].
ty
 == 0)

837 
yc_sum
 +
vec_cf
[
i
].
num
 * 2 / vec_cf[i].
da_n
;

838 if(
vec_cf
[
i
].
ty
 == 1)

839 
ym_sum
 +
vec_cf
[
i
].
num
 * 2 / vec_cf[i].
da_n
;

840 if(
vec_cf
[
i
].
ty
 == 2)

841 
yx_sum
 +
vec_cf
[
i
].
num
 * 16;

845 
	}
}

847 
BOOL
 
	gModBusT_Gh
::
	$In
(
BYTE
 
byLeNo
)

849 
szFeName
[128] = "";

850 
vec_cf
.
	`r
();

851 
	`rtf
(
szFeName
, "%s%s", 
MODBUSTPREFIXNAME
, 
m_sTemePh
);

852 
lesum
 = 
	`adcf
(
szFeName
);

853 if(
lesum
 <= 0){

854 
	`tf
("Using Defaultconfig!\n");

855 
ame
 
ameobj
;

856 
	`addeucfig
(&
ameobj
);

857 
vec_cf
.
	`push_back
(
ameobj
);

858 
lesum
 = 1;

860 
	`gghnumb
();

861  
TRUE
;

862 
	}
}

864 
	gModBusT_Gh
::
	$TimProc
()

866 
ptus
 = (
rtimes
 > 
ERROR_CONST
? 
COMSTATUS_FAULT
 : 
COMSTATUS_ONLINE
;

867 
	}
}

869 
BOOL
 
	gModBusT_Gh
::
	$GDevCommS
()

871  (
ptus
 =
COMSTATUS_ONLINE
? 
COM_DEV_NORMAL
 : 
COM_DEV_ABNORMAL
;

872 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/ModBusTcp_Gather.h

1 #ide
_MODBUSTCP_H_


2 
	#_MODBUSTCP_H_


	)

4 #ide
UINT


5 
	tUINT
;

6 
	tULONG
;

8 
	~"CProc_ModBusT.h
"

9 
	~<ve
>

10 
	~<time.h
>

11 
usg
 
mea
 
	gd
;

13 as
	came
{

14 
	mpublic
:

15 
BYTE
 
ty
;

16 
WORD
 
	maf
;

17 
WORD
 
	my
;

19 
BYTE
 
	mfunc
;

20 
WORD
 
	mgi_addr
;

21 
WORD
 
	mgi_addr_yk
[6];

22 
WORD
 
	mnum
;

23 
BYTE
 
	mda_n
;

24 
BYTE
 
	mykty
;

25 
UINT
 
	myk_rui
;

26 
WORD
 
	met_vue
;

27 
UINT
 
	myx_mask
;

28 
BYTE
 
	mdy
;

29 
BYTE
 
	mdafm
;

30 
BYTE
 
	msag
;

33 as
	cModBusT_Gh
 : 
public
 
CProc_ModBusT_Gh
{

34 
public
:

35 
ModBusT_Gh
();

36 ~
ModBusT_Gh
();

37 
BOOL
 
GProcBuf
(
BYTE
 *, &, 
PBUSMSG
 
pBusMsg
 = 
NULL
);

38 
gykame
(
BYTE
 *, &);

39 
gycame
(
BYTE
 *, &);

40 
gymame
(
BYTE
 *, &);

41 
gyxame
(
BYTE
 *, &);

42 
gsyname
(
BYTE
 *, &);

43 
gsame
(
BYTE
 *, &);

44 
BOOL
 
ProssProcBuf
(
BYTE
 *, );

45 
BOOL
 
sveyxame
(
BYTE
 *);

46 
BOOL
 
sveymame
(
BYTE
 *, );

47 
BOOL
 
sveycame
(
BYTE
 *, );

48 
sveykame
(
BYTE
 *);

49 
svsame
(
BYTE
 *, 
ame
);

50 
sveYZ202same
(
BYTE
 *, 
ame
);

51 
sveE_411same
(
BYTE
 *, 
ame
);

52 
BOOL
 
svesame
(
BYTE
 *, 
ame
);

53 
dwoby
(
BYTE
 *);

54 
dlfourby
(
BYTE
 *);

55 
dltby
(
BYTE
 *, );

56 
addeucfig
(
ame
 *);

57 
BYTE
 
adcf
(*);

58 
gghnumb
();

59 
BOOL
 
In
(
BYTE
 
byLeNo
);

60 
TimProc
();

61 
BOOL
 
GDevCommS
();

62 
	meed
:

63 
ve
 <
ame
> 
vec_cf
;

64 
YK_DATA
 * 
	myk_da
;

65 
BYTE
 
	mykty
;

66 
BYTE
 
	mbyBusNo
;

67 
BYTE
 
	mwDevNo
;

68 
BYTE
 
	mwP
;

69 
BYTE
 
	mbyV
;

70 
BYTE
 
	mlesum
;

71 
BYTE
 
	mle
;

72 
UINT
 
	mrtimes
;

73 
UINT
 
	mtime_ag
;

74 
UINT
 
	mptus
;

75 
WORD
 
	myc_d
;

76 
WORD
 
	mym_d
;

77 
WORD
 
	myx_d
;

79 
WORD
 
	myx_sum
;

80 
WORD
 
	myc_sum
;

81 
WORD
 
	mym_sum
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/main.cpp

1 
	~<dio.h
>

2 
	~"CProc_ModBusT.h
"

6 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

11 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

13 
CProc
 * 
pProc
 = 
NULL
 ;

14 
pProc
 = 
w
 
CProc_ModBusT_Gh
;

15 if
pProc
 )

16 
pProc
->
m_pMhod
 = 
pMhod
 ;

18  
pProc
 ;

19 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/CProtocol_Resume.cpp

5 
	~"CProc_Resume.h
"

6 
	~"Resume.h
"

12 
	gCProc_Resume
::
	$CProc_Resume
()

14 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

15 
	}
}

17 
	gCProc_Resume
::~
	$CProc_Resume
()

19 
size
 = 
m_modu
.
	`size
() ;

20  
i
 = 0 ; i < 
size
 ; i++ )

22 
de
 
m_modu
[ 
i
 ] ;

24 
m_modu
.
	`r
() ;

25 
	`tf
( "Delete All CProtocol_Resume OK . \n" );

26 
	}
}

30 
BOOL
 
	gCProc_Resume
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

32  
TRUE
;

33 
	}
}

35 
BOOL
 
	gCProc_Resume
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

37  
FALSE
 ;

38 
	}
}

40 
BOOL
 
	gCProc_Resume
::
	$In

BYTE
 
byLeNo
 )

44 
m_byLeNo
 = 
byLeNo
 ;

46 
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

47  
	`GDevDa
( ) ;

48 
	}
}

50 
BOOL
 
	gCProc_Resume
::
	$GDevDa
( )

52 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

53 
	`rtf

m_sDevPh
 , "%s/Resume/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

54 
CProfe
 
	`ofe

m_sDevPh
 ) ;

55  
	`ProssFeDa

ofe
 ) ;

56 
	}
}

58 
BOOL
 
	gCProc_Resume
::
	$ProssFeDa

CProfe
 &
ofe
 )

60 
BOOL
 
bR
 = 
FALSE
;

61 if!
ofe
.
	`IsVid
() )

63 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

64  
FALSE
 ;

67 
sSe
[ 200 ] = "DEVNUM" ;

68 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

70 
WORD
 
wModu
 = 0 ;

71 
ro
=1 ;

72 
WORD
 
addr
 =3 ;

73 
sName
[ 50 ] = { 0 };

74 
eme
[ 200 ] = { 0 };

75 
iNum
 = 0 ;

77 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

78 if
iNum
 == 0 )

80 
	`tf
( "Get DEVNUM Failed ! \n " );

81  
FALSE
 ;

84  
i
 = 0 ; i < 
iNum
 ; i++ )

86 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

88 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

89 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

90 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

91 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

92 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

95 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

96 i!
bR
 )

98 
	`tf
 ( "CResumModu=%d so=%dddr=%d sName=%eme=%\
 \n", 
wModu
, 
ro
, 
addr
, 
sName
, 
eme
 );

100  
FALSE
;

103  
TRUE
 ;

104 
	}
}

106 
BOOL
 
	gCProc_Resume
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

108 
CProc_Resume
 * 
pProc
 = 
NULL
 ;

110 
pProc
 = 
w
 
Resume
;

111 
pProc
->
m_byLeNo
 = m_byLineNo ;

112 
pProc
->
m_wModuTy
 = 
iModu
 ;

113 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

114 
pProc
->
m_SlNo
 = 
iSlNo
 ;

116 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

117 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

118 
pProc
->
m_pMhod
 = m_pMethod ;

119 
pProc
->
m_ProTy
 = 
PROTOCO_TRANSPROT
 ;

122 if!
pProc
->
	`In

m_byLeNo
 ) )

123  
FALSE
 ;

124 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

127 
m_modu
.
	`push_back

pProc
 ) ;

129  
TRUE
 ;

130 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/CProtocol_Resume.h

5 #i!
defed
(
AFX_CPROTOCOL_MODBUSTCP_H__DB4E4A83_510B_4232_A294_B1B4EE1AF4FD__INCLUDED_
)

6 
	#AFX_CPROTOCOL_MODBUSTCP_H__DB4E4A83_510B_4232_A294_B1B4EE1AF4FD__INCLUDED_


	)

10 
	~"../../she/Rtu.h
"

11 
	~"../../she/CMhod.h
"

12 
	#MODBUSTCPPREFIXFILENAME
 "/mynd/cfig/Resume/"

	)

14 as
	cCProc_Resume
 : 
public
 
CRtuBa


16 
public
:

17 
CProc_Resume
();

18 
	mvtu
 ~
CProc_Resume
();

20 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

21 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

23 
BOOL
 
UPSQuySPack

BYTE
 * 
buf
 , &
n
 );

25 
BOOL
 
UPSQuySDl

BYTE
 * 
buf
 , 
n
 );

27 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

29 
	meed
:

30 
BOOL
 
GDevDa
( ) ;

31 
	meed
:

32 
BOOL
 
ProssFeDa

CProfe
 &
ofe
 );

33 
BOOL
 
CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

35 
	mmt_sMaAddr
[ 24 ] ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/Resume.cpp

1 
	~"Resume.h
"

4 cڡ 
	gERROR_CONST
 = 5;

5 cڡ 
	gCOMSTATUS_ONLINE
 = 1;

6 cڡ 
	gCOMSTATUS_FAULT
 = 0;

8 cڡ 
	gERROR_FUN
 = 1;

9 cڡ 
	gERROR_REGISTER
 = 2;

10 cڡ 
	gERROR_DATA
 = 3;

11 cڡ 
	gERROR_CONFIG
 = 4;

13 
	gResume
::
	$Resume
()

15 
SdFg
 = 0;

16 
MsgFg
 = 0;

17 
FunNum
 = 0;

18 
m_wETim
 = 0;

19 
m_byPtStus
 = 0;

20 
EFg
 = 0;

21 
yk_cv_ag
 = 
FALSE
;

22 
time_ag
 = 0;

23 
Yk_FunNum
 = 0x05;

24 
ndtimeag
 = 0;

25 
cvtimeag
 = 0;

26 
	`memt
(
yk_bufSl
,0,(yk_bufSerial));

27 
	`memt
(
mt_sMaAddr
, 0, (mt_sMasterAddr));

28 
	}
}

30 
	gResume
::~
	$Resume
()

33 
	}
}

35 
BOOL
 
Resume
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

38 if
buf
 =
NULL
 )

39  
FALSE
 ;

41 
m_wETim
++;

42 if
m_wETim
 > 
ERROR_CONST
 )

44 
m_wETim
 = 
ERROR_CONST
 + 1 ;

45 
m_byPtStus
 = 
COMSTATUS_FAULT
;

49 
m_byPtStus
 = 
COMSTATUS_ONLINE
;

52 if
pBusMsg
 )

54 
	`DlBusMsgInfo

pBusMsg
);

58 if
MsgFg
 == 2 )

60  
FALSE
;

62 
MsgFg
 = 2;

63 
	`memy

buf
 , 
MsgBuf
 , 
MsgL
 );

64 
n
 = 
MsgL
;

65 
	`memt

MsgBuf
 , 0 , 
MsgL
);

66 
MsgL
 = 0;

67 
yk_cv_ag
 = 
FALSE
;

69 
ty
){

71 
	`YXPack
(
buf
, 
n
);

74 
	`YcYmPack
(
buf
, 
n
);

76 
ndtimeag
 = 
	`time
(
NULL
);

77  
TRUE
;

79 
	}
}

81 
BOOL
 
	gResume
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

85 
BOOL
 
R
 = 
FALSE
;

86 if
n
 =0 || 
buf
 =
NULL
 )

87  
FALSE
 ;

89 if(
yk_cv_ag
){

90 
time_t
 
t
;

91 
t
 = 
	`time
(
NULL
);

92 if((
t
 - 
time_ag
) < 5)

93  
FALSE
;

96 if(
buf
[7] == 0x05){

97 
yk_cv_ag
 = 
TRUE
;

98 
time_t
 
t
;

99 
t
 = 
	`time
(
NULL
);

100 
time_ag
 = 
t
;

103 if
buf
[2]==0 && buf[3]==0 && buf[4]==0

104 && (
buf
[5]+6)==
n
 && buf[6]=
m_wRtuAddr
 )

106 
FunNum
 = 
buf
[7];

107 
MsgFg
 = 0;

108  
FunNum
 )

111 
R
 = 
	`YXPack

buf
 , 
n
 );

114 
R
 = 
	`YcYmPack

buf
 , 
n
 );

117 
R
 = 
	`YcYmPack

buf
 , 
n
 );

120 
R
 = 
	`YKMsg

buf
 , 
n
 );

123 
	`EPack

buf
 , 
ERROR_FUN
 );

126 if
R
 =
TRUE
 )

128 
m_wETim
 = 0;

130  
TRUE
 ;

133 if((
buf
[0] =0x68&& (buf[1] =0xF1&& (
n
 == 2)){

134 
cvtimeag
 = 
	`time
(
NULL
);

135  
TRUE
;

137  
FALSE
 ;

138 
	}
}

140 
BOOL
 
	gResume
::
	$In

BYTE
 
byLeNo
 )

142 
m_byLeNo
 = 
byLeNo
 ;

143 
m_byProID
 = 4;

144 
m_byEb
 = 1;

145 
m_wObjNum
 = 1;

146 
	`rtf

m_szObjName
, "%s", 
m_sDevName
 );

147 
	`rtf

m_ComCl1
, "%s", 
mt_sMaAddr
 );

148 
m_wRtuAddr
 = 
m_wDevAddr
 ;

149 
szFeName
[256] = "";

151 
	`rtf

szFeName
, "%s%s", 
MODBUSTCPPREFIXFILENAME
, 
m_sTemePh
 );

153 
	`RdMCfig

szFeName
 );

156 
	`InRtuBa
() ;

160  
TRUE
 ;

161 
	}
}

163 
BOOL
 
	gResume
::
	$InRtuBa
( )

165 
UINT
 
uPt
;

166 
BOOL
 
bOk
 = 
FALSE
;

167 
szCl
[32];

171 
CBaPt
::
	`GCommArib
(
m_ComCl1
, 
szCl
, 
uPt
);

173 
m_wPtNum
 = (
WORD
)
uPt
 ;

176 
	`CeTnsTab
();

179 
m_pMhod
->
	`RdAYcDa
(&
m_wYCBuf
[0]);

180 
m_pMhod
->
	`RdAYmDa
(&
m_dwYMBuf
[0]);

181 
m_pMhod
->
	`RdAYxDa
&
m_byYXbuf
[ 0 ] ) ;

183 
m_bTaskRun
 = 
TRUE
;

184  
bOk
;

185 
	}
}

187 
BOOL
 
	gResume
::
	$DlBusMsgInfo

PBUSMSG
 
pBusMsg
 )

189 
DeviNo
 = 0;

190 
YK_DATA
 *
pDa
 = (YK_DATA *)(
pBusMsg
->pData);

192  
pBusMsg
->
byMsgTy
 )

194 
YK_PROTO
:

195  
pBusMsg
->
dwDaTy
 )

198 
YK_EXCT_RTN
:

200 if
pBusMsg
->
DaNum
 != 1

201 || 
pBusMsg
->
DaL
 !(
YK_DATA
) )

203 
	`tf
("Resume Yk DataNumrr\n");

207 
DeviNo
 = 
m_pMhod
->
	`GSlNo
(
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
);

208 if
DeviNo
 == -1 )

212 
	`YKPack

m_wRayNum
 , 
pDa
->
byV
 );

213 
MsgFg
 = 0;

214 if
pDa
->
byV
 =
YK_ERROR
 && 
DeviNo
 > 10000 )

216 if
DeviNo
 > 10000 )

217 
	`EPack

yk_bufSl
, 
ERROR_REGISTER
 );

218 if
pDa
->
byV
 =
YK_ERROR
 )

219 
	`EPack

yk_bufSl
, 
ERROR_DATA
 );

224 
	`tf
("Resumn'fdhYK_DATATYPE %d\n", ()
pBusMsg
->
dwDaTy
);

232  
TRUE
;

233 
	}
}

235 
	gResume
::
	$RayEchoProc
(
BYTE
 
byCommd
, 
WORD
 
wIndex
, BYTE 
byResu
)

238 
	}
}

240 
BOOL
 
	gResume
::
	$YXPack

BYTE
 * 
buf
 , 
n
 )

242 
WORD
 
dex
 = 0;

243 
WORD
 
mt_gi
 = 256 * 
buf
[8] + buf[9];

244 
WORD
 
ginum
 = 256 * 
buf
[10] + buf[11];

246 
WORD
 
ModBusByL
 = ((
ginum
-1)/8)+1;

247 
WORD
 
ResumeByL
 = 3+
ModBusByL
;

249 if
mt_gi
 > 9999 || mt_gi =0 ) || ( 
ginum
 > 9999 ||egisternum == 0 ) )

251 if
mt_gi
 > 9999 || mt_register == 0 )

252 
	`EPack

buf
 , 
ERROR_REGISTER
 );

253  
FALSE
;

255 
MsgBuf
[
dex
++] = 
buf
[0];

256 
MsgBuf
[
dex
++] = 
buf
[1];

257 
MsgBuf
[
dex
++] = 0;

258 
MsgBuf
[
dex
++] = 0;

259 
MsgBuf
[
dex
++] = 
ResumeByL
 >> 8;

260 
MsgBuf
[
dex
++] = 
ResumeByL
;

261 
MsgBuf
[
dex
++] = 
m_wRtuAddr
;

262 
MsgBuf
[
dex
++] = 
FunNum
;

263 
MsgBuf
[
dex
++] = 
ModBusByL
;

264 
j
 = 0;

265  
j
=0; j<
ModBusByL
; j++ )

268 
BYTE
 
i
 = 0;

269 
BYTE
 
ByYXV
 = 0;

270  
i
=0; i<8; i++ )

272 if
j
==
ModBusByL
-1 && 
i
 =
ginum
%8 && 0 !=egisternum%8)

275 if
m_pDIMTab
[
mt_gi
-1+(8*
j
+
i
)].
wS
 > 0 && m_pDIMTab[mt_gi-1+(8*j+i)].
wPNum
 > 0 )

276 
ByYXV
 |
m_byYXbuf
[
mt_gi
-1+(8*
j
+
i
)]<<i;

279 
	`EPack

buf
 , 
ERROR_REGISTER
 );

280  
FALSE
;

283 
MsgBuf
[
dex
++] = 
ByYXV
;

286 
MsgL
 = 
dex
;

287  
TRUE
;

288 
	}
}

290 
BOOL
 
	gResume
::
	$YcYmPack

BYTE
 * 
buf
 , 
n
 )

292 
BOOL
 
ag
 ;

293 
DWORD
 
ymv
 ;

294 
WORD
 
dex
 = 0,
wV
 = 0;;

295 
fV
 = 0.0f ;

296 
WORD
 
mt_gi
 = 256 * 
buf
[8] + buf[9];

297 
WORD
 
ginum
 = 256 * 
buf
[10] + buf[11];

299 
WORD
 
ModBusByL
 = 2*
ginum
;

300 
WORD
 
ResumeByL
 = 3+
ModBusByL
;

302 if
mt_gi
 > 9999 || mt_gi =0 ) || ( 
ginum
 > 9999 ||egisternum == 0 )

303 || ( 
mt_gi
 <6800 && mt_gi+
ginum
 > 6800 ) )

305 
	`EPack

buf
 , 
ERROR_REGISTER
 );

306  
FALSE
;

308 
MsgBuf
[
dex
++] = 
buf
[0];

309 
MsgBuf
[
dex
++] = 
buf
[1];

310 
MsgBuf
[
dex
++] = 0;

311 
MsgBuf
[
dex
++] = 0;

312 
MsgBuf
[
dex
++] = 
ResumeByL
 >> 8;

313 
MsgBuf
[
dex
++] = 
ResumeByL
;

314 
MsgBuf
[
dex
++] = 
m_wRtuAddr
;

315 
MsgBuf
[
dex
++] = 
FunNum
;

316 
MsgBuf
[
dex
++] = 
ModBusByL
;

317 
j
 = 0;

318  
j
=0; j<
ginum
; j++ )

321 if
mt_gi
 >= 1 && mt_register <= 6800 )

323 if
m_pAIMTab
[
mt_gi
-1+
j
].
wS
 > 0 && m_pAIMTab[mt_gi-1+j].
wPNum
 > 0 )

325 
fV
 = 
	`CcAIReV
(
m_pAIMTab
[
mt_gi
-1+
j
].
wS
, m_pAIMTab[mt_gi-1+j].
wPNum
, 
m_wYCBuf
[mt_register-1+j]);

326 
wV
 = ( 
WORD
 )
fV
 ;

327 
MsgBuf
[
dex
++] = 
	`HIBYTE
(
wV
);

328 
MsgBuf
[
dex
++] = 
	`LOBYTE
(
wV
);

332 
	`EPack

buf
 , 
ERROR_REGISTER
 );

333  
FALSE
;

336 if
mt_gi
 >= 6801 && mt_register <= 9999 )

338 if
mt_gi
-6801 )%2 =1 ) || ( 
ginum
%2 == 1 ) )

340 
	`EPack

buf
 , 
ERROR_REGISTER
 );

341  
FALSE
;

345 if
j
%2 == 0 )

347 if
m_pPIMTab
[(
mt_gi
-6801)/2+
j
/2].
wS
 > 0 && m_pPIMTab[(mt_gi-6801)/2+j/2].
wPNum
 > 0 )

349 
ymv
 = 
	`GPulDa
 ( 
m_pPIMTab
[(
mt_gi
-6801)/2+
j
/2].
wS
,

350 
m_pPIMTab
[(
mt_gi
-6801)/2+
j
/2].
wPNum
, &
ag
 );

351 if!
ag
 )

353 
	`EPack

buf
 , 
ERROR_DATA
 );

354  
FALSE
;

356 
MsgBuf
[
dex
++] = 
	`HIBYTE
(
	`HIWORD
(
ymv
));

357 
MsgBuf
[
dex
++] = 
	`LOBYTE
(
	`HIWORD
(
ymv
));

358 
MsgBuf
[
dex
++] = 
	`HIBYTE
(
	`LOWORD
(
ymv
));

359 
MsgBuf
[
dex
++] = 
	`LOBYTE
(
	`LOWORD
(
ymv
));

363 
	`EPack

buf
 , 
ERROR_REGISTER
 );

364  
FALSE
;

370 
MsgL
 = 
dex
;

371  
TRUE
;

372 
	}
}

374 
BOOL
 
	gResume
::
	$YKMsg

BYTE
 * 
buf
 , 
n
 )

376 
WORD
 
mt_gi
 = 256 * 
buf
[8] + buf[9];

378 if
mt_gi
 > 10000 || mt_register == 0 ) ||

379 !
buf
[10] == 0xff || buf[10] == 0x00 ) && buf[11] == 0x00 ) )

381 if
mt_gi
 > 10000 || mt_register == 0 )

382 
	`EPack

buf
 , 
ERROR_REGISTER
 );

383 if!
buf
[10] == 0xff || buf[10] == 0x00 ) && buf[11] == 0x00 ) )

384 
	`EPack

buf
 , 
ERROR_DATA
 );

385  
FALSE
;

387 
BYTE
 
byBusNo
;

388 
WORD
 
byS
;

389 
BYTE
 
byStus
;

390 
WORD
 
wDevAddr
;

391 
WORD
 
wP
;

393  
buf
[10] )

396 
byStus
 = 1;

399 
byStus
 = 0;

403 
byS
 = 
m_pDOMTab
[
mt_gi
-1].
wS
 - 1 ;

404 
wP
 = 
m_pDOMTab
[
mt_gi
-1].
wPNum
 - 1 ;

405 if
m_pDOMTab
[
mt_gi
-1].
wS
 > 0 && m_pDOMTab[mt_gi-1].
wPNum
 > 0 )

407 
yk_bufSl
[0]=
buf
[0];

408 
yk_bufSl
[1]=
buf
[1];

409 
Yk_FunNum
 = 
buf
[7];

410 if(
m_pMhod
->
	`GBusLeAndAddr
(
byS
, 
byBusNo
, 
wDevAddr
))

412 
m_pMhod
->
	`SYkExe
(
this
, 
byBusNo
, 
wDevAddr
, 
wP
, 
byStus
);

414 
m_wRayNum
 = 
mt_gi
;

415  
TRUE
;

419 
	`EPack

buf
 , 
ERROR_REGISTER
 );

420  
FALSE
;

422 
	}
}

424 
BOOL
 
	gResume
::
	$YKPack

yk_gi
 , 
v
 )

427 
WORD
 
dex
 = 0;

428 
WORD
 
ResumeByL
 = 6;

430 if
yk_gi
 > 10000 || yk_register == 0 )

432 
	`EPack

yk_bufSl
 , 
ERROR_REGISTER
 );

433  
FALSE
;

435 
MsgBuf
[
dex
++] = 
yk_bufSl
[0];

436 
MsgBuf
[
dex
++] = 
yk_bufSl
[1];

437 
MsgBuf
[
dex
++] = 0;

438 
MsgBuf
[
dex
++] = 0;

439 
MsgBuf
[
dex
++] = 
ResumeByL
 >> 8;

440 
MsgBuf
[
dex
++] = 
ResumeByL
;

441 
MsgBuf
[
dex
++] = 
m_wRtuAddr
;

443 
MsgBuf
[
dex
++] = 
Yk_FunNum
;

445 
MsgBuf
[
dex
++] = 
yk_gi
>>8;

446 
MsgBuf
[
dex
++] = 
yk_gi
;

448 if
v
==1 )

449 
MsgBuf
[
dex
++] = 0xff;

450 if
v
==0 )

451 
MsgBuf
[
dex
++] = 0x00;

454 
	`EPack

yk_bufSl
 , 
ERROR_DATA
 );

455  
TRUE
;

458 
MsgBuf
[
dex
++] = 0x00;

460 
MsgL
 = 
dex
;

461  
TRUE
;

462 
	}
}

464 
BOOL
 
	gResume
::
	$EPack
(
BYTE
 * 
buf
,BYTE 
rag
)

466 
MsgFg
 = 1;

468 
BYTE
 
dex
 = 0;

470 
MsgBuf
[
dex
++] = 
buf
[0];

471 
MsgBuf
[
dex
++] = 
buf
[1];

472 
MsgBuf
[
dex
++] = 0;

473 
MsgBuf
[
dex
++] = 0;

474 
MsgBuf
[
dex
++] = 0;

475 
MsgBuf
[
dex
++] = 3;

476 
MsgBuf
[
dex
++] = 
m_wRtuAddr
;

477 
MsgBuf
[
dex
++] = 
FunNum
 | 0x80;;

478 
MsgBuf
[
dex
++] = 
rag
;

480 
MsgL
 = 
dex
;

481  
TRUE
;

482 
	}
}

484 
BOOL
 
	gResume
::
	$WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
wV
)

486 if(
m_pwAITns
==
NULL
 
FALSE
;

487 
WORD
 
wNum
 = 
m_pwAITns
[
wP
];

488 if(
wNum
>
m_wAISum
 
FALSE
;

489 if(
wNum
<
MODBUSTCPMAX_AI_LEN
)

491 
nDt
 = 
wV
 - 
m_wYCBuf
[
wNum
];

492 if(
	`abs
(
nDt
)>=
m_wDdV
)

494 
m_wYCBuf
[
wNum
] = 
wV
;

495 
	`AddAlogEvt

wSlNo
 , 
wNum
 , 
wV
 );

498  
TRUE
 ;

499 
	}
}

501 
BOOL
 
	gResume
::
	$WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
)

503 if(
m_pwDITns
==
NULL
 
FALSE
;

504 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

505 if(
wNum
>
m_wDISum
 
FALSE
;

506 if
wNum
<
MODBUSTCPMAX_DI_LEN
)

508 if
m_byYXbuf
[ 
wNum
 ] !
wV
 )

510 
m_byYXbuf
[ 
wNum
 ] = 
wV
 ;

512 
	`AddDigEvt

wSlNo
 , 
wNum
 , 
wV
 );

515  
TRUE
 ;

516 
	}
}

518 
BOOL
 
	gResume
::
	$WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
)

520 if(
m_pwPITns
==
NULL
 
FALSE
;

521 
WORD
 
wNum
 = 
m_pwPITns
[
wP
];

522 if(
wNum
>
m_wPISum
 
FALSE
;

523 if(
wNum
<
MODBUSTCPMAX_PI_LEN
)

525 
m_dwYMBuf
[
wNum
] = 
dwV
;

527  
TRUE
 ;

528 
	}
}

530 
BOOL
 
	gResume
::
	$WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

532 if(
m_pwDITns
==
NULL
 
FALSE
;

533 
WORD
 
wNum
 = 
m_pwDITns
[
wP
] & 0x7fff;

534 if(
wNum
>=
m_wDISum
 
FALSE
;

535 if(
wNum
<
MODBUSTCPMAX_DI_LEN
)

537 
	`AddSOEInfo
(
wSlNo
 , 
wNum
, 
wV
, 
lTime
, 
wMiSecd
);

539  
TRUE
 ;

540 
	}
}

542 
	gResume
::
	$TimProc
()

545 
	`RdChgDa
();

547 
	}
}

549 
BOOL
 
	gResume
::
	$GDevCommS
( )

551 if(
m_byPtStus
 =
COMSTATUS_ONLINE
)

553  
COM_DEV_NORMAL
 ;

557  
COM_DEV_ABNORMAL
 ;

559 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/Resume.h

1 #i!
defed
(
MODBUSTCP_
)

2 
	#MODBUSTCP_


	)

7 
	~"CProc_Resume.h
"

9 
	#MODBUSTCPMAX_AI_LEN
 (6800)

	)

10 
	#MODBUSTCPMAX_PI_LEN
 (1599)

	)

11 
	#MODBUSTCPMAX_DI_LEN
 (9999)

	)

13 
	#MODBUSTCPMAX_MSG_LEN
 (1024)

	)

15 as
	cResume
 : 
public
 
CProc_Resume


17 
public
:

18 
Resume
();

19 
	mvtu
 ~
Resume
();

21 
BYTE
 
	mSdFg
;

22 
	mm_wYCBuf
[
MODBUSTCPMAX_AI_LEN
];

23 
DWORD
 
	mm_dwYMBuf
[
MODBUSTCPMAX_PI_LEN
];

24 
BYTE
 
	mm_byYXbuf
[
MODBUSTCPMAX_DI_LEN
 ];

26 
BYTE
 
	mMsgBuf
[
MODBUSTCPMAX_MSG_LEN
];

27 
WORD
 
	mMsgL
;

28 
BYTE
 
	mMsgFg
;

29 
BYTE
 
	mFunNum
;

30 
BYTE
 
	mEFg
;

31 
	mm_wETim
;

32 
	mm_byPtStus
;

33 
BYTE
 
	myk_bufSl
[2];

35 
BYTE
 
	mYk_FunNum
;

36 
BOOL
 
	myk_cv_ag
;

37 
UINT
 
	mtime_ag
;

39 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

40 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

41 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

42 
vtu
 
BOOL
 
InRtuBa
();

43 
vtu
 
BOOL
 
WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
wV
) ;

44 
vtu
 
BOOL
 
WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
) ;

45 
vtu
 
BOOL
 
WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
) ;

46 
vtu
 
BOOL
 
WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
) ;

47 
vtu
 
RayEchoProc
(
BYTE
 
byCommd
, 
WORD
 
wIndex
, BYTE 
byResu
);

50 
vtu
 
BOOL
 
GDevCommS
( ) ;

51 
vtu
 
TimProc
() ;

53 
BOOL
 
YXPack

BYTE
 * 
buf
 , 
n
 );

54 
BOOL
 
YcYmPack

BYTE
 * 
buf
 , 
n
 );

55 
BOOL
 
YKMsg

BYTE
 * 
buf
 , 
n
 );

56 
BOOL
 
YKPack

yk_gi
 , 
v
 );

58 
BOOL
 
DlBusMsgInfo

PBUSMSG
 
pBusMsg
 );

60 
BOOL
 
EPack

BYTE
 * 
buf
 , BYTE 
rag
 );

61 
time_t
 
	mndtimeag
;

62 
time_t
 
	mcvtimeag
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/main.cpp

1 
	~<dio.h
>

2 
	~"CProc_Resume.h
"

6 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

11 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

13 
CProc
 * 
pProc
 = 
NULL
 ;

14 
pProc
 = 
w
 
CProc_Resume
;

15 if
pProc
 )

17 
pProc
->
m_pMhod
 = 
pMhod
 ;

18 
	`tf
( "ModBusTcp DLL OK.\n " ) ;

21  
pProc
 ;

22 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CGroupBroadProto.cpp

19 
	~<dio.h
>

20 
	~<dlib.h
>

21 
	~<rg.h
>

22 
	~<lux/sockios.h
>

23 
	~<sys/sock.h
>

24 
	~<sys/tys.h
>

25 
	~<sys/m.h
>

26 
	~<sys/iol.h
>

27 
	~<sys/sock.h
>

28 
	~<t/if.h
>

29 
	~<t/.h
>

30 
	~<t/if_p.h
>

31 
	~</.h
>

32 
	~<unid.h
>

33 
	~<lux/mii.h
>

34 #ifde
SOLARIS


35 
	~<sys/sockio.h
>

38 
	~"CGroupBrdPro.h
"

39 
	~"GroupBrd.h
"

40 
	~"../../she/ofe.h
"

41 
	~"../../she/rdbFun.h
"

42 
	~"../../BayLay/ma.h
"

45 cڡ 
BYTE
 
	gASK_IP
 = 0x01;

46 cڡ 
	gg_GroupIp
[16] = "224.0.0.100";

55 
	gCGroupBrdPro
::
	$CGroupBrdPro
 ()

57 
chPrjNameFe
[] = 
BUS_PATH
;

58  
i
=0; i<4; i++ )

60 
m_IsAddRou
[
i
] = 
FALSE
;

62 
	`memt

m_bySdBuf
, 0, 
GROUP_BROAD_PROTO_MAX_LEN
 );

63 
m_wSdL
 = 0;

64 
m_lTimeFg
 = 0;

65 
m_RouPt
 = 0;

66 
	`memt

m_chPrjName
, 0, 32 );

67 
m_iSockFd
 = -1;

69 
CProfe
 
	`Profe

chPrjNameFe
 );

70 
Profe
.
	`GProfeSg
( (*)"PROJECT" ,

73 
m_chPrjName
 ,

77 
	}
}

87 
	gCGroupBrdPro
::~
	$CGroupBrdPro
 ()

89 if
m_iSockFd
 > 0 )

91 
	`o

m_iSockFd
 );

94  
i
=0; i<4; i++)

96 if
m_IsAddRou
[
i
] )

98 
chBuf
[256] = "";

99 
	`rtf

chBuf
,

101 
g_GroupIp
, 
i
);

102 
m_IsAddRou
[ 
i
-1 ] = 
FALSE
;

103 
	`syem

chBuf
 );

107 
	}
}

118 
	gCGroupBrdPro
::
	$STimeFg
 ( 
lTimeFg
 )

120 
m_lTimeFg
 = 
lTimeFg
;

121 
	}
}

133 
BOOL
 
	gCGroupBrdPro
::
	$CheckTimeFg
 ( 
lTimeFg
 )

135  ( 
lTimeFg
 =
m_lTimeFg
 );

136 
	}
}

148 
	#MAXINTERFACES
 16

	)

149 
BYTE
 
	gCGroupBrdPro
::
	$GNCdNum
 ( )

151 
ieq
 
buf
[
MAXINTERFACES
];

152 
ifcf
 
ifc
;

154 if
m_iSockFd
 < 0 )

156 
m_iSockFd
 = 
	`sock
 (
AF_INET
, 
SOCK_DGRAM
, 0);

159 
	`tf
("m_iSockFd:%de:%d\n", 
m_iSockFd
, 
__LINE__
);

160 i(
m_iSockFd
 >= 0)

162 
ifc
.
ifc_n
 =  
buf
;

163 
ifc
.
ifc_buf
 = (
ddr_t

buf
;

164 i(!
	`iol
 (
m_iSockFd
, 
SIOCGIFCONF
, (*&
ifc
))

166 

 = 0;

168 

 = 
ifc
.
ifc_n
 /  (
ieq
);

169  

;

174 
	`o
 (
m_iSockFd
);

175 
	`
 ("cpm: ioctl");

181 
	`
 ("cpm: socket");

185 
	}
}

197 
BOOL
 
	gCGroupBrdPro
::
	$GNS
 ( cڡ *
if_me
,

198 
phy_id
,

199 
g_num
 )

201 
ieq
 
i
;

202 
mii_iol_da
 *
mii
;

203 
BOOL
 
vue
;

204 if
m_iSockFd
 < 0 )

206 
m_iSockFd
 = 
	`sock
 (
AF_INET
, 
SOCK_DGRAM
, 0);

209 i(
m_iSockFd
 < 0)

211 
	`
("socket");

212 
	`o
(
m_iSockFd
);

216 
	`bzo
(&
i
, (ifr));

217 
	`y
(
i
.
i_me
, 
if_me
, 
IFNAMSIZ
-1);

218 
i
.
i_me
[
IFNAMSIZ
-1] = 0;

220 i(
	`iol
(
m_iSockFd
, 
SIOCGMIIPHY
, &
i
) < 0)

222 
	`
("ioctl");

223 
	`o
(
m_iSockFd
);

227 
mii
 = (
mii_iol_da
 *)&
i
.
i_da
;

228 
mii
->
g_num
 =eg_num;

229 i(
	`iol
(
m_iSockFd
, 
SIOCGMIIREG
, &
i
) < 0)

231 
	`
("ioctl");

232 
	`o
(
m_iSockFd
);

236 
vue
 = ((
mii
->
v_out
&0x04)>>2);

238  
vue
;

239 
	}
}

250 
BOOL
 
	gCGroupBrdPro
::
	$GNIpAndS
 ( cڡ 
BYTE
 
byNCd
,

251 *
pchBuf
,

252 
BOOL
 &
bS
)

254 
ieq
 
buf
[
MAXINTERFACES
];

255 
ifcf
 
ifc
;

257 if
m_iSockFd
 < 0 )

259 
m_iSockFd
 = 
	`sock
 (
AF_INET
, 
SOCK_DGRAM
, 0);

262 i((
m_iSockFd
 = 
	`sock
 (
AF_INET
, 
SOCK_DGRAM
, 0)) >= 0)

264 
ifc
.
ifc_n
 =  
buf
;

265 
ifc
.
ifc_buf
 = (
ddr_t

buf
;

266 i(!
	`iol
 (
m_iSockFd
, 
SIOCGIFCONF
, (*&
ifc
))

268 

 = 0;

270 

 = 
ifc
.
ifc_n
 /  (
ieq
);

272 if
byNCd
 > 0 )

274 

 = 
byNCd
;

306 
bS
 = 
	`GNS

buf
[

].
i_me
, 0x10, 0x01 );

309 i(!(
	`iol
 (
m_iSockFd
, 
SIOCGIFADDR
, (*&
buf
[

])))

312 
	`ry

pchBuf
, (*)
	`_
(((
sockaddr_
*)(&
buf
[

].
i_addr
))->
s_addr
));

319 
r
[256];

320 
	`rtf
 (
r
, "m: iodevi %s", 
buf
[

].
i_me
);

321 
	`
 (
r
);

322  
FALSE
;

328 
	`
 ("cpm: ioctl");

329  
FALSE
;

334 
	`
 ("cpm: socket");

335  
FALSE
;

338  
TRUE
;;

339 
	}
}

351 
le
 
	gCGroupBrdPro
::
	$IpToBy
 ( *
pchBuf
, 
BYTE
 *
byIpBuf
 )

353 
a
, 
b
, 
c
, 
d
;

354 
	`ssnf

pchBuf
, "%3d.%3d.%3d.%3d", &
a
, &
b
, &
c
, &
d
 );

355 
byIpBuf
[0] = 
a
 & 0xff;

356 
byIpBuf
[1] = 
b
 & 0xff;

357 
byIpBuf
[2] = 
c
 & 0xff;

358 
byIpBuf
[3] = 
d
 & 0xff;

359 
	}
}

371 
le
 
	gCGroupBrdPro
::
	$SIpS
 ( 
BYTE
 &
bySBy
,

372 
BOOL
 
bS
,

373 
BYTE
 
byNCd
)

375 if
bS
 )

377 
bySBy
 |1 << 
byNCd
 );

379 
	}
}

391 
	gCGroupBrdPro
::
	$AddFmeFm
 ( 
BYTE
 *
byDaBuf
, 
WORD
 
wDaL
 )

394 
m_bySdBuf
[ 
HEAD_START
 ] = 0x68;

395 
m_bySdBuf
[ 
HEAD_HILEN
 ] = 
	`HIBYTE

wDaL
 );

396 
m_bySdBuf
[ 
HEAD_LOLEN
 ] = 
	`LOBYTE

wDaL
 );

397 
m_bySdBuf
[ 
HEAD_RESTART
 ] = 0x68;

400  
WORD
 
i
=0; i<
wDaL
; i++ )

402 
m_bySdBuf
[ 
DATA_FUNC
 + 
i
 ] = 
byDaBuf
[ i ];

405 
m_bySdBuf
[ 
DATA_FUNC
 ] |= 0x80;

407 
m_bySdBuf
[ 
DATA_FUNC
 + 
wDaL
 ]

408 
	`GCheckBy
&
m_bySdBuf
[ 
DATA_FUNC
 ], 
wDaL
 );

411 
m_bySdBuf
[ 
DATA_FUNC
 + 
wDaL
 + 1 ] = 0x16;

412 
m_wSdL
 = 
wDaL
 + 6;

413 
	}
}

424 
BOOL
 
	gCGroupBrdPro
::
	$GAnsIpFme
 ( )

426 
WORD
 
wDaL
 = 0;

427 
BYTE
 
byDaBuf
[ 
GROUP_BROAD_PROTO_MAX_LEN
 - 6 ] = "";

428 
chPrjNameFe
[] = 
BUS_PATH
;

430 
byDaBuf
[ 
wDaL
 ++ ] = 0x01;

431 
byDaBuf
[ 
wDaL
 ++ ] = 
	`HIBYTE

	`HIWORD

m_lTimeFg
 ) );

432 
byDaBuf
[ 
wDaL
 ++ ] = 
	`LOBYTE

	`HIWORD

m_lTimeFg
 ) );

433 
byDaBuf
[ 
wDaL
 ++ ] = 
	`HIBYTE

	`LOWORD

m_lTimeFg
 ) );

434 
byDaBuf
[ 
wDaL
 ++ ] = 
	`LOBYTE

	`LOWORD

m_lTimeFg
 ) );

436 
CProfe
 
	`Profe

chPrjNameFe
 );

437 
Profe
.
	`GProfeSg
( (*)"PROJECT" ,

440 
m_chPrjName
 ,

442 
	`memy
&
byDaBuf
[
wDaL
], 
m_chPrjName
, 32 );

443 
wDaL
 += 32;

445 
BYTE
 
byNCdNum
 = 
	`GNCdNum
( );

447 
byDaBuf
[ 
wDaL
 ++ ] = 
byNCdNum
-1;

449 
BYTE
 
bySBy
 = 0;

450  
BYTE
 
i
=1; i<
byNCdNum
; i++)

453 
chIpBuf
[16] = "";

454 
BOOL
 
bS
;

455 if
	`GNIpAndS

i
, 
chIpBuf
, 
bS
 ) )

457 
	`IpToBy

chIpBuf
, &
byDaBuf
[ 
wDaL
 ] );

458 
wDaL
 += 4;

459 
	`SIpS

bySBy
, 
bS
, 
i
-1 );

463 
	`tf
 ( "GetAnsIpFrame::ip stateot find\n" );

464  
FALSE
;

468 
byDaBuf
[ 
wDaL
 ++ ] = 
bySBy
;

469 
	`AddFmeFm

byDaBuf
, 
wDaL
 );

471  
TRUE
;

472 
	}
}

484 
BOOL
 
	gCGroupBrdPro
::
	$PDF_AskIp
 ( 
BYTE
 *
buf
, 
n
 )

486 
BYTE
 *
pPot
 = 
buf
 + 
DATA_FUNC
;

489 
pPot
 ++;

490 
lTimeFg
 = ( *
pPot
 << 24 )

491 |*
pPot
 + 1 ) << 16 )

492 |*
pPot
+ 2 ) << 8 )

493 |*
pPot
 + 3 ) );

495 if
	`CheckTimeFg

lTimeFg
 ) )

497  
FALSE
;

501 
	`STimeFg

lTimeFg
 );

504  
	`GAnsIpFme
( );

505 
	}
}

517 
BOOL
 
	gCGroupBrdPro
::
	$ProssDaFme
 ( 
BYTE
 *
buf
, 
n
 )

520  
buf
[
DATA_FUNC
] )

522 
FUNC_ASK_IP
:

523  
	`PDF_AskIp

buf
, 
n
 );

530  
FALSE
;

531 
	}
}

542 
le
 
BYTE
 
	gCGroupBrdPro
::
	$GCheckBy
 ( 
BYTE
 *
buf
, 
n
 )

544 
BYTE
 
byCheckBy
 = 0;

546  
i
=0; i<
n
; i++)

548 
byCheckBy
+=
buf
[
i
] ;

551  
byCheckBy
;

552 
	}
}

564 
BOOL
 
	gCGroupBrdPro
::
	$CheckFmeFm
 ( 
BYTE
 *
buf
, 
n
 )

566 if
NULL
 =
buf


567 || 6 > 
n
)

569  
FALSE
;

572 if0x68 !
buf
[
HEAD_START
]

573 && 
buf
[
HEAD_START
] !buf[
HEAD_RESTART
])

575 
	`tf
 ( "headrror\n" );

576  
FALSE
;

579 
WORD
 
wRecvL
 = 
	`MAKEWORD

buf
[
HEAD_LOLEN
], buf[
HEAD_HILEN
] );

580 if
n
-6 ) !
wRecvL
)

582 
	`tf
 ( "lenrror\n" );

583  
FALSE
;

586 if0x16 !
buf
[
n
-1] )

588 
	`tf
 ( "0x16rror\n" );

589  
FALSE
;

592 
BYTE
 
byCheckBy
 = 
	`GCheckBy

buf
+
DATA_FUNC
, 
wRecvL
 );

593 if
byCheckBy
 !
buf
[
n
-2] )

595 
	`tf
 ( "check %x %x\n", 
byCheckBy
, 
buf
[
n
-2] );

596  
FALSE
;

599 if
buf
[
DATA_FUNC
] & 0x80 )

601  
FALSE
;

604  
TRUE
;

605 
	}
}

617 
BOOL
 
	gCGroupBrdPro
::
	$ProssProDa
 ( 
BYTE
 *
buf
, 
n
 )

619 if!
	`CheckFmeFm

buf
, 
n
 ) )

621  
FALSE
;

623  
	`ProssDaFme

buf
, 
n
 );

624 
	}
}

636 
BYTE
 
	gCGroupBrdPro
::
	$GONPt
 ( )

638 
BYTE
 
byNCdNum
 = 
	`GNCdNum
( );

641  
BYTE
 
i
=1; i < 
byNCdNum
;i++ )

643 
chBuf
[256] = "";

644 
	`rtf

chBuf
, "h%d", ( 
i
-1 ) );

645 
BOOL
 
bS
 = 
	`GNS

chBuf
, 0x10, 0x01 );

646 if
bS
 )

648 
m_IsAddRou
[
i
-1] = 
TRUE
;

649  
i
;

654 
	}
}

666 
	gCGroupBrdPro
::
	$SRouPt
 ( 
BYTE
 
byPt
 )

668 if0 =
byPt
 || 4 < byPort )

673 if
byPt
 =
m_RouPt
 )

678 
BYTE
 
byNCdNum
 = 
	`GNCdNum
( );

679  
BYTE
 
i
=1; i<
byNCdNum
; i++)

681 
chBuf
[256]= "";

682 if
byPt
 =
i
 )

684 
	`rtf

chBuf
,

686 
g_GroupIp
, 
i
-1);

687 
m_RouPt
 = 
byPt
;

688 
	`syem

chBuf
 );

689 
	`GroupBrdIn
( );

693 if
m_IsAddRou
[ 
i
-1 ] )

695 
	`rtf

chBuf
,

697 
g_GroupIp
, 
i
-1);

699 
m_IsAddRou
[ 
i
-1 ] = 
FALSE
;

700 
	`syem

chBuf
 );

704 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CGroupBroadProto.h

21 #ide 
CGROUPBROADPROTO_INC


22 
	#CGROUPBROADPROTO_INC


	)

24 
	~"../../she/tydef.h
"

27 
	#GROUP_BROAD_PROTO_MAX_LEN
 1024

	)

35 as
	cCGroupBrdPro


37 
	mpublic
:

39 
CGroupBrdPro
 ();

40 ~
CGroupBrdPro
 ();

42 
	mpublic
:

44 
BOOL
 
ProssProDa

BYTE
 *
buf
, 
n
 );

47 
BYTE
 
GONPt
( );

49 
SRouPt

BYTE
 
byPt
 );

51 
	mive
:

53 
BYTE
 
GCheckBy
BYTE *
buf
, 
n
 );

55 
BOOL
 
CheckFmeFm

BYTE
 *
buf
, 
n
 );

57 
BOOL
 
ProssDaFme

BYTE
 *
buf
, 
n
 );

59 
BOOL
 
PDF_AskIp

BYTE
 *
buf
, 
n
 );

61 
STimeFg

lTimeFg
 );

63 
BOOL
 
CheckTimeFg

lTimeFg
 );

65 
BOOL
 
GAnsIpFme
( );

67 
BYTE
 
GNCdNum
( );

69 
BOOL
 
GNS
 ( cڡ *
if_me
, 
phy_id
, 
g_num
 );

71 
BOOL
 
GNIpAndS
(cڡ 
BYTE
 
byNCd
, *
pchBuf
, BOOL &
bS
 );

73 
IpToBy
*
pchBuf
, 
BYTE
 *
byIpBuf
 );

75 
SIpS

BYTE
 &
bySBy
 , 
BOOL
 
bS
, BYTE 
byNCd
 );

77 
AddFmeFm

BYTE
 *
byDaBuf
, 
WORD
 
wDaL
 );

79 
	meed
:

82 
public
:

83 
BYTE
 
m_bySdBuf
[
GROUP_BROAD_PROTO_MAX_LEN
];

84 
WORD
 
	mm_wSdL
;

85 
	mive
:

86 
m_lTimeFg
;

87 
	em_eFmeBy


89 
	mHEAD_START
 = 0,

90 
	mHEAD_HILEN
,

91 
	mHEAD_LOLEN
,

92 
	mHEAD_RESTART
,

93 
	mDATA_FUNC


96 
	em_eFuncCode


98 
	gFUNC_ASK_IP
 = 1

101 
BYTE
 
	gm_RouPt
;

102 
BOOL
 
	gm_IsAddRou
[4];

104 
	gm_chPrjName
[32];

106 
	gm_iSockFd
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtp.cpp

20 
	~"CSockF.h
"

21 
	~"GroupBrd.h
"

23 
	#CSOCKETFTP_PRINT_MSG
 1

	)

33 
	$tMsg
 ( cڡ 
BYTE
 *
buf
, 
n
, 
BOOL
 
bFg
 )

36 
i
 = 0;

38 
bFg
?
	`tf
 ( "Rx%d::", 
n
 ):printf ( "Tx%d::" ,len);

40  
i
=0; i <
n
; i++ )

42 
	`tf
 ( "%.2x ", 
buf
[
i
]);

44 
	`tf
 ( "\n" );

45 
	}
}

54 *
	$Thad
 ( *
pVoid
 )

56 
CSockF
 *
pSockF
 = (CSockF *)
pVoid
;

57 
	`tf
 ( "CSocketFtphread\n" );

58 
DWORD
 
dwRecvETime
 = 0;

59 cڡ 
DWORD
 
dwETime
 = 10000000;

60 
DWORD
 
dwUpIv
 = 500000;

61 
	`p
( 5 );

65 
BYTE
 
buf
[
FTP_MAX_SEND_LEN
] = "";

68 
iRdL
 =
pSockF
->
m_pPt
->
	`AsyRdDa

buf
, 
FTP_MAX_SEND_LEN
 );

69 if
iRdL
 <= 0 )

71 
dwRecvETime
 +
dwUpIv
;

72 i
dwETime
 <
dwRecvETime
 )

74 
BYTE
 
byNCd
 = 
pSockF
->
m_pGroupPro
->
	`GONPt
( );

75 
pSockF
->
m_pGroupPro
->
	`SRouPt

byNCd
 );

76 
dwUpIv
 = 500000;

77 
pSockF
->
m_pPro
->
	`In
();

78 
dwRecvETime
 = 0;

81 
	`up

dwUpIv
 );

86 
dwRecvETime
 = 0;

87 
dwUpIv
 = 10000;

88 
	`tMsg

buf
, 
iRdL
 , 
TRUE
 );

90 
pSockF
->
m_pPro
->
	`ProssProSdBuf

buf
, 
iRdL
 );

92 if(
pSockF
->
m_pPro
->
m_wSdL
 > 0 )

94 
	`tMsg

pSockF
->
m_pPro
->
m_bySdBuf
,SockF->m_pPro->
m_wSdL
 , 
FALSE
 );

96 
pSockF
->
m_pPt
->
	`WrePt
(

97 
pSockF
->
m_pPro
->
m_bySdBuf
,

98 
pSockF
->
m_pPro
->
m_wSdL
 );

100 if
pSockF
->
m_pPro
->
m_bRebo
 )

102 
	`p
( 1 );

103 
	`syem
( "reboot" );

110 
	`had_jo

pSockF
->
m_had_id
, 
NULL
 );

111 
	}
}

122 *
	$GroupBrdThad
 ( *
pVoid
 )

124 
CSockF
 *
pSockF
 = (CSockF *)
pVoid
;

125 
	`tf
 ( "CSocketFtp GroupBroadThread\n" );

126 cڡ 
GROUPSLEEPTIME
 = 500000;

127 
n
;

128 
	`p
( 10 );

132 
BYTE
 
buf
[
GROUP_BROAD_PROTO_MAX_LEN
] = "";

133 
n
 = 0;

134 
iR
 = 
	`GroupBrdRecv

buf
, &
n
 );

135 if0 =
iR
 && 
n
 > 0)

137 
	`tMsg

buf
,
n
, 
TRUE
 );

138 
BOOL
 
bR
 = 
pSockF
->
m_pGroupPro
->
	`ProssProDa

buf
, 
n
 );

139 if
bR
 && 
pSockF
->
m_pGroupPro
->
m_wSdL
 > 0 )

141 
	`tMsg

pSockF
->
m_pGroupPro
->
m_bySdBuf
,

142 
pSockF
->
m_pGroupPro
->
m_wSdL
, 
FALSE
);

143 
	`GroupBrdSd

pSockF
->
m_pGroupPro
->
m_bySdBuf
,

144 
pSockF
->
m_pGroupPro
->
m_wSdL
);

149 
	`up

GROUPSLEEPTIME
 );

153 
	`had_jo

pSockF
->
m_groupbrd_id
, 
NULL
 );

154 
	}
}

162 
	gCSockF
::
	$CSockF
 ()

165 
m_pPt
 = 
NULL
;

166 
m_pPro
 = 
NULL
;

167 
m_pGroupPro
 = 
NULL
;

168 
	}
}

178 
	gCSockF
::~
	$CSockF
 ()

181 if
NULL
 !
m_pPt
 )

183 
m_pPt
->
	`CloPt
();

184 
de
 
m_pPt
;

185 
m_pPt
 = 
NULL
;

188 if
NULL
 !
m_pPro
 )

190 
de
 
m_pPro
;

191 
m_pPro
 = 
NULL
;

194 if
NULL
 !
m_pGroupPro
 )

196 
de
 
m_pGroupPro
;

197 
m_pGroupPro
 = 
NULL
;

200 
	}
}

213 
BOOL
 
	gCSockF
::
	$CeTSv
 ( )

215 
chEBuf
[256] = "";

217 
m_pPt
 = 
w
 
CTPtSv
;

218 if
NULL
 =
m_pPt
 )

220 
	`tf
 ( "CSocketFtp::CreateTcpServer fail\n" );

221  
FALSE
;

224 
m_pPt
->
m_uThePt
 = 65530;

225 
	`rtf

m_pPt
->
m_szArib
,"%u", 
INADDR_ANY
 );

228 
m_pPt
->
	`OnPt

chEBuf
 );

230  
TRUE
;

231 
	}
}

243 
BOOL
 
	gCSockF
::
	$CePro
 ( )

245 
m_pPro
 = 
w
 
	`CSockFPro
( );

246 if
NULL
 =
m_pPro
 )

248 
	`tf
 ( "CSocketFtp::CreateProto fail\n" );

249  
FALSE
;

252  
TRUE
;

253 
	}
}

264 
BOOL
 
	gCSockF
::
	$CeGroupBrd
 ( )

266 
m_pGroupPro
 = 
w
 
	`CGroupBrdPro
( );

267 if
NULL
 =
m_pGroupPro
 )

269  
FALSE
;

272 if-1 =
	`GroupBrdIn
( ) )

274 
	`tf
 ( "CreateGroupBroadrror\n" );

275  
FALSE
;

278  ( 0 =
	`had_
&
m_groupbrd_id
, 
NULL
, 
GroupBrdThad
, 
this
 ) );

279 
	}
}

291 
BOOL
 
	gCSockF
::
	$In
 ( )

294 if!
	`CeTSv
( ) )

296  
FALSE
;

300 if!
	`CePro
( ) )

302  
FALSE
;

305 if!
	`CeGroupBrd
( ) )

307  
FALSE
;

311  
TRUE
;

313 
	}
}

327 
BOOL
 
	gCSockF
::
	$CeThad
 ( )

330  ( 0 =
	`had_
&
m_had_id
, 
NULL
, 
Thad
, 
this
 ) );

331 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtp.h

21 #ide 
CSOCKETFTP_INC


22 
	#CSOCKETFTP_INC


	)

26 
	~"../../she/CTPtSv.h
"

27 
	~"CGroupBrdPro.h
"

28 
	~"CSockFPro.h
"

40 as
	cCSockF


42 
	mpublic
:

44 
CSockF
 ();

45 ~
CSockF
 ();

47 
	mpublic
:

49 
BOOL
 
In
 ( );

51 
BOOL
 
CeThad
 ( );

53 
	mive
:

55 
BOOL
 
CeTSv
 ( );

57 
BOOL
 
CePro
 ( );

60 
BOOL
 
CeGroupBrd
 ( );

62 
	mpublic
:

64 
CTPtSv
 *
m_pPt
;

65 
CSockFPro
 *
	mm_pPro
;

66 
CGroupBrdPro
 *
	mm_pGroupPro
;

68 
had_t
 
	mm_had_id
;

69 
had_t
 
	mm_groupbrd_id
;

71 
	meed
:

74 
ive
:

78 
ive
:

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtpFile.cpp

19 
	~<dio.h
>

20 
	~"CSockFFe.h
"

22 
	ggs_uiTٮSize
 = 0;

31 
	$CDSize
 ( cڡ *
th
,

32 cڡ 

 *
s
,

33 
agty
)

38 
gs_uiTٮSize
 +
s
->
_size
;

40 
	}
}

49 
	gCSockFFe
::
	$CSockFFe
 ()

52 
gs_uiTٮSize
 = 0;

53 
	}
}

62 
	gCSockFFe
::~
	$CSockFFe
 ()

64 
	}
}

75 
CSockFFe
::
	$WreFe
 ( *
pchFeName
,

76 *
puchBuf
,

77 
iL
)

79 
FILE
 *
pFe
 = 
NULL
;

80 
uiWreNum
;

88 if!
	`IsFeExi

pchFeName
 ) )

90 
pchDPh
[256];

91 
n
 = 
	`

pchFeName
 )- s
	`chr
(chFileName, '/' ));

92 
	`y

pchDPh
, 
pchFeName
, 
n
 ) ;

93 
pchDPh
[
n
] = 0;

95 
	`CeD

pchDPh
 );

99 
pFe
 = 
	`fݒ

pchFeName
, "ab+" );

100 if
NULL
 =
pFe
 )

102 
	`tf
 ( "pchFeName=%s\n", 
pchFeName
 );

103 
	`
( "pszFileName" );

108 
uiWreNum
 = 
	`fwre

puchBuf
, 1, 
iL
, 
pFe
 );

109 if0 =
uiWreNum
 )

113 
	`fo

pFe
 );

115  
uiWreNum
;

116 
	}
}

130 
	gCSockFFe
::
	$RdFe
 ( *
pchFeName
,

131 *
puchBuf
,

132 
iL
,

133 &
uiRdpos
)

135 
FILE
 *
pFe
 = 
NULL
;

136 
uiRdNum
=0;

138 if0 =
puchBuf
 )

143 
pFe
 = 
	`fݒ

pchFeName
, "rb" );

144 if
NULL
 =
pFe
 )

146 
	`tf
 ( "pchFeName=%s\n", 
pchFeName
 );

147 
	`
( "pszFileName" );

151 if-1 =
	`fek

pFe
, 
uiRdpos
, 
SEEK_SET
 ) )

153 
	`fo

pFe
 );

158 
uiRdNum
 = 
	`d

puchBuf
, 1, 
iL
, 
pFe
 );

160 
uiRdpos
 +
uiRdNum
;

162 
	`fo

pFe
 );

164  
uiRdNum
;

165 
	}
}

177 
	gCSockFFe
::
	$CeD
 ( cڡ *
pchDPh
 )

179 
DName
[256];

180 
	`ry
(
DName
, 
pchDPh
);

181 
i
,
n
 = 
	`
(
DName
);

182 if(
DName
[
n
-1]!='/')

183 
	`rt
(
DName
, "/");

185 
n
 = 
	`
(
DName
);

187 
i
=1; i<
n
; i++)

189 if(
DName
[
i
]=='/')

191 
DName
[
i
] = 0;

192 if
	`acss
(
DName
, 
F_OK
)!=0 )

194 if(
	`mkd
(
DName
, 0755)==-1)

196 
	`
("mkdirrror");

200 
DName
[
i
] = '/';

205 
	}
}

217 
	gCSockFFe
::
	$GFeSize
 ( cڡ *
chFeName
)

219 

 
buff
;

222 if(
	`
(
chFeName
, &
buff
) < 0)

224 
	`tf
 ( "%%lu\n", 
chFeName
, 
buff
.
_size
 );

228  
buff
.
_size
;

229 
	}
}

242 
	gCSockFFe
::
	$GDSize
 ( cڡ *
pchDPh
 )

244 
iR
;

245 
gs_uiTٮSize
 = 0;

247 i(
NULL
 =
pchDPh
 || 
	`acss
chDPh, 
R_OK
))

249 
	`tf
 ( "GetDirSize:isot dirpath\n" );

254 
iR
 = 
	`w

pchDPh
, 
CDSize
, 20 );

255 if-1 =
iR
)

257 
	`tf
 ( "GDSizr %s\n", 
pchDPh
 );

260  
gs_uiTٮSize
;

261 
	}
}

272 
bo
 
	gCSockFFe
::
	$IsFeExi
 ( cڡ *
chFeName
 )

274 

 
buf
;

275 if(
	`l
(
chFeName
, &
buf
) ==0)

277  
	`S_ISREG
(
buf
.
_mode
) != 0;

280  
l
;

281 
	}
}

293 
bo
 
	gCSockFFe
::
	$IsDExi
 ( cڡ *
chDPh
 )

295 

 
buf
;

296 if(
	`l
(
chDPh
, &
buf
) ==0)

298  
	`S_ISDIR
(
buf
.
_mode
) != 0;

301  
l
;

302 
	}
}

314 
bo
 
	gCSockFFe
::
	$IsSclD
 ( cڡ *
chDPh
 )

316  
	`rcmp
(
chDPh
, ".") == 0 || strcmp(cpchDirPath, "..") == 0;

317 
	}
}

331 
	gCSockFFe
::
	$GTٮFePh
 ( cڡ *
chPh
,

332 cڡ *
chFeName
,

333 *
chFePh
)

335 
	`ry
(
chFePh
, 
chPh
);

336 if(
chFePh
[
	`
(
chPh
) - 1] != '/')

337 
	`rt
(
chFePh
, "/");

338 
	`rt
(
chFePh
, 
chFeName
);

339 
	}
}

363 
bo
 
	gCSockFFe
::
	$ChgeFeMode
 ( *
pszFeName
, 
imode
 )

365 if
NULL
 =
pszFeName
 )

367  
l
;

370 if0 =
	`chmod
 ( 
pszFeName
, 
imode
 ))

372  
ue
;

375  
l
;

376 
	}
}

387 
bo
 
	gCSockFFe
::
	$ChgeDFesMode
 ( *
pchDPh
, 
imode
 )

389 
DIR
 *
d
;

390 
dt
 *
r
;

391 

 ;

392 
ba
[1000];

394 i((
d
=
	`ݒd
(
pchDPh
)=
NULL
)

396 
	`
("Open dirrror...");

397  
l
;

401 (
r
=
	`add
(
d
)!
NULL
)

403 if(
	`IsSclD

r
->
d_me
 ))

405 if(
r
->
d_ty
 == 8 ||

406 
r
->
d_ty
 == 10)

408 
chFeName
[256];

409 
	`rtf

chFeName
, "%s/%s", 
pchDPh
, 
r
->
d_me
 );

410 if!
	`ChgeFeMode

chFeName
, 
imode
 ) )

412 
	`od

d
 );

413  
l
;

416 if(
r
->
d_ty
 == 4)

418 
	`memt
(
ba
,'\0',(base));

419 
	`ry
(
ba
,
pchDPh
);

420 
	`rt
(
ba
,"/");

421 
	`rt
(
ba
,
r
->
d_me
);

422 if!
	`ChgeDFesMode
(
ba
, 
imode
))

424 
	`od

d
 );

425  
l
;

430 
	`od
(
d
);

431  
ue
 ;

432 
	}
}

444 
bo
 
	gCSockFFe
::
	$DeDFes
 ( cڡ *
pchDPh
 )

446 
DIR
 *
d
 = 
NULL
;

447 
dt
 *
d_fo
;

448 
fe_th
[
PATH_MAX
];

449 if(
	`IsFeExi
(
pchDPh
))

451 
	`move
(
pchDPh
);

452  
l
;

455 if(
	`IsDExi
(
pchDPh
))

457 if((
d
 = 
	`ݒd
(
pchDPh
)=
NULL
)

458  
l
;

459 (
d_fo
 = 
	`add
(
d
)!
NULL
)

461 
	`GTٮFePh
(
pchDPh
, 
d_fo
->
d_me
, 
fe_th
);

462 if(
	`IsSclD
(
d_fo
->
d_me
))

464 
	`DeDFes
(
fe_th
);

465 
	`rmd
(
fe_th
);

469 
	`od

d
 );

471  
ue
;

472 
	}
}

485 
bo
 
	gCSockFFe
::
	$MoveDFes
 ( *
pchSrcPh
, *
pchDPh
 )

487 if
NULL
 =
pchSrcPh


488 || 
NULL
 =
pchDPh
 )

490  
l
;

493 if0 =
	`me

pchSrcPh
, 
pchDPh
 ) )

495  
ue
;

497 
	`
( "rename" );

499  
l
;

500 
	}
}

512 
bo
 
	gCSockFFe
::
	$WreFeLiFe
 ( *
pchDPh
, *
pchFeName
 )

514 
DIR
 *
d
;

515 
dt
 *
r
;

516 

 ;

517 
ba
[1000];

519 if
NULL
 =
pchFeName
 )

521  
l
;

524 i((
d
=
	`ݒd
(
pchDPh
)=
NULL
)

526 
	`
("Open dirrror...");

527  
l
;

531 (
r
=
	`add
(
d
)!
NULL
)

533 if(
	`IsSclD

r
->
d_me
 ))

535 if(
r
->
d_ty
 == 8 ||

536 
r
->
d_ty
 == 10)

538 
chFeName
[256];

539 
	`rtf

chFeName
, "%s/%s\n", 
pchDPh
, 
r
->
d_me
 );

540 
	`WreFe

pchFeName
, (*)
chFeName
 , 
	`
( chFileName ));

542 if(
r
->
d_ty
 == 4)

544 
	`memt
(
ba
,'\0',(base));

545 
	`ry
(
ba
,
pchDPh
);

546 
	`rt
(
ba
,"/");

547 
	`rt
(
ba
,
r
->
d_me
);

548 if!
	`WreFeLiFe
(
ba
, 
pchFeName
))

550 
	`od

d
 );

551  
l
;

556 
	`od
(
d
);

557  
ue
 ;

558 
	}
}

576 
bo
 
	gCSockFFe
::
	$CheckFeLi
 ( )

578 cڡ 
iCheckNum
 = 5;

579 cڡ 
iMaxFeNum
 = 50;

580 
bo
 
bPrgm
[
iCheckNum
] = {
l
, false, false, false, false};

581 
ih
 = 0;

582 
szCheckTy
[
iCheckNum
][64] = {"/mynand/bin/pman", "/mynand/bin/gather", "/mynand/bin/rtdbserver", ".so", "/myapp/user.sh"};

583 
chLeBuf
[256];

585  
i
=1; 
NULL
 !
	`GFeLeBuf

FTP_FILE_LIST
, i, 
chLeBuf
 ) && i<
iMaxFeNum
; i++)

587 if'\n' =
chLeBuf
[0] )

592 
j
 = 0;

593  
j
=0; j<
iCheckNum
; j++ )

595 if
NULL
 !
	`rr

chLeBuf
, 
szCheckTy
[
j
] ) )

597 
bPrgm
[
j
] = 
ue
;

602 if
ih
 )

603 if
j
 >
iCheckNum
 )

605  
l
;

610  
k
=0; k<
iCheckNum
-1; k++)

612 if!
bPrgm
[
k
] )

614 
	`tf
 ( "CheckFeLiڐ%s\n", 
szCheckTy
[
k
] );

615  
l
;

619  
ue
;

620 
	}
}

632 
FTP_FILE_TYPE
 
	gCSockFFe
::
	$GDownTy
 ( *
pchFeName
 )

634 
FILE
 *

 = 
NULL
;

635 
chLeBuf
[256];

637 

 = 
	`fݒ

pchFeName
, "rb" );

638 if
NULL
 =

 )

640 
	`
( "ftp_list" );

641  
FTP_NONE_TYPE
;

644  
	`fgs

chLeBuf
, chLeBu), 

 ) )

646 if
NULL
 !
	`rr

chLeBuf
, "/mynand/config/" ) )

648 
	`fo


 );

649  
FTP_CFG_TYPE
;

652 if
NULL
 !
	`rr

chLeBuf
, "/mynand/bin" ) ||

653 
NULL
 !
	`rr

chLeBuf
, "/mynand/lib" ) ||

654 
NULL
 !
	`rr

chLeBuf
, "/myapp/user.sh" ))

656 
	`fo


 );

657  
FTP_PRGM_TYPE
;

663 
	`fo


 );

664  
FTP_NONE_TYPE
;

665 
	}
}

676 * 
	gCSockFFe
::
	$GDownFeName
 ( 
FTP_FILE_TYPE
 
fTy
,

677 *
pchFeName
 )

679 
chTmpBuf
[256];

680 
	`memt

chTmpBuf
, 0, 256 );

682 if
NULL
 =
pchFeName
 ||

683 
FTP_NONE_TYPE
 =
fTy
)

685  
NULL
;

688 if
FTP_CFG_TYPE
 =
fTy
 )

690 if0 =
	`cmp

pchFeName
, "/mynand/", 8 ) )

692 
	`ry

chTmpBuf
, 
FTP_DOWN_CFG_FILE
 );

693 
	`rt

chTmpBuf
, 
pchFeName
+8 );

694 
	`ry

pchFeName
, 
chTmpBuf
 );

695  
pchFeName
;

699 if
FTP_PRGM_TYPE
 =
fTy
 )

701 if0 =
	`cmp

pchFeName
, "/mynand/", 8 ) )

703 
	`ry

chTmpBuf
, 
FTP_DOWN_PRGM_FILE
 );

704 
	`rt

chTmpBuf
, 
pchFeName
+8 );

705 
	`ry

pchFeName
, 
chTmpBuf
 );

706  
pchFeName
;

708 if0 =
	`cmp

pchFeName
, "/myapp/user.sh" , 14) )

710 
	`ry

pchFeName
, 
FTP_DOWN_USER_FILE
 );

711  
pchFeName
;

715  
NULL
;

716 
	}
}

727 * 
	gCSockFFe
::
	$GFeLeBuf
 ( *
pchFeName
,

728 
iLe
,

729 *
pchLeBuf
 )

731 
FILE
 *

 = 
NULL
;

732 
chLeBuf
[256];

733 
iCou
 = 0;

735 if
NULL
 =
pchFeName
 ||

736 
NULL
 =
pchLeBuf
)

738  
NULL
;

741 

 = 
	`fݒ

pchFeName
, "rb" );

742 if
NULL
 =

 )

744 
	`
( "ftp_list" );

745  
NULL
;

748  
	`fgs

chLeBuf
, chLeBu), 

 ) )

750 if
NULL
 =
	`rr

chLeBuf
, "/" ) )

755 
iCou
 ++ ;

756 if
iCou
 =
iLe
 )

758 
	`ry

pchLeBuf
, 
chLeBuf
 );

759 
	`fo


 );

760  
pchLeBuf
;

764 
	`fo


 );

765  
NULL
;

766 
	}
}

778 
bo
 
	gCSockFFe
::
	$BakDFes
 ( * 
pchSrcPh
,

779 *
pchDPh
 )

781 if
NULL
 =
pchSrcPh
 ||

782 
NULL
 =
pchDPh
)

784  
l
;

788 
	`DeDFes

pchDPh
 ) ;

789 if!
	`MoveDFes

pchSrcPh
, 
pchDPh
 ) )

791 
	`tf
 ( "BakDFes::%bak %\n", 
pchSrcPh
, 
pchDPh
 );

792  
l
;

795  
ue
;

796 
	}
}

808 
bo
 
	gCSockFFe
::
	$UpdeCfg
 ( )

810 
chCfgFe
[256] = "/mynand/config/";

811 
chBakCfgFe
[256] = "/mynand/bak/config/";

812 
chTmp
[256] = "";

814 
	`rtf

chTmp
, "%s%s", 
FTP_DOWN_CFG_FILE
, (*)"config/" );

815 if!
	`IsDExi

chTmp
 ) )

817 
	`tf
 ( "n'fd %s\n", 
chTmp
 );

818  
l
;

820 
	`tf
 ( "/mynand/config begino update\n" );

823 if!
	`BakDFes

chCfgFe
, 
chBakCfgFe
 ) )

825  
l
;

829 if!
	`BakDFes

chTmp
, 
chCfgFe
 ) )

831 if!
	`BakDFes

chBakCfgFe
, 
chCfgFe
 ) )

833  
l
;

836  
l
;

844 if!
	`ChgeDFesMode

chCfgFe
,

845 
S_IRUSR
 | 
S_IRGRP
 ) )

847  
l
;

850 
	`DeDFes

FTP_DOWN_CFG_FILE
 );

851 
	`rmd

FTP_DOWN_CFG_FILE
 );

852 
	`tf
 ( "/mynand/config update success\n" );

853  
ue
;

854 
	}
}

866 
bo
 
	gCSockFFe
::
	$UpdePrgm
 ( )

868 
chPrgmBFe
[256] = "/mynand/bin/";

869 
chBakPrgmBFe
[256] = "/mynand/bak/bin/";

870 
chPrgmLibFe
[256] = "/mynand/lib/";

871 
chBakPrgmLibFe
[256] = "/mynand/bak/lib/";

872 
chPrgmUrFe
[256] = "/myapp/user.sh";

873 
chBakPrgmUrFe
[256] = "/myapp/bak/user.sh";

874 
chTmp
[256] = "";

876 if!
	`IsDExi

FTP_DOWN_PRGM_FILE
 ) )

878  
l
;

881 
	`rtf

chTmp
, "%s%s", 
FTP_DOWN_PRGM_FILE
, "bin/" );

882 if
	`IsDExi

chTmp
 ) )

884 
	`tf
 ( "/mynand/bin begino update\n" );

886 if!
	`BakDFes

chPrgmBFe
, 
chBakPrgmBFe
 ) )

888  
l
;

892 if!
	`BakDFes

chTmp
, 
chPrgmBFe
 ) )

894 if!
	`BakDFes

chBakPrgmBFe
, 
chPrgmBFe
 ) )

896  
l
;

899  
l
;

903 if!
	`ChgeDFesMode

chPrgmBFe
,

904 
S_IRUSR
 | 
S_IWUSR
 | 
S_IXUSR
 |

905 
S_IRGRP
 | 
S_IWGRP
 | 
S_IXGRP
 |

906 
S_IROTH
 | 
S_IWOTH
) )

908  
l
;

910 
	`tf
 ( "/mynand/bin update success\n" );

911 
	`DeDFes

chTmp
 );

912 
	`rmd

chTmp
 );

916 
	`tf
 ( "n'fd %s\n", 
chTmp
 );

920 
	`rtf

chTmp
, "%s%s", 
FTP_DOWN_PRGM_FILE
, "lib/" );

921 if
	`IsDExi

chTmp
 ) )

923 
	`tf
 ( "/mynand/lib begino update\n" );

925 if!
	`BakDFes

chPrgmLibFe
, 
chBakPrgmLibFe
 ) )

927  
l
;

931 if!
	`BakDFes

chTmp
, 
chPrgmLibFe
 ) )

933 if!
	`BakDFes

chBakPrgmLibFe
, 
chPrgmLibFe
 ) )

935  
l
;

938  
l
;

942 if!
	`ChgeDFesMode

chPrgmLibFe
,

943 
S_IRUSR
 | 
S_IWUSR
 |

944 
S_IRGRP
 | 
S_IWGRP
 |

945 
S_IROTH
 | 
S_IWOTH
) )

947  
l
;

950 
	`DeDFes

chTmp
 );

951 
	`rmd

chTmp
 );

952 
	`tf
 ( "/mynand/lib update success\n" );

956 
	`tf
 ( "n'fd %s\n", 
chTmp
 );

959 if
	`IsFeExi

FTP_DOWN_USER_FILE
 ) )

961 
	`tf
 ( "/myapp/user.sh begino update\n" );

963 if!
	`BakDFes

chPrgmUrFe
, 
chBakPrgmUrFe
 ) )

965  
l
;

970 if!
	`BakDFes
(
FTP_DOWN_USER_FILE
 , 
chPrgmUrFe
 ) )

972 if!
	`BakDFes

chBakPrgmUrFe
, 
chPrgmUrFe
 ) )

974  
l
;

977  
l
;

981 if!
	`ChgeFeMode

chPrgmUrFe
,

982 
S_IRUSR
 | 
S_IWUSR
 | 
S_IXUSR
 |

983 
S_IRGRP
 | 
S_IWGRP
 | 
S_IXGRP
 |

984 
S_IROTH
 | 
S_IWOTH
) )

986  
l
;

989 
	`DeDFes

FTP_DOWN_USER_FILE
 );

990 
	`rmd

FTP_DOWN_USER_FILE
 );

991 
	`tf
 ( "/myapp/usr.sh update success\n" );

995 
	`tf
 ( "n'fd %s\n", 
FTP_DOWN_USER_FILE
 );

998  
ue
 ;

999 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtpFile.h

21 #ide 
CSOCKETFTPFILE_INC


22 
	#CSOCKETFTPFILE_INC


	)

25 
	~"../../she/md5.h
"

26 
	~<dio.h
>

27 
	~<dlib.h
>

28 
	~<rg.h
>

29 
	~<unid.h
>

30 
	~<dt.h
>

31 
	~<sys/.h
>

32 
	~<dlib.h
>

33 
	~<w.h
>

34 
	~<sys/tys.h
>

35 
	~<f.h
>

36 
	~<dt.h
>

41 
	#FTP_FILE_LIST
 (*)"/mynd/fi.tmp"

	)

42 
	#FTP_DOWN_CFG_FILE
 (*)"/mynd/dowrgm/"

	)

43 
	#FTP_DOWN_PRGM_FILE
 (*)"/mynd/dowrgm/"

	)

44 
	#FTP_DOWN_USER_FILE
 (*)"/myp/downur/ur.sh"

	)

47 
	e_FTP_FILE_TYPE


49 
	mFTP_NONE_TYPE
,

50 
	mFTP_CFG_TYPE
,

51 
	mFTP_PRGM_TYPE


52 }
	tFTP_FILE_TYPE
;

64 as
	cCSockFFe


66 
	mpublic
:

68 
CSockFFe
 ();

69 ~
CSockFFe
 ();

71 
	mpublic
:

74 
WreFe
 ( *
pchFeName
,

75 *
puchBuf
,

76 
iL
);

78 
RdFe
 ( *
pchFeName
,

79 *
puchBuf
,

80 
iL
,

81 &
uiRdpos
) ;

84 
CeD
 ( cڡ *
pchDPh
 );

86 
GFeSize
 ( cڡ *
chFeName
);

88 
GDSize
 ( cڡ *
pchDPh
 );

90 
bo
 
IsFeExi
 ( cڡ *
chFeName
 );

92 
bo
 
IsDExi
 ( cڡ *
chDPh
 );

94 
bo
 
IsSclD
 ( cڡ *
chDPh
 );

96 
GTٮFePh
 ( cڡ *
chPh
,

97 cڡ *
chFeName
,

98 *
chFePh
);

100 
bo
 
ChgeFeMode
 ( *
pszFeName
,

101 
imode
 );

103 
bo
 
ChgeDFesMode
 ( *
pchDPh
,

104 
imode
 );

106 
bo
 
DeDFes
 ( cڡ *
pchDPh
 );

108 
bo
 
MoveDFes
 ( *
pchSrcPh
, *
pchDPh
 );

110 
bo
 
WreFeLiFe
 ( *
pchDPh
, *
pchFeName
 );

112 * 
GFeLeBuf
 ( *
pchFeName
,

113 
iLe
,

114 *
pchLeBuf
 );

116 
	mpublic
:

118 
bo
 
CheckFeLi
 ();

120 
FTP_FILE_TYPE
 
GDownTy
 ( *
pchFeName
 );

122 * 
GDownFeName
 ( 
FTP_FILE_TYPE
 
fTy
,

123 *
pchFeName
 );

126 
bo
 
UpdeCfg
 ( );

128 
bo
 
UpdePrgm
 ( );

130 
	meed
:

132 
ive
:

134 
bo
 
BakDFes
 ( * 
pchSrcPh
,

135 *
pchDPh
 );

136 
	mive
:

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtpProto.cpp

29 
	~<dio.h
>

30 
	~"CSockFPro.h
"

31 
	~"../../she/glob.h
"

40 
	gCSockFPro
::
	$CSockFPro
 ()

43 
	`In
( );

44 
	}
}

54 
	gCSockFPro
::~
	$CSockFPro
 ()

56 
	}
}

68 
CSockFPro
::
	$SFeName
 ( cڡ *
pchFeName
 )

70 if
NULL
 =
pchFeName
 )

72 
	`memt

m_chFeName
, 0, 256 );

76 
	`ry

m_chFeName
, 
pchFeName
 );

80 
	}
}

92 
	gCSockFPro
::
	$SEB
 ( )

94 
m_bySdBuf
[3] |= 0x80;

95 
	}
}

106 
	gCSockFPro
::
	$SReڣB
 ( )

108 
m_bySdBuf
[3] |= 0x40;

109 
	}
}

121 
	gCSockFPro
::
	$SFeB
 ( )

123 
m_bySdBuf
[3] |= 0x20;

124 
	}
}

135 
BOOL
 
	gCSockFPro
::
	$isFeS
 ( ) const

137  ( 
m_bySdBuf
[3] & 0x20 ) > 0;

138 
	}
}

150 
	gCSockFPro
::
	$SDownLdB
 ( )

152 
m_bySdBuf
[3] |= 0x10;

153 
	}
}

165 
BOOL
 
	gCSockFPro
::
	$IsLd
 ( ) const

167  ( 
m_bySdBuf
[3] & 0x10 ) > 0 ;

168 
	}
}

180 
	gCSockFPro
::
	$SFuncCode
 ( 
BYTE
 
byFunc
 )

182 
m_bySdBuf
[3] &= 0xf0;

183 
m_bySdBuf
[3] |
byFunc
 & 0x0f );

184 
	}
}

195 
BYTE
 
	gCSockFPro
::
	$GFuncCode
 ( ) const

197  ( 
m_bySdBuf
[3] & 0x0f );

198 
	}
}

210 
	gCSockFPro
::
	$AddFmeHd
 ( )

212 
m_bySdBuf
[0] = 0x68;

213 
m_bySdBuf
[1] = 
	`HIBYTE

m_wSdL
 );

214 
m_bySdBuf
[2] = 
	`LOBYTE

m_wSdL
 );

215 
m_wSdL
 += 3;

216 
	}
}

228 
BOOL
 
	gCSockFPro
::
	$IsFmeFm
 ( 
BYTE
 *
buf
, 
n
 )

231 i
n
 > 
FTP_MAX_SEND_LEN
 ||en < 4 )

233  
FALSE
;

237 if0x68 !
buf
[0] )

239  
FALSE
;

243 if
	`MAKEWORD

buf
[2], buf[1] ) !
n
 - 3 )

245  
FALSE
;

249 if0 !(
buf
[3] & 0x40) )

251  
FALSE
;

254  
TRUE
;

255 
	}
}

267 
BOOL
 
	gCSockFPro
::
	$ProssSBy
 ( 
BYTE
 
byS
 )

269 if0 !0x80 & 
byS
 ) )

272  
FALSE
;

275 if0 !0x20 & 
byS
 ) )

277 
	`SFeB
( );

280 if0 !0x10 & 
byS
) )

282 
	`SDownLdB
( );

285 
	`SReڣB
( );

287  
TRUE
;

288 
	}
}

299 
BOOL
 
	gCSockFPro
::
	$PLD_BegTns
 ( )

301 cڡ 
BYTE
 
byFuncPos
 = 3;

302 
	`SFuncCode

START_TRANS
 );

303 
m_wSdL
 = 1;

305 
m_bySdBuf
[ 
byFuncPos
 + 
m_wSdL
++ ] = 
	`HIBYTE

	`HIWORD

EMU2000_VERSION
 ) );

306 
m_bySdBuf
[ 
byFuncPos
 + 
m_wSdL
++ ] = 
	`LOBYTE

	`HIWORD

EMU2000_VERSION
 ) );

307 
m_bySdBuf
[ 
byFuncPos
 + 
m_wSdL
++ ] = 
	`HIBYTE

	`LOWORD

EMU2000_VERSION
 ) );

308 
m_bySdBuf
[ 
byFuncPos
 + 
m_wSdL
++ ] = 
	`LOBYTE

	`LOWORD

EMU2000_VERSION
 ) );

310 
	`AddFmeHd
( );

311  
TRUE
;

312 
	}
}

324 
BOOL
 
	gCSockFPro
::
	$PLD_FeLiInfo
 ( )

326 cڡ 
BYTE
 
byFuncPos
 = 3;

327 * 
pchFesLiPh
 = (*)"/mynand/config";

329 
m_FFe
.
	`DeDFes

FTP_FILE_LIST
 );

330 
m_FFe
.
	`WreFeLiFe

pchFesLiPh
, 
FTP_FILE_LIST
 );

331 
m_dwFeSize
 = 
m_FFe
.
	`GFeSize

FTP_FILE_LIST
 );

332 
	`SFeName

FTP_FILE_LIST
 );

333 
m_wFeNum
 = 0;

335 
	`SFuncCode

FILE_LIST_INFO
 );

336 
m_wSdL
 = 1;

337 
m_bySdBuf
[
byFuncPos
+
m_wSdL
++] = ( 
m_dwFeSize
 >>24) & 0xff;

338 
m_bySdBuf
[
byFuncPos
+
m_wSdL
++] = ( 
m_dwFeSize
 >>16) & 0xff;

339 
m_bySdBuf
[
byFuncPos
+
m_wSdL
++] = ( 
m_dwFeSize
 >>8) & 0xff;

340 
m_bySdBuf
[
byFuncPos
+
m_wSdL
++] = ( 
m_dwFeSize
 ) & 0xff;

342 
	`AddFmeHd
( );

344  
TRUE
;

345 
	}
}

356 
BOOL
 
	gCSockFPro
::
	$PLD_Fe
 ( )

358 
m_wSdL
 = 1;

359 
DWORD
 
dwRdL
 = 
m_FFe
.
	`RdFe

m_chFeName
,

360 
m_bySdBuf
+4,

361 
FTP_MAX_SEND_LEN
 - 4,

362 
m_uiRdPos
 );

364 
m_wSdL
 +
dwRdL
;

365 
	`SFeB
( );

366 
	`SFuncCode

NONE_FUNC
 );

368 
	`AddFmeHd
( );

370  
TRUE
;

371 
	}
}

382 
BOOL
 
	gCSockFPro
::
	$PLD_MD5
 ( )

384 
m_uiRdPos
 = 0;

385 
	`SFuncCode

MD5
 );

386 if
NULL
 !
	`GFeMD5

m_chFeName
, 
m_bySdBuf
+ 4) )

388 
m_wSdL
 += 16;

389 
	`AddFmeHd
( );

390  
TRUE
;

393  
FALSE
;

394 
	}
}

406 
BOOL
 
	gCSockFPro
::
	$PLD_FeInfo
 ( )

408 
m_wFeNum
 ++;

409 
m_wSdL
 = 1;

411 
chFeName
[256];

412 if
NULL
 !
m_FFe
.
	`GFeLeBuf

FTP_FILE_LIST
, 
m_wFeNum
, 
chFeName
 ) )

414 if'\n' =
chFeName
[0]

415 || 0 =
chFeName
[0])

417  
FALSE
;

420 
chFeName
[
	`
(chFileName)-1] = 0;

421 
m_dwFeSize
 = 
m_FFe
.
	`GFeSize

chFeName
 );

422 
	`SFeName

chFeName
 );

424 if
m_dwFeSize
 != 0xffffffff )

426 cڡ 
BYTE
 
byFuncPos
 = 3;

427 
m_bySdBuf
[
byFuncPos
+
m_wSdL
++] = ( 
m_dwFeSize
 >>24) & 0xff;

428 
m_bySdBuf
[
byFuncPos
+
m_wSdL
++] = ( 
m_dwFeSize
 >>16) & 0xff;

429 
m_bySdBuf
[
byFuncPos
+
m_wSdL
++] = ( 
m_dwFeSize
 >>8) & 0xff;

430 
m_bySdBuf
[
byFuncPos
+
m_wSdL
++] = ( 
m_dwFeSize
 ) & 0xff;

432 
	`memy

m_bySdBuf
+
m_wSdL
+3, 
chFeName
, 
	`
( chFileName ) );

433 
m_wSdL
 +
	`

chFeName
 );

434 
	`SFuncCode

FILE_INFO
 );

435  
TRUE
;

439 
	`SEB
( );

440  
TRUE
;

444  
FALSE
;

445 
	}
}

456 
BOOL
 
	gCSockFPro
::
	$PLD6
 ( )

459 if
	`PLD_FeInfo
( ) )

464 
m_wSdL
 =1;

465 
	`SFuncCode

END_TRANS
 );

468 
	`AddFmeHd
( );

469  
TRUE
;

470 
	}
}

481 
BOOL
 
	gCSockFPro
::
	$PLD15
 ( )

483 
m_wSdL
 = 1;

485 if
m_uiRdPos
 >
m_dwFeSize
 )

487 
	`PLD_MD5
( );

491 
	`PLD_Fe
( );

495  
TRUE
;

496 
	}
}

507 
BOOL
 
	gCSockFPro
::
	$ProssLdDa
 ( 
BYTE
 *
buf
, 
n
 )

510 
BOOL
 
bR
 = 
TRUE
;

511  
	`GFuncCode
( ) )

513 
START_TRANS
:

514 
	`PLD_FeLiInfo
( );

517 
END_TRANS
:

518 
	`SFuncCode

START_DOWN
 );

519 
m_wSdL
 = 1;

520 
m_FFe
.
	`DeDFes

FTP_FILE_LIST
 );

521 
	`AddFmeHd
( );

524 
FILE_LIST_INFO
:

525 
FILE_INFO
:

526 
bR
 = 
	`PLD_Fe
( );

529 
START_DOWN
:

530 
	`PLD_BegTns
( );

533 
MD5
:

534 
bR
 = 
	`PLD6
( );

537 
RECV_CONFIG
:

538 
bR
 = 
	`PLD15
( );

541 
REBOOT
:

542 
m_wSdL
 = 1;

543 
m_FFe
.
	`DeDFes

FTP_FILE_LIST
 );

544 
	`SFuncCode

REBOOT
 );

545 
	`AddFmeHd
( );

546 
m_bRebo
 = 1;

551 
	`tf
 ( "defalut\n" );

552 
m_wSdL
 = 0;

553 
bR
 = 
FALSE
;

554  
FALSE
;

558  
bR
;

559 
	}
}

571 
BOOL
 
	gCSockFPro
::
	$PDD_dTns
 ( )

573 
m_wSdL
 = 1;

574 
m_FFe
.
	`DeDFes

FTP_FILE_LIST
 );

575 
	`sync
( );

576 
	`syem
( "sync" );

577 if
FTP_PRGM_TYPE
 =
m_FeTy
 )

579 
m_FFe
.
	`UpdePrgm
( );

580 
	`syem
( "reboot" );

583 
	`AddFmeHd
( );

584  
TRUE
;

585 
	}
}

597 
BOOL
 
	gCSockFPro
::
	$PDD_FeLiInfo
 ( )

599 if
m_FFe
.
	`IsFeExi

FTP_FILE_LIST
) )

601 
m_FFe
.
	`DeDFes

FTP_FILE_LIST
 );

604 
m_FeTy
 = 
FTP_NONE_TYPE
;

605 
m_wFeNum
 = 0;

606 
	`SFeName

FTP_FILE_LIST
);

607 
m_wSdL
 = 1;

609 
	`AddFmeHd
( );

610  
TRUE
;

611 
	}
}

622 
BOOL
 
	gCSockFPro
::
	$PDD_FeInfo
 ( )

624 
m_wSdL
 = 1;

625 if
NULL
 =
m_FFe
.
	`GDownFeName

m_FeTy
, 
m_chFeName
 ) )

627 
	`SEB
( ) ;

630 
	`AddFmeHd
( );

631  
TRUE
;

632 
	}
}

643 
BOOL
 
	gCSockFPro
::
	$PDD6
 ( cڡ *
chMd5Buf
 )

645 
m_wSdL
 = 1;

646 if!
	`IsFeMD5Right

m_chFeName
, (*)
chMd5Buf
 ) )

648 
	`SEB
( );

649 
	`AddFmeHd
( );

650  
TRUE
;

653 
chLeBuf
[256];

656 if0 =
	`rcmp

m_chFeName
, 
FTP_FILE_LIST
 )

657 && 
FTP_NONE_TYPE
 =
m_FeTy
)

659 
chTmp
[256] = "";

660 
m_FeTy
 = 
m_FFe
.
	`GDownTy

m_chFeName
 );

661 if
FTP_CFG_TYPE
 =
m_FeTy
 )

663 
	`rtf

chTmp
, "%s%s", 
FTP_DOWN_CFG_FILE
, "config/" );

664 
m_FFe
.
	`DeDFes

chTmp
);

666 if
FTP_PRGM_TYPE
 =
m_FeTy
 )

668 if!
m_FFe
.
	`CheckFeLi
( ) )

670 
	`SEB
( );

671 
	`AddFmeHd
( );

672  
TRUE
;

675 
	`rtf

chTmp
, "%s%s", 
FTP_DOWN_PRGM_FILE
, "bin/" );

676 
m_FFe
.
	`DeDFes

chTmp
);

677 
	`rtf

chTmp
, "%s%s", 
FTP_DOWN_PRGM_FILE
, "lib/" );

678 
m_FFe
.
	`DeDFes

chTmp
);

679 
m_FFe
.
	`DeDFes

FTP_DOWN_USER_FILE
 );

682 
m_wFeNum
++;

685 if
NULL
 !
m_FFe
.
	`GFeLeBuf

FTP_FILE_LIST
, 
m_wFeNum
,
chLeBuf
 ))

687 
m_wFeNum
++;

688 *
p
 = 
	`chr

m_chFeName
, '/' );

690 if
NULL
 =
	`rr

chLeBuf
, 
p
 ) )

692 
	`tf
 ( "error\n" );

693 
	`SEB
( );

698 
	`SEB
( );

701 
	`AddFmeHd
( );

702  
TRUE
;

703 
	}
}

715 
BOOL
 
	gCSockFPro
::
	$ProssDownDa
 ( 
BYTE
 *
buf
, 
n
 )

717 
BOOL
 
bR
 = 
TRUE
;

719 if
	`isFeS
( ) )

722 if0 =
m_FFe
.
	`WreFe

m_chFeName
, 
buf
+1, 
n
-1 ))

727 
	`SFuncCode

RECV_CONFIG
 );

728 
m_wSdL
 = 1;

729 
	`AddFmeHd
( );

734  
	`GFuncCode
( ) )

736 
START_TRANS
:

738 
DWORD
 
dwVsi
 = ( 
buf
[1] << 24 )

739 | ( 
buf
[2]<<16 )

740 | ( 
buf
[3] << 8 )

741 | ( 
buf
[4] );

742 if
	`HIWORD

dwVsi
 ) !HIWORD
EMU2000_VERSION
 ) )

744 
	`SEB
( );

746 
m_wSdL
 = 1;

747 
	`AddFmeHd
( );

750 
END_TRANS
:

751 
	`PDD_dTns
( );

754 
FILE_LIST_INFO
:

755 
	`PDD_FeLiInfo
( );

759 
FILE_INFO
:

760 
	`SFeName
(*)
buf
+5 ) );

761 
	`PDD_FeInfo
( );

764 
MD5
:

765 
	`PDD6
(*)
buf
 + 1 ) );

768 
REBOOT
:

769 
m_wSdL
 = 1;

770 
m_FFe
.
	`DeDFes

FTP_FILE_LIST
 );

771 
	`SFuncCode

REBOOT
 );

772 
	`AddFmeHd
( );

773 
m_bRebo
 = 
TRUE
;

776 
bR
 = 
FALSE
;

782  
bR
;

783 
	}
}

795 
BOOL
 
	gCSockFPro
::
	$ProssProSdBuf
 ( 
BYTE
 *
buf
, 
n
 )

797 
	`memt

m_bySdBuf
, 0, 
FTP_MAX_SEND_LEN
 );

798 
m_wSdL
 = 0;

801 i!
	`IsFmeFm

buf
, 
n
 ) )

803 
	`tf
 ( "ProcessProtoSendBuf::fault format\n" );

804  
FALSE
;

808 if!
	`ProssSBy

buf
[3] & 0xf0 ) )

810 
	`tf
 ( "ProcessProtoSendBuf::fault state\n" );

811  
FALSE
;

814 
	`SFuncCode

buf
[3] & 0x0f );

817 if
	`IsLd
( ) )

820  
	`ProssLdDa

buf
 + 3, 
n
 - 3 ) ;

825  
	`ProssDownDa

buf
 + 3, 
n
 - 3 ) ;

828  
FALSE
;

829 
	}
}

842 
BOOL
 
	gCSockFPro
::
	$In
 ( )

844 
	`memt

m_bySdBuf
, 0, 
FTP_MAX_SEND_LEN
 );

845 
m_wSdL
 = 0;

846 
	`memt

m_chFeName
, 0 , 256 );

847 
m_uiRdPos
 = 0;

848 
m_wFeNum
= 0;

849 
m_FeTy
 = 
FTP_NONE_TYPE
;

850 
m_dwFeSize
 = 0xffffffff;

851 
m_bRebo
 = 
FALSE
;

853  
TRUE
;

854 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtpProto.h

21 #ide 
CSOCKETFTPPROTO_INC


22 
	#CSOCKETFTPPROTO_INC


	)

24 
	~"../../she/tydef.h
"

25 
	~"CSockFFe.h
"

26 
	~"../../she/md5.h
"

28 
	#FTP_MAX_SEND_LEN
 1028

	)

36 as
	cCSockFPro


38 
	mpublic
:

40 
CSockFPro
 ();

41 ~
CSockFPro
 ();

43 
	mpublic
:

45 
BOOL
 
ProssProSdBuf
 ( 
BYTE
 *
buf
, 
n
 );

47 
BOOL
 
In
 ( );

50 
	meed
:

53 
ive
:

56 
SFeName
 ( cڡ *
pchFeName
 );

59 
SEB
 ( );

61 
SReڣB
 ( );

63 
SFeB
 ( );

65 
BOOL
 
	$isFeS
 ( ) const;

67 
	`SDownLdB
 ( );

69 
BOOL
 
	$IsLd
 ( ) const;

71 
	`SFuncCode
 ( 
BYTE
 
byFunc
 );

73 
BYTE
 
	$GFuncCode
 ( ) const;

75 
	`AddFmeHd
 ( );

78 
BOOL
 
	`IsFmeFm
 ( 
BYTE
 *
buf
, 
n
 );

80 
BOOL
 
	`ProssSBy
 ( 
BYTE
 
byS
 );

82 
BOOL
 
	`ProssLdDa
 ( 
BYTE
 *
buf
, 
n
 );

84 
BOOL
 
	`ProssDownDa
 ( 
BYTE
 *
buf
, 
n
 );

86 
BOOL
 
	`PLD_BegTns
 ( );

88 
BOOL
 
	`PLD_FeLiInfo
 ( );

90 
BOOL
 
	`PLD_FeInfo
 ( );

92 
BOOL
 
	`PLD_Fe
 ( );

94 
BOOL
 
	`PLD_MD5
 ( );

96 
BOOL
 
	`PLD15
 ( );

98 
BOOL
 
	`PLD6
 ( );

100 
BOOL
 
	`PDD_dTns
 ( );

102 
BOOL
 
	`PDD_FeLiInfo
 ( );

104 
BOOL
 
	`PDD_FeInfo
 ( );

106 
BOOL
 
	`PDD6
 ( cڡ *
chMd5Buf
 );

111 
public
:

113 
BYTE
 
m_bySdBuf
[ 
FTP_MAX_SEND_LEN
 ];

114 
WORD
 
m_wSdL
;

115 
CSockFFe
 
m_FFe
;

116 
BOOL
 
m_bRebo
;

118 
ive
:

120 
m_chFeName
[256];

121 
DWORD
 
m_dwFeSize
;

123 
FTP_FILE_TYPE
 
m_FeTy
;

124 
UINT
 
m_uiRdPos
;

125 
WORD
 
m_wFeNum
;

127 
	em_eFuncCode


129 
NONE_FUNC
 = 0,

130 
START_TRANS
 = 1,

131 
END_TRANS
 = 2,

132 
FILE_LIST_INFO
 = 3,

133 
FILE_INFO
 = 4,

134 
START_DOWN
 = 5,

135 
MD5
 = 6,

136 
REBOOT
 = 7,

137 
RECV_CONFIG
 = 15

141 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/GroupBroad.c

25 
	~<had.h
>

26 
	~<sys/tys.h
>

27 
	~<sys/sock.h
>

28 
	~<t/.h
>

29 
	~</.h
>

30 
	~<dio.h
>

31 
	~<rg.h
>

32 
	~<unid.h
>

35 
	#MCAST_PORT
 65529

	)

36 
	#MCAST_ADDR
 "224.0.0.100"

	)

37 
	#BUFF_SIZE
 1024

	)

40 
	grcv_fd
 = -1;

41 
	gsd_fd
 = -1;

42 
sockaddr_
 
	gr_addr
;

43 
sockaddr_
 
	glol_addr
;

46 
	#LOCAL_DATA_MAXLEN
 1024

	)

48 
	$GroupBrdRecv
(* 
pBuf
,* 
pL
)

50 
n
 = (
lol_addr
);

51 if(
rcv_fd
<=0)

55 *
pL
 = 
	`cvom
 (
rcv_fd
,

56 
pBuf
,

57 
LOCAL_DATA_MAXLEN
,

59 (
sockaddr
 *&
lol_addr
,

60 (
sockn_t
 *)&
n
);

62 i(* 
pL
 < 0 )

64 
	`
 ("recvfrom");

74 
	}
}

77 
	$GroupBrdSdEn
(* 
pBuf
,
L
)

80 if(
sd_fd
<=0)

84 if(
L
>
LOCAL_DATA_MAXLEN
)

86 
L
=
LOCAL_DATA_MAXLEN
;

91 i(
	`ndto
 (
sd_fd
, 
pBuf
, 
L
, 0, (
sockaddr
 *)&
r_addr
,  (r_addr)) < 0 )

100 
	}
}

102 
	gMuxIned
 = 0;

103 
had_mux_t
 
	gmux
;

105 
	$GroupBrdSd
(* 
pBuf
,
L
)

107 if(
MuxIned
 == 0)

109 
	`had_mux_
 (&
mux
, 
NULL
);

110 
MuxIned
=1;

112 
	`had_mux_lock
(&
mux
);

113 
	`GroupBrdSdEn
(
pBuf
, 
L
);

114 
	`had_mux_uock
(&
mux
);

116 
	}
}

118 
	$GroupBrdSdIn
()

122 
sd_fd
 = 
	`sock
(
AF_INET
, 
SOCK_DGRAM
, 0);

123 i(
sd_fd
== -1)

125 
	`
("socket()");

129 
	`memt
(&
r_addr
, 0, (r_addr));

130 
r_addr
.
s_my
 = 
AF_INET
;

131 
r_addr
.
s_addr
.
s_addr
 = 
	`_addr
(
MCAST_ADDR
);

132 
r_addr
.
s_pt
 = 
	`hts
(
MCAST_PORT
);

135 
nV
 = 1;

136 
r
 = 
	`tsockt
(
sd_fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, (*)&
nV
, (nVal));

137 if(
r
 < 0)

139 
	`
("setsockopt():SO_REUSEADDR");

143 
	}
}

146 
	$GroupBrdRecvIn
()

149 
r
 = -1;

150 
rcv_fd
 = 
	`sock
(
AF_INET
, 
SOCK_DGRAM
, 0);

151 i(
sd_fd
 == -1)

153 
	`
("socket()");

158 
nV
 = 1;

159 
r
 = 
	`tsockt
(
rcv_fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, (*)&
nV
, (nVal));

160 if(
r
 < 0)

162 
	`
("setsockopt():SO_REUSEADDR");

166 
	`memt
(&
lol_addr
, 0, (local_addr));

167 
lol_addr
.
s_my
 = 
AF_INET
;

168 
lol_addr
.
s_addr
.
s_addr
 = 
	`htl
(
INADDR_ANY
);

169 
lol_addr
.
s_pt
 = 
	`hts
(
MCAST_PORT
);

172 
lo
 = 0;

173 
r
 = 
	`tsockt
(
rcv_fd
,
IPPROTO_IP
, 
IP_MULTICAST_LOOP
,&
lo
, (loop));

174 if(
r
 < 0)

176 
	`
("setsockopt():IP_MULTICAST_LOOP");

180 
_mq
 
mq
;

181 
mq
.
imr_muɟddr
.
s_addr
 = 
	`_addr
(
MCAST_ADDR
);

182 
mq
.
imr_r
.
s_addr
 = 
	`htl
(
INADDR_ANY
);

184 
r
 = 
	`tsockt
(
rcv_fd
, 
IPPROTO_IP
, 
IP_ADD_MEMBERSHIP
,&
mq
, 

185 (
mq
));

186 i(
r
 < 0)

188 
	`
("setsockopt():IP_ADD_MEMBERSHIP");

193 
r
 = 
	`bd
(
rcv_fd
,(
sockaddr
*)&
lol_addr
, (local_addr)) ;

194 if(
r
 < 0)

196 
	`
("bind()");

204 
	}
}

206 
	$GroupBrdIn
()

208 if
rcv_fd
 >= 0 )

210 
	`shutdown

rcv_fd
, 2 );

211 
	`o

rcv_fd
 );

212 
rcv_fd
 = -1;

214 if
sd_fd
 >= 0 )

216 
	`shutdown

sd_fd
, 2 );

217 
	`o

sd_fd
 );

218 
sd_fd
 = -1;

221 
	`GroupBrdSdIn
();

222 
	`GroupBrdRecvIn
();

224 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/GroupBroad.h

1 #ide
GroupBrd_H


2 
	#GroupBrd_H


	)

4 #ifdef 
__lulus


7 
GroupBrdIn
();

8 
GroupBrdSd
(* 
pBuf
,
L
);

9 
GroupBrdRecv
(* 
pBuf
,* 
pL
);

12 #ifdef 
__lulus


	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/Protocol_UPS.cpp

5 
	~"Proc_UPS.h
"

6 
	~"ups.h
"

12 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

14 
	gCProc_UPS
::
	$CProc_UPS
()

16 
	`memt

m_sTemePh
 , 0 , ( m_sTemplatePath ) ) ;

17 
	}
}

19 
	gCProc_UPS
::~
	$CProc_UPS
()

21 
size
 = 
m_modu
.
	`size
() ;

22  
i
 = 0 ; i < 
size
 ; i++ )

24 
de
 
m_modu
[ 
i
 ] ;

26 
m_modu
.
	`r
() ;

27 
	`tf
( "Delete All CProtocol_UPS OK . \n" );

28 
	}
}

32 
BOOL
 
	gCProc_UPS
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

34  
TRUE
;

35 
	}
}

37 
BOOL
 
	gCProc_UPS
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

39  
FALSE
 ;

40 
	}
}

42 
BOOL
 
	gCProc_UPS
::
	$In

BYTE
 
byLeNo
 )

46 
m_byLeNo
 = 
byLeNo
 ;

48 
m_ProTy
 = 
PROTOCO_GATHER
 ;

49  
	`GDevDa
( ) ;

50 
	}
}

52 
BOOL
 
	gCProc_UPS
::
	$GDevDa
( )

54 
	`memt

m_sDevPh
 , 0 , ( m_sDevPath ) ) ;

55 
	`rtf

m_sDevPh
 , "%s/UPS/%s%02d.i" , 
SYSDATAPATH
 , 
DEVNAME
 , 
m_byLeNo
 + 1 );

56 
CProfe
 
	`ofe

m_sDevPh
 ) ;

57  
	`ProssFeDa

ofe
 ) ;

58 
	}
}

60 
BOOL
 
	gCProc_UPS
::
	$ProssFeDa

CProfe
 &
ofe
 )

62 
BOOL
 
bR
 = 
FALSE
;

63 if!
ofe
.
	`IsVid
() )

65 
	`tf
"Of%Faed ! \" , 
ofe
.
m_szFeName
 );

66  
FALSE
 ;

69 
sSe
[ 200 ] = "DEVNUM" ;

70 
sKey
[ 20 ][ 100 ]={ "module" , "serialno" , "addr" , "name" , "template" } ;

72 
WORD
 
wModu
 = 0 ;

73 
ro
=1 ;

74 
WORD
 
addr
 =3 ;

75 
sName
[ 50 ] = { 0 };

76 
eme
[ 200 ] = { 0 };

77 
iNum
 = 0 ;

79 
iNum
 = 
ofe
.
	`GProfeI

sSe
 , (*)"NUM" , 0 ) ;

80 if
iNum
 == 0 )

82 
	`tf
( "Get DEVNUM Failed ! \n " );

83  
FALSE
 ;

86  
i
 = 0 ; i < 
iNum
 ; i++ )

88 
	`rtf

sSe
 , "%s%03d" , "DEV" , 
i
 + 1 );

90 
wModu
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 0 ] , 0 ) ;

91 
ro
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 1 ] , 0 ) ;

92 
addr
 = 
ofe
.
	`GProfeI

sSe
 , 
sKey
[ 2 ] , 0 ) ;

93 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 3 ] , (*)"NULL" , 
sName
 , ( sName ) ) ;

94 
ofe
.
	`GProfeSg

sSe
 , 
sKey
[ 4 ] , (*)"NULL" , 
eme
 , ( stemplate ) ) ;

97 
bR
 = 
	`CeModu

wModu
 , 
ro
 , 
addr
 , 
sName
 , 
eme
 ) ;

98 i!
bR
 )

100 
	`tf
 ( "Create UPS Module=%d serialno=%dddr=%d sName=%s stemplate=%s \

101 
E
 \
n
", wModule, serialno,ddr, sName, stemplate );

102  
FALSE
;

105  
TRUE
 ;

106 
	}
}

108 
BOOL
 
	gCProc_UPS
::
	$CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 )

110 
CProc_UPS
 * 
pProc
 = 
NULL
 ;

112 
pProc
 = 
w
 
CUPS
;

113 
pProc
->
m_byLeNo
 = m_byLineNo ;

114 
pProc
->
m_wModuTy
 = 
iModu
 ;

115 
pProc
->
m_wDevAddr
 = 
iAddr
 ;

116 
pProc
->
m_SlNo
 = 
iSlNo
 ;

118 
	`ry

pProc
->
m_sTemePh
 , 
ePh
 ) ;

119 
m_pMhod
->
m_pRtuObj
 = 
pProc
;

120 
pProc
->
m_pMhod
 = m_pMethod ;

121 
pProc
->
m_ProTy
 = 
PROTOCO_GATHER
 ;

124 if!
pProc
->
	`In

m_byLeNo
 ) )

125  
FALSE
 ;

126 
	`tf
" Add bu%d Add%d s%d\n" , 
m_byLeNo
 , 
iAddr
, 
iSlNo
 ) ;

129 
m_modu
.
	`push_back

pProc
 ) ;

131  
TRUE
 ;

132 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/Protocol_UPS.h

5 #i!
defed
(
AFX_PROTOCOL_UPS_H__DB4E4A83_510B_4232_A294_B1B4EE1AF4FD__INCLUDED_
)

6 
	#AFX_PROTOCOL_UPS_H__DB4E4A83_510B_4232_A294_B1B4EE1AF4FD__INCLUDED_


	)

9 
	~"../../she/CProc.h
"

10 
	~"../../she/CMhod.h
"

12 as
	cCProc_UPS
 : 
public
 
CProc


14 
public
:

15 
CProc_UPS
();

16 
	mvtu
 ~
CProc_UPS
();

18 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

19 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

21 
BOOL
 
UPSQuySPack

BYTE
 * 
buf
 , &
n
 );

23 
BOOL
 
UPSQuySDl

BYTE
 * 
buf
 , 
n
 );

25 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

27 
	meed
:

28 
BOOL
 
GDevDa
( ) ;

29 
	meed
:

30 
BOOL
 
ProssFeDa

CProfe
 &
ofe
 );

31 
BOOL
 
CeModu

iModu
 , 
iSlNo
 , 
WORD
 
iAddr
 , * 
sName
 , * 
ePh
 ) ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/main.cpp

2 
	~<dio.h
>

3 
	~"Proc_UPS.h
"

7 
CProc
 * 
CeProc

CMhod
 * 
pMhod
 ) ;

12 
CProc
 * 
	$CeProc

CMhod
 * 
pMhod
 )

14 
CProc
 * 
pProc
 = 
NULL
 ;

15 
pProc
 = 
w
 
CProc_UPS
 ;

16 if
pProc
 )

18 
pProc
->
m_pMhod
 = 
pMhod
 ;

19 
	`tf
( "UPS DLL OK.\n " ) ;

22  
pProc
 ;

23 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/ups.cpp

1 
	~"ups.h
"

2 "C" 
OutBusDebug
(
BYTE
 
byBusNo
, BYTE *
buf
, 
n
, 
ag
);

3 
	gCUPS
::
	$CUPS
()

5 
SdFg
 = 0;

6 
m_bySdCou
 = 0;

7 
m_bLkStus
 = 
FALSE
;

8 
	}
}

10 
	gCUPS
::~
	$CUPS
()

13 
	}
}

15 
BOOL
 
CUPS
::
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

25 
SdFg
)

28 
	`UPSQuySPack

buf
 , 
n
 );

29 
SdFg
 = 1;

32 
	`UPSQuyClSPack

buf
 , 
n
 );

33 
SdFg
 = 2;

36 
	`UPSQuyG2SPack

buf
 , 
n
 );

37 
SdFg
 = 3;

40 
	`UPSQuyG3SPack

buf
 , 
n
 );

41 
SdFg
 = 0;

44 
SdFg
 = 0;

48 
m_bySdCou
++;

50  
TRUE
;

51 
	}
}

53 
BOOL
 
	gCUPS
::
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 )

55 
SdFg
)

58 
	`UPSQuyG3SDl

buf
 , 
n
 );

61 
	`UPSQuySDl

buf
 , 
n
 );

64 
	`UPSQuyClSDl

buf
 , 
n
 );

67 
	`UPSQuyG2SDl

buf
 , 
n
 );

70 
SdFg
 = 0;

73 
m_bySdCou
 = 0;

74 
m_bLkStus
 = 
TRUE
;

75  
TRUE
 ;

76 
	}
}

78 
BOOL
 
	gCUPS
::
	$In

BYTE
 
byLeNo
 )

80  
TRUE
 ;

81 
	}
}

85 
BOOL
 
	gCUPS
::
	$GYKBufr

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 )

87 
YK_DATA
 *
yk_da
;

88 
yk_da
 = (
YK_DATA
 *)
pBusMsg
->
pDa
;

91 if
pBusMsg
->
dwDaTy
 =
YK_SEL
 ||BusMsg->dwDaTy =
YK_CANCEL
 )

93 if
yk_da
->
wP
 < 8 )

95 if
pBusMsg
->
dwDaTy
 =
YK_SEL
 )

97 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
 , 
yk_da
->
wP
 , yk_da->
byV
 );

101 
m_pMhod
->
	`SYkClR

this
 , 
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
 , 
yk_da
->
wP
 , yk_da->
byV
 );

103  
TRUE
 ;

105 
yk_da
->
byV
 = 
YK_ERROR
;

106 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
 , 
yk_da
->
wP
 , yk_da->
byV
 );

107  
TRUE
 ;

109 if
pBusMsg
->
dwDaTy
 =
YK_EXCT
 )

112 if
yk_da
->
wP
 < 8 )

114 if
yk_da
->
byV
 == 1 )

116  
yk_da
->
wP
 )

119 
	`UPSTeTSecdPack

buf
 , 
n
 ) ;

122 
	`UPSTeundvޏgePack

buf
 , 
n
 ) ;

125 
	`UPSTeSomeMusPack

buf
 , 
n
 ) ;

128 
	`UPSCڌBuzzPack

buf
 , 
n
 ) ;

131 
	`UPSPowOffPack

buf
 , 
n
 ) ;

134 
	`UPSPowOffPowOnPack

buf
 , 
n
 ) ;

137 
	`UPSClPowOffPack

buf
 , 
n
 ) ;

140 
	`UPSClTePack

buf
 , 
n
 ) ;

143 
yk_da
->
byV
 = 
YK_ERROR
;

144 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
 , 
yk_da
->
wP
 , yk_da->
byV
 );

145  
TRUE
 ;

149 
m_pMhod
->
	`SYkExeR
 ( 
this
 , 
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
 , 
yk_da
->
wP
 , yk_da->
byV
 );

150  
TRUE
 ;

152 
yk_da
->
byV
 = 
YK_ERROR
;

153 
m_pMhod
->
	`SYkSR
 ( 
this
 , 
pBusMsg
->
SrcInfo
.
byBusNo
,BusMsg->SrcInfo.
wDevNo
 , 
yk_da
->
wP
 , yk_da->
byV
 );

154  
TRUE
 ;

157  
TRUE
 ;

158 
	}
}

160 
BOOL
 
	gCUPS
::
	$UPSQuySPack

BYTE
 * 
buf
 , &
n
 )

162 
dex
 = 0;

164 
buf
[
dex
++] = 'Q';

165 
buf
[
dex
++] = '1';

166 
buf
[
dex
++] = 13;

167 
n
 = 
dex
;

168  
TRUE
;

169 
	}
}

171 
BOOL
 
	gCUPS
::
	$UPSQuyClSPack

BYTE
 * 
buf
 , &
n
 )

173 
dex
 = 0;

175 
buf
[
dex
++] = 'G';

176 
buf
[
dex
++] = '1';

177 
buf
[
dex
++] = 13;

178 
n
 = 
dex
;

179  
TRUE
;

180 
	}
}

182 
BOOL
 
	gCUPS
::
	$UPSQuyG2SPack

BYTE
 * 
buf
 , &
n
 )

184 
dex
 = 0;

186 
buf
[
dex
++] = 'G';

187 
buf
[
dex
++] = '2';

188 
buf
[
dex
++] = 13;

189 
n
 = 
dex
;

190  
TRUE
;

191 
	}
}

193 
BOOL
 
	gCUPS
::
	$UPSQuyG3SPack

BYTE
 * 
buf
 , &
n
 )

195 
dex
 = 0;

197 
buf
[
dex
++] = 'G';

198 
buf
[
dex
++] = '3';

199 
buf
[
dex
++] = 13;

200 
n
 = 
dex
;

201  
TRUE
;

202 
	}
}

204 
BOOL
 
	gCUPS
::
	$UPSTeTSecdPack

BYTE
 * 
buf
 , &
n
 )

206 
dex
 = 0;

208 
buf
[
dex
++] = 'T';

209 
buf
[
dex
++] = 13;

210 
n
 = 
dex
;

211  
TRUE
;

212 
	}
}

213 
BOOL
 
	gCUPS
::
	$UPSTeundvޏgePack

BYTE
 * 
buf
 , &
n
 )

215 
dex
 = 0;

217 
buf
[
dex
++] = 'T';

218 
buf
[
dex
++] = 'L';

219 
buf
[
dex
++] = 13;

220 
n
 = 
dex
;

221  
TRUE
;

222 
	}
}

223 
BOOL
 
	gCUPS
::
	$UPSTeSomeMusPack

BYTE
 * 
buf
 , &
n
 )

225 
dex
 = 0;

227 
buf
[
dex
++] = 'T';

228 
buf
[
dex
++] = '0';

229 
buf
[
dex
++] = '1';

230 
buf
[
dex
++] = 13;

231 
n
 = 
dex
;

232  
TRUE
;

233 
	}
}

234 
BOOL
 
	gCUPS
::
	$UPSCڌBuzzPack

BYTE
 * 
buf
 , &
n
 )

236 
dex
 = 0;

238 
buf
[
dex
++] = 'Q';

239 
buf
[
dex
++] = 13;

240 
n
 = 
dex
;

241  
TRUE
;

242 
	}
}

243 
BOOL
 
	gCUPS
::
	$UPSPowOffPack

BYTE
 * 
buf
 , &
n
 )

245 
dex
 = 0;

247 
buf
[
dex
++] = 'S';

248 
buf
[
dex
++] = '0';

249 
buf
[
dex
++] = '1';

250 
buf
[
dex
++] = 13;

251 
n
 = 
dex
;

252  
TRUE
;

253 
	}
}

254 
BOOL
 
	gCUPS
::
	$UPSPowOffPowOnPack

BYTE
 * 
buf
 , &
n
 )

256 
dex
 = 0;

258 
buf
[
dex
++] = 'S';

259 
buf
[
dex
++] = '0';

260 
buf
[
dex
++] = '1';

261 
buf
[
dex
++] = 'R';

262 
buf
[
dex
++] = '0';

263 
buf
[
dex
++] = '0';

264 
buf
[
dex
++] = '1';

265 
buf
[
dex
++] = '1';

266 
buf
[
dex
++] = 13;

267 
n
 = 
dex
;

268  
TRUE
;

269 
	}
}

270 
BOOL
 
	gCUPS
::
	$UPSClPowOffPack

BYTE
 * 
buf
 , &
n
 )

272 
dex
 = 0;

274 
buf
[
dex
++] = 'C';

275 
buf
[
dex
++] = 13;

276 
n
 = 
dex
;

277  
TRUE
;

278 
	}
}

279 
BOOL
 
	gCUPS
::
	$UPSClTePack

BYTE
 * 
buf
 , &
n
 )

281 
dex
 = 0;

283 
buf
[
dex
++] = 'C';

284 
buf
[
dex
++] = 'T';

285 
buf
[
dex
++] = 13;

286 
n
 = 
dex
;

287  
TRUE
;

288 
	}
}

290 
BOOL
 
	gCUPS
::
	$UPSQuySDl

BYTE
 * 
buf
 , 
n
 )

292 
i
 = 0 ;

293 
BYTE
 
EFg
 = 
UPSMSGFALSE
;

294  
n
 >= 47 )

296  
i
=0 ; i<47; i++ )

298 if
i
 == 0 )

300 if
buf
[
i
] != '(' )

303 if
i
 == 4 || i == 10 || i == 16

304 || 
i
 == 25 || i == 35 )

306 if
buf
[
i
] != '.' )

309 if
i
 == 6 || i == 12 || i == 18

310 || 
i
 == 22 || i == 27 || i == 32 || i == 37 )

312 if
buf
[
i
] != ' ' )

315 if
i
 == 46 )

317 if
buf
[
i
] != 13 )

321 
EFg
 = 
UPSMSGTRUE
;

325 if
i
 < 37 && i != 29 && i != 30 )

327 if!
buf
[
i
] >= '0' && buf[i] <= '9' ) )

330 if
i
 > 37 )

332 if
buf
[
i
] != '0' && buf[i] != '1' )

337 if
EFg
 =
UPSMSGTRUE
 )

341 
buf
 = buf + 1;

342 
n
--;

346 if
EFg
 =
UPSMSGFALSE
 )

348 
	`tf
("Q1rror\n");

349  
FALSE
;

355 
YcV
[7];

356 
BYTE
 
YcNo
 = 0;

357 
BYTE
 
YxNo
 = 0;

358 
	`memt

YcV
, 0, 7);

359 
YcV
[0] = 
	`of
((cڡ *)
buf
+1);

360 
YcV
[1] = 
	`of
((cڡ *)
buf
+7);

361 
YcV
[2] = 
	`of
((cڡ *)
buf
+13);

362 
YcV
[3] = 
	`of
((cڡ *)
buf
+19);

363 
YcV
[4] = 
	`of
((cڡ *)
buf
+23);

364 
YcV
[5] = 
	`of
((cڡ *)
buf
+28);

365 
YcV
[6] = 
	`of
((cڡ *)
buf
+33);

367  
YcNo
=0; YcNo<7; YcNo++ )

369 
m_pMhod
->
	`SYcDa

m_SlNo
 , 
YcNo
 , 
YcV
[YcNo] );

374  
YxNo
=0; YxNo<8; YxNo++ )

376 
BYTE
 
YxV
 = 
buf
[38+
YxNo
]-48;

377 
m_pMhod
->
	`SYxDa

m_SlNo
 , 
YxNo
 , 
YxV
 );

383  
TRUE
;

384 
	}
}

386 
BOOL
 
	gCUPS
::
	$UPSQuyClSDl

BYTE
 * 
buf
 , 
n
 )

388 
i
 = 0 ;

389 
BYTE
 
EFg
 = 
UPSMSGFALSE
;

390  
n
 >= 41 )

392  
i
=0 ; i<41; i++ )

394 if
i
 == 0 )

396 if
buf
[
i
] != '!' )

399 if
i
 == 17 || i == 23

400 || 
i
 == 28 || i == 33 || i == 38 )

402 if
buf
[
i
] != '.' )

405 if
i
 == 4 || i == 8 || i == 13

406 || 
i
 == 19 || i == 25 || i == 30 || i == 35 )

408 if
buf
[
i
] != ' ' )

411 if
i
 == 20 )

413 if
buf
[
i
] != '+' && buf[i] != '-' )

416 if
i
 == 40 )

418 if
buf
[
i
] != 13 )

422 
EFg
 = 
UPSMSGTRUE
;

426 if
i
 == 5 )

428 if
buf
[
i
] != '0' && buf[i] != '1' )

431 if
i
 < 40 )

433 if!
buf
[
i
] >= '0' && buf[i] <= '9' ) )

437 if
EFg
 =
UPSMSGTRUE
 )

441 
buf
 = buf + 1;

442 
n
--;

446 if
EFg
 =
UPSMSGFALSE
 )

448 
	`tf
("G1rror\n");

449  
FALSE
;

455 
YcV
[8];

456 
BYTE
 
YcNo
 = 0;

457 
	`memt

YcV
, 0, 8);

458 
YcV
[0] = 
	`of
((cڡ *)
buf
+1);

459 
YcV
[1] = 
	`of
((cڡ *)
buf
+5);

460 
YcV
[2] = 
	`of
((cڡ *)
buf
+9);

461 
YcV
[3] = 
	`of
((cڡ *)
buf
+14);

462 
YcV
[4] = 
	`of
((cڡ *)
buf
+20);

463 
YcV
[5] = 
	`of
((cڡ *)
buf
+26);

464 
YcV
[6] = 
	`of
((cڡ *)
buf
+31);

465 
YcV
[7] = 
	`of
((cڡ *)
buf
+36);

467  
YcNo
=0; YcNo<8; YcNo++ )

469 
m_pMhod
->
	`SYcDa

m_SlNo
 , 
YcNo
+7 , 
YcV
[YcNo] );

474  
TRUE
;

475 
	}
}

477 
BOOL
 
	gCUPS
::
	$UPSQuyG2SDl

BYTE
 * 
buf
 , 
n
 )

479 
i
 = 0 ;

480 
BYTE
 
EFg
 = 
UPSMSGFALSE
;

481  
n
 >= 28 )

483  
i
=0 ; i<28; i++ )

485 if
i
 == 0 )

487 if
buf
[
i
] != '!' )

490 if
i
 == 9 || i == 18 )

492 if
buf
[
i
] != ' ' )

495 if
i
 == 27 )

497 if
buf
[
i
] != 13 )

501 
EFg
 = 
UPSMSGTRUE
;

505 if
i
 < 28 )

507 if
buf
[
i
] != '0' && buf[i] != '1' )

511 if
EFg
 =
UPSMSGTRUE
 )

515 
buf
 = buf + 1;

516 
n
--;

520 if
EFg
 =
UPSMSGFALSE
 )

522 
	`tf
("G2rror\n");

523  
FALSE
;

530 
BYTE
 
YxNo
 = 0;

531  
YxNo
=0; YxNo<8; YxNo++ )

533 
BYTE
 
YxV
 = 
buf
[1+
YxNo
]-48;

534 
m_pMhod
->
	`SYxDa

m_SlNo
 , 
YxNo
+8 , 
YxV
 );

539  
YxNo
=8; YxNo<16; YxNo++ )

541 
BYTE
 
YxV
 = 
buf
[2+
YxNo
]-48;

542 
m_pMhod
->
	`SYxDa

m_SlNo
 , 
YxNo
+8 , 
YxV
 );

547  
YxNo
=16; YxNo<24; YxNo++ )

549 
BYTE
 
YxV
 = 
buf
[3+
YxNo
]-48;

550 
m_pMhod
->
	`SYxDa

m_SlNo
 , 
YxNo
+8 , 
YxV
 );

556  
TRUE
;

557 
	}
}

559 
BOOL
 
	gCUPS
::
	$UPSQuyG3SDl

BYTE
 * 
buf
 , 
n
 )

561 
i
 = 0 ;

562 
BYTE
 
EFg
 = 
UPSMSGFALSE
;

563  
n
 >= 73 )

565  
i
=0 ; i<73; i++ )

567 if
i
 == 0 )

569 if
buf
[
i
] != '!' )

572 if
i
 == 4 || i == 10 || i == 16 || i == 22 || i == 28 || i == 34

573 || 
i
 == 40 || i == 46 || i == 52 || i == 58 || i == 64 || i == 70)

575 if
buf
[
i
] != '.' )

578 if
i
 == 18 || i == 36 || i == 54 )

580 if
buf
[
i
] != ' ' )

583 if
i
 == 6 || i == 12 || i == 24 || i == 30 || i == 42

584 || 
i
 == 48 || i == 60 || i == 66 )

586 if
buf
[
i
] != '/' )

589 if
i
 == 72 )

591 if
buf
[
i
] != 13 )

595 
EFg
 = 
UPSMSGTRUE
;

599 if
i
 < 73 )

601 if!
buf
[
i
] >= '0' && buf[i] <= '9' ) )

605 if
EFg
 =
UPSMSGTRUE
 )

609 
buf
 = buf + 1;

610 
n
--;

614 if
EFg
 =
UPSMSGFALSE
 )

616 
	`tf
("G3rror\n");

617  
FALSE
;

619 
YcV
[12];

620 
BYTE
 
YcNo
 = 0;

621 
	`memt

YcV
, 0, 8);

622 
YcV
[0] = 
	`of
((cڡ *)
buf
+1);

623 
YcV
[1] = 
	`of
((cڡ *)
buf
+7);

624 
YcV
[2] = 
	`of
((cڡ *)
buf
+13);

625 
YcV
[3] = 
	`of
((cڡ *)
buf
+19);

626 
YcV
[4] = 
	`of
((cڡ *)
buf
+25);

627 
YcV
[5] = 
	`of
((cڡ *)
buf
+31);

628 
YcV
[6] = 
	`of
((cڡ *)
buf
+37);

629 
YcV
[7] = 
	`of
((cڡ *)
buf
+43);

630 
YcV
[8] = 
	`of
((cڡ *)
buf
+49);

631 
YcV
[9] = 
	`of
((cڡ *)
buf
+55);

632 
YcV
[10] = 
	`of
((cڡ *)
buf
+61);

633 
YcV
[11] = 
	`of
((cڡ *)
buf
+67);

635  
YcNo
=0; YcNo<12; YcNo++ )

637 
m_pMhod
->
	`SYcDa

m_SlNo
 , 
YcNo
+15 , 
YcV
[YcNo] );

643  
TRUE
;

644 
	}
}

645 
	gCUPS
::
	$TimProc
()

647 if
m_bySdCou
 > 3 )

649 
m_bySdCou
 = 0;

650 if
m_bLkStus
 )

652 
m_bLkStus
 = 
FALSE
;

653 
	`OutBusDebug

m_byLeNo
, (
BYTE
 *)"UPS:unlink\n", 30, 2 );

656 
	}
}

658 
BOOL
 
	gCUPS
::
	$GDevCommS
 ( )

660 i
m_bLkStus
 )

662  
COM_DEV_NORMAL
;

666  
COM_DEV_ABNORMAL
;

668 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/ups.h

1 #i!
defed
(
UPS_
)

2 
	#UPS_


	)

4 
	#UPSMSGFALSE
 (1)

	)

5 
	#UPSMSGTRUE
 (0)

	)

8 
	~"Proc_UPS.h
"

10 as
	cCUPS
 : 
public
 
CProc_UPS


12 
public
:

13 
CUPS
();

14 
	mvtu
 ~
CUPS
();

16 
BYTE
 
	mSdFg
;

17 
BOOL
 
	mm_bLkStus
;

18 
BYTE
 
	mm_bySdCou
;

21 
vtu
 
BOOL
 
GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ) ;

22 
vtu
 
BOOL
 
ProssProcBuf

BYTE
 * 
buf
 , 
n
 ) ;

23 
vtu
 
BOOL
 
In

BYTE
 
byLeNo
 ) ;

25 
vtu
 
TimProc
() ;

27 
vtu
 
BOOL
 
GDevCommS
( ) ;

29 
BOOL
 
GYKBufr

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 );

31 
BOOL
 
UPSQuySPack

BYTE
 * 
buf
 , &
n
 );

33 
BOOL
 
UPSQuyClSPack

BYTE
 * 
buf
 , &
n
 );

35 
BOOL
 
UPSQuyG2SPack

BYTE
 * 
buf
 , &
n
 );

37 
BOOL
 
UPSQuyG3SPack

BYTE
 * 
buf
 , &
n
 );

39 
BOOL
 
UPSTeTSecdPack

BYTE
 * 
buf
 , &
n
 );

40 
BOOL
 
UPSTeundvޏgePack

BYTE
 * 
buf
 , &
n
 );

41 
BOOL
 
UPSTeSomeMusPack

BYTE
 * 
buf
 , &
n
 );

42 
BOOL
 
UPSCڌBuzzPack

BYTE
 * 
buf
 , &
n
 );

43 
BOOL
 
UPSPowOffPack

BYTE
 * 
buf
 , &
n
 );

44 
BOOL
 
UPSPowOffPowOnPack

BYTE
 * 
buf
 , &
n
 );

45 
BOOL
 
UPSClPowOffPack

BYTE
 * 
buf
 , &
n
 );

46 
BOOL
 
UPSClTePack

BYTE
 * 
buf
 , &
n
 );

48 
BOOL
 
UPSQuySDl

BYTE
 * 
buf
 , 
n
 );

50 
BOOL
 
UPSQuyClSDl

BYTE
 * 
buf
 , 
n
 );

52 
BOOL
 
UPSQuyG2SDl

BYTE
 * 
buf
 , 
n
 );

54 
BOOL
 
UPSQuyG3SDl

BYTE
 * 
buf
 , 
n
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/cgi/getdata.cpp

1 
	~<dio.h
>

2 
	~<mh.h
>

3 
	~<ve
>

4 
	~<ioam
>

5 
	~"../she/rdbFun.h
"

6 
	~"../libdb/rdbObj.h
"

12 
usg
 
mea
 
	gd
;

14 
	s_CutDa


16 
	mDaTy
[10];

17 
WORD
 
	mwSlNo
;

18 
WORD
 
	mwP
;

19 
	mvue
[15];

20 }
	tCURRENTDATA
;

22 
	gve
<
	gCURRENTDATA
> 
	gv_CutDa
;

24 
CRTDBObj
 *
	gg_pRTDBObj_cgi
;

27 
	$GCutDaFromShe
 ( )

29 
CURRENTDATA
 
tmpDa
;

30 
i
, 
j
;

31 
STNPARAM
 *
pSUn
;

33  
i
=0; i<
g_pRTDBObj_cgi
->
m_wSSum
; i++ )

35 
WORD
 
wNum
 = 0;

36 
pSUn
 = &
g_pRTDBObj_cgi
->
m_pRTDBS
->
RTDBa
.
SUn
[
i
];

37 if
NULL
 =
pSUn
 )

39 
	`tf
 ( "cgi GetCurrentDataFromShare NULL =StnUnit\n" );

44 
wNum
 = 
pSUn
->
wAlogSum
;

45  
j
=0; j<
wNum
; j++)

48 
ANALOGITEM
 *
pIm
 = &
g_pRTDBObj_cgi
->
m_pRTDBS
->
RTDBa
.
AlogTab
[
pSUn
->
dwAlogPos
+
j
];

49 
	`ry
(
tmpDa
.
DaTy
 , "YC");

50 
tmpDa
.
wSlNo
 = 
pSUn
->
wSNum
;

51 
tmpDa
.
wP
 = 
pIm
->
wPID
;

54 if
pIm
->
fRlV
 >9.99999 * 
	`pow
( 10, 9 ) ||Item->fRealVal <= -9.99999 *ow( 10, 8 ))

56 
	`ry
(
tmpDa
.
vue
, "9999999999.999" );

60 
	`rtf

tmpDa
.
vue
, "%.4f", ()
pIm
->
fRlV
 *Im->
fRio
 ) );

63 
tmpDa
.
vue
[15 - 1] = '\0';

64 
v_CutDa
.
	`push_back

tmpDa
 );

68 
wNum
 = 
g_pRTDBObj_cgi
->
m_pRTDBS
->
RTDBa
.
SUn
[
i
].
wDigSum
;

69  
j
=0; j<
wNum
; j++)

71 
DIGITALITEM
 *
pIm
 = &
g_pRTDBObj_cgi
->
m_pRTDBS
->
RTDBa
.
DigTab
[
pSUn
->
dwDigPos
+
j
];

72 
	`ry
(
tmpDa
.
DaTy
 , "YX");

73 
tmpDa
.
wSlNo
 = 
pSUn
->
wSNum
;

74 
tmpDa
.
wP
 = 
pIm
->
wPID
;

75 
	`rtf

tmpDa
.
vue
, "%u", 
pIm
->
wStus
 & 0x03 );

77 
v_CutDa
.
	`push_back

tmpDa
 );

81 
wNum
 = 
g_pRTDBObj_cgi
->
m_pRTDBS
->
RTDBa
.
SUn
[
i
].
wPulSum
;

82  
j
=0; j<
wNum
; j++)

84 
PULSEITEM
 *
pIm
 = &
g_pRTDBObj_cgi
->
m_pRTDBS
->
RTDBa
.
PulTab
[
pSUn
->
dwPulPos
+
j
];

85 
	`ry
(
tmpDa
.
DaTy
 , "YM");

86 
tmpDa
.
wSlNo
 = 
pSUn
->
wSNum
;

87 
tmpDa
.
wP
 = 
pIm
->
wPID
;

88 
tmpCV
 = ( )
pIm
->
dwRawV
 *Im->
fRio
 );

89 if
tmpCV
 >9.99999 * 
	`pow
( 10, 9 ) ||mpCalVal <= -9.99999 *ow( 10, 8 ) )

91 
	`ry
(
tmpDa
.
vue
, "9999999999.999" );

96 
	`rtf

tmpDa
.
vue
, "%.4lf", ( )
pIm
->
dwRawV
 *Im->
fRio
 ));

100 
v_CutDa
.
	`push_back

tmpDa
 );

103  
v_CutDa
.
	`size
( );

104 
	}
}

106 
	$On_SHM_DBa_Cgi
()

108 
szText
[128];

110 if!
g_pRTDBObj_cgi
 )

111 
g_pRTDBObj_cgi
 = 
w
 
	`CRTDBObj
();

112 if!
g_pRTDBObj_cgi
 )  -1;

114 if
g_pRTDBObj_cgi
->
	`OnRTDBObj_Cgi
(
szText
) < 0 )

116 
de
 
g_pRTDBObj_cgi
;

117 
g_pRTDBObj_cgi
 = 
NULL
;

120 
	`tf
("%s\n",
szText
);

121 
	`tf
("-------------- Open RTDB OK ---------------\n");

123 
	}
}

126 
	$ma
(
gc
, **
gv
)

128 
i
 = 0;

129 
g_pRTDBObj_cgi
 = 
NULL
;

130 if
	`On_SHM_DBa_Cgi
() < 0 )

132 
	`tf
("cgi open Dbaserr!!!");

136 
v_CutDa
.
	`r
();

137 
DaNum
 = 
	`GCutDaFromShe
();

139 
	`tf
("Content-type:text/html\n\n");

141  
i
=0; i<
DaNum
 ; i++ )

143 
	`tf
("<tr>");

144 
	`tf
("<td>%d</td><td>%s</td><td>%d</td><td>%s</td>",

145 
v_CutDa
[
i
].
wSlNo
,v_CutDa[i].
DaTy
,

146 
v_CutDa
[
i
].
wP
,v_CutDa[i].
vue
);

147 
	`tf
("</tr>");

151 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/main.cpp

12 
	~"mObj.h
"

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/msgManage.cpp

6 
	~<dio.h
>

7 
	~<dlib.h
>

8 
	~<rg.h
>

9 
	~<unid.h
>

10 
	~<rmios.h
>

11 
	~<f.h
>

12 
	~<dg.h
>

13 
	~<o.h
>

14 
	~<y.h
>

15 
	~<sigl.h
>

16 
	~<sys/iol.h
>

17 
	~<sys/tys.h
>

18 
	~<sys/m.h
>

19 
	~<sys/.h
>

20 
	~<sys/time.h
>

21 
	~<sys/c.h
>

22 
	~<sys/mm.h
>

24 
	~"msgMage.h
"

27 
	gCMsgMage
::
	$CMsgMage
()

29 
m_pMsgAa
 = 
NULL
;

30 
	}
}

32 
	gCMsgMage
::~
	$CMsgMage
()

34 
	`Clo
();

35 
	}
}

37 
	gCMsgMage
::
	$IsOn
()

39 if
m_pMsgAa
 )  1;

41 
	}
}

43 
	gCMsgMage
::
	$On
(*
pAddr
)

45 if
pAddr
 =
NULL
 ) ;

46 
m_pMsgAa
 = (
MSGSTORE
*)
pAddr
;

47 
m_hSemhe
.
	`Ce

MSGBUSSEMKEY
 );

48 if
m_pMsgAa
->
nQuy
 != 0xAA55)

50 
	`In
();

51 
m_pMsgAa
->
nQuy
 = 0xAA55;

53 
	}
}

55 
	gCMsgMage
::
	$Clo
()

57 
m_hSemhe
.
	`Remove
();

58 
m_pMsgAa
 = 
NULL
;

59 
	}
}

61 
	gCMsgMage
::
	$In
()

63 
i
;

64 
MSGLIST
 *
pLi
;

65 
m_hSemhe
.
	`mTake
();

66 
i
=0; i<
MSG_SLOT_SUM
; i++)

68 
m_pMsgAa
->

[
i
].
nStus
 = 0;

69 
m_pMsgAa
->

[
i
].
nProcKey
 = -1;

70 
m_pMsgAa
->

[
i
].
dwMsgCl
 = 0;

71 
m_pMsgAa
->

[
i
].
szProcName
[0] = '\0';

72 
m_pMsgAa
->

[
i
].
nMsgPos
 = -1;

74 
m_pMsgAa
->
nFeNum
 = 
MSG_POOL_SUM
;

75 
m_pMsgAa
->
nFePos
 = 0;

76 
m_pMsgAa
->
nFeTa
 = 
MSG_POOL_SUM
 - 1;

77 
i
=0; i<
MSG_POOL_SUM
; i++)

79 
m_pMsgAa
->
po
[
i
].
nSrcKey
 = -1;

80 
m_pMsgAa
->
po
[
i
].
nAive
 = 0;

81 
m_pMsgAa
->
po
[
i
].
wLev
 = 0;

82 
m_pMsgAa
->
po
[
i
].
wTys
 = 0;

83 
m_pMsgAa
->
po
[
i
].
wMsgL
 = 0;

84 
pLi
 = &
m_pMsgAa
->
ve
[
i
];

85 
pLi
->
lf
 = 
i
;

86 if
i
 < (
MSG_POOL_SUM
 - 1) )

88 
pLi
->
xt
 = 
i
+1;

92 
pLi
->
xt
 = -1;

95 
m_hSemhe
.
	`mGive
();

96 
	}
}

98 
	gCMsgMage
::
	$GBufr
()

100 if
m_pMsgAa
->
nFePos
 < 0 )  -1;

101 
MSGLIST
 *
pLi
 = &
m_pMsgAa
->
ve
[m_pMsgAa->
nFePos
];

102 
m_pMsgAa
->
nFePos
 = 
pLi
->
xt
;

103 if
m_pMsgAa
->
nFePos
 < 0 )

104 
m_pMsgAa
->
nFeTa
 = -1;

105 
m_pMsgAa
->
nFeNum
--;

106 
pLi
->
xt
 = -1;

107  
pLi
->
lf
;

108 
	}
}

110 
	gCMsgMage
::
	$FeBufr

nPos
, 
nCou
 )

112 
MSGLIST
 *
pLi
;

113 if
nPos
 < 0 ) ;

114 if
m_pMsgAa
->
nFePos
 < 0 )

116 
m_pMsgAa
->
nFePos
 = 
nPos
;

117 
pLi
 = &
m_pMsgAa
->
ve
[
nPos
];

118  
pLi
->
xt
 >= 0 )

120 
pLi
 = &
m_pMsgAa
->
ve
[pLi->
xt
];

122 
m_pMsgAa
->
nFeTa
 = 
pLi
->
lf
;

126 
m_pMsgAa
->
ve
[m_pMsgAa->
nFeTa
].
xt
 = 
nPos
;

127 
pLi
 = &
m_pMsgAa
->
ve
[
nPos
];

128  
pLi
->
xt
 >= 0 )

130 
pLi
 = &
m_pMsgAa
->
ve
[pLi->
xt
];

132 
m_pMsgAa
->
nFeTa
 = 
pLi
->
lf
;

134 
m_pMsgAa
->
nFeNum
 +
nCou
;

135 
	}
}

137 
	gCMsgMage
::
	$C˪upSl

nSlNo
 )

139 if
nSlNo
<0 ||SlNo>=
MSG_SLOT_SUM
 ) ;

140 
PROCSLOT
 *
pSl
 = &
m_pMsgAa
->

[
nSlNo
];

141 if
pSl
->
nMsgPos
 >= 0 )

143 
m_hSemhe
.
	`mTake
();

144 
nCou
=1;

145 
MSGLIST
 *
pLi
 = &
m_pMsgAa
->
ve
[
pSl
->
nMsgPos
];

146  
pLi
->
xt
 >= 0 )

148 
nCou
++;

149 
pLi
 = &
m_pMsgAa
->
ve
[pLi->
xt
];

151 
	`FeBufr
(
pSl
->
nMsgPos
, 
nCou
);

152 
m_hSemhe
.
	`mGive
();

154 
	}
}

156 
	gCMsgMage
::
	$LaunchMsg

MSGITEM
* 
pMesge
 )

159 
	}
}

161 
	gCMsgMage
::
	$TimProc
()

163 
i
, 
nPos
, 
k
;

164 if!
m_pMsgAa
 ) ;

165 
m_hSemhe
.
	`mTake
();

166  
i
=0; i<
MSG_SLOT_SUM
; i++ )

168 
PROCSLOT
 *
pSl
 = &
m_pMsgAa
->

[
i
];

169 
nPos
 = 
pSl
->
nMsgPos
;

170  
nPos
 >= 0 )

172 
MSGITEM
 *
pMsg
 = &
m_pMsgAa
->
po
[
nPos
];

173 
MSGLIST
 *
pLi
 = &
m_pMsgAa
->
ve
[
nPos
];

174 
pMsg
->
nAive
--;

175 if
pMsg
->
nAive
 < 0 )

177 
k
 = 
nPos
;

178 if
pSl
->
nMsgPos
 =
nPos
 )

179 
pSl
->
nMsgPos
 = 
pLi
->
xt
;

180 
nPos
 = 
pLi
->
xt
;

181 
pLi
->
xt
 = -1;

182 
	`FeBufr

k
 );

186 
nPos
 = 
pLi
->
xt
;

190 
m_hSemhe
.
	`mGive
();

191 
	}
}

193 
	gCMsgMage
::
	$FdDock
(*
szName
)

195 if!
m_pMsgAa
 )  -1;

196 
i
=0; i<
MSG_SLOT_SUM
; i++)

198 if
m_pMsgAa
->

[
i
].
nProcKey
 <= 0 ) ;

199 if
	`rcmp
(
m_pMsgAa
->

[
i
].
szProcName
, 
szName
) != 0 ) ;

200  
m_pMsgAa
->

[
i
].
nProcKey
;

203 
	}
}

206 
	gCMsgMage
::
	$LogBus
(*
szName
)

208 if!
m_pMsgAa
 )  -1;

209 
i
=0; i<
MSG_SLOT_SUM
; i++)

211 if
m_pMsgAa
->

[
i
].
nProcKey
 > 0 )

213 if
	`rcmp
(
m_pMsgAa
->

[
i
].
szProcName
, 
szName
) != 0 ) ;

214 
	`C˪upSl

i
 );

218 
	`rtf
(
m_pMsgAa
->

[
i
].
szProcName
, 
szName
);

220 
m_pMsgAa
->

[
i
].
nStus
 = 0;

221 
m_pMsgAa
->

[
i
].
nProcKey
 = i+1;

222 
m_pMsgAa
->

[
i
].
dwMsgCl
 = 0;

223 
m_pMsgAa
->

[
i
].
nMsgPos
 = -1;

225  
m_pMsgAa
->

[
i
].
nProcKey
;

228 
	}
}

230 
	gCMsgMage
::
	$Subsibe
(
nProcKey
, 
dwOi
)

232 if!
m_pMsgAa
 )  -1;

233 if
nProcKey
<=0 ||ProcKey>
MSG_SLOT_SUM
 )  -2;

234 
PROCSLOT
 *
pSl
 = &
m_pMsgAa
->

[
nProcKey
-1];

235 if
pSl
->
nProcKey
 <= 0 )  -3;

237 
pSl
->
dwMsgCl
 |
dwOi
;

240 
	}
}

242 
	gCMsgMage
::
	$UnSubsibe
(
nProcKey
, 
dwOi
)

244 if!
m_pMsgAa
 )  -1;

245 if
nProcKey
<=0 ||ProcKey>
MSG_SLOT_SUM
 )  -2;

246 
PROCSLOT
 *
pSl
 = &
m_pMsgAa
->

[
nProcKey
-1];

247 if
pSl
->
nProcKey
 <= 0 )  -3;

248 
pSl
->
dwMsgCl
 &~
dwOi
;

250 
	}
}

252 
	gCMsgMage
::
	$ExBus
(
nProcKey
)

254 if!
m_pMsgAa
 )  -1;

255 if
nProcKey
<=0 ||ProcKey>
MSG_SLOT_SUM
 )  -1;

257 
PROCSLOT
 *
pSl
 = &
m_pMsgAa
->

[
nProcKey
-1];

258 if
pSl
->
nMsgPos
 >= 0 )

260 
m_hSemhe
.
	`mTake
();

261 
nCou
=1;

262 
MSGLIST
 *
pLi
 = &
m_pMsgAa
->
ve
[
pSl
->
nMsgPos
];

263  
pLi
->
xt
 >= 0 )

265 
nCou
++;

266 
pLi
 = &
m_pMsgAa
->
ve
[pLi->
xt
];

268 
	`FeBufr
(
pSl
->
nMsgPos
, 
nCou
);

269 
m_hSemhe
.
	`mGive
();

271 
pSl
->
nStus
 = 0;

272 
pSl
->
nProcKey
 = -1;

273 
pSl
->
dwMsgCl
 = 0;

274 
pSl
->
nMsgPos
 = -1;

275 
pSl
->
szProcName
[0] = '\0';

277 
	}
}

279 
	gCMsgMage
::
	$MesgeSd
(
MSGITEM
 *
pMesge
, *
pD
)

281 
PROCSLOT
 *
pSl
;

282 
MSGITEM
 *
pMsgBuf
;

283 
i
, 
nPos
, 
nCou
=0;

285 if!
m_pMsgAa
 )  -1;

286 if!
pMesge
 ||Mesge->
wMsgL
>
MSG_BODY_LEN
 )  -2;

287 
m_hSemhe
.
	`mTake
();

288  
i
=0; i<
MSG_SLOT_SUM
; i++ )

290 
pSl
 = &
m_pMsgAa
->

[
i
];

291 if
pSl
->
nProcKey
 < 0 ) ;

292 if
pSl
->
nProcKey
 =
pMesge
->
nSrcKey
 ) ;

293 if(
pSl
->
dwMsgCl
 & (1<<
pMesge
->
wTys
)) == 0 ) ;

295 
nPos
 = 
	`GBufr
();

296 if
nPos
 < 0 ) ;

297 
pMsgBuf
 = &
m_pMsgAa
->
po
[
nPos
];

298 
	`memy
(
pMsgBuf
, 
pMesge
, 12+pMesge->
wMsgL
);

299 if
pSl
->
nMsgPos
 < 0 )

301 
pSl
->
nMsgPos
 = 
nPos
;

305 
MSGLIST
 *
pLi
 = &
m_pMsgAa
->
ve
[
pSl
->
nMsgPos
];

306  
pLi
->
xt
 >= 0 )

308 
pLi
 = &
m_pMsgAa
->
ve
[pLi->
xt
];

310 
pLi
->
xt
 = 
nPos
;

312 
pSl
->
nStus
++;

313 
nCou
++;

315 
m_hSemhe
.
	`mGive
();

316  
nCou
;

317 
	}
}

319 
	gCMsgMage
::
	$MesgeRecv
(
nProcKey
, 
MSGITEM
 *
pMesge
, 
nSync
)

321 
MSGLIST
 *
pLi
;

322 
MSGITEM
 *
pBuff
;

323 
nPos
, 
nL
=0;

325 if!
m_pMsgAa
 )  -1;

326 if!
pMesge
 || 
nProcKey
<=0 ||ProcKey>
MSG_SLOT_SUM
 )  -2;

327 
PROCSLOT
 *
pSl
 = &
m_pMsgAa
->

[
nProcKey
-1];

328 if
pSl
->
nProcKey
 < 0 )  -3;

329 if
pSl
->
nMsgPos
 < 0 )  0;

331 
m_hSemhe
.
	`mTake
();

332 
nPos
 = 
pSl
->
nMsgPos
;

333 
pBuff
 = &
m_pMsgAa
->
po
[
nPos
];

334 
nL
 = 
pBuff
->
wMsgL
;

335 
	`memy
(
pMesge
, 
pBuff
, 12+
nL
);

337 
pLi
 = &
m_pMsgAa
->
ve
[
nPos
];

338 
pSl
->
nMsgPos
 = 
pLi
->
xt
;

339 
pLi
->
xt
 = -1;

340 
	`FeBufr

nPos
 );

341 
pSl
->
nStus
--;

342 
m_hSemhe
.
	`mGive
();

343  
nL
;

344 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/msgManage.h

2 #i!
defed
(
_MSGMANAGE_H__
)

3 
	#_MSGMANAGE_H__


	)

5 
	~"mObj.h
"

6 
	~"../she/msgdef.h
"

8 
	#MSGBUSSEMKEY
 20140101

	)

10 as
	cCMsgMage


12 
	mpublic
:

13 
CMsgMage
();

14 ~
CMsgMage
();

16 
	mive
:

17 
MSGSTORE
 *
m_pMsgAa
;

18 
CSemObj
 
	mm_hSemhe
;

20 
	mive
:

21 
In
();

22 
GBufr
();

23 
FeBufr

nPos
, 
nCou
=1 );

24 
C˪upSl

nSlNo
 );

25 
LaunchMsg

MSGITEM
* 
pMesge
 );

27 
	mpublic
:

28 
On
(*
pAddr
);

29 
Clo
();

30 
IsOn
();

31 
TimProc
();

32 
Dich
();

34 
FdDock
(*
szName
);

35 
LogBus
(*
szName
);

36 
ExBus
(
nProcKey
);

37 
Subsibe
(
nProcKey
, 
dwOi
);

38 
UnSubsibe
(
nProcKey
, 
dwOi
);

39 
MesgeSd
(
MSGITEM
 *
pMesge
, *
pD
=
NULL
);

40 
MesgeRecv
(
nProcKey
, 
MSGITEM
 *
pMesge
, 
nSync
=0);

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/rdbObj.cpp

5 
	~<dio.h
>

6 
	~<dlib.h
>

7 
	~<rg.h
>

8 
	~<y.h
>

9 
	~<f.h
>

10 
	~<unid.h
>

11 
	~<dg.h
>

12 
	~<sys/mm.h
>

13 
	~<sys/tys.h
>

14 
	~<sys/m.h
>

15 
	~<sys/.h
>

16 
	~<sigl.h
>

18 
	~<time.h
>

19 
	~<sys/time.h
>

21 
	~"rdbObj.h
"

22 
	~"../she/gDaTy.h
"

23 
	~"../she/glob.h
"

25 
	#ONE_EXTEND_PAGE
 4096

26 
	#MAX_EXTEND_SIZE
 0x01000000

27 
	#RTDBSER_SOE_VAL
 1

28 
	#RTDBSER_YX_VAL
 0

29 

	)

30 "C" *
GWkPh
();

31 "C" 
OutPromText
(*
szText
);

32 "C" 
LogPromText
(cڡ *
fmt
, ...);

33 "C" 
G_Syem_Time
(*
ts
, *
ms
);

34 
G_ACSI_Timeamp
(
ACSI_TIMESTAMP
 *
ts
, *
p
);

36 
	sgSTNDEF


38 
WORD
 
	mwNum
;

39 
	mszName
[16];

40 
WORD
 
	mwAICou
;

41 
WORD
 
	mwDICou
;

42 
WORD
 
	mwDOCou
;

43 
WORD
 
	mwPICou
;

44 
WORD
 
	mwAOCou
;

45 } 
	tSTNDEF
;

47 
	gg_nExndSize
 = 0;

48 
STNDEF
 
	gg_SDef
[
MAX_STN_SUM
];

51 #ifde
__lulus


55 
SDeuCfig
()

57 
i
;

58 
STNDEF
 *
pObj
;

59  
i
=0; i<
MAX_STN_SUM
; i++ )

61 
pObj
 = &
g_SDef
[
i
];

62 
pObj
->
wNum
 = (
WORD
)
i
;

63 
rtf
(
pObj
->
szName
, "Un%02d", 
i
);

64 
pObj
->
wAICou
 = 32;

65 
pObj
->
wDICou
 = 32;

66 
pObj
->
wDOCou
 = 4;

67 
pObj
->
wPICou
 = 4;

68 
pObj
->
wAOCou
 = 1;

72 
	#CONFIG_STATION_SUM
 0x1001

	)

73 
	#CONFIG_RDBASE_SIZE
 0x1002

	)

74 
	#CONFIG_EXTEND_SIZE
 0x1003

	)

76 
	#CONFIG_STN_PARAM
 0x2001

	)

77 
	#CONFIG_AI_PARAM
 0x2101

	)

78 
	#CONFIG_DI_PARAM
 0x2102

	)

79 
	#CONFIG_PI_PARAM
 0x2103

	)

80 
	#CONFIG_DO_PARAM
 0x2104

	)

81 
	#CONFIG_AO_PARAM
 0x2105

	)

83 
PCfigIm
(*
rIm
, 
WORD
 *
pwNum
)

85 
rTy
[32];

86 
i
, 
nL
;

88 if
rr
(
rIm
, "i_sum" 
CONFIG_STATION_SUM
;

89 if
rr
(
rIm
, "rdba_size" 
CONFIG_RDBASE_SIZE
;

90 if
rr
(
rIm
, "exnd_size" 
CONFIG_EXTEND_SIZE
;

91 
i
 = 0;

92 
nL
 = 

(
rIm
);

93  !
isdig
(
rIm
[
i
]&& i<()(
rTy
) )

95 
rTy
[
i
] = 
tou
(
rIm
[i]);

96 if++
i
 >
nL
 ) ;

98 
rTy
[
i
] = '\0';

99 if
i
 >
nL
 ) *
pwNum
 = 0;

100 *
pwNum
 = (
WORD
)
oi
(&
rIm
[
i
]);

101 if
rcmp
(
rTy
, "STN"=0 )  
CONFIG_STN_PARAM
;

102 if
rcmp
(
rTy
, "AI"=0 )  
CONFIG_AI_PARAM
;

103 if
rcmp
(
rTy
, "DI"=0 )  
CONFIG_DI_PARAM
;

104 if
rcmp
(
rTy
, "PI"=0 )  
CONFIG_PI_PARAM
;

105 if
rcmp
(
rTy
, "DO"=0 )  
CONFIG_DO_PARAM
;

109 
GCutTime

REALTIME
 *
pRlTime
 )

111 
time_t
 
lSecd
;

112 
tm
 
cuTime
;

113 
timev
 
tv
;

114 
timeze
 
tz
;

116 
gtimeofday
(&
tv
, &
tz
);

117 
lSecd
 = (
time_t
)(
tv
.
tv_c
);

118 
loime_r
&
lSecd
, &
cuTime
 );

119 
pRlTime
->
wMliSec
 = 
tv
.
tv_uc
/1000;

120 
pRlTime
->
wSecd
 = 
cuTime
.
tm_c
;

121 
pRlTime
->
wMu
 = 
cuTime
.
tm_m
;

122 
pRlTime
->
wHour
 = 
cuTime
.
tm_hour
;

123 
pRlTime
->
wDay
 = 
cuTime
.
tm_mday
;

124 
pRlTime
->
wMth
 = 1+
cuTime
.
tm_m
;

125 
pRlTime
->
wYr
 = 1900+
cuTime
.
tm_yr
;

128 
bo
 
IsLpYr
(
yr
)

130 if(
yr
 % 4!0 
l
;

131 if(
yr
 % 100!0 
ue
;

132 if(
yr
 % 400!0 
l
;

133  
ue
;

136 
	#ONE_DAY_TIME
 86400

	)

137 
time_t
 
MakeSecd

wYr
, 
wMth
, 
wDay
,

138 
wHour
, 
wMu
, 
wSecd
 )

140 
i
;

141 
time_t
 
sum
=0;

143 if
wMth
 < 1 || wMonth > 12 ||

144 
wDay
 < 1 || wDay > 31 ||

145 
wHour
 > 23 || 
wMu
 > 59 )  0;

146 if
wMth
 == 2 )

148 if
IsLpYr

wYr
 ) )

150 if
wDay
 > 29 )  0;

154 if
wDay
 > 28 )  0;

157  
i
=1970; i<
wYr
; i++ )

159 if!
IsLpYr
(
i
) )

160 
sum
 +365 * 
ONE_DAY_TIME
;

162 
sum
 +366 * 
ONE_DAY_TIME
;

164  
i
=1; i<
wMth
; i++ )

166 if(
i
 == 1 || i == 3 || i == 5 || i == 7 || i == 8|| i == 10 || i == 12)

167 
sum
 +31 * 
ONE_DAY_TIME
;

168 if(
i
 == 4 || i == 6 || i == 9 || i == 11)

169 
sum
 +30 * 
ONE_DAY_TIME
;

172 if
IsLpYr
(
wYr
) )

173 
sum
 +29 * 
ONE_DAY_TIME
;

175 
sum
 +28 * 
ONE_DAY_TIME
;

178 
sum
 +(
wDay
-1* 
ONE_DAY_TIME
;

179 
sum
 +
wHour
 * 3600;

180 
sum
 +
wMu
 * 60;

181 
sum
 +
wSecd
;

182  
sum
;

185 
SCutTime
(
REALTIME
 *
pRlTime
)

187 if
pRlTime
 =
NULL
 )  -1;

188 
timev
 
tv
;

189 
tv
.
tv_c
 = 
MakeSecd

pRlTime
->
wYr
,RlTime->
wMth
,RlTime->
wDay
,

190 
pRlTime
->
wHour
,RlTime->
wMu
,RlTime->
wSecd
 );

191 
tv
.
tv_uc
 = 
pRlTime
->
wMliSec
*1000;

192  
imeofday
(&
tv
, 
NULL
);

195 #ifde
__lulus


201 
CRTDBObj
::
	$CRTDBObj
()

203 
m_bInFg
 = 
FALSE
;

204 
m_wRunS
 = 0;

206 
m_dwASize
 = (
SHM_SPACE
);

207 
m_dwExtSize
 = 0;

209 
m_wSSum
 = 1;

210 
m_nAlogSum
 = 0;

211 
m_nDigSum
 = 0;

212 
m_nPulSum
 = 0;

213 
m_nRaySum
 = 0;

214 
m_nAdjuSum
 = 0;

216 
m_pRTDBS
 = 
NULL
;

217 
	}
}

219 
CRTDBObj
::~
	$CRTDBObj
()

221 
	`FeRTDBObj
();

222 
	}
}

224 
CRTDBObj
::
	$SSSize
(
nExtL
)

226 if
nExtL
 < 0 ) 
m_dwExtSize
 = 0;

227 if
nExtL
==0 ) 
m_dwExtSize
 = (
DWORD
)
g_nExndSize
;

228 if(
nExtL
>0 &&ExtL<=
MAX_EXTEND_SIZE
)

230 
m_dwExtSize
 = (
DWORD
)
nExtL
;

232 
m_dwASize
 = (
SHM_SPACE
)+
m_dwExtSize
;

233 
	}
}

235 
CRTDBObj
::
	$CeRTDBObj
(*
szProm
)

237 
nSize
;

238 
nSize
 = ()
m_dwASize
;

239 if
m_MemyObj
.
	`Ce
(
SHMDBKEY
, 
nSize
, 0600) < 0 )

241 
nPos
 = ()
m_MemyObj
.
	`AachShm
();

242 if
nPos
 < 0 )  -2;

243 
m_mWre
.
	`Ce
(
SHMDBKEY
+1);

244 
m_pRTDBS
 = (
SHM_SPACE
*)
nPos
;

245 if
szProm
 )

246 
	`rtf
(
szProm
, "Memy(%d 0x%x", 
nSize
, ()
m_pRTDBS
);

247 
m_MemyObj
.
	`InShmV
();

248 
m_pRTDBS
->
dwASize
 = (
DWORD
)
nSize
;

249 
m_pRTDBS
->
dwExtSize
 = 
m_dwExtSize
;

250 
m_pRTDBS
->
dwQuy
 = 0;

251 
m_pRTDBS
->
dwEdi
 = (
DWORD
)
SHM_STRUCT_VER
;

253  
nPos
;

254 
	}
}

256 
CRTDBObj
::
	$OnRTDBObj
(*
szProm
)

258 
nSize
 = (
SHM_SPACE
);

259 if
m_MemyObj
.
	`On
(
SHMDBKEY
, 
nSize
, 0600) < 0 )

261 
nPos
 = ()
m_MemyObj
.
	`AachShm
();

262 if
nPos
 < 0 )  -2;

263 
m_mWre
.
	`Ce
(
SHMDBKEY
+1);

264 
m_pRTDBS
 = (
SHM_SPACE
*)
nPos
;

265 if
szProm
 )

266 
	`rtf
(
szProm
, "Memy(%d 0x%x", 
nSize
, ()
m_pRTDBS
);

267 
m_dwASize
 = 
m_pRTDBS
->
dwASize
;

268 
m_dwExtSize
 = 
m_pRTDBS
->
dwExtSize
;

269 
m_wSSum
 = 
m_pRTDBS
->
sysInfo
.
wSSum
;

270 
m_nAlogSum
 = 
m_pRTDBS
->
sysInfo
.
nAlogSum
;

271 
m_nDigSum
 = 
m_pRTDBS
->
sysInfo
.
nDigSum
;

272 
m_nPulSum
 = 
m_pRTDBS
->
sysInfo
.
nPulSum
;

273 
m_nRaySum
 = 
m_pRTDBS
->
sysInfo
.
nRaySum
;

274 
m_nAdjuSum
 = 
m_pRTDBS
->
sysInfo
.
nAdjuSum
;

275 
m_bInFg
 = (
BOOL
)
m_pRTDBS
->
sysInfo
.
wS
;

278  
i
=0; i<
m_wSSum
; i++ )

280 
STNPARAM
 *
pSObj
 = &
m_pRTDBS
->
RTDBa
.
SUn
[
i
];

281 
pSObj
->
pAlogTab
 = &
m_pRTDBS
->
RTDBa
.
AlogTab
[pSObj->
dwAlogPos
];

282 
pSObj
->
pDigTab
 = &
m_pRTDBS
->
RTDBa
.
DigTab
[pSObj->
dwDigPos
];

283 
pSObj
->
pRayTab
 = &
m_pRTDBS
->
RTDBa
.
RayTab
[pSObj->
dwRayPos
];

284 
pSObj
->
pPulTab
&
m_pRTDBS
->
RTDBa
.
PulTab
[pSObj->
dwPulPos
];

287  
nPos
;

288 
	}
}

290 
CRTDBObj
::
	$OnRTDBObj_Cgi
(*
szProm
)

293 
nSize
 = (
SHM_SPACE
);

294 if
m_MemyObj
.
	`On
(
SHMDBKEY
, 
nSize
, 0600) < 0 )

296 
nPos
 = ()
m_MemyObj
.
	`AachShm
();

297 if
nPos
 < 0 )  -2;

298 
m_mWre
.
	`Ce
(
SHMDBKEY
+1);

299 
m_pRTDBS
 = (
SHM_SPACE
*)
nPos
;

300 if
szProm
 )

301 
	`rtf
(
szProm
, "Memy(%d 0x%x", 
nSize
, ()
m_pRTDBS
);

302 
m_dwASize
 = 
m_pRTDBS
->
dwASize
;

303 
m_dwExtSize
 = 
m_pRTDBS
->
dwExtSize
;

304 
m_wSSum
 = 
m_pRTDBS
->
sysInfo
.
wSSum
;

305 
m_nAlogSum
 = 
m_pRTDBS
->
sysInfo
.
nAlogSum
;

306 
m_nDigSum
 = 
m_pRTDBS
->
sysInfo
.
nDigSum
;

307 
m_nPulSum
 = 
m_pRTDBS
->
sysInfo
.
nPulSum
;

308 
m_nRaySum
 = 
m_pRTDBS
->
sysInfo
.
nRaySum
;

309 
m_nAdjuSum
 = 
m_pRTDBS
->
sysInfo
.
nAdjuSum
;

310 
m_bInFg
 = (
BOOL
)
m_pRTDBS
->
sysInfo
.
wS
;

312  
nPos
;

313 
	}
}

316 
CRTDBObj
::
	$RTDBIn
()

318 
WORD
 
i
;

319 
rFe
[96];

322 
i
=0; i<
m_wSSum
; i++)

325 
	`SIn
((
WORD
)
i
, &
g_SDef
[i]);

327 
	`rtf
(
rFe
, "%s/Sti/n%02d.cf", 
	`GWkPh
(), 
i
+1);

330 
	`PIn
(
i
, 
rFe
);

332 
m_pRTDBS
->
sysInfo
.
wSSum
 = 
m_wSSum
;

333 
m_pRTDBS
->
sysInfo
.
nAlogSum
 = 
m_nAlogSum
;

334 
m_pRTDBS
->
sysInfo
.
nDigSum
 = 
m_nDigSum
;

335 
m_pRTDBS
->
sysInfo
.
nRaySum
 = 
m_nRaySum
;

336 
m_pRTDBS
->
sysInfo
.
nPulSum
 = 
m_nPulSum
;

337 
m_pRTDBS
->
sysInfo
.
nAdjuSum
 = 
m_nAdjuSum
;

338 
m_pRTDBS
->
sysInfo
.
nSOEWrePos
 = 0;

339 
m_pRTDBS
->
sysInfo
.
nAIEWrePos
 = 0;

340 
m_pRTDBS
->
sysInfo
.
wS
 = 1;

341 
m_pRTDBS
->
sysInfo
.
nIsDuty
 = 1;

342 
m_bInFg
 = 
TRUE
;

343 
	}
}

345 
CRTDBObj
::
	$RdCfig
(
LPCSTR
 
szFe
)

347 
k
;

348 
FILE
 *
hFe
;

349 
rLe
[192];

350 *
pIm
, *
pPam
;

351 
WORD
 
wNum
;

353 
	`SDeuCfig
();

355 
hFe
 = 
	`fݒ
(
szFe
, "r");

356 if
hFe
 >0 )

358 
	`LogPromText
("Of%ok.\n", 
szFe
);

359  
	`fgs
(
rLe
, (rLe), 
hFe
) )

362 if
rLe
[0]==';' || strLine[0]=='#' ) ;

364 
pIm
 = 
	`ok
(
rLe
, "=");

365 if
pIm
 =
NULL
 ) ;

366 
pPam
 = 
	`ok
(
NULL
, "=");

367 if
pPam
 =
NULL
 ) ;

369 
nTy
 = 
	`PCfigIm
(
pIm
, &
wNum
);

370  
nTy
 )

372 
CONFIG_STATION_SUM
:

373 
m_wSSum
 = (
WORD
)
	`oi
(
pPam
);

374 if
m_wSSum
 > 
MAX_STN_SUM
 )

375 
m_wSSum
 = 
MAX_STN_SUM
;

377 
CONFIG_RDBASE_SIZE
:

378 
k
 = 
	`oi
(
pPam
);

380 
CONFIG_EXTEND_SIZE
:

381 
k
 = 
	`oi
(
pPam
);

382 if(
k
>0
g_nExndSize
 = 
ONE_EXTEND_PAGE
 * k;

384 
CONFIG_STN_PARAM
:

385 
	`SSArib
(
wNum
-1, 
pPam
);

389 
	`fo
(
hFe
);

391 
	}
}

393 
CRTDBObj
::
	$SSArib
(
WORD
 
wS
, * 
szPam
)

395 
i
 = 0;

396 if
wS
 >
m_wSSum
 ) ;

397 
STNDEF
 *
pObj
 = &
g_SDef
[
wS
];

399 if
	`
(
szPam
) <= 0 ) ;

400 *
p
 = 
	`ok
(
szPam
, ",");

401  
p
 )

403 
i
)

406 
	`rtf
(
pObj
->
szName
, "%s", 
p
);

409 
pObj
->
wAICou
 = (
WORD
)
	`oi
(
p
);

412 
pObj
->
wDICou
 = (
WORD
)
	`oi
(
p
);

415 
pObj
->
wDOCou
 = (
WORD
)
	`of
(
p
);

418 
pObj
->
wPICou
 = (
WORD
)
	`of
(
p
);

421 
pObj
->
wAOCou
 = (
WORD
)
	`of
(
p
);

424 
p
 = 
	`ok
(
NULL
, ",");

425 
i
++;

427 
	}
}

429 
BOOL
 
CRTDBObj
::
	$SIn
(
WORD
 
wS
, * 
pPam
)

431 
i
, 
nCou
, 
iIndex
;

432 
STNPARAM
 *
pSObj
;

433 
ANALOGITEM
 *
pAiIm
;

434 
DIGITALITEM
 *
pDiIm
;

435 
PULSEITEM
 *
pPiIm
;

436 
RELAYITEM
 *
pDoIm
;

438 
STNDEF
 *
pSDef
 = (STNDEF*)
pPam
;

439 if
wS
 >
MAX_STN_SUM
 )  
FALSE
;

440 
pSObj
 = &
m_pRTDBS
->
RTDBa
.
SUn
[
wS
];

442 
pSObj
->
wSNum
 = 
wS
;

443 
	`rtf
(
pSObj
->
szSName
, 
pSDef
->
szName
);

445 if(
m_nAlogSum
+
pSDef
->
wAICou
)>
MAX_ANALOG_SUM
 )

448 
nCou
 = 
	`max
(0, 
MAX_ANALOG_SUM
-
m_nAlogSum
);

452 
nCou
 = 
pSDef
->
wAICou
;

454 
pSObj
->
wAlogSum
 = 
nCou
;

455 
pSObj
->
dwAlogPos
 = 
m_nAlogSum
;

456 
pSObj
->
pAlogTab
 = &
m_pRTDBS
->
RTDBa
.
AlogTab
[
m_nAlogSum
];

457 
pAiIm
 = 
pSObj
->
pAlogTab
;

458 
iIndex
 = 
m_nAlogSum
;

459  
i
=0; i<
nCou
; i++ )

461 
pAiIm
->
wPID
 = (
WORD
)
i
;

462 
pAiIm
->
byTy
 = 0;

463 
pAiIm
->
byUn
 = 0;

464 
	`rtf
(
pAiIm
->
szName
, "%02dAI%03d", 
wS
+1, 
i
+1);

465 
pAiIm
->
wPCl
 = 1;

466 
pAiIm
->
wThshd
 = 0;

467 
pAiIm
->
fRio
 = 1.0f;

468 
pAiIm
->
fOfft
 = 0.0f;

469 
pAiIm
->
dwRawV
 = (
DWORD
)0;

470 
pAiIm
->
fRlV
 = ()0.0f;

471 
pAiIm
->
iTnsNum
 = 
iIndex
;

472 
pAiIm
++;

473 
iIndex
++;

475 
m_nAlogSum
 +
pSObj
->
wAlogSum
;

477 if(
m_nDigSum
+
pSDef
->
wDICou
)<=
MAX_DIGITAL_SUM
 )

478 
nCou
 = 
pSDef
->
wDICou
;

480 
nCou
 = 
	`max
(0, 
MAX_DIGITAL_SUM
 - 
m_nDigSum
);

482 
pSObj
->
wDigSum
 = 
nCou
;

483 
pSObj
->
dwDigPos
 = 
m_nDigSum
;

484 
pSObj
->
pDigTab
 = &
m_pRTDBS
->
RTDBa
.
DigTab
[
m_nDigSum
];

485 
pDiIm
 = 
pSObj
->
pDigTab
;

486 
iIndex
 = 
m_nDigSum
;

487  
i
=0; i<
nCou
; i++ )

489 
pDiIm
->
wPID
 = (
WORD
)
i
;

490 
pDiIm
->
byTy
 = 0;

491 
pDiIm
->
byAr
 = 0;

492 
	`rtf
(
pDiIm
->
szName
, "%02dDI%03d", 
wS
+1, 
i
+1);

493 
pDiIm
->
wPCl
 = 1;

494 
pDiIm
->
wEvtCode
 = -1;

495 
pDiIm
->
wRerve
 = 0;

496 
pDiIm
->
wStus
 = 
DISTATUS_VALID
 ;

497 
pDiIm
->
iTnsNum
 = 
iIndex
;

498 
pDiIm
++;

499 
iIndex
++;

501 
m_nDigSum
 +
pSObj
->
wDigSum
;

503 if(
m_nRaySum
+
pSDef
->
wDOCou
)<=
MAX_RELAY_SUM
 )

504 
nCou
 = 
pSDef
->
wDOCou
;

506 
nCou
 = 
	`max
(0, 
MAX_RELAY_SUM
 - 
m_nRaySum
);

508 
pSObj
->
wRaySum
 = 
nCou
;

509 
pSObj
->
dwRayPos
 = 
m_nRaySum
;

510 
pSObj
->
pRayTab
 = &
m_pRTDBS
->
RTDBa
.
RayTab
[
m_nRaySum
];

511 
pDoIm
 = 
pSObj
->
pRayTab
;

512 
iIndex
 = 
m_nRaySum
;

513  
i
=0; i<
nCou
; i++ )

515 
pDoIm
->
wPID
 = (
WORD
)
i
;

516 
pDoIm
->
byTy
 = 0;

517 
pDoIm
->
byAr
 = 0;

518 
	`rtf
(
pDoIm
->
szName
, "%02dDO%03d", 
wS
+1, 
i
+1);

519 
pDoIm
->
wPCl
 = 1;

520 
pDoIm
->
wStus
 = 0 ;

521 
pDoIm
->
iTnsNum
 = 
iIndex
;

522 
pDoIm
++;

523 
iIndex
++;

525 
m_nRaySum
 +
pSObj
->
wRaySum
;

529 if(
m_nPulSum
+
pSDef
->
wPICou
)<=
MAX_PULSE_SUM
 ) 
nCou
 =StnDef->wPICount;

530 
nCou
 = 
	`max
(0, 
MAX_PULSE_SUM
 - 
m_nPulSum
);

531 
pSObj
->
wPulSum
 = 
nCou
;

532 
pSObj
->
dwPulPos
 = 
m_nPulSum
;

533 
pSObj
->
pPulTab
 = &
m_pRTDBS
->
RTDBa
.
PulTab
[
m_nPulSum
];

534 
pPiIm
 = 
pSObj
->
pPulTab
;

535 
iIndex
 = 
m_nPulSum
;

536  
i
=0; i<
nCou
; i++ )

538 
pPiIm
->
wPID
 = (
WORD
)
i
;

539 
pPiIm
->
byTy
 = 0;

540 
pPiIm
->
byAr
 = 0;

541 
	`rtf
(
pPiIm
->
szName
, "%02dPI%03d", 
wS
+1, 
i
+1);

542 
pPiIm
->
wPCl
 = 1;

543 
pPiIm
->
wRerve
 = 0;

544 
pPiIm
->
fRio
 = 1.0f;

545 
pPiIm
->
dwRawV
 = 0;

546 
pPiIm
->
iTnsNum
 = 
iIndex
;

547 
pPiIm
++;

548 
iIndex
++;

550 
m_nPulSum
 +
pSObj
->
wPulSum
;

553 
pSObj
->
wStus
 = 1;

554  
TRUE
;

555 
	}
}

557 
CRTDBObj
::
	$PIn
(
WORD
 
wS
, 
LPCSTR
 
szFe
)

559 
FILE
 *
hFe
;

560 
rLe
[256];

561 *
pIm
, *
pPam
;

562 
WORD
 
wNum
;

564 if
wS
 >
m_wSSum
 ) ;

565 
STNPARAM
 *
pSObj
 = &
m_pRTDBS
->
RTDBa
.
SUn
[
wS
];

567 
hFe
 = 
	`fݒ
(
szFe
, "r");

568 if
hFe
 > 0 )

570 
	`LogPromText
("Of%ok.\n", 
szFe
);

571  
	`fgs
(
rLe
, (rLe), 
hFe
) )

574 if
rLe
[0]==';' || strLine[0]=='#' ) ;

576 
pIm
 = 
	`ok
(
rLe
, "=");

577 if
pIm
 =
NULL
 ) ;

578 
pPam
 = 
	`ok
(
NULL
, "=");

579 if
pPam
 =
NULL
 ) ;

581 
nTy
 = 
	`PCfigIm
(
pIm
, &
wNum
);

582  
nTy
 )

585 
CONFIG_AI_PARAM
:

586 if(
wNum
-1< 
pSObj
->
wAlogSum
 )

588 
ANALOGITEM
 *
pAIObj
 = 
	`GAlogObj
(
wS
, 
wNum
-1);

589 if
pAIObj
 ) 
	`SAlogPam
AIObj, 
pPam
);

593 
CONFIG_DI_PARAM
:

594 if(
wNum
-1< 
pSObj
->
wDigSum
 )

596 
DIGITALITEM
 *
pDIObj
 = 
	`GDigObj
(
wS
, 
wNum
-1);

597 if
pDIObj
 ) 
	`SDigPam
DIObj, 
pPam
);

601 
CONFIG_PI_PARAM
:

602 if(
wNum
-1< 
pSObj
->
wPulSum
 )

604 
PULSEITEM
 *
pPIObj
 = 
	`GPulObj
(
wS
, 
wNum
-1);

605 if
pPIObj
 ) 
	`SPulPam
PIObj, 
pPam
);

609 
CONFIG_DO_PARAM
:

610 if(
wNum
-1< 
pSObj
->
wRaySum
 )

612 
RELAYITEM
 *
pDoObj
 = 
	`GRayObj
(
wS
, 
wNum
-1);

613 if
pDoObj
 ) 
	`SRayPam
DoObj, 
pPam
);

618 
	`fo
(
hFe
);

620 
	}
}

622 
CRTDBObj
::
	$FeRTDBObj
( )

624 
m_bInFg
 = 
FALSE
;

625 
m_wRunS
 = 0;

626 
m_wSSum
 = 0;

627 
m_nAlogSum
 = 0;

628 
m_nDigSum
 = 0;

629 
m_nPulSum
 = 0;

630 
m_nRaySum
 = 0;

631 
m_nAdjuSum
 = 0;

634 
m_MemyObj
.
	`DachShm
();

635 
m_MemyObj
.
	`RemoveShm
();

636 
m_pRTDBS
 = 
NULL
;

637 
	}
}

639 
CRTDBObj
::
	$TimProc
(
WORD
 
wTick
)

641 if
m_pRTDBS
 )

645 
	}
}

647 cڡ 
STNPARAM
* 
CRTDBObj
::
	$GSObj
(
WORD
 
wS
)

649 if!
m_pRTDBS
 )  
NULL
;

650 if
wS
 >
MAX_STN_SUM
 )  
NULL
;

651  &
m_pRTDBS
->
RTDBa
.
SUn
[
wS
];

652 
	}
}

654 cڡ 
SOEITEM
* 
CRTDBObj
::
	$GTheSOE
(
iPos
)

656 if!
m_pRTDBS
 )  
NULL
;

657 if(
iPos
<0 || iPos>=
SOE_QUEUE_SUM
 
NULL
;

658  &
m_pRTDBS
->
sAay
[
iPos
];

659 
	}
}

661 cڡ 
AIEITEM
* 
CRTDBObj
::
	$GTheAIE
(
iPos
)

663 if!
m_pRTDBS
 )  
NULL
;

664 if(
iPos
<0 || iPos>=
AIE_QUEUE_SUM
 
NULL
;

665  &
m_pRTDBS
->
aAay
[
iPos
];

666 
	}
}

668 
CRTDBObj
::
	$WreAIEInfo
(
WORD
 
wS
, WORD 
wP
, 
dwV
, 
fV
)

670 
nPos
 = 
m_pRTDBS
->
sysInfo
.
nAIEWrePos
;

671 
AIEITEM
 *
pIm
 = &
m_pRTDBS
->
aAay
[
nPos
];

672 
pIm
->
byTy
 = 0;

673 
pIm
->
wSID
 = 
wS
;

674 
pIm
->
wPNum
 = 
wP
;

675 
pIm
->
dwVue
 = 
dwV
;

676 
pIm
->
fVue
 = 
fV
;

677 
nPos
 = (nPos+1)%
AIE_QUEUE_SUM
;

678 
m_pRTDBS
->
sysInfo
.
nAIEWrePos
 = 
nPos
;

680 
	}
}

682 
CRTDBObj
::
	$WreSOEInfo1
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
, WORD 
wAr
)

684 
nPos
 = 
m_pRTDBS
->
sysInfo
.
nSOEWrePos
;

685 
SOEITEM
 *
pIm
 = &
m_pRTDBS
->
sAay
[
nPos
];

687 
	`G_Syem_Time
(&
pIm
->
lTime
, &pIm->
wMiSecd
);

688 
pIm
->
byS
 = (
wV
==0)?0:1;

689 
pIm
->
wSID
 = 
wS
;

690 
pIm
->
wPNum
 = 
wP
;

691 
pIm
->
wArib
 = 
wAr
;

693 
nPos
 = (nPos+1)%
SOE_QUEUE_SUM
;

694 
m_pRTDBS
->
sysInfo
.
nSOEWrePos
 = 
nPos
;

696 
	}
}

698 
CRTDBObj
::
	$WreSOEInfo2
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
, WORD 
wAr
)

700 
nPos
 = 
m_pRTDBS
->
sysInfo
.
nSOEWrePos
;

701 
SOEITEM
 *
pIm
 = &
m_pRTDBS
->
sAay
[
nPos
];

703 
pIm
->
lTime
 =Time;

704 
pIm
->
wMiSecd
 = wMiSecond;

705 
pIm
->
byS
 = (
wV
==0)?0:1;

706 
pIm
->
wSID
 = 
wS
;

707 
pIm
->
wPNum
 = 
wP
;

708 
pIm
->
wArib
 = 
wAr
;

711 
nPos
 = (nPos+1)%
SOE_QUEUE_SUM
;

712 
m_pRTDBS
->
sysInfo
.
nSOEWrePos
 = 
nPos
;

716 
	}
}

1200 
CRTDBObj
::
	$SAlogPam
(
ANALOGITEM
 *
pObj
, * 
szPam
)

1202 
i
 = 0;

1203 
nL
 = 
	`
(
szPam
);

1204 if
nL
 <= 0 ) ;

1205 *
p
 = 
	`ok
(
szPam
, ",");

1206  
p
 )

1208 
i
)

1211 
	`rtf
(
pObj
->
szName
, "%s", 
p
);

1214 
pObj
->
byTy
 = (
BYTE
)
	`oi
(
p
);

1217 
pObj
->
byUn
 = (
BYTE
)
	`oi
(
p
);

1220 
pObj
->
fRio
 = ()
	`of
(
p
);

1223 
pObj
->
fOfft
 = ()
	`of
(
p
);

1226 
pObj
->
wPCl
 = (
WORD
)
	`oi
(
p
);

1229 
pObj
->
wThshd
 = (
WORD
)
	`oi
(
p
);

1232 
p
 = 
	`ok
(
NULL
, ",");

1233 
i
++;

1235 
	}
}

1237 
ANALOGITEM
* 
CRTDBObj
::
	$GAlogObj
(
WORD
 
wS
, WORD 
wP
)

1239 if!
m_pRTDBS
 )  
NULL
;

1240 if
wS
 >
MAX_STN_SUM
 )  
NULL
;

1241 
STNPARAM
 *
pSObj
 = &
m_pRTDBS
->
RTDBa
.
SUn
[
wS
];

1242 if
wP
 >
pSObj
->
wAlogSum
 )  
NULL
;

1243  &
pSObj
->
pAlogTab
[
wP
];

1244 
	}
}

1246 
CRTDBObj
::
	$GAnogName
(
WORD
 
wS
, WORD 
wP
, *
szName
)

1248 
ANALOGITEM
* 
pObj
 = 
	`GAlogObj
(
wS
, 
wP
);

1249 if
pObj
 =
NULL
 )  -1;

1250 
	`rtf
(
szName
, 
pObj
->szName);

1252 
	}
}

1254 
CRTDBObj
::
	$WreAIV
(
WORD
 
wS
, WORD 
wP
, 
t32
 
dwV
, *
ts
)

1256 
ANALOGITEM
* 
pObj
 = 
	`GAlogObj
(
wS
, 
wP
);

1257 if
pObj
 =
NULL
 )  -1;

1258 if
pObj
->
dwRawV
 !
dwV
 )

1260 
pObj
->
fRlV
 = 
dwV
 *Obj->
fRio
 +Obj->
fOfft
;

1261 
	`G_ACSI_Timeamp
(&
pObj
->
ACSITime
, 
ts
);

1262 if
	`abs
(
pObj
->
dwRawV
-
dwV
>pObj->
wThshd
 )

1263 
	`WreAIEInfo
((
BYTE
)
wS
, 
wP
, 
dwV
, 
pObj
->
fRlV
);

1264 
pObj
->
dwRawV
 = 
dwV
;

1268 
	}
}

1270 
CRTDBObj
::
	$SAIV
(
WORD
 
wS
, WORD 
wP
, 
fV
, *
ts
)

1272 
ANALOGITEM
* 
pObj
 = 
	`GAlogObj
(
wS
, 
wP
);

1273 if
pObj
 =
NULL
 )  -1;

1274 if
pObj
->
fRlV
 !
fV
 )

1276 
	`G_ACSI_Timeamp
(&
pObj
->
ACSITime
, 
ts
);

1277 if
pObj
->
fRio
 != 0 )

1279 
t32
 
dwV
 = (t32)(
fV
 -
pObj
->
fOfft
)/pObj->
fRio
);

1280 if
	`abs
(
pObj
->
dwRawV
-
dwV
>pObj->
wThshd
 )

1282 
	`WreAIEInfo
(
wS
, 
wP
, 
dwV
, 
fV
 );

1283 
pObj
->
fRlV
 = 
fV
 ;

1285 
pObj
->
dwRawV
 = 
dwV
;

1289 
	}
}

1291 
CRTDBObj
::
	$GAIReV
(
WORD
 
wS
, WORD 
wP
, 
t32
 
dwV
)

1293 
fV
 = 0;

1294 
ANALOGITEM
* 
pObj
 = 
	`GAlogObj
(
wS
, 
wP
);

1295 if
pObj
 )

1296 
fV
 = 
dwV
 * 
pObj
->
fRio
 +Obj->
fOfft
;

1297  
fV
;

1298 
	}
}

1302 
CRTDBObj
::
	$SDigPam
(
DIGITALITEM
 *
pObj
, * 
szPam
)

1304 
i
 = 0;

1305 
nL
 = 
	`
(
szPam
);

1306 if
nL
 <= 0 ) ;

1307 *
p
 = 
	`ok
(
szPam
, ",");

1308  
p
 )

1310 
i
)

1313 
	`rtf
(
pObj
->
szName
, "%s", 
p
);

1316 
pObj
->
byTy
 = (
BYTE
)
	`oi
(
p
);

1319 
pObj
->
byAr
 = (
BYTE
)
	`oi
(
p
);

1322 
pObj
->
wPCl
 = (
WORD
)
	`oi
(
p
);

1325 
pObj
->
wEvtCode
 = ()
	`oi
(
p
);

1328 
p
 = 
	`ok
(
NULL
, ",");

1329 
i
++;

1331 
	}
}

1333 
DIGITALITEM
* 
CRTDBObj
::
	$GDigObj
(
WORD
 
wS
, WORD 
wP
)

1335 if!
m_pRTDBS
 )  
NULL
;

1336 if
wS
 >
MAX_STN_SUM
 )  
NULL
;

1337 
STNPARAM
 *
pSObj
 = &
m_pRTDBS
->
RTDBa
.
SUn
[
wS
];

1338 if
wP
 >
pSObj
->
wDigSum
 )  
NULL
;

1339  &
pSObj
->
pDigTab
[
wP
];

1340 
	}
}

1342 
CRTDBObj
::
	$GDigName
(
WORD
 
wS
, WORD 
wP
, *
szName
)

1344 
DIGITALITEM
* 
pObj
 = 
	`GDigObj
(
wS
, 
wP
);

1345 if
pObj
 =
NULL
 )  -1;

1346 
	`rtf
(
szName
, 
pObj
->szName);

1348 
	}
}

1350 
CRTDBObj
::
	$GDigV
(
WORD
 
wS
, WORD 
wP
, WORD* 
pwV
)

1352 
DIGITALITEM
* 
pObj
 = 
	`GDigObj
(
wS
, 
wP
);

1353 if
pObj
 =
NULL
 )  -1;

1354 *
pwV
 = 
pObj
->
wStus
 & 
DISTATUS_VALUE
;

1356 
	}
}

1358 
CRTDBObj
::
	$WreDIV
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
, *
ts
)

1360 
DIGITALITEM
* 
pObj
 = 
	`GDigObj
(
wS
, 
wP
);

1361 if
pObj
 =
NULL
 )  0;

1364 
WORD
 
wBack
 = 
pObj
->
wStus
;

1365 if
pObj
->
byTy
 == 5 )

1367 if
pObj
->
byAr
 == 1 )

1368 
wBack
 = ((
wV
>>12)&0x000f)*1000 + ((wVal>>8)&0x000f)*100 + ((wVal>>4)&0x000f)*10 + (wVal&0x000f);

1370 
wBack
 = 
wV
;

1374 
wBack
 = 
pObj
->
wStus
 & ~
DISTATUS_VALUE
;

1375 if(
pObj
->
wPCl
 & 
DICTRL_DOUBLEBIT
) == 0 )

1377 if
wV
 !0 ) 
wBack
 |
DIVALUE_ON
;

1378 if(
pObj
->
wPCl
 & 
DICTRL_OPPOSITE
) != 0 )

1379 
wBack
 = wBack ^ 
DIVALUE_ON
;

1383 
wBack
 |(
wV
 & 
DISTATUS_VALUE
);

1384 if(
pObj
->
wPCl
 & 
DICTRL_OPPOSITE
) != 0 )

1385 
wBack
 = wBack ^ 
DISTATUS_VALUE
;

1387 if(
pObj
->
wStus
 & 
DISTATUS_VALID
) == 0 )

1389 
pObj
->
wStus
 = 
wBack
;

1390 
	`G_ACSI_Timeamp
(&
pObj
->
ACSITime
, 
ts
);

1391 
pObj
->
wStus
 |
DISTATUS_VALID
;

1395 if
pObj
->
wStus
 !
wBack
 )

1397 
pObj
->
wStus
 = 
wBack
;

1398 
	`G_ACSI_Timeamp
(&
pObj
->
ACSITime
, 
ts
);

1402 
	}
}

1404 
CRTDBObj
::
	$SDIV
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
)

1406 
DIGITALITEM
* 
pObj
 = 
	`GDigObj
(
wS
, 
wP
);

1407 if
pObj
 =
NULL
 )  -1;

1408 
pObj
->
wStus
 = 
wV
;

1410 
	}
}

1414 
CRTDBObj
::
	$SPulPam
(
PULSEITEM
 *
pObj
, * 
szPam
)

1416 
i
 = 0;

1417 
nL
 = 
	`
(
szPam
);

1418 if
nL
 <= 0 ) ;

1419 *
p
 = 
	`ok
(
szPam
, ",");

1420  
p
 )

1422 
i
)

1425 
	`rtf
(
pObj
->
szName
, "%s", 
p
);

1428 
pObj
->
byTy
 = (
BYTE
)
	`oi
(
p
);

1431 
pObj
->
byAr
 = (
BYTE
)
	`oi
(
p
);

1434 
pObj
->
fRio
 = ()
	`of
(
p
);

1437 
pObj
->
wPCl
 = (
WORD
)
	`oi
(
p
);

1440 
p
 = 
	`ok
(
NULL
, ",");

1441 
i
++;

1443 
	}
}

1445 
PULSEITEM
* 
CRTDBObj
::
	$GPulObj
(
WORD
 
wS
, WORD 
wP
)

1447 if!
m_pRTDBS
 )  
NULL
;

1448 if
wS
 >
MAX_STN_SUM
 )  
NULL
;

1449 
STNPARAM
 *
pSObj
 = &
m_pRTDBS
->
RTDBa
.
SUn
[
wS
];

1450 if
wP
 >
pSObj
->
wPulSum
 )  
NULL
;

1451  &
pSObj
->
pPulTab
[
wP
];

1452 
	}
}

1454 
CRTDBObj
::
	$GPulName
(
WORD
 
wS
, WORD 
wP
, *
szName
)

1456 
PULSEITEM
* 
pObj
 = 
	`GPulObj
(
wS
, 
wP
);

1457 if
pObj
 =
NULL
 )  -1;

1458 
	`rtf
(
szName
, 
pObj
->szName);

1460 
	}
}

1462 
CRTDBObj
::
	$GPulV
(
WORD
 
wS
, WORD 
wP
, 
DWORD
* 
pdwV
)

1464 
PULSEITEM
* 
pObj
 = 
	`GPulObj
(
wS
, 
wP
);

1465 if
pObj
 =
NULL
 )  -1;

1466 *
pdwV
 = 
pObj
->
dwRawV
;

1468 
	}
}

1470 
CRTDBObj
::
	$WrePulV
(
WORD
 
wS
, WORD 
wP
, 
DWORD
 
dwV
, *
ts
)

1472 
PULSEITEM
* 
pObj
 = 
	`GPulObj
(
wS
, 
wP
);

1473 if
pObj
 =
NULL
 )  -1;

1474 
pObj
->
dwRawV
 = 
dwV
;

1475 
	`G_ACSI_Timeamp
(&
pObj
->
ACSITime
, 
ts
);

1477 
	}
}

1481 
CRTDBObj
::
	$SRayPam
(
RELAYITEM
 *
pObj
, * 
szPam
)

1483 
i
 = 0;

1484 
nL
 = 
	`
(
szPam
);

1485 if
nL
 <= 0 ) ;

1486 *
p
 = 
	`ok
(
szPam
, ",");

1487  
p
 )

1489 
i
)

1492 
	`rtf
(
pObj
->
szName
, "%s", 
p
);

1495 
pObj
->
byTy
 = (
BYTE
)
	`oi
(
p
);

1498 
pObj
->
byAr
 = (
BYTE
)
	`oi
(
p
);

1501 
pObj
->
wPCl
 = (
WORD
)
	`oi
(
p
);

1504 
p
 = 
	`ok
(
NULL
, ",");

1505 
i
++;

1507 
	}
}

1509 
RELAYITEM
* 
CRTDBObj
::
	$GRayObj
(
WORD
 
wS
, WORD 
wP
)

1511 if!
m_pRTDBS
 )  
NULL
;

1512 if
wS
 >
MAX_STN_SUM
 )  
NULL
;

1513 
STNPARAM
 *
pSObj
 = &
m_pRTDBS
->
RTDBa
.
SUn
[
wS
];

1514 if
wP
 >
pSObj
->
wRaySum
 )  
NULL
;

1515  &
pSObj
->
pRayTab
[
wP
];

1516 
	}
}

1518 
CRTDBObj
::
	$GRayName
(
WORD
 
wS
, WORD 
wP
, *
szName
)

1520 
RELAYITEM
* 
pObj
 = 
	`GRayObj
(
wS
, 
wP
);

1521 if
pObj
 =
NULL
 )  -1;

1522 
	`rtf
(
szName
, 
pObj
->szName);

1524 
	}
}

1526 
CRTDBObj
::
	$GRayV
(
WORD
 
wS
, WORD 
wP
, WORD* 
pwV
)

1528 
RELAYITEM
* 
pObj
 = 
	`GRayObj
(
wS
, 
wP
);

1529 if
pObj
 =
NULL
 )  -1;

1530 *
pwV
 = 
pObj
->
wStus
;

1532 
	}
}

1534 
CRTDBObj
::
	$SDOV
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
)

1536 
RELAYITEM
* 
pObj
 = 
	`GRayObj
(
wS
, 
wP
);

1537 if
pObj
 =
NULL
 )  -1;

1538 
pObj
->
wStus
 = 
wV
;

1540 
	}
}

1542 
CRTDBObj
::
	$WreV

WORD
 
wSiNo
 , 
BYTE
 
byTy
 , * 
pDa
 )

1544 if
wSiNo
>=
MAX_STN_SUM
 ) || ( 
pDa
 =
NULL
 ) )

1547 
m_mWre
.
	`mTake
();

1548  
byTy
 )

1550 
YC_TYPE
:

1552 
PYC_DATA
 
pYcDa
 = ( PYC_DATA )
pDa
 ;

1553 if0 =
pYcDa
->
byYcTy
 )

1555 
	`SAIV

pYcDa
->
wSlNo
 ,YcDa->
wP
 ,YcDa->
fYcVue
 ) ;

1557 if2 =
pYcDa
->
byYcTy
 )

1559 
WORD
 
wMS
 = (
pYcDa
->
Secd
 * 1000 +YcDa->
MSecd
);

1560 
wMS
 = wMS % 1000;

1561 
ACSI_TIMESTAMP
 
t
;

1563 
t
.
SecdSEpoch
 = 
	`MakeSecd
(
pYcDa
->
Yr
,YcDa->
Mth
,YcDa->
Day
,YcDa->
Hour
,YcDa->
Mu
,YcDa->
Secd
 );

1564 
t
.
FiOfSecd
 = 
wMS
*0x00ffffff /1000;

1565 
t
.
TimeQuy
 = 0x0a;

1567 
	`SAIV

pYcDa
->
wSlNo
 ,YcDa->
wP
 ,YcDa->
fYcVue
, &
t
 ) ;

1575 
YX_TYPE
:

1577 
PYX_DATA
 
pYxDa
 = ( PYX_DATA )
pDa
;

1578 i
pYxDa
->
byYxTy
 == 2 )

1580 
LONG
 
lTime
 ;

1582 
tm
 
tmru
 ;

1583 
TIMEDATA
 
cTime
;

1584 
cTime
.
Yr
 = 
pYxDa
->Year ;

1585 
cTime
.
Mth
 = 
pYxDa
->Month ;

1586 
cTime
.
Day
 = 
pYxDa
->Day ;

1587 
cTime
.
Hour
 = 
pYxDa
->Hour ;

1588 
cTime
.
Mu
 = 
pYxDa
->Minute ;

1589 
cTime
.
Secd
 = 
pYxDa
->Second ;

1591 
	`SSuTm

cTime
, 
tmru
, 
lTime
 );

1597 
	`WreSOEInfo2

pYxDa
->
wSlNo
 ,YxDa->
wP
,YxDa->
YxVue
, 
lTime
,YxDa->
MSecd
 , 
RTDBSER_SOE_VAL
 );

1600 i
pYxDa
->
byYxTy
 == 0 )

1602 
DIGITALITEM
* 
pObj
 = 
	`GDigObj
(
pYxDa
->
wSlNo
,YxDa->
wP
);

1603 if
pObj
 =
NULL
 )

1605 
m_mWre
.
	`mGive
();

1609 if
pObj
->
wStus
 & 0x0001 ) !
pYxDa
->
YxVue
 )

1613 if
	`WreDIV

pYxDa
->
wSlNo
 ,YxDa->
wP
,YxDa->
YxVue
 ) > 0 )

1616 
	`WreSOEInfo2

pYxDa
->
wSlNo
 ,YxDa->
wP
,YxDa->
YxVue
, 0, 0 , 
RTDBSER_YX_VAL
 );

1622 
YM_TYPE
:

1624 
PYM_DATA
 
pYmDa
 = ( PYM_DATA )
pDa
 ;

1625 
PULSEITEM
* 
PulInfo
 = 
	`GPulObj
(
pYmDa
->
wSlNo
,YmDa->
wP
);

1626 if
PulInfo
 =
NULL
 )

1628 
DWORD
 
Dw_YmVue
 = (DWORD)(
pYmDa
->
YmVue
 * 
PulInfo
->
fRio
);

1629 
	`WrePulV

pYmDa
->
wSlNo
,YmDa->
wP
, 
Dw_YmVue
 );

1635 
m_mWre
.
	`mGive
();

1638 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/rdbObj.h

5 #ide
_RTDBOBJ_H__


6 
	#_RTDBOBJ_H__


	)

8 
	~"shm.h
"

9 
	~"mObj.h
"

10 
	~"../she/rdbDef.h
"

11 
	~<ioam
>

12 
usg
 
mea
 
	gd
;

15 
	#SHMDBKEY
 20123568

	)

17 as
	cCRTDBObj


19 
	mpublic
:

20 
CRTDBObj
();

21 
	mvtu
 ~
CRTDBObj
();

24 
	mpublic
:

25 
BOOL
 
m_bInFg
;

26 
WORD
 
	mm_wRunS
;

28 
DWORD
 
	mm_dwASize
;

29 
DWORD
 
	mm_dwExtSize
;

30 
WORD
 
	mm_wSSum
;

31 
	mm_nAlogSum
;

32 
	mm_nDigSum
;

33 
	mm_nRaySum
;

34 
	mm_nPulSum
;

35 
	mm_nAdjuSum
;

37 
CSemObj
 
	mm_mWre
;

38 
CShm
 
	mm_MemyObj
;

39 
SHM_SPACE
 *
	mm_pRTDBS
;

41 
	mive
:

42 
BOOL
 
SIn
(
WORD
 
wS
, * 
pPam
);

43 
PIn
(
WORD
 
wS
, 
LPCSTR
 
szFe
);

45 
WreAIEInfo
(
WORD
 
wS
, WORD 
wP
, 
dwV
, 
fV
);

46 
WreSOEInfo1
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
, WORD 
wAr
=0);

47 
WreSOEInfo2
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
, WORD 
wAr
=1);

67 
	mpublic
:

68 
RdCfig
(
LPCSTR
 
szFe
);

69 
SSSize
(
nExtL
);

70 
OnRTDBObj
(*
szProm
=
NULL
);

71 
OnRTDBObj_Cgi
(*
szProm
=
NULL
);

72 
CeRTDBObj
(*
szProm
=
NULL
);

73 
RTDBIn
();

74 
FeRTDBObj
();

75 
TimProc
(
WORD
 
wTick
);

77 
SSArib
(
WORD
 
wS
, * 
szPam
);

78 cڡ 
STNPARAM
* 
GSObj
(
WORD
 
wS
);

79 cڡ 
SOEITEM
* 
GTheSOE
(
iPos
);

80 cڡ 
AIEITEM
* 
GTheAIE
(
iPos
);

82 
RdDa
(*
pBuf
, 
nL
);

84 
SAlogPam
(
ANALOGITEM
 *
pObj
, * 
szPam
);

85 
ANALOGITEM
* 
GAlogObj
(
WORD
 
wS
, WORD 
wP
);

86 
GAnogName
(
WORD
 
wS
, WORD 
wP
, *
szName
);

87 
WreAIV
(
WORD
 
wS
, WORD 
wP
, 
t32
 
dwV
, *
ts
=
NULL
);

88 
SAIV
(
WORD
 
wS
, WORD 
wP
, 
fV
, *
ts
=
NULL
);

89 
GAIReV
(
WORD
 
wS
, WORD 
wP
, 
t32
 
dwV
);

91 
SDigPam
(
DIGITALITEM
 *
pObj
, * 
szPam
);

92 
DIGITALITEM
* 
GDigObj
(
WORD
 
wS
, WORD 
wP
);

93 
GDigName
(
WORD
 
wS
, WORD 
wP
, *
szName
);

94 
GDigV
(
WORD
 
wS
, WORD 
wP
, WORD* 
pwV
);

95 
WreDIV
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
, *
ts
=
NULL
);

96 
SDIV
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
);

98 
SPulPam
(
PULSEITEM
 *
pObj
, * 
szPam
);

99 
PULSEITEM
* 
GPulObj
(
WORD
 
wS
, WORD 
wP
);

100 
GPulName
(
WORD
 
wS
, WORD 
wP
, *
szName
);

101 
GPulV
(
WORD
 
wS
, WORD 
wP
, 
DWORD
* 
pdwV
);

102 
WrePulV
(
WORD
 
wS
, WORD 
wP
, 
DWORD
 
dwV
, *
ts
=
NULL
);

104 
SRayPam
(
RELAYITEM
 *
pObj
, * 
szPam
);

105 
RELAYITEM
* 
GRayObj
(
WORD
 
wS
, WORD 
wP
);

106 
GRayName
(
WORD
 
wS
, WORD 
wP
, *
szName
);

107 
GRayV
(
WORD
 
wS
, WORD 
wP
, WORD* 
pwV
);

108 
SDOV
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
);

111 
WreV

WORD
 
wSiNo
 ,
BYTE
 
byTy
 , * 
pDa
 ) ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/rdbms.cpp

1 
	~<dio.h
>

2 
	~<dlib.h
>

3 
	~<rg.h
>

4 
	~<y.h
>

5 
	~<f.h
>

6 
	~<unid.h
>

7 
	~<dg.h
>

8 
	~<sys/mm.h
>

9 
	~<sys/tys.h
>

10 
	~<sys/m.h
>

11 
	~<sys/.h
>

13 
	~<sigl.h
>

14 
	~<time.h
>

15 
	~<sys/time.h
>

17 
	~"rdbObj.h
"

18 
	~"msgMage.h
"

19 
	~"../she/rdbFun.h
"

21 
	#MSG_LIFETIME_CONST
 16

	)

24 
	#RTDB_VESION_CODE
 "2.1.0"

	)

26 
BOOL
 
	gg_bDebugA
 = 
TRUE
;

27 
	gg_rWkD
[64];

28 
CRTDBObj
 *
	gg_pRTDBObj
=
NULL
;

29 
CMsgMage
 
	gg_MsgKr
;

30 
	gg_nTimeZeOff
 = -28800;

33 #ifdef 
__lulus


37 *
GWkPh
()

39  
g_rWkD
;

42 
GTimeZeOfft
()

44  
g_nTimeZeOff
;

47 
OutPromText
(*
szText
);

50 
LogPromText
(cڡ *
fmt
, ...);

53 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
);

56 
G_Syem_Time
(*
ts
, *
ms
)

59 
timev
 
tv
;

60 
timeze
 
tz
;

61 
gtimeofday
(&
tv
, &
tz
);

62 if
tz
.
tz_muswe
 == 0 )

63 
tz
.
tz_muswe
 = -480;

64 *
ms
 = ()(
tv
.
tv_uc
 / 1000);

65 *
ts
 = 
tv
.
tv_c
 + 
tz
.
tz_muswe
*60;

66 if*
ts
 < 0 ) *ts = 0;

69 
RTDB_Tim_Proc
(
wSecd
)

73 
g_MsgKr
.
TimProc
();

76 #ifdef 
__lulus


81 
BOOL
 
	$EbDebug
(
BOOL
 
bEb
)

83 
g_bDebugA
 = 
bEb
;

84  
g_bDebugA
;

85 
	}
}

87 
	$ShowRTDBInfo
()

89 
	`tf
("\n ********* RTDB Infomation *********");

90 
	`tf
("\Progm Vesi : %s", 
RTDB_VESION_CODE
);

91 
	`tf
("\Wk Dey : %s", 
g_rWkD
);

92 
	`tf
("\IDebug Mod? : %s", 
g_bDebugA
 ? "Yes" : "No");

93 if
g_pRTDBObj
 )

95 
	`tf
("\Memy Adds: 0x%x", ()
g_pRTDBObj
->
m_pRTDBS
);

96 if
g_pRTDBObj
->
m_pRTDBS
 )

98 
	`tf
("\A Memy Lgth : %d", ()
g_pRTDBObj
->
m_pRTDBS
->
dwASize
);

99 
	`tf
("\ExMemy Lgth : %d", ()
g_pRTDBObj
->
m_pRTDBS
->
dwExtSize
);

100 
	`tf
("\ThS Quy : %X", ()
g_pRTDBObj
->
m_pRTDBS
->
dwQuy
);

101 
	`tf
("\RTDBa S : %d", 
g_pRTDBObj
->
m_pRTDBS
->
sysInfo
.
wS
);

105 
	`tf
("\n Invalid Memory Space !");

107 
	`tf
("\Sti Amou = %d", 
g_pRTDBObj
->
m_wSSum
);

108 
	`tf
("\Alog Sum = %d", 
g_pRTDBObj
->
m_nAlogSum
);

109 
	`tf
("\Dig Sum = %d", 
g_pRTDBObj
->
m_nDigSum
);

110 
	`tf
("\Pul Sum = %d", 
g_pRTDBObj
->
m_nPulSum
);

111 
	`tf
("\Ray Sum = %d", 
g_pRTDBObj
->
m_nRaySum
);

115 
	`tf
("\n Invalid RTDB Object !");

117 
	`tf
("\n----All Copy Right By HouPeng ----");

118 
	`tf
("\n Email:sys2000net@126.com ");

119 
	`tf
("\n*********** 2008-2038 ************\n");

120 
	}
}

122 
	$Ce_SHM_DBa
(* 
szPh
, 
nExtL
)

124 
szText
[128];

127 
	`rtf
(
g_rWkD
, 
szPh
);

128 if!
g_pRTDBObj
 )

129 
g_pRTDBObj
 = 
w
 
	`CRTDBObj
();

130 if!
g_pRTDBObj
 )  -1;

132 
	`rtf
(
szText
, "%s/db.cf", 
g_rWkD
);

133 
g_pRTDBObj
->
	`RdCfig
(
szText
);

135 
g_pRTDBObj
->
	`SSSize
(
nExtL
);

137 if
g_pRTDBObj
->
	`CeRTDBObj
(
szText
) < 0 )

139 
de
 
g_pRTDBObj
;

140 
g_pRTDBObj
 = 
NULL
;

143 
	`OutPromText
(
szText
);

145 
g_pRTDBObj
->
	`RTDBIn
();

146 
	`OutPromText
((*)"-------------- Create RTDB OK ---------------");

148 
	}
}

150 
	$On_SHM_DBa
()

152 
szText
[128];

154 if!
g_pRTDBObj
 )

155 
g_pRTDBObj
 = 
w
 
	`CRTDBObj
();

156 if!
g_pRTDBObj
 )  -1;

158 if
g_pRTDBObj
->
	`OnRTDBObj
(
szText
) < 0 )

160 
de
 
g_pRTDBObj
;

161 
g_pRTDBObj
 = 
NULL
;

164 
	`OutPromText
(
szText
);

165 
	`OutPromText
((*)"-------------- Open RTDB OK ---------------");

167 
	}
}

169 
	$Clo_SHM_DBa
()

171 if
g_pRTDBObj
 )

173 
de
 
g_pRTDBObj
;

174 
g_pRTDBObj
 = 
NULL
;

176 
	`OutPromText
((*)"-------------- Close RTDB ---------------");

177 
	}
}

179 
	$Check_SHM_DBa
()

181 if!
g_pRTDBObj
 )  -1;

182 if!
g_pRTDBObj
->
m_pRTDBS
 )  -2;

183 if
g_pRTDBObj
->
m_pRTDBS
->
dwQuy
==0xffffffff )  -3;

184  
g_pRTDBObj
->
m_pRTDBS
->
sysInfo
.
wS
;

185 
	}
}

187 *
	$G_RTDB_S
()

189 if!
g_pRTDBObj
 )  
NULL
;

190  (*)
g_pRTDBObj
->
m_pRTDBS
;

191 
	}
}

193 
	$G_RTDB_Exnd
(*
addr
)

195 if!
g_pRTDBObj
 )  -1;

196 if!
g_pRTDBObj
->
m_pRTDBS
 )  -2;

197 *
addr
 = ()&
g_pRTDBObj
->
m_pRTDBS
->
pExtAddr
;

198  ()
g_pRTDBObj
->
m_pRTDBS
->
dwExtSize
;

199 
	}
}

201 cڡ 
SYSINFO
* 
	$G_RTDB_SysInfo
()

203 if!
g_pRTDBObj
 )  
NULL
;

204 if!
g_pRTDBObj
->
m_pRTDBS
 )  
NULL
;

205  &
g_pRTDBObj
->
m_pRTDBS
->
sysInfo
;

206 
	}
}

208 cڡ 
STNPARAM
* 
	$G_RTDB_Sti
(
WORD
 
wSNum
)

210 if!
g_pRTDBObj
 )  
NULL
;

211 if!
g_pRTDBObj
->
m_pRTDBS
 )  
NULL
;

212 if
wSNum
 >
MAX_STN_SUM
 )  
NULL
;

213  &
g_pRTDBObj
->
m_pRTDBS
->
RTDBa
.
SUn
[
wSNum
];

214 
	}
}

216 cڡ 
ANALOGITEM
* 
	$G_RTDB_Alog
(
WORD
 
wS
, WORD 
wP
)

218 if!
g_pRTDBObj
 )  
NULL
;

219 if!
g_pRTDBObj
->
m_pRTDBS
 )  
NULL
;

220  
g_pRTDBObj
->
	`GAlogObj
(
wS
, 
wP
);

221 
	}
}

223 cڡ 
DIGITALITEM
* 
	$G_RTDB_Dig
(
WORD
 
wS
, WORD 
wP
)

225 if!
g_pRTDBObj
 )  
NULL
;

226  
g_pRTDBObj
->
	`GDigObj
(
wS
, 
wP
);

227 
	}
}

229 cڡ 
PULSEITEM
* 
	$G_RTDB_Pul
(
WORD
 
wS
, WORD 
wP
)

231 if!
g_pRTDBObj
 )  
NULL
;

232  
g_pRTDBObj
->
	`GPulObj
(
wS
, 
wP
);

233 
	}
}

235 cڡ 
RELAYITEM
* 
	$G_RTDB_Ray
(
WORD
 
wS
, WORD 
wP
)

237 if!
g_pRTDBObj
 )  
NULL
;

238  
g_pRTDBObj
->
	`GRayObj
(
wS
, 
wP
);

239 
	}
}

241 cڡ 
SOEITEM
* 
	$Rd_RTDB_SOE
(
iPos
)

243 if!
g_pRTDBObj
 )  
NULL
;

244  
g_pRTDBObj
->
	`GTheSOE
(
iPos
);

245 
	}
}

247 cڡ 
AIEITEM
* 
	$Rd_RTDB_AIE
(
iPos
)

249 if!
g_pRTDBObj
 )  
NULL
;

250  
g_pRTDBObj
->
	`GTheAIE
(
iPos
);

251 
	}
}

268 
	$LogMesgeBus
(*
szProcName
)

270 if!
g_pRTDBObj
 )  -1;

271 if!
g_pRTDBObj
->
m_pRTDBS
 )  -2;

272 if
g_MsgKr
.
	`IsOn
()==0 )

274 
g_MsgKr
.
	`On
((*)&
g_pRTDBObj
->
m_pRTDBS
->
msgSte
);

276  
g_MsgKr
.
	`LogBus
(
szProcName
);

277 
	}
}

279 
	$ExMesgeBus
(
nProcKey
)

281 
g_MsgKr
.
	`ExBus
(
nProcKey
);

282 
g_MsgKr
.
	`Clo
();

284 
	}
}

286 
	$MesgeSd
(
MSGITEM
 *
pMesge
, *
pD
)

288  
g_MsgKr
.
	`MesgeSd
(
pMesge
, 
pD
);

289 
	}
}

291 
	$MesgeRecv
(
nProcKey
, 
MSGITEM
 *
pMesge
, 
nSync
)

293  
g_MsgKr
.
	`MesgeRecv
(
nProcKey
, 
pMesge
, 
nSync
);

294 
	}
}

296 
	$MesgeSubsibe
(
nProcKey
, 
dwOi
)

298  
g_MsgKr
.
	`Subsibe
(
nProcKey
, 
dwOi
);

299 
	}
}

301 
	$MesgeUnSubsibe
(
nProcKey
, 
dwOi
)

303  
g_MsgKr
.
	`UnSubsibe
(
nProcKey
, 
dwOi
);

304 
	}
}

310 
g_MsToNTP
[1000] =

487 
	$SNTP_MsToNFi

wMliSecds
 )

489 if
wMliSecds
 < 1000 )

490  (
g_MsToNTP
[
wMliSecds
]);

492 
	}
}

494 
	$G_ACSI_Timeamp
(
ACSI_TIMESTAMP
 *
ts
, *
p
)

496 if
p
 =
NULL
 )

498 
timev
 
tv
;

499 
timeze
 
tz
;

500 
	`gtimeofday
(&
tv
, &
tz
);

501 if
tz
.
tz_muswe
 == 0 )

502 
tz
.
tz_muswe
 = -480;

503 
wMS
 = ()(
tv
.
tv_uc
 / 1000);

504 
ts
->
SecdSEpoch
 = 
tv
.
tv_c
+
tz
.
tz_muswe
*60;

505 
ts
->
FiOfSecd
 = (
	`SNTP_MsToNFi
(
wMS
)>>8) & 0x00ffffff;

506 
ts
->
TimeQuy
 = 0x0a;

510 
	`memy
(
ts
, 
p
, (
ACSI_TIMESTAMP
));

512 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/semObj.cpp

4 
	~<dio.h
>

5 
	~<dlib.h
>

6 
	~<rg.h
>

7 
	~<dg.h
>

8 
	~<y.h
>

9 
	~<o.h
>

11 
	~"mObj.h
"

14 
	gCSemObj
::
	$CSemObj
()

16 
m_iSemId
 = -1;

17 
m_bCe
 = 
l
;

18 
m_tKey
 = 
	`ok
(".", 's');

19 
	}
}

21 
	gCSemObj
::
	$CSemObj
(
key_t
 
tKey
, 
iMode
)

22 : 
	$m_tKey
(
tKey
)

24 
m_bCe
 = 
l
;

25 
	`Ce
(
m_tKey
, 
iMode
);

26 
	}
}

28 
	gCSemObj
::~
	$CSemObj
()

30 if(
m_bCe
)

31 
	`Remove
();

32 
	}
}

34 
	gCSemObj
::
	$Ce
(
key_t
 
tKey
, 
iMode
)

36 
m_tKey
 = 
tKey
;

37 if(
m_iSemId
 = 
	`mg
(
m_tKey
, 1, 
IPC_CREAT
 | 
IPC_EXCL
 | 
iMode
)) < 0 )

39 if(
o
 !
EEXIST
)

41 
	`
("semget(IPC_CREAT) fail");

44 if(
m_iSemId
 = 
	`mg
(
m_tKey
, 1, 
iMode
)) < 0 )

46 
	`
("semget() fail");

49 
m_bCe
 = 
l
;

53 
	`SVue
(1);

54 
m_bCe
 = 
ue
;

57 
	}
}

59 
	gCSemObj
::
	$Remove
()

61 
mun
 
unSem
;

62 
	`ml
(
m_iSemId
, 0, 
IPC_RMID
, 
unSem
);

63 
m_iSemId
 = -1;

64 
m_bCe
 = 
l
;

65 
	}
}

67 
bo
 
	gCSemObj
::
	$mTake
()

69 
mbuf
 
mb
;

70 
mb
.
m_num
 = 0;

71 
mb
.
m_
 = -1;

72 
mb
.
m_g
 = 
SEM_UNDO
;

73 if
	`m
(
m_iSemId
, &
mb
, 1) < 0 )

75 if(
o
 =
EAGAIN
 ||n=
EINTR
)

77  
l
;

79  
l
;

81  
ue
;

82 
	}
}

84 
	gCSemObj
::
	$mGive
()

86 
mbuf
 
mb
;

87 
mb
.
m_num
 = 0;

88 
mb
.
m_
 = 1;

89 
mb
.
m_g
 = 
SEM_UNDO
;

90 
	`m
(
m_iSemId
, &
mb
, 1);

91 
	}
}

93 
	gCSemObj
::
	$SVue
(
iVue
)

95 
mun
 
unSem
;

96 
unSem
.
v
 = 
iVue
;

97 
	`ml
(
m_iSemId
, 0, 
SETVAL
, 
unSem
);

98 
	}
}

100 
	gCSemObj
::
	$GVue
()

102 
mun
 
unSem
;

103 
iVue
 = 
	`ml
(
m_iSemId
, 0, 
GETVAL
, 
unSem
);

104  
iVue
;

105 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/semObj.h

4 #ide
_SEMOBJ_H_


5 
	#_SEMOBJ_H_


	)

7 
	~<sys/tys.h
>

8 
	~<sys/c.h
>

9 
	~<sys/m.h
>

12 #i
defed
(
__GNU_LIBRARY__
&& !defed(
_SEM_SEMUN_UNDEFINED
)

16 
	umun
 {

17 
	mv
;

18 
mid_ds
 *
	mbuf
;

19 *
	my
;

20 
mfo
 *
	m__buf
;

26 as
	cCSemObj


28 
	meed
:

29 
m_iSemId
;

30 
key_t
 
	mm_tKey
;

31 
bo
 
	mm_bCe
;

33 
	mpublic
:

34 
CSemObj
();

35 
CSemObj
(
key_t
 
tKey
, 
iMode
 = 0600);

36 
	mvtu
 ~
CSemObj
();

38 
Ce
(
key_t
 
tKey
, 
iMode
 = 0600);

39 
Remove
();

40 
bo
 
mTake
();

41 
mGive
();

42 
SVue
(
iVue
);

43 
GVue
();

45 
bo
 
	$IfCe
({  
m_bCe
; }

46 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/shm.cpp

4 
	~<dio.h
>

5 
	~<dlib.h
>

6 
	~<rg.h
>

7 
	~<dg.h
>

8 
	~<y.h
>

9 
	~<o.h
>

11 
	~"shm.h
"

14 
	gCShm
::
	$CShm
()

16 
m_pchShm
 = 
NULL
;

17 
m_bCe
 = 
l
;

18 
m_tShmKey
 = 
	`ok
(".", 'm');

19 
m_iShmSize
 = 0;

20 
	}
}

22 
	gCShm
::
	$CShm
(
key_t
 
tKey
, 
iSize
, 
iMode
)

23 : 
	`m_tShmKey
(
tKey
), 
	$m_iShmSize
(
iSize
)

25 
	`GShm
(
iMode
);

26 
	`AachShm
();

27 
	}
}

29 
	gCShm
::~
	$CShm
()

31 
	`DachShm
();

32 
	`RemoveShm
();

33 
	}
}

35 
	gCShm
::
	$GShm
(
iMode
)

38 if(
m_iShmId
 = 
	`shmg
(
m_tShmKey
, 
m_iShmSize
, 
IPC_CREAT
 | 
IPC_EXCL
 | 
iMode
)) < 0 )

40 if(
o
 !
EEXIST
)

42 
	`
("shmget(IPC_CREAT) fail");

46 if(
m_iShmId
 = 
	`shmg
(
m_tShmKey
, 
m_iShmSize
, 
iMode
)) < 0 )

48 
	`
("shmget() fail");

51 
m_bCe
 = 
l
;

54 
m_bCe
 = 
ue
;

56 
	}
}

58 
	gCShm
::
	$On
(
key_t
 
tKey
, 
iSize
, 
iMode
)

60 
m_tShmKey
 = 
tKey
;

61 
m_iShmSize
 = 
iSize
;

62 if(
m_iShmId
 = 
	`shmg
(
m_tShmKey
, 
m_iShmSize
, 
iMode
)) < 0 )

64 
	`
("shmget() fail");

67 
m_bCe
 = 
l
;

69 
	}
}

71 
	gCShm
::
	$Ce
(
key_t
 
tKey
, 
iSize
, 
iMode
)

73 
m_tShmKey
 = 
tKey
;

74 
m_iShmSize
 = 
iSize
;

75 if(
m_iShmId
 = 
	`shmg
(
m_tShmKey
, 
m_iShmSize
, 
IPC_CREAT
 | 
IPC_EXCL
 | 
iMode
)) < 0 )

77 
	`
("shmget(IPC_CREAT) fail");

80 
m_bCe
 = 
ue
;

82 
	}
}

84 
	gCShm
::
	$AachShm
()

86 
	`tf
(" shmid = %d\n", 
m_iShmId
);

87 
m_pchShm
 = (*)
	`shm
(
m_iShmId
, 
NULL
, 0);

88 if()
m_pchShm
 < 0 )

90 
	`
("shmat fail");

92  (()
m_pchShm
);

93 
	}
}

95 
	gCShm
::
	$DachShm
()

97 if()
m_pchShm
 <= 0 ) ;

98 if
	`shmdt
(
m_pchShm
) < 0 )

100 
	`
("shmdt fail");

103 
m_pchShm
 = 
NULL
;

104 
	}
}

106 
	gCShm
::
	$RemoveShm
()

108 if!
m_bCe
 ) ;

109 if
	`shml
(
m_iShmId
, 
IPC_RMID
, 
NULL
) < 0 )

111 
	`
("shmctl(IPC_RMID) fail");

114 
m_bCe
 = 
l
;

115 
	}
}

117 
	gCShm
::
	$InShmV
()

119 
	`memt
(
m_pchShm
, 0, 
m_iShmSize
);

120 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/shm.h

4 #ide
_SHM_H_DEF_


5 
	#_SHM_H_DEF_


	)

7 
	~<sys/c.h
>

8 
	~<sys/shm.h
>

11 as
	cCShm


13 
	mpublic
:

14 
CShm
();

15 
CShm
(
key_t
 
tKey
, 
iSize
, 
iMode
=0600);

16 
	mvtu
 ~
CShm
();

18 
	meed
:

19 
key_t
 
m_tShmKey
;

20 
	mm_iShmSize
;

22 
	mm_bCe
;

23 
	mm_iShmId
;

24 * 
	mm_pchShm
;

26 
	mpublic
:

27 
GShm
(
iMode
=0600);

28 
AachShm
();

29 
DachShm
();

30 
RemoveShm
();

31 
InShmV
();

32 
bo
 
	$IfCe
({  
m_bCe
; }

33 * 
	$GMemy
({  
m_pchShm
; 
	}
}

34 
	$GMemSize
({  
m_iShmSize
; 
	}
}

36 
On
(
key_t
 
tKey
, 
iSize
, 
iMode
=0600);

37 
Ce
(
key_t
 
tKey
, 
iSize
, 
iMode
=0600);

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/procman/CWatchDog.cpp

1 
	~"CWchDog.h
"

2 
	~<dio.h
>

3 
	~<sys/tys.h
>

4 
	~<sys/.h
>

5 
	~<f.h
>

6 
	~<sys/iol.h
>

7 
	~<lux/wchdog.h
>

8 
	~<unid.h
>

10 
	gCWchDog
::
	$CWchDog
()

13 
fd
 = -1 ;

14 
	}
}

16 
	gCWchDog
::~
	$CWchDog
()

19 
	}
}

21 
CWchDog
::
	$OnWchDog
( )

23 
fd
 = 
	`ݒ
"/dev/wchdog" ,
O_RDWR
);

24 i(
fd
 < 0)

26 
	`tf
("Open WDT Dev Error!\n");

30 
	`SWchDogTimeOut
( ) ;

31 
	`SWchDogO
( ) ;

33  
fd
 ;

34 
	}
}

36 
	gCWchDog
::
	$SWchDogTimeOut
( )

38 if
	`GWchDogS
( ) < 0 )

40 
	`tf
( "WatchDog Isot Open !\n" ) ;

44 
cmd
 = -1 ;

45 
cmd
 = 
WDIOC_SETTIMEOUT
;

46 
g
 = 60;

47 
iRu
 = 
	`iol
(
fd
, 
cmd
 , &
g
 ) ;

49 i(
iRu
 < 0)

51 
	`tf
("Call cmd Settimerout fail\n");

55  
iRu
 ;

56 
	}
}

58 
	gCWchDog
::
	$SWchDogO
( )

60 if
	`GWchDogS
( ) < 0 )

62 
	`tf
( "WatchDog Isot Open !\n" ) ;

66 
cmd
 = -1 ;

67 
cmd
 = 
WDIOC_SETOPTIONS
;

68 
iRu
 = 
	`iol
(
fd
, 
cmd
) ;

70 i
iRu
 < 0)

72 
	`tf
("Call cmd Start WDT fail\n");

76  
iRu
 ;

77 
	}
}

79 
	gCWchDog
::
	$FdDog
( )

81 if
	`GWchDogS
( ) < 0 )

87 
cmd
 = -1 ;

88 
cmd
 = 
WDIOC_KEEPALIVE
;

89 
iRu
 = 
	`iol
(
fd
, 
cmd
) ;

91 i
iRu
 < 0)

93 
	`tf
("Call cmd Feedwatchdog fail\n");

97  
iRu
 ;

98 
	}
}

100 
	gCWchDog
::
	$oWchDog
( )

102 if
	`GWchDogS
( ) < 0 )

104 
	`tf
( "WatchDog Isot Open !\n" ) ;

109 
iRe
 = 
	`o

fd
 ) ;

110  
iRe
 ;

111 
	}
}

114 
	gCWchDog
::
	$GWchDogS
( )

116  
fd
 ;

117 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/procman/CWatchDog.h

1 #ide
CWATCHDOG_H


2 
	#CWATCHDOG_H


	)

5 as
	cCWchDog


7 
	mpublic
:

8 
CWchDog
();

9 
	mvtu
 ~
CWchDog
();

10 
OnWchDog
( ) ;

11 
oWchDog
( ) ;

12 
FdDog
( ) ;

13 
	meed
:

14 
ive
:

15 
fd
 ;

16 
SWchDogTimeOut
( ) ;

17 
SWchDogO
( ) ;

18 
GWchDogS
( ) ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/procman/main.cpp

1 
	~<dio.h
>

2 
	~<dlib.h
>

3 
	~<rg.h
>

4 
	~<y.h
>

5 
	~<f.h
>

6 
	~<unid.h
>

7 
	~<dg.h
>

8 
	~<sys/iol.h
>

9 
	~<sys/mm.h
>

10 
	~<sys/tys.h
>

11 
	~<sys/m.h
>

12 
	~<sys/.h
>

13 
	~<sys/time.h
>

14 
	~<o.h
>

15 
	~<sigl.h
>

16 
	~<sys/bo.h
>

17 
	~<lux/kl.h
>

18 
	~<sys/sysfo.h
>

20 
	~"oc.h
"

21 
	~"../she/glob.h
"

22 
	~"CWchDog.h
"

23 
	~"../Proc/SockF/CSockF.h
"

25 
	#WATCHDOG


	)

26 
	#RUN_LED_NUM
 1

27 
	#WDOG_TIMEOUT
 5

	)

29 
	#CMD_SET_LEDRUN_ON
 21

30 
	#CMD_SET_LEDRUN_OFF
 22

31 

	)

34 
	gg_szAPh
[64] = {"/mynand"};

36 
	gg_szEnviV
[160] = {"LD_LIBRARY_PATH=/mynand/usrlib"};

38 
BOOL
 
	gg_bARun
 = 
TRUE
;

39 
WORD
 
	gg_wALED
 = 0x0001;

40 
	gg_hLedPt
 = -1;

42 
	gg_nWDogTout
 = 0;

43 
	gg_hWchDog
 = -1;

45 
PROC_DB
 
	gg_ProcDB
;

46 
CWchDog
 
	gg_Wchdog
 ;

49 #ifdef 
__lulus


53 
ady_rug
(cڡ *
fame
);

54 
rim
(*
s
);

55 
rim
(*
s
);

56 
OutPromText
(*
szText
);

57 
LogPromText
(cڡ *
fmt
, ...);

58 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
);

59 
SiglHook
(
iSigNo
, 
LPSIGPROC
 
func
);

60 
_dm
();

61 
SignHdr
(
signum
, 
sigfo_t
 *
pInfo
, *
pRerved
)

63 
g_bARun
 = 
FALSE
;

65 #ifdef 
__lulus


70 
	$InProcPam
()

72 
i
, 
j
;

73 
g_ProcDB
.
wCou
 = 0;

74 
g_ProcDB
.
wag
 = 0;

75 
i
=0; i<
PROC_MAX_SUM
; i++)

77 
g_ProcDB
.
oc
[
i
].
wProcTy
 = 0;

78 
g_ProcDB
.
oc
[
i
].
wSMode
 = 0;

79 
g_ProcDB
.
oc
[
i
].
lSTime
 = 0;

80 
g_ProcDB
.
oc
[
i
].
szDesibe
[0] = '\0';

81 
g_ProcDB
.
oc
[
i
].
szExecPh
[0] = '\0';

82 
g_ProcDB
.
oc
[
i
].
szProcName
[0] = '\0';

83 
g_ProcDB
.
oc
[
i
].
szPam
[0] = '\0';

84 
j
=0; j<
PARA_MAX_SUM
+2; j++)

85 
g_ProcDB
.
oc
[
i
].
gv
[
j
] = 0;

86 
g_ProcDB
.
oc
[
i
].
hPross
 = -1;

87 
g_ProcDB
.
oc
[
i
].
nRunS
 = 0;

88 
g_ProcDB
.
oc
[
i
].
nETim
 = 0;

89 
g_ProcDB
.
oc
[
i
].
nReeNum
 = 0;

91 
	}
}

93 
	#CONFIG_ENV_VAR
 0x1001

	)

94 
	#CONFIG_PROC_STYLE
 0x2001

	)

95 
	#CONFIG_PROC_PARAM
 0x2002

	)

97 
	$PCfigIm
(*
rIm
, 
WORD
 *
pwNum
)

99 
rTy
[32];

100 
i
, 
nL
;

102 if
	`rr
(
rIm
, "v" 
CONFIG_ENV_VAR
;

103 
i
 = 0;

104 
nL
 = 
	`
(
rIm
);

105  !
	`isdig
(
rIm
[
i
]&& i<()(
rTy
) )

107 
rTy
[
i
] = 
	`tou
(
rIm
[i]);

108 if++
i
 >
nL
 ) ;

111 
rTy
[
i
] = '\0';

112 if
i
 >
nL
 ) *
pwNum
 = 0;

113 *
pwNum
 = (
WORD
)
	`oi
(&
rIm
[
i
]);

115 if
	`rcmp
(
rTy
, "PROC") == 0 )

116  
CONFIG_PROC_STYLE
;

117 if
	`rcmp
(
rTy
, "PARA") == 0 )

118  
CONFIG_PROC_PARAM
;

120 
	}
}

122 * 
	$GFeName
(* 
szPh
)

124 
i
, 
nL
;

125 *
p
 = 
szPh
;

127 
nL
 = 
	`
(
szPh
);

128 if
nL
 <0 )  
NULL
;

129 
i
=
nL
-1; i>0; i--)

131 if
szPh
[
i
]=='\\' ||

132 
szPh
[
i
]=='/' )

134 
p
 = &
szPh
[
i
+1];

138  
p
;

139 
	}
}

141 
BOOL
 
	$SProcArib
(
WORD
 
wNum
, * 
szPam
)

143 
i
 = 0;

144 *
tok
, *
p
;

145 if
wNum
 >
PROC_MAX_SUM
 )  
FALSE
;

146 if
	`
(
szPam
<0 )  
FALSE
;

148 
tok
 = 
	`ok
(
szPam
, ",");

149  
tok
 )

151 
	`rim
(
tok
);

152 
i
)

155 
	`rtf
(
g_ProcDB
.
oc
[
wNum
].
szDesibe
, 
tok
);

158 
	`rtf
(
g_ProcDB
.
oc
[
wNum
].
szExecPh
, 
tok
);

159 
p
 = 
	`GFeName
(
tok
);

160 if
p
 ) 
	`rtf
(
g_ProcDB
.
oc
[
wNum
].
szProcName
,);

161 
g_ProcDB
.
oc
[
wNum
].
gv
[0] = g_ProcDB.oc[wNum].
szProcName
;

164 
g_ProcDB
.
oc
[
wNum
].
wProcTy
 = (
WORD
)
	`oi
(
tok
);

167 
g_ProcDB
.
oc
[
wNum
].
wSMode
 = (
WORD
)
	`oi
(
tok
);

170 
g_ProcDB
.
oc
[
wNum
].
lSTime
 = (
LONG
)
	`
(
tok
);

175 
tok
 = 
	`ok
(
NULL
, ",");

176 
i
++;

178  
TRUE
;

179 
	}
}

181 
	$GPamAay
(
WORD
 
wNum
, *
szText
)

183 
i
 = 0;

184 *
s
 = 
szText
;

185 *
p
 = 
g_ProcDB
.
oc
[
wNum
].
szPam
;

186 
g_ProcDB
.
oc
[
wNum
].
gv
[1] = 
p
;

188  (*
p
 = *
s
++) != 0 )

190 if*
p
==' ' && (*
s
==' ' || *s=='\0') )

194 if*
p
=='[' || *p==']' || *p=='(' || *p==')' )

199 if*
p
 != ' ' && *p != '\t' )

201 
p
++;

205 *
p
++ = '\0';

206 if(
i
>=
PARA_MAX_SUM
)

209 
g_ProcDB
.
oc
[
wNum
].
gv
[2+
i
] = 
p
;

210 
i
++;

213 *
p
++ = '\0';

223 
	}
}

225 
BOOL
 
	$RdProcCfig
()

227 
FILE
 *
hFe
;

228 
szText
[160];

229 *
pIm
, *
pPam
;

230 
WORD
 
wNum
;

233 
	`rtf
(
szText
, "%s/ocm.cf", 
g_szAPh
);

234 
hFe
 = 
	`fݒ
(
szText
, "r");

235 if
hFe
 >0 )

237 
	`LogPromText
("Of%ok.\n", 
szText
);

238  
	`fgs
(
szText
, (szText), 
hFe
) )

241 
	`rim
(
szText
);

243 if
szText
[0]==';' || szText[0]=='#' ) ;

245 
pIm
 = 
	`ok
(
szText
, "=");

246 if
pIm
 =
NULL
 ) ;

247 
pPam
 = 
	`ok
(
NULL
, "@");

249 if
pPam
 )

251 
	`rim
(
pPam
);

253 
nTy
 = 
	`PCfigIm
(
pIm
, &
wNum
);

255  
nTy
 )

257 
CONFIG_ENV_VAR
:

258 
	`rtf
(
g_szEnviV
, 
pPam
);

260 
CONFIG_PROC_STYLE
:

261 
	`SProcArib
(
g_ProcDB
.
wCou
, 
pPam
);

262 
g_ProcDB
.
wCou
++;

264 
CONFIG_PROC_PARAM
:

265 
	`GPamAay
(
wNum
-1, 
pPam
);

270 
	`fo
(
hFe
);

273  
FALSE
 ;

275  
TRUE
 ;

276 
	}
}

278 
pid_t
 
	$SChdProc
(* 
szPh
, *
gv
[])

280 
pid_t
 
chd
;

282 
chd
 = 
	`fk
();

283 if
chd
 < 0 )

285 
	`
("Create childrocess fail");

290 if
chd
 == 0 )

292 if
	`execv
(
szPh
, 
gv
) < 0 )

294 
	`

szPh
 );

295 
	`ex
(-2);

300  
chd
;

301 
	}
}

303 
	$SAProc
()

305 
i
;

306 
pid_t
 
chd
;

308 
i
=0; i<
g_ProcDB
.
wCou
; i++)

311 if(
g_ProcDB
.
oc
[
i
].
lSTime
>0)

312 
	`p

g_ProcDB
.
oc
[
i
].
lSTime
 );

313 
	`LogPromText
("................................startrocess(%s)................................\n",

314 
g_ProcDB
.
oc
[
i
].
szExecPh
);

315 
chd
 = 
	`SChdProc
(
g_ProcDB
.
oc
[
i
].
szExecPh
, g_ProcDB.oc[i].
gv
);

316 if
chd
 > 0 )

318 
	`LogPromText
("oss(%s衬did=%u\n", 
g_ProcDB
.
oc
[
i
].
szDesibe
, 
chd
);

319 
g_ProcDB
.
oc
[
i
].
hPross
 = 
chd
;

320 
g_ProcDB
.
oc
[
i
].
nRunS
 = 1;

321 
g_ProcDB
.
oc
[
i
].
nETim
 = 0;

322 
g_ProcDB
.
oc
[
i
].
nReeNum
 = 0;

326 
g_ProcDB
.
wag
 = 1;

327 
	}
}

329 
	sru_oc


331 
pid
;

332 
exName
[
_POSIX_PATH_MAX
];

333 
e
;

336 
euid
,

337 
egid
;

338 
id
;

339 
pg
;

340 
ssi
;

341 
y
;

342 
gid
;

343 
ags
;

344 
mt
;

345 
cmt
;

346 
majt
;

347 
cmajt
;

348 
utime
;

349 
ime
;

350 
cutime
;

351 
cime
;

352 
cou
;

353 
iܙy
;

354 
timeout
;

355 
vue
;

356 
ime
;

357 
vsize
;

358 
rss
;

359 
im
;

360 
tcode
;

361 
dcode
;

362 
tack
;

363 
kke
;

364 
kke
;

365 
sigl
;

366 
blocked
;

367 
sigigne
;

368 
sigtch
;

369 
wch
;

370 
sched
,

371 
sched_iܙy
;

372 } 
	tocfo
;

374 
	$GProssInfo

pid_t
 
pid
, 
ocfo
 *
pfo
 )

376 
FILE
 *

;

377 
szFeName
[
FILENAME_MAX
];

378 
szSt
[2048], *
s
, *
t
;

379 

 

;

381 
	`rtf

szFeName
, "/oc/%d/", 
pid
 );

383 if-1 =
	`acss
(
szFeName
, 
F_OK
) )  -1;

385 if-1 =
	`acss
(
szFeName
, 
R_OK
) )  0;

387 if-1 !
	`
(
szFeName
, &

) )

389 
pfo
->
euid
 = 

.
_uid
;

390 
pfo
->
egid
 = 

.
_gid
;

394 
pfo
->
euid
 =fo->
egid
 = 0;

397 if(

 = 
	`fݒ
(
szFeName
, "r")=
NULL
 )  0;

399 if(
s
 = 
	`fgs
(
szSt
, (szSt), 

)=
NULL
 )

401 
	`fo
(

);

405 
	`ssnf
(
szSt
, "%u", &(
pfo
->
pid
));

407 
s
 = 
	`rchr
(
szSt
, '(') + 1;

408 
t
 = 
	`rchr
(
szSt
, ')');

409 
	`y
(
pfo
->
exName
, 
s
, 
t
-s);

410 
pfo
->
exName
[
t
-
s
] = '\0';

412 
	`ssnf

t
 + 2, "%c %d %d %d %d %d %u %u %u %u %u %d %d %d %d %d %d %u %u %d %u %u %u %u %u %u %u %u %d %d %d %d %u",

414 &(
pfo
->
e
),

415 &(
pfo
->
id
),

416 &(
pfo
->
pg
),

417 &(
pfo
->
ssi
),

418 &(
pfo
->
y
),

419 &(
pfo
->
gid
),

420 &(
pfo
->
ags
),

421 &(
pfo
->
mt
),

422 &(
pfo
->
cmt
),

423 &(
pfo
->
majt
),

424 &(
pfo
->
cmajt
),

425 &(
pfo
->
utime
),

426 &(
pfo
->
ime
),

427 &(
pfo
->
cutime
),

428 &(
pfo
->
cime
),

429 &(
pfo
->
cou
),

430 &(
pfo
->
iܙy
),

431 &(
pfo
->
timeout
),

432 &(
pfo
->
vue
),

433 &(
pfo
->
ime
),

434 &(
pfo
->
vsize
),

435 &(
pfo
->
rss
),

436 &(
pfo
->
im
),

437 &(
pfo
->
tcode
),

438 &(
pfo
->
dcode
),

439 &(
pfo
->
tack
),

440 &(
pfo
->
kke
),

441 &(
pfo
->
kke
),

442 &(
pfo
->
sigl
),

443 &(
pfo
->
blocked
),

444 &(
pfo
->
sigigne
),

445 &(
pfo
->
sigtch
),

446 &(
pfo
->
wch
) );

448 
	`fo
(

);

450 
	}
}

452 
	$GProssSt

pid_t
 
pid
 )

454 
FILE
 *

;

455 
szFeName
[
FILENAME_MAX
];

456 
szSt
[1024], *
s
;

457 
pid_t
 
idProc
;

458 
szExeName
[64], 
e
='X';

460 
	`rtf

szFeName
, "/oc/%d/", 
pid
 );

462 if-1 =
	`acss
(
szFeName
, 
F_OK
) )  -1;

464 if-1 =
	`acss
(
szFeName
, 
R_OK
) )  0;

466 if(

 = 
	`fݒ
(
szFeName
, "r")=
NULL
 )  0;

468 if(
s
 = 
	`fgs
(
szSt
, (szSt), 

)=
NULL
 )

470 
	`fo
(

);

481 
	`ssnf

szSt
, "%u %%c", &
idProc
, 
szExeName
, &
e
 );

482 
	`fo
(

);

485  
e
;

486 
	}
}

488 
	$WchAProc
(
WORD
 
wSecd
)

490 
i
, 
e
;

491 
pid_t
 
chd
;

493  
i
=0; i<
g_ProcDB
.
wCou
; i++ )

495 if
g_ProcDB
.
oc
[
i
].
hPross
 < 0 ) ;

496 
e
 = 
	`GProssSt
(
g_ProcDB
.
oc
[
i
].
hPross
);

499 if
e
 < 0 || state=='Z' )

501 
g_ProcDB
.
oc
[
i
].
nRunS
 = 3;

502 
g_ProcDB
.
oc
[
i
].
nETim
 +
wSecd
;

503 if
g_ProcDB
.
oc
[
i
].
nETim
 < 30 ) ;

505 
g_ProcDB
.
oc
[
i
].
nETim
 = 0;

506 
g_ProcDB
.
oc
[
i
].
nReeNum
++;

507 if
g_ProcDB
.
oc
[
i
].
wProcTy
 < 2 )

509 
chd
 = 
	`SChdProc
(
g_ProcDB
.
oc
[
i
].
szExecPh
, g_ProcDB.oc[i].
gv
);

510 if
chd
 > 0 )

512 
	`LogPromText
("oss(%s:%uok \n", 
g_ProcDB
.
oc
[
i
].
szDesibe
, 
chd
);

513 
g_ProcDB
.
oc
[
i
].
hPross
 = 
chd
;

514 
g_ProcDB
.
oc
[
i
].
nRunS
 = 1;

515 
g_ProcDB
.
oc
[
i
].
nETim
 = 0;

516 
g_ProcDB
.
oc
[
i
].
nReeNum
 = 0;

520 
g_ProcDB
.
oc
[
i
].
wProcTy
)

525 if(
g_ProcDB
.
oc
[
i
].
nReeNum
>3)

527 
g_ProcDB
.
wag
 = 2;

528 
g_bARun
 = 
FALSE
;

537 
g_ProcDB
.
wag
 = 2;

538 
g_bARun
 = 
FALSE
;

542 if(
e
=='R' || state=='S')

544 if
g_ProcDB
.
oc
[
i
].
nRunS
 != 2 )

545 
g_ProcDB
.
oc
[
i
].
nRunS
 = 2;

546 
g_ProcDB
.
oc
[
i
].
nETim
 = 0;

547 
g_ProcDB
.
oc
[
i
].
nReeNum
 = 0;

550 
	}
}

554 
	ggpiofd
 = -1 ;

555 
	$OnRunLed
( )

558 
gpiofd
 = 
	`ݒ
"/dev/gpio_drv" , 
O_RDWR
);

559 if
gpiofd
 < 0 )

561 
gpiofd
 = -1 ;

564 
	}
}

566 
	$CloRunL
( )

568 if
gpiofd
 >= 0 )

570 
	`o
(
gpiofd
);

571 
gpiofd
 = -1 ;

573 
	}
}

575 
	$RunLed
( )

577 
BYTE
 
byV
 = 0 ;

578 
byV
 ^= 1 ;

580 
bOn
 = 
CMD_SET_LEDRUN_OFF
 ;

581 if
byV
 )

582 
bOn
 = 
CMD_SET_LEDRUN_ON
 ;

584 
	`iol
(
gpiofd
, 
bOn
, 0);

585 
	}
}

595 
	$CeSockF
 ( 
CSockF
 **
pSockF
 )

597 
	`mkd
( "/myapp/bak", 0755 );

598 
	`mkd
( "/mynand/bak",0755 );

599 
	`mkd
( "/myapp/downuser", 0755 );

600 
	`mkd
( "/mynand/downprgm", 0755 );

602 *
pSockF
 = 
w
 
	`CSockF
( );

603 if
NULL
 =*
pSockF
 ) )

605 
	`tf
 ( "CreateSocketFtp failed\n" );

609 if!*
pSockF
 )->
	`In
() )

611 
	`tf
 ( "CreateSocketFtp Init failed\n" );

615 if!*
pSockF
 )->
m_pPro
->
m_FFe
.
	`IsFeExi

FTP_FILE_LIST
 ) )

617 *
pSockF
 )->
m_pPro
->
m_FFe
.
	`UpdeCfg
();

621 *
pSockF
 )->
	`CeThad
( );

625 
	}
}

628 
	$ma
(
gc
, **
gv
)

630 
nSecd
 = 5;

631 
timev
 
tv
;

633 i
	`ady_rug
( "/mynand/config/procman.lock" ) )

635 
	`tf
 ( "the Procman isunning \n" );

639 
	`tf
 ( "the Procman Begino Run\n" );

641 
	`tf
("------------Start Process Manager------------\n");

642 if
gc
>=4 && 
	`oi
(
gv
[3])>0 )

644 
	`_dm
();

648 
	`SiglHook
(
SIGTERM
, 
SignHdr
);

650 
g_bARun
 = 
TRUE
;

652 
	`SiglHook
(
SIGINT
, 
SignHdr
);

653 
	`SiglHook
(
SIGQUIT
, 
SignHdr
);

654 
	`SiglHook
(
SIGSTOP
, 
SignHdr
);

656 
	`sigl
(
SIGCHLD
, 
SIG_IGN
);

659 
	`InProcPam
();

662 if
gc
 >2 ) 
	`rtf
(
g_szAPh
, "%s", 
gv
[1]);

663 if
gc
 >3 ) 
g_nWDogTout
 = 
	`oi
(
gv
[2]);

665 
	`tf
("---------------Init ProcTable----------------\n");

667 if!
	`RdProcCfig
() )

669 
	`tf
( "Read Parameter File Failed! Exit! \n" );

670 
	`ex
( -1 ) ;

675 
	`tf
("ProsSum = %d\n", 
g_ProcDB
.
wCou
);

681 
	`tf
("---------------Manager Running---------------\n");

683 
	`SAProc
();

684 
	`p
(1);

687 
	`OnRunLed
( ) ;

690 #ifde
WATCHDOG


691 if
g_nWDogTout
 > 0 )

693 
g_hWchDog
 = 
g_Wchdog
.
	`OnWchDog
() ;

697 
nSecd
 = 0;

698  
g_bARun
 )

700 
tv
.
tv_c
 = 0;

701 
tv
.
tv_uc
 = 500 * 1000 ;

702 
	`
(0, 
NULL
, NULL, NULL, &
tv
);

703 #ifde
WATCHDOG


705 
g_Wchdog
.
	`FdDog
() ;

708 if++
nSecd
 >= 6 )

710 
nSecd
 = 0;

711 
	`WchAProc
(3);

715 
	`RunLed
() ;

717 
	`tf
("----------------Exit Manager----------------\n");

720 
	`CloRunL
() ;

723 if(
g_ProcDB
.
wag
==2)

725 
	`sync
();

726 
	`bo
(
RB_AUTOBOOT
);

730 #ifde
WATCHDOG


732 if
g_hWchDog
 >= 0 )

734 
g_Wchdog
.
	`oWchDog
() ;

739 
	}
}

741 
	$GRlSysMemy
( )

743 
sysfo
 
s_fo
;

744 
r
 = -1 ;

746 
r
 = 
	`sysfo
(&
s_fo
);

747 
	`tf
"\RAM:ٮ %ld f%ld \n" , 
s_fo
.
tٮm
, s_fo.
䓿m
);

749  
r
 ;

750 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/procman/proc.h

5 #ide
_PROCDEF_H__


6 
	#_PROCDEF_H__


	)

8 
	~"../she/tydef.h
"

10 
	#PROC_MAX_SUM
 16

	)

11 
	#PROC_NAME_LEN
 24

	)

12 
	#PROC_PATH_LEN
 64

	)

14 
	#PARA_MAX_SUM
 4

	)

15 
	#PROC_PARA_LEN
 96

	)

17 #i
defed
(
__unix
)

18 
	#END_PROC_SIGNAL
 
SIGKILL


	)

19 #i
defed
(
WIN32
)

20 
	#END_PROC_SIGNAL
 
WM_CLOSE


	)

24 
	eAUTOSTARTMODE


26 
	mNOTSTART
 = 0,

27 
	mRESPAWN
,

28 
	mSTARTAT
,

29 
	mSTARTCYCLE


32 
	eProcS


34 
	mPROC_NOEXIST
 = 0,

35 
	mPROC_START
,

36 
	mPROC_RUN
,

37 
	mPROC_ERROR
,

38 
	mPROC_STOP
,

42 #agm
ck
(1)

47 
WORD
 
	mwCou
;

48 
WORD
 
	mwag
;

49 
	s_gProc


51 
WORD
 
	mwProcTy
;

52 
WORD
 
	mwSMode
;

53 
LONG
 
	mlSTime
;

54 
	mszDesibe
[
PROC_NAME_LEN
];

55 
	mszExecPh
[
PROC_PATH_LEN
];

56 
	mszProcName
[
PROC_NAME_LEN
];

57 
	mszPam
[
PROC_PARA_LEN
];

59 *
	mgv
[
PARA_MAX_SUM
+2];

61 
pid_t
 
	mhPross
;

62 
	mnRunS
;

63 
	mnETim
;

64 
	mnReeNum
;

65 }
	moc
[
PROC_MAX_SUM
];

66 }
	tPROC_DB
;

68 
GRlSysMemy
( ) ;

69 #agm
ck
()

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/rdbms/rdbServer.cpp

1 
	~<dio.h
>

2 
	~<dlib.h
>

3 
	~<rg.h
>

4 
	~<y.h
>

5 
	~<f.h
>

6 
	~<unid.h
>

7 
	~<dg.h
>

8 
	~<sys/iol.h
>

9 
	~<sys/mm.h
>

10 
	~<sys/tys.h
>

11 
	~<sys/m.h
>

12 
	~<sys/.h
>

13 
	~<sys/time.h
>

14 
	~<o.h
>

15 
	~<sigl.h
>

17 
	~"../she/rdbFun.h
"

18 
	~"../she/glob.h
"

20 
	#RUN_LED_NUM
 2

	)

22 
	gg_szAPh
[64] = {"/mynand"};

23 
BOOL
 
	gg_bARun
 = 
TRUE
;

24 
	gg_nBusKeyID
 = -1;

29 #ifdef 
__lulus


32 
ady_rug
(cڡ *
fame
);

34 
SignHdr
(
signum
, 
sigfo_t
 *
pInfo
, *
pRerved
)

36 
g_bARun
 = 
FALSE
;

39 
RTDB_Tim_Proc
(
wSecd
);

40 
SiglHook
(
iSigNo
, 
LPSIGPROC
 
func
);

41 
_dm
();

43 #ifdef 
__lulus


48 
	$ma
(
gc
, **
gv
)

50 
nTicks
=0;

51 
MSGITEM
 
msgRecv
;

53 i
	`ady_rug
( "/mynand/config/rdbSever.lock" ) )

55 
	`tf
 ( "thedbSever isunning \n" );

59 
	`tf
 ( "thedbSever Begino Run\n" );

61 if
gc
 >2 ) 
	`rtf
(
g_szAPh
, "%s", 
gv
[1]);

62 if
gc
 >= 3 )

64 if
	`oi
(
gv
[2]) > 0 )

66 
	`_dm
();

69 
	`SiglHook
(
SIGTERM
, 
SignHdr
);

70 
g_bARun
 = 
TRUE
;

71 
	`SiglHook
(
SIGINT
, 
SignHdr
);

72 
	`SiglHook
(
SIGQUIT
, 
SignHdr
);

73 
	`SiglHook
(
SIGSTOP
, 
SignHdr
);

77 
	`tf
("----------------start RTDB Server----------------\n");

78 if
	`Ce_SHM_DBa
(
g_szAPh
, 0) < 0 )

80 if
	`On_SHM_DBa
() < 0 )

81 
	`ex
(-1);

84 
	`ShowRTDBInfo
();

88 
g_nBusKeyID
 = 
	`LogMesgeBus
((*)"RDBServer");

90 
	`MesgeSubsibe
(
g_nBusKeyID
, 0x00000C00);

91 
	`tf
("---------------RTDB Server Running---------------\n");

93 
timev
 
tv
;

94 
g_bARun
)

96  
	`MesgeRecv
(
g_nBusKeyID
, &
msgRecv
, 0) > 0 )

100 if++
nTicks
 >= 4 )

102 
nTicks
 = 0;

103 
	`RTDB_Tim_Proc
(1);

107 
tv
.
tv_c
 = 0;

108 
tv
.
tv_uc
 = 250000;

109 
	`
(0, 
NULL
, NULL, NULL, &
tv
);

112 
	`tf
("----------------Exit RTDB Server----------------\n");

113 
	`ExMesgeBus
(
g_nBusKeyID
);

114 
	`Clo_SHM_DBa
();

118  
i
=0; i<6; i++ )

120 
	`tf
 ( "dbvxv%ds\n", 6-
i
 );

121 
	`up
(1000000);

123 
	`tf
("**ByeBye**\n");

126 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/BasePort.cpp

5 
	~"dio.h
"

6 
	~"dlib.h
"

7 
	~"rg.h
"

8 
	~"y.h
"

10 
	~"BaPt.h
"

11 
	~"glob.h
"

14 
	gCBaPt
::
	$CBaPt
()

16 
m_hComm
 = 0;

17 
m_bVid
 = 
FALSE
;

18 
m_wPtS
 = 0;

20 
m_byEb
 = 1;

21 
m_uThePt
 = 2044;

22 
	}
}

24 
	gCBaPt
::~
	$CBaPt
()

26 
	`CloPt
();

27 
	}
}

29 *
	$Sr
(cڡ *
s1
, cڡ *
s2
)

31 cڡ *
p
 = 
s1
;

32 cڡ 
size_t
 
n
 = 
	`
(
s2
);

33 ; (
p
 = 
	`rchr
, *
s2
)) != 0;++)

34 if(
	`cmp
(
p
,
s2
,
n
) == 0)

35  (*)
p
;

36  
NULL
;

37 
	}
}

39 
	gCBaPt
::
	$GCommArib
cڡ * 
p
, * 
szAr
, 
UINT
& 
uPt
 )

41 cڡ * 
szCl
 = 
p
;

43 if(
szCl
 =
NULL
)

45 *
pRu
 = 
	`Sr
(
szCl
, "_");

46 if
pRu
 =
NULL
 )

50 
su
;

51 
su
 = 
pRu
 - 
szCl
 + 1;

53 
cTyBuf
[ 30 ] ;

54 
	`memt

cTyBuf
 , 0 , ( cTypeBuf ) ) ;

55 
	`memy

cTyBuf
 , 
szCl
 , 
su
 ) ;

57 
BYTE
 
byComTy
 = 0 ;

58 if!
	`rcmp

cTyBuf
 , 
COMRS_232
 ) )

59 
byComTy
 = 
COMRS232
 ;

60 if!
	`rcmp

cTyBuf
 , 
COMRS_485
 ) )

61 
byComTy
 = 
COMRS485
 ;

62 if!
	`rcmp

cTyBuf
 , 
COMRS_422
 ) )

63 
byComTy
 = 
COMRS422
 ;

64 if!
	`rcmp

cTyBuf
 , 
LAN_TCP
 ) )

66 
byComTy
 = 
SOCKETTCP
 ;

68 
pRu
++ ;

69 
uPt
 = 
	`oi

pRu
 ) ;

70 
	`ry

szAr
 , "NULL" ) ;

71  
byComTy
 ;

73 if!
	`rcmp

cTyBuf
 , 
LAN_TCP_CLIENT
 ) )

74 
byComTy
 = 
TCP_CLIENT
 ;

75 if!
	`rcmp

cTyBuf
 , 
LAN_TCP_CLIENT_SHORT
 ) )

76 
byComTy
 = 
TCP_CLIENT_SHORT
 ;

81 
pRu
++ ;

82 * 
pPt
 = 
	`rr

pRu
 , ":" ) ;

83 if
pPt
 =
NULL
 )

86 
su
 = 
pPt
 - 
pRu
 ;

87 
	`memt

cTyBuf
 , 0 , ( cTypeBuf ) ) ;

88 
	`memy

cTyBuf
 , 
pRu
 , 
su
 ) ;

89 
uPt
 = 
	`oi

cTyBuf
 ) ;

92 
pPt
++ ;

93 
	`ry

szAr
 , 
pPt
 ) ;

95  
byComTy
 ;

96 
	}
}

98 
	gCBaPt
::
	$GCommArib_ig
cڡ * 
szCl
, * 
szAr
, 
UINT
& 
uPt
 )

100 
i
, 
nL
;

101 
k
, 
nSty
 = -1;

102 
szPam
[32];

103 cڡ * 
p
 = 
szCl
;

105 
k
 = 0;

106 
nL
 = 
	`
(
szCl
);

107  
i
=0; i<
nL
; i++, 
p
++ )

109 if*
p
==' ' || *p=='\t' ) { ; }

110 if!
	`isdig
(*
p
{ 
szPam
[
k
++] = 
	`tou
(*p); }

111 { 
szPam
[
k
] = '\0'; ; }

113 
	`rtf

szAr
, "%s", 
p
 );

115 if(
	`rcmp
(
szPam
, "COM")==0{ 
nSty
 = 0; }

116 if(
	`rcmp
(
szPam
, "TCP")==0{ 
nSty
 = 1; }

117 if(
	`rcmp
(
szPam
, "UDP")==0{ 
nSty
 = 2; }

118 if(
	`rcmp
(
szPam
, "CAN")==0{ 
nSty
 = 3; }

120  
k
=0; 
i
<
nL
; i++, 
p
++ )

122 if*
p
 !':' ) { 
szPam
[
k
++] = *p; }

123 { 
szPam
[
k
] = '\0'; 
p
++; ; }

125 
	`rtf

szAr
, "%s", 
p
 );

126 
uPt
 = (
UINT
)
	`oi
(
szPam
);

128  
nSty
;

129 
	}
}

131 
	gCBaPt
::
	$ReiveProc
( )

133 
	}
}

135 
BOOL
 
CBaPt
::
	$IsPtVid
( )

137  
FALSE
;

138 
	}
}

140 
	gCBaPt
::
	$CloPt
( )

142 
	}
}

144 
BOOL
 
CBaPt
::
	$OnPt
* 
szE
 )

146  
FALSE
;

147 
	}
}

149 
BOOL
 
	gCBaPt
::
	$SQueue

DWORD
 
dwInQueueSize
, DWORD 
dwOutQueueSize
 )

151  
FALSE
;

152 
	}
}

154 
	gCBaPt
::
	$GInQueue
( )

157 
	}
}

159 
	gCBaPt
::
	$GOutQueue
( )

162 
	}
}

164 
	gCBaPt
::
	$RdPt

BYTE
 *
pBuf
, 
nRd
 )

167 
	}
}

169 
	gCBaPt
::
	$WrePt

BYTE
 *
pBuf
, 
nWre
 )

172 
	}
}

174 
	gCBaPt
::
	$AsyRdDa

BYTE
 *
pBuf
, 
nRd
 )

177 
	}
}

179 
	gCBaPt
::
	$AsySdDa

BYTE
 *
pBuf
, 
nWre
 )

182 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/BasePort.h

6 #ide
_BASEPORT_H_


7 
	#_BASEPORT_H_


	)

9 
	~"tydef.h
"

14 as
	cCBaPt


17 
	mpublic
:

18 
CBaPt
();

19 
	mvtu
 ~
CBaPt
();

20 
vtu
 * 
	$CssName
(){ (*)"CBasePort";}

23 
eed
:

24 
BOOL
 
m_bVid
;

25 
HANDLE
 
m_hComm
;

26 
WORD
 
m_wPtS
;

28 
public
:

29 
BYTE
 
m_byEb
;

30 
UINT
 
m_uThePt
;

31 
m_szArib
[32];

32 
m_szLolAddr
[24];

33 
m_szRemeAddr
[24];

36 
public
:

37 
	`GCommArib
cڡ * 
szCl
, * 
szAr
, 
UINT
& 
uPt
 );

38 
	`GCommArib_ig
cڡ * 
szCl
, * 
szAr
, 
UINT
& 
uPt
 );

39 
	`ReiveProc
( );

41 
vtu
 
BOOL
 
	`IsPtVid
( );

42 
vtu
 
BOOL
 
	`OnPt
* 
szE
=
NULL
 );

43 
vtu
 
	`CloPt
( );

44 
vtu
 
BOOL
 
	`SQueue

DWORD
 
dwInQueueSize
, DWORD 
dwOutQueueSize
 );

45 
vtu
 
	`GInQueue
( );

46 
vtu
 
	`GOutQueue
( );

47 
vtu
 
	`RdPt

BYTE
 *
pBuf
, 
nRd
 );

48 
vtu
 
	`WrePt

BYTE
 *
pBuf
, 
nWre
 );

49 
vtu
 
	`AsyRdDa

BYTE
 *
pBuf
, 
nRd
 );

50 
vtu
 
	`AsySdDa

BYTE
 *
pBuf
, 
nWre
 );

51 
vtu
 
BOOL
 
	$C
){  
FALSE
 ;
	}
}

52 
vtu
 
BOOL
 
	$Pg
* 
cIp
 ){  
FALSE
 ;
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/CMethod.h

19 #ide 
CMETHOD_H_INC


20 
	#CMETHOD_H_INC


	)

23 
	~<dio.h
>

24 
	~<dlib.h
>

26 
	~"rdbDef.h
"

27 
	~"tydef.h
"

28 
	~"gDaTy.h
"

30 
ass
 
	gCProc
 ;

31 
ass
 
	gCRTDBObj
 ;

32 
ass
 
	gCBusMg
;

33 
ass
 
	gCBaPt
 ;

34 
	ggBusMag
 ;

35 
gBusMag
 * 
	tPBUSMANAGER
 ;

43 as
	cCMhod


45 
	mpublic
:

48 
	$CMhod
 ()

50 
m_pRdbObj
 = 
NULL
;

51 
m_pRtuObj
 = 
NULL
;

52 
m_pBusMag
 = 
NULL
;

53 
m_pPt
=
NULL
;

56 
vtu
 ~
	$CMhod
 (){; 
	}
}

63 
vtu
 
BOOL
 
	$GBusLeAndAddr
 ( 
WORD
 
wSlNo
, 
BYTE
 &
byBusNo
, WORD &
wDevAddr
 ){ 
FALSE
;
	}
}

65 
vtu
 
	$GSlNo
 ( 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
 ){  -1; 
	}
}

68 
vtu
 
	$YcUpde
 ( 
WORD
 
SlNo
, 
YC_DATA
 
YcDa
[], 
UINT
 
YcNum
 ){ ;
	}
}

70 
vtu
 
	$SYcDa
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
fV
 ){ ;
	}
}

72 
vtu
 
	$SYcDaWhTime
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
fV
, *
pTime
 ){ ;
	}
}

74 
vtu
 
	$RdAYcDa
 ( *
pDa
 ){ ;
	}
}

76 
vtu
 
DWORD
 
	$RdYcDa
 ( 
WORD
 
wSlNO
, WORD 
wP
 ){ 0;
	}
}

78 
vtu
 
	$YxUpde
 ( 
WORD
 
SlNo
, 
YX_DATA
 
YxDa
[], 
UINT
 
YxNum
){ ;
	}
}

80 
vtu
 
	$SYxDa
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
BYTE
 
byV
 ){ ;
	}
}

82 
vtu
 
	$SYxDaWhTime
 ( 
WORD
 
wSlNo
, WORD 
wP
, 
BYTE
 
byV
, 
TIMEDATA
 *
pTime
 ){ ;
	}
}

84 
vtu
 
	$RdAYxDa
 ( 
BYTE
 *
pDa
 ){ ;
	}
}

86 
vtu
 
	$RdYxDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, WORD *
pwV
){ -1 ;
	}
}

88 
vtu
 
	$YmUpDe
 ( 
WORD
 
SlNo
, 
YM_DATA
 
YmDa
[], 
UINT
 
YmNum
 ){ ;
	}
}

90 
vtu
 
	$SYmDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, 
fV
 ){ ;
	}
}

91 
vtu
 
BOOL
 
	$GYmDa

WORD
 
wSlNo
, WORD 
wP
, 
DWORD
 &
dwV
 ){  
FALSE
 ;
	}
}

93 
vtu
 
	$RdAYmDa
 ( 
DWORD
 *
pdwDa
 ){ ;
	}
}

95 
vtu
 
	$RdYmDa
 ( 
WORD
 
wSlNO
, WORD 
wP
, 
DWORD
 *
pdwV
 ){ -1;
	}
}

98 
vtu
 
	$SYkSR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ){ ;
	}
}

100 
vtu
 
	$SYkExeR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ){ ;
	}
}

102 
vtu
 
	$SYkClR
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ){ ;
	}
}

105 
vtu
 
	$SYkS
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ){
	}
};

107 
vtu
 
	$SYkExe
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ){
	}
};

109 
vtu
 
	$SYkCl
 (cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, WORD 
wP
, BYTE 
byV
 ){
	}
};

112 
vtu
 
	$SDzZeCl
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 ){
	}
};

114 
vtu
 
	$SDzZeClR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 ){
	}
};

116 
vtu
 
	$SDzZeSwchPt
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 ){
	}
};

118 
vtu
 
	$SDzZeSwchPtR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 ){
	}
};

120 
vtu
 
	$SDzZeSwchEx
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 ){
	}
};

122 
vtu
 
	$SDzZeSwchExR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 ){
	}
};

124 
vtu
 
	$SDzZeSwchCl
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 ){
	}
};

126 
vtu
 
	$SDzZeSwchClR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
, BYTE 
byDzZeNo
 ){
	}
};

128 
vtu
 
	$SDzZeE
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
 ){
	}
};

130 
vtu
 
	$SDzCl
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

132 
vtu
 
	$SDzClR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

134 
vtu
 
	$SDzWrePt
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

136 
vtu
 
	$SDzWrePtR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

138 
vtu
 
	$SDzWreEx
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

140 
vtu
 
	$SDzWreExR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

142 
vtu
 
	$SDzWreCl
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

144 
vtu
 
	$SDzWreClR
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

146 
vtu
 
	$SDzE
(cڡ 
CProc
 *
pProc
, 
BYTE
 
byBusNo
, 
WORD
 
wDevAddr
,BYTE 
byDzZeNo
, 
DZ_DATA
 
DzDa
[], 
iDzDaNum
){
	}
};

149 
vtu
 
	$CloSock

BYTE
 
byBusLe
 ) {  ; 
	}
}

151 
vtu
 
	$OnSock
 ( 
BYTE
 
byBusLe
 ){;
	}
}

152 
vtu
 
BOOL
 
	$IsPtVid
{  
FALSE
; 
	}
}

153 
vtu
 
BOOL
 
	$GDevCommS

BYTE
 
byLeNo
 , 
WORD
 
wDevNo
 ){  
FALSE
 ; 
	}
}

154 
vtu
 
BOOL
 
	$GDevCommS

WORD
 
wSlNo
 ) {  
FALSE
 ; 
	}
}

155 
vtu
 
BOOL
 
	$GCommS

BYTE
 
byLeNo
 ){  
FALSE
 ; 
	}
}

156 
vtu
 
BYTE
 
	$GToTBusNum
){  0 ;
	}
}

157 
vtu
 
BYTE
 
	$GDevNum

BYTE
 
byBusNo
 ){  0 ;
	}
}

159 
vtu
 
WORD
 
	$GAddrByLeNoAndModuNo
 ( 
BYTE
 
byLeNo
, 
WORD
 
wModuNo
 ){ 0;
	}
}

160 
vtu
 
BYTE
 
	$GBusLeProcTy

BYTE
 
byLeNo
 ){  0 ;
	}
}

161 
vtu
 
BOOL
 
	$IsSTime
 ( 
UINT
 
uiMSec
, UINT 
uiSec
, UINT 
uiM
, UINT 
uiHour
, UINT 
uiDay
, UINT 
uiMth
, UINT 
uiYr
cڡ{ 
FALSE
;
	}
}

164 
vtu
 
WORD
 
	$GGhDevCou
{  0 ; 
	}
}

167 
vtu
 
BOOL
 
	$SGhDevCou

WORD
 
wCou
 ) {  
FALSE
 ;
	}
}

170 
vtu
 
BYTE
 
	$GSgGhDevCou

BYTE
 
byBusNo
 , BYTE 
byDevIndex
 = 0 , 
WORD
 * 
pAddr
 = 
NULL
 ) {  0 ; 
	}
}

172 
vtu
 
PBUSMANAGER
 
	$GBus

BYTE
 
byIndex
 ) {  
NULL
 ;
	}
}

173 
	gpublic
:

176 
CRTDBObj
 *
m_pRdbObj
;

177 
CProc
 *
	gm_pRtuObj
;

178 
CBusMg
 *
	gm_pBusMag
;

179 
CBaPt
 * 
	gm_pPt
 ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/CProtocol.h

1 #ide
CPROTOCOL_H


2 
	#CPROTOCOL_H


	)

4 
	~<rg.h
>

5 
	~<ve
>

6 
	~"tydef.h
"

7 
	~"ofe.h
"

8 
	~"mObj.h
"

10 
ass
 
	gCProc
 ;

11 
ass
 
	gCMhod
 ;

13 
	gd
::
	tve
<
	tCProc
*> 
	tCPROTO_ARRAY
;

16 
	#SYSDATAPATH
 "/mynd/cfig"

	)

17 
	#DEVNAME
 "Bus"

	)

20 
	#COM_DEV_NORMAL
 0

21 
	#COM_NORMAL
 0

22 
	#COM_DEV_ABNORMAL
 1

23 
	#COM_ABNORMAL
 1

24 

	)

26 
	#PROTOCO_TRANSPROT
 0

	)

27 
	#PROTOCO_GATHER
 1

	)

29 
	s_MSGSTNINFO


31 
BYTE
 
	mbyBusNo
 ;

32 
WORD
 
	mwDevNo
 ;

33 } 
	tMSGSTNINFO
;

35 
	sBUS_MSG


37 
BUS_MSG
( )

39 
	mDaNum
 = 0;

40 
	mdwDaTy
 = 0;

41 
	mDaL
 = 0;

42 
	mbyMsgTy
 = 0 ;

43 
memt
&
DInfo
, 0, 
MSGSTNINFO
 ) );

44 
memt
&
SrcInfo
, 0, 
MSGSTNINFO
 ) );

45 
	mpDa
 = 
NULL
 ;

47 ~
BUS_MSG
()

49 
	mbyMsgTy
 = 0 ;

50 if
	mpDa
 !
NULL
 )

53 
ݔ
 
de
 ( 
pDa
 ) ;

54 
	mpDa
 = 
NULL
 ;

58 
MSGSTNINFO
 
	mDInfo
;

59 
MSGSTNINFO
 
	mSrcInfo
;

64 
	mDaNum
;

65 
DWORD
 
	mdwDaTy
 ;

69 
BYTE
 
	mbyMsgTy
 ;

70 
	mDaL
;

71 * 
	mpDa
 ;

72 }
	tBUSMSG
 , *
	tPBUSMSG
;

75 
	#BROADCASET_PROTO
 1

	)

76 
	#YK_PROTO
 2

	)

77 
	#THREAD_EXIT
 3

	)

78 
	#DZ_PROTO
 4

	)

81 
	#YK_SEL
 1

	)

82 
	#YK_EXCT
 2

	)

83 
	#YK_CANCEL
 3

	)

84 
	#YK_SEL_RTN
 4

	)

85 
	#YK_EXCT_RTN
 5

	)

86 
	#YK_CANCEL_RTN
 6

	)

87 
	#YK_ERROR
 0xFF

	)

90 
	#DZZONE_CALL
 1

	)

91 
	#DZZONE_CALL_RTN
 2

	)

92 
	#DZZONE_SWITCH_PRESET
 3

	)

93 
	#DZZONE_SWITCH_PRESET_RTN
 4

	)

94 
	#DZZONE_SWITCH_EXCT
 5

	)

95 
	#DZZONE_SWITCH_EXCT_RTN
 6

	)

96 
	#DZZONE_SWITCH_CANCEL
 7

	)

97 
	#DZZONE_SWITCH_CANCEL_RTN
 8

	)

98 
	#DZ_CALL
 9

	)

99 
	#DZ_CALL_RTN
 10

	)

100 
	#DZ_WRITE_PRESET
 11

	)

101 
	#DZ_WRITE_PRESET_RTN
 12

	)

102 
	#DZ_WRITE_EXCT
 13

	)

103 
	#DZ_WRITE_EXCT_RTN
 14

	)

104 
	#DZ_WRITE_CANCEL
 15

	)

105 
	#DZ_WRITE_CANCEL_RTN
 16

	)

106 
	#DZZONE_ERROR
 0xFF

	)

107 
	#DZ_ERROR
 0xFE

	)

109 
	sgSDa


111 
WORD
 
	mwSlNo
 ;

112 
WORD
 
	mwP
 ;

113 
	mfV
 ;

114 
WORD
 
	mwV
 ;

115 
gSDa
( )

117 
	mwSlNo
 = 0 ;

118 
	mwP
 = 0 ;

119 
	mfV
 = 0.0f ;

120 
	mwV
 = 0 ;

122 }
	tSETDATA
 , *
	tPSETDATA
;

125 
	#YC_SUM
 0

	)

126 
	#YX_SUM
 1

	)

127 
	#YM_SUM
 2

	)

128 
	#YK_SUM
 3

	)

130 as
	cCProc


132 
	mpublic
:

133 
	$CProc
()

135 
CProfe
 
	`Profe
( (*)"/mynand/config/BusLine.ini" );

136 
m_TnsDay
 = 
Profe
.
	`GProfeI
( (*)"PROJECT" ,(*)"transdelay" , 30) ;

139 
vtu
 ~
	$CProc
({
	}
}

141 
vtu
 
BOOL
 
	$GProcBuf

BYTE
 * 
buf
 , &
n
 , 
PBUSMSG
 
pBusMsg
 = 
NULL
 ){  
FALSE
 ;
	}
}

142 
vtu
 
BOOL
 
	$ProssProcBuf

BYTE
 * 
buf
 , 
n
 ){  
FALSE
 ; 
	}
}

143 
vtu
 
BOOL
 
	$In

BYTE
 
byLeNo
 ) {  
FALSE
 ;
	}
}

144 
vtu
 
BOOL
 
	$BrdCa

BYTE
 * 
buf
 , &
n
 ){  
FALSE
 ;
	}
}

145 
vtu
 
	$TimProc
(){
	`tf
("CProc\n"); ; 
	}
}

146 
vtu
 
BOOL
 
	$GUrossBuf
 ( cڡ 
BYTE
 *
pBuf
, cڡ 
iL
, *
pVoid
 ){ 
FALSE
;
	}
}

148 
vtu
 
BOOL
 
	$WreCIV

WORD
 
wSlNo
 , WORD 
wP
, 
fV
){  
FALSE
 ;
	}
}

149 
vtu
 
BOOL
 
	$WreAIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
){  
FALSE
 ; 
	}
}

150 
vtu
 
BOOL
 
	$WreDIV
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
){  
FALSE
 ; 
	}
}

151 
vtu
 
BOOL
 
	$WrePIV
(
WORD
 
wSlNo
 ,WORD 
wP
, 
DWORD
 
dwV
){  
FALSE
 ;
	}
}

152 
vtu
 
BOOL
 
	$WreSOEInfo

WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
){  
FALSE
 ;
	}
}

153 
vtu
 
	$RdAlogDa
(*
pDa
){
	}
}

154 
vtu
 
	$RdDigDa
(
BYTE
 *
pDa
 ){
	}
}

155 
vtu
 
	$RdPulDa
(
DWORD
 *
pDa
){
	}
}

156 
vtu
 
BOOL
 
	$GDevCommS
{  
FALSE
 ; 
	}
}

157 
vtu
 
	$SDevCommS
{  ; 
	}
}

158 
vtu
 
BOOL
 
	$InDevS
{  
FALSE
 ; 
	}
}

159 
	gpublic
:

161 
	$GModuNo

WORD
 
wDevAddr
 )

163 
size
 = 
m_modu
.
	`size
() ;

164  
i
 = 0 ; i < 
size
 ; i++ )

166 
CProc
 * 
pProc
 = 
m_modu
[ 
i
 ] ;

167 if
pProc
->
m_wDevAddr
 =
wDevAddr
 )

168  
i
 ;

171 
	}
}

173 
	gpublic
:

174 
BYTE
 
m_byLeNo
 ;

175 
WORD
 
	gm_wDevAddr
 ;

176 
WORD
 
	gm_SlNo
 ;

177 
WORD
 
	gm_wModuTy
 ;

178 
	gm_sDevPh
[ 200 ];

179 
	gm_sDevName
[ 50 ];

180 
	gm_sTemePh
[ 200 ] ;

181 
CMhod
 *
	gm_pMhod
 ;

182 
CPROTO_ARRAY
 
	gm_modu
 ;

183 
BOOL
 
	gm_ProTy
 ;

184 
WORD
 
	gm_TnsDay
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/CTcpPortServer.cpp

1 
	~"CTPtSv.h
"

3 
BOOL
 
	gCTPtSvDege
::
	$AcProc
(
hSock
, 
nPt
,

4 * 
szReme
, * 
szLol
)

6 if
m_pSv
 )

7 
m_pSv
->
	`ProssAcProc

hSock
 , 
nPt
 , 
szReme
 , 
szLol
 ) ;

9 
CDegeBa
::
	`AcProc

hSock
 , 
nPt
 , 
szReme
 , 
szLol
 ) ;

10  
TRUE
 ;

11 
	}
}

14 
	gCTPtSv
::
	$CTPtSv
()

17 
m_dege
.
m_pSv
 = 
this
 ;

18 
	}
}

20 
	gCTPtSv
::~
	$CTPtSv
()

23 
	`tf
( "TcpPortServer Destruct OK.\n" );

24 
	}
}

26 
BOOL
 
	gCTPtSv
::
	$OnPt
* 
szE
 )

28 if
szE
 =
NULL
 )

29  
FALSE
 ;

32 
m_Li
.
m_nThePt
 = 
m_uThePt
 ;

33 
	`ry

m_Li
.
m_szLolAddr
 , 
m_szArib
 ) ;

36 
szE
[ 200 ];

37 
	`memt

szE
 , 0 , ( szError ) );

38 
m_Li
.
	`CeObj

szE
 ) ;

39 
m_Li
.
	`SRun
&
m_dege
 ) ;

41  
TRUE
 ;

42 
	}
}

44 
BOOL
 
	gCTPtSv
::
	$ProssAcProc
(
hSock
, 
nPt
,

45 * 
szReme
, * 
szLol
)

47 
szSty
[32];

49 
	`rtf
(
szSty
, "TCP%d:%s", 
nPt
, 
szReme
);

50 
	`LogPromText
("\n***CClLay::ProssAc(%s:%d)***", 
szReme
, 
nPt
);

52 
	`Aach

hSock
 ) ;

53  
TRUE
 ;

54 
	}
}

56 
BOOL
 
	gCTPtSv
::
	$InPtOthPa
* 
th
 )

58  
TRUE
 ;

59 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/CTcpPortServer.h

1 #ide
CTCPPORTSERVER_H


2 
	#CTCPPORTSERVER_H


	)

4 
	~"TPt.h
"

5 
	~"TLi.h
"

6 
	~"ofe.h
"

8 
ass
 
	gCTPtSv
 ;

10 as
	cCTPtSvDege
 : 
public
 
CDegeBa


12 
public
:

13 
	$CTPtSvDege
( )

15 
m_pSv
 = 
NULL
 ;

17 
vtu
 ~
	$CTPtSvDege
()

19 
	}
}

21 
vtu
 
BOOL
 
AcProc
(
hSock
, 
nPt
,

22 * 
szReme
, * 
szLol
) ;

24 
CTPtSv
 * 
	gm_pSv
 ;

27 as
	cCTPtSv
 : 
public
 
CTPt


29 
public
:

30 
CTPtSv
();

31 
	mvtu
 ~
CTPtSv
();

32 
vtu
 
BOOL
 
OnPt
* 
szE
=
NULL
 );

33 
BOOL
 
InPtOthPa
* 
th
 ) ;

34 
BOOL
 
ProssAcProc
(
hSock
, 
nPt
,

35 * 
szReme
, * 
szLol
) ;

36 
CTLi
 
	mm_Li
 ;

37 
CTPtSvDege
 
	mm_dege
 ;

38 
	mm_szLolGeWay
[24];

39 
	mm_szLolSubNMask
[24];

40 
	mm_szLolDNS
[24];

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/PintTest.cpp

5 
	~<sys/time.h
>

6 
	~<sys/sock.h
>

7 
	~<tdb.h
>

8 
	~<unid.h
>

9 
	~<t/.h
>

10 
	~</.h
>

11 
	~<rg.h
>

12 
	~"PtTe.h
"

18 
	gCPtTe
::
	$CPtTe
()

20 
	`InPg
( ) ;

21 
m_daL
 = 
DEFAULT_LEN
 ;

22 
	}
}

24 
	gCPtTe
::~
	$CPtTe
()

27 
	}
}

29 
CPtTe
::
	$InPg
( )

31 
m_sock
 = ::
	`sock

AF_INET
 , 
SOCK_RAW
 , 
IPPROTO_ICMP
 ) ;

32 
	}
}

34 
BOOL
 
	gCPtTe
::
	$Pg
* 
pDeIp
 )

51  
TRUE
 ;

52 
	}
}

54 
BOOL
 
	gCPtTe
::
	$SdICMP
* 
pDeIp
 )

62  
TRUE
 ;

63 
	}
}

65 
BOOL
 
	gCPtTe
::
	$RecvICMP
* 
pDeIp
 )

67 if
pDeIp
 =
NULL
 )

68  
FALSE
 ;

70 
BYTE
 
byRecv
[1024] ;

71 
	`memt

byRecv
 , 0 , ( byRecv ) ) ;

72 
sockaddr_
 
de
 ;

73 
sockn_t
 
n
 = 0 ;

74 
iR
 = 0 ;

75 
iR
 = 
	`cvom

m_sock
 , 
byRecv
 , byRecv ) , 0 , ( 
sockaddr
 * )&
de
 , &
n
 ) ;

77 if
iR
 )

78  
TRUE
 ;

80  
FALSE
 ;

81 
	}
}

83 
BOOL
 
	gCPtTe
::
	$PackICMP
* 
pDeIP
 )

85 if
pDeIP
 =
NULL
 )

86  
FALSE
 ;

88 
hdr
 *
_hdr
;

89 
icmphdr
 *
icmp_hdr
;

90 
n
;

91 
n1
;

94 
_hdr
=(
hdr
 *)
m_sbuf
;

95 
_hdr
->
hn
=(
hdr
)>>2;

96 
_hdr
->
v
=
IPVERSION
;

97 
_hdr
->
tos
=0;

98 
_hdr
->
t_n
=
IP_HSIZE
+
ICMP_HSIZE
+
m_daL
;

99 
_hdr
->
id
=0;

100 
_hdr
->
ag_off
=0;

101 
_hdr
->
oc
=
IPPROTO_ICMP
;

102 
_hdr
->
l
=255;

103 
_hdr
->
daddr

	`_addr

pDeIP
 );

104 
n1
=
_hdr
->
hn
<<2;

107 
icmp_hdr
=(
icmphdr
 *)(
m_sbuf
+
n1
);

108 
icmp_hdr
->
ty
=8;

109 
icmp_hdr
->
code
=0;

110 
icmp_hdr
->
wRequeID
=
	`gpid
( );

111 
icmp_hdr
->
wSequ
= 0 ;

112 
	`gtimeofday
((
timev
 *)
icmp_hdr
->
timeSmp
,
NULL
);

114 
n
=
_hdr
->
t_n
;

115 
icmp_hdr
->
checksum
=0;

116 
icmp_hdr
->
checksum
=
	`checksum
((
BYTE
 *)icmp_hdr,
n
);

118 
sockaddr_
 
de
 ;

119 
de
.
s_my
 = 
AF_INET
 ;

120 
de
.
s_pt
 = 
	`hts
( 0 ) ;

121 
de
.
s_addr
.
s_addr
 = 
	`_addr

pDeIP
 ) ;

123 
	`ndto

m_sock
 , 
m_sbuf
 , 
n
 , 0 , (
sockaddr
 *)&
de
, (dest) );

124  
TRUE
 ;

125 
	}
}

127 
WORD
 
	gCPtTe
::
	$checksum

BYTE
 *
buf
,
n
)

129 
DWORD
 
sum
=0;

130 
WORD
 *
cbuf
;

132 
cbuf
=(
WORD
 *)
buf
;

134 
n
>1){

135 
sum
+=*
cbuf
++;

136 
n
-=2;

139 if(
n
)

140 
sum
+=*(
BYTE
 *)
cbuf
;

142 
sum
=(sum>>16)+(sum & 0xffff);

143 
sum
+=(sum>>16);

145  ~
sum
;

146 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/PintTest.h

5 #i!
defed
(
AFX_PINTTEST_H__90ECF2C5_8928_41E7_A471_A56514CF8119__INCLUDED_
)

6 
	#AFX_PINTTEST_H__90ECF2C5_8928_41E7_A471_A56514CF8119__INCLUDED_


	)

8 #i
_MSC_VER
 > 1000

9 #agm



11 
	~"tydef.h
"

13 
	#IP_HSIZE
 (
hdr


	)

14 
	#IPVERSION
 4

	)

15 
	#ICMP_HSIZE
 (
icmphdr
)

	)

16 
	#BUFSIZE
 1500

	)

17 
	#DEFAULT_LEN
 56

	)

20 
	sicmphdr
 {

21 
BYTE
 
	mty
;

22 
BYTE
 
	mcode
;

23 
WORD
 
	mchecksum
;

25 
WORD
 
	mwRequeID
 ;

26 
WORD
 
	mwSequ
 ;

27 
DWORD
 
	mtimeSmp
 ;

28 
icmphdr
( )

30 
	mty
 = 0 ;

31 
	mcode
 = 0 ;

32 
	mchecksum
 = 0 ;

33 
	mwRequeID
 = 0 ;

34 
	mwSequ
 = 0 ;

35 
	mtimeSmp
 = 0 ;

39 
	shdr
 {

40 
BYTE
 
	mhn
:4, 
	mv
:4;

41 
BYTE
 
	mtos
;

42 
WORD
 
	mt_n
;

43 
WORD
 
	mid
;

44 
WORD
 
	mag_off
;

45 
BYTE
 
	ml
;

46 
BYTE
 
	moc
;

47 
WORD
 
	mcheck
;

48 
DWORD
 
	mddr
;

49 
WORD
 
	mdaddr
;

52 as
	cCPtTe


54 
	mpublic
:

55 
CPtTe
();

56 
	mvtu
 ~
CPtTe
();

57 
BOOL
 
Pg
* 
pDeIp
 ) ;

59 
	meed
:

60 
InPg
( ) ;

61 
BOOL
 
PackICMP
* 
pDeIP
 ) ;

62 
BOOL
 
SdICMP
* 
pDeIp
 );

63 
BOOL
 
RecvICMP
* 
pDeIp
 );

64 
WORD
 
checksum

BYTE
 *
buf
,
n
) ;

65 
icmphdr
 *
	mm_pICMP_hdr
 ;

66 
BYTE
 
	mm_sbuf
[ 
BUFSIZE
 ] ;

67 
WORD
 
	mm_wRequeID
 ;

68 
HANDLE
 
	mm_sock
 ;

69 
	mm_daL
 ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/Rtu.cpp

5 
	~<dio.h
>

6 
	~<dlib.h
>

7 
	~<rg.h
>

8 
	~<unid.h
>

9 
	~<f.h
>

10 
	~<rmios.h
>

11 
	~<y.h
>

12 
	~<sys/iol.h
>

13 
	~<sys/mm.h
>

14 
	~<sys/tys.h
>

15 
	~<sys/m.h
>

16 
	~<sys/.h
>

17 
	~<sys/time.h
>

18 
	~<sigl.h
>

19 
	~<o.h
>

20 
	~<t/.h
>

21 
	~<sys/sock.h
>

22 
	~</.h
>

23 
	~<tdb.h
>

25 
	~"Rtu.h
"

26 
	~"../she/ofe.h
"

27 
	~"../she/rdbFun.h
"

28 
	~"../BayLay/ma.h
"

29 
	~"../BayLay/BusMg.h
"

31 
CBusMg
 
m_busMag
 ;

33 
	#RTUKEY1
 2011200

	)

34 
	#RTUKEY2
 2011210

	)

35 
	#RTUKEY3
 2011220

	)

37 
	#YC_NUM
 1

	)

38 
	#YX_NUM
 2

	)

39 
	#YM_NUM
 3

	)

40 
	#YK_NUM
 4

	)

41 
	#DZ_NUM
 5

	)

42 
	#YC_DEAD
 6

43 
	#YC_PROPTY
 7

44 
	#TIMING
 8

45 

	)

46 
	#YC_PROPERTY
 40

47 
	#YX_PROPERTY
 50

48 
	#YM_PROPERTY
 60

49 
	#YK_PROPERTY
 70

50 
	#DZ_PROPERTY
 80

51 

	)

52 
	gg_cszTyDef
[][20] =

67 "C" 
rim
(*
s
);

69 "C" 
OutPromText
(*
szText
);

70 "C" 
LogPromText
(cڡ *
fmt
, ...);

74 
	$GMIm
(*
rIm
, 
WORD
 *
pwNum
)

76 
rTy
[32];

77 
i
, 
nL
, 
nTy
=-1;

78 
size
 = 
g_cszTyDef
 ) / ( g_lpcszTypeDef[ 0 ] ) ;

80  
i
 = 0 ; i < 
size
 ; i++ )

82 if
	`rr
(
rIm
, 
g_cszTyDef
[ 
i
 ] ) )

83  
i
 ;

86 
i
 = 0;

87 
nL
 = 
	`
(
rIm
);

88  (!
	`isdig
(
rIm
[
i
])) && i<32 )

90 
rTy
[
i
] = 
	`tou
(
rIm
[i]);

91 if++
i
 >
nL
 ) ;

93 
rTy
[
i
] = '\0';

94 if
i
 >
nL
 ) *
pwNum
 = 0;

95 *
pwNum
 = (
WORD
)
	`oi
(&
rIm
[
i
]);

97 if
	`rcmp
(
rTy
, "YC"=0 )  
YC_PROPERTY
 ;

98 if
	`rcmp
(
rTy
, "YX"=0 )  
YX_PROPERTY
 ;

99 if
	`rcmp
(
rTy
, "DD"=0 )  
YM_PROPERTY
 ;

100 if
	`rcmp
(
rTy
, "YK"=0 )  
YK_PROPERTY
 ;

101 if
	`rcmp
(
rTy
, "DZ"=0 )  
DZ_PROPERTY
 ;

102  
nTy
;

103 
	}
}

107 
	$GMPam
(* 
rPam
,

108 
WORD
 *
pwV1
, WORD *
pwV2
, WORD *
pwV3
, WORD *
pwV4
, WORD *
pwV5
)

110 
i
, 
nL
;

111 *
pVue
;

113 
nL
 = 
	`
(
rPam
);

114 if
nL
 <= 0 ) ;

115 
pVue
 = 
	`ok
(
rPam
, ", ");

117 
i
=0; 
pVue
 !
NULL
; i++)

119 
i
)

122 if
pwV1
 ) *pwV1 = (
WORD
)
	`oi
(
pVue
);

125 if
pwV2
 ) *pwV2 = (
WORD
)
	`oi
(
pVue
);

128 if
pwV3
 ) *pwV3 = (
WORD
)
	`oi
(
pVue
);

131 if
pwV4
 ) *pwV4 = (
WORD
)
	`oi
(
pVue
);

134 if
pwV5
 ) *pwV5 = (
WORD
)
	`oi
(
pVue
);

137 
pVue
 = 
	`ok
(
NULL
, ", ");

139 
	}
}

158 
	$PMLe
(* 
rLe
, 
WORD
 *
pwNum
,

159 
WORD
 *
pwV1
, WORD *
pwV2
, WORD *
pwV3
, WORD *
pwV4
, WORD *
pwV5
)

161 *
pIm
, *
pPam
;

162 
nTy
=-1;

164 
pIm
 = 
	`ok
(
rLe
, "=,\t ");

166 if
pIm
 =
NULL
 )

169 
pPam
 = 
	`ok
(
NULL
, "=");

170 if
pPam
 =
NULL
 )

173 
nTy
 = 
	`GMIm
(
pIm
, 
pwNum
);

175 
	`GMPam
(
pPam
, 
pwV1
, 
pwV2
, 
pwV3
, 
pwV4
, 
pwV5
);

176  
nTy
;

177 
	}
}

179 
	$GTnsNum
(
BYTE
 
byTy
, 
WORD
 
wS
, WORD 
wP
)

181 
iNum
 = -1;

182 if
byTy
 == 0 )

184 cڡ 
ANALOGITEM
 *
pIm
 = 
	`G_RTDB_Alog
(
wS
, 
wP
);

185 if
pIm
 ) 
iNum
 =Im->
iTnsNum
;

187 if
byTy
 == 1 )

189 cڡ 
DIGITALITEM
 *
pIm
 = 
	`G_RTDB_Dig
(
wS
, 
wP
);

190 if
pIm
 ) 
iNum
 =Im->
iTnsNum
;

192 if
byTy
 == 2 )

194 cڡ 
PULSEITEM
 *
pIm
 = 
	`G_RTDB_Pul
(
wS
, 
wP
);

195 if
pIm
 ) 
iNum
 =Im->
iTnsNum
;

197 if
byTy
 == 3 )

199 cڡ 
RELAYITEM
 *
pIm
 = 
	`G_RTDB_Ray
(
wS
, 
wP
);

200 if
pIm
 ) 
iNum
 =Im->
iTnsNum
;

202  
iNum
;

203 
	}
}

208 
	gCRtuBa
::
	$CRtuBa
()

210 
m_byProID
 = 0;

211 
m_byEb
 = 0;

212 
m_wPtNum
 = (
WORD
)-1;

213 
	`rtf
(
m_ComCl1
, "%s", "");

214 
	`rtf
(
m_ComCl2
, "%s", "");

215 
m_wObjNum
 = (
WORD
)-1;

216 
m_wRtuAddr
 = (
WORD
)-1;

217 
m_wDdV
 = 4;

218 
m_wReV
 = 0;

219 
m_wRecvClock
 = 0;

221 
m_byAi
 = 0;

222 
m_byABay
 = 0;

223 
m_byAMk
 = 0;

224 
m_wANum
 = 0;

225 
m_wRayNum
 = 0;

226 
m_wSeTim
 = 0;

228 
m_wAISum
 = 0;

229 
m_wDISum
 = 0;

230 
m_wPISum
 = 0;

231 
m_wDOSum
 = 0;

232 
m_wAOSum
 = 0;

233 
m_wSignSum
 = 0;

234 
m_wDZSum
 = 0 ;

236 
m_pwCITns
 = 
NULL
;

237 
m_pAIMTab
 = 
NULL
; 
m_pwAITns
 = NULL;

238 
m_pDIMTab
 = 
NULL
; 
m_pwDITns
 = NULL;

239 
m_pPIMTab
 = 
NULL
; 
m_pwPITns
 = NULL;

240 
m_pDOMTab
 = 
NULL
; 
m_pwDOTns
 = NULL;

241 
m_pAOMTab
 = 
NULL
; 
m_pwAOTns
 = NULL;

242 
m_pDZMTab
 = 
NULL
 ;
m_pwDZTns
 = NULL ;

244 
m_iSOE_wr_p
 = 0;

245 
m_iSOE_rd_p
 = 0;

248 
m_pDBInfo
 = (
SYSINFO
*)
	`G_RTDB_SysInfo
();

249 
m_iAIEPos
 = 
m_pDBInfo
->
nAIEWrePos
;

250 
m_iSOEPos
 = 
m_pDBInfo
->
nSOEWrePos
;

252 
m_bTaskRun
 = 
FALSE
;

253 
	}
}

255 
	gCRtuBa
::~
	$CRtuBa
()

257 if(
m_wAISum
 > 0)

259 if(
m_pAIMTab

de
 []m_pAIMapTab;

260 if(
m_pwAITns

de
 []m_pwAITrans;

262 if(
m_wDISum
 > 0)

264 if(
m_pDIMTab

de
 []m_pDIMapTab;

265 if(
m_pwDITns

de
 []m_pwDITrans;

267 if(
m_wPISum
 > 0)

269 if(
m_pPIMTab

de
 []m_pPIMapTab;

270 if(
m_pwPITns

de
 []m_pwPITrans;

272 if(
m_wDOSum
 > 0)

274 if(
m_pDOMTab

de
 []m_pDOMapTab;

275 if(
m_pwDOTns

de
 []m_pwDOTrans;

277 if(
m_wAOSum
 > 0)

279 if(
m_pAOMTab

de
 []m_pAOMapTab;

280 if(
m_pwAOTns

de
 []m_pwAOTrans;

282 if(
m_pwCITns
 !
NULL
)

284 if(
m_pwCITns

de
 []m_pwCITrans;

287 if
m_wDZSum
 > 0 )

289 if
m_pwDZTns
 )

290 
de
 [ ] 
m_pwDZTns
 ;

292 if
m_pDZMTab
 )

293 
de
 [ ] 
m_pDZMTab
 ;

296 
	`CloPt
();

297 
m_dwAIEQueue
.
	`r
();

298 
m_dwDIEQueue
.
	`r
();

299 
m_iSOE_wr_p
 = 0;

300 
m_iSOE_rd_p
 = 0;

301 
	}
}

303 
	gCRtuBa
::
	$CloPt
()

305 
	}
}

307 
BOOL
 
CRtuBa
::
	$IsPtVid
()

309  
FALSE
;

310 
	}
}

312 
	gCRtuBa
::
	$CeTnsTab
()

314 
i
, 
k
;

319 
nAlogSum
 = 
	`GPSum
(0);

320 if(
m_wAISum
>0 && 
nAlogSum
>0)

322 
m_pwAITns
 = 
w
 
WORD
[
nAlogSum
];

323 
	`memt
((*)
m_pwAITns
, 0xFFFF, (
WORD
)*
nAlogSum
);

324 
i
=0; i<
m_wAISum
; i++)

326 if
m_pAIMTab
[
i
].
wS
==0 || m_pAIMTab[i].
wPNum
==0 )  ;

327 
k
 = 
	`GTnsNum
(0, 
m_pAIMTab
[
i
].
wS
-1, m_pAIMTab[i].
wPNum
-1);

328 if(
k
>=0 && k<
nAlogSum
)

330 
m_pwAITns
[
k
] = 
i
 ;

334 
nDigSum
 = 
	`GPSum
(1);

335 if(
m_wDISum
>0 && 
nDigSum
>0)

337 
m_pwDITns
 = 
w
 
WORD
[
nDigSum
];

338 
	`memt
((*)
m_pwDITns
, 0xFFFF , (
WORD
)*
nDigSum
);

339 
i
=0; i<
m_wDISum
; i++)

341 if
m_pDIMTab
[
i
].
wS
==0 || m_pDIMTab[i].
wPNum
==0 ) ;

342 
k
 = 
	`GTnsNum
(1, 
m_pDIMTab
[
i
].
wS
-1, m_pDIMTab[i].
wPNum
-1);

343 if(
k
>=0 && k<
nDigSum
)

344 
m_pwDITns
[
k
] = 
i
 ;

347 
nPulSum
 = 
	`GPSum
(2);

348 if(
m_wPISum
>0 && 
nPulSum
>0)

350 
m_pwPITns
 = 
w
 
WORD
[
nPulSum
];

351 
	`memt
((*)
m_pwPITns
, 0xFFFF, (
WORD
)*
nPulSum
);

352 
i
=0; i<
m_wPISum
; i++)

354 if
m_pPIMTab
[
i
].
wS
==0 || m_pPIMTab[i].
wPNum
==0 ) ;

355 
k
 = 
	`GTnsNum
(2, 
m_pPIMTab
[
i
].
wS
-1, m_pPIMTab[i].
wPNum
-1);

356 if(
k
>=0 && k<
nPulSum
)

357 
m_pwPITns
[
k
] = 
i
 ;

360 
nRaySum
 = 
	`GPSum
(3);

361 if(
m_wDOSum
>0 && 
nRaySum
>0)

363 
m_pwDOTns
 = 
w
 
WORD
[
nRaySum
];

364 
	`memt
((*)
m_pwDOTns
, 0xFFFF, (
WORD
)*
nRaySum
);

365 
i
=0; i<
m_wDOSum
; i++)

367 if
m_pDOMTab
[
i
].
wS
==0 ) ;

368 
k
 = 
	`GTnsNum
(3, 
m_pDOMTab
[
i
].
wS
-1, m_pDOMTab[i].
wPNum
 - 1 );

369 if(
k
>=0 && k<
nRaySum
)

370 
m_pwDOTns
[
k
] = 
i
 ;

389 
	}
}

391 
	gCRtuBa
::
	$RdMCfig
(
LPCSTR
 
szFe
)

393 
FILE
* 
fd
;

394 
rLe
[256];

395 
nTy
;

396 
WORD
 
wNum
, 
wV1
, 
wV2
, 
wV3
, 
wV4
, 
wV5
;

398 
fd
 = 
	`fݒ
(
szFe
, "r");

399 if(
fd
 =
NULL
 ) {
	`LogPromText
("\Of%u!", 
szFe
); ;}

400  
	`fgs
(
rLe
, (rLe), 
fd
) )

402 
	`rim
(
rLe
);

403 if
rLe
[0]==';' || strLine[0]=='#' ) ;

404 
nTy
 = 
	`PMLe
(
rLe
, &
wNum
, &
wV1
, &
wV2
, &
wV3
, &
wV4
, &
wV5
);

405 
nTy
)

407 
YC_NUM
:

408 if(
m_wAISum
>0) ;

409 
m_wAISum
 = 
wV1
;

410 if(
m_wAISum
 > 
MAPMAX_AI_LEN
) m_wAISum = MAPMAX_AI_LEN;

411 if(
m_wAISum
==0) ;

412 
m_pAIMTab
 = 
w
 
MAPITEM
[
m_wAISum
];

413 
	`memt
((*)
m_pAIMTab
, 0, (
MAPITEM
)*
m_wAISum
 );

415 
YX_NUM
:

416 if(
m_wDISum
>0) ;

417 
m_wDISum
 = 
wV1
;

418 if(
m_wDISum
 > 
MAPMAX_DI_LEN
) m_wDISum = MAPMAX_DI_LEN;

419 if(
m_wDISum
==0) ;

420 
m_pDIMTab
 = 
w
 
MAPITEM
[
m_wDISum
];

421 
	`memt
((*)
m_pDIMTab
, 0, (
MAPITEM
)*
m_wDISum
 );

423 
YM_NUM
:

424 if(
m_wPISum
>0) ;

425 
m_wPISum
 = 
wV1
;

426 if(
m_wPISum
 > 
MAPMAX_PI_LEN
) m_wPISum = MAPMAX_PI_LEN;

427 if(
m_wPISum
==0) ;

428 
m_pPIMTab
 = 
w
 
MAPITEM
[
m_wPISum
];

429 
	`memt
((*)
m_pPIMTab
, 0, (
MAPITEM
)*
m_wPISum
 );

431 
YK_NUM
:

432 if(
m_wDOSum
>0) ;

433 
m_wDOSum
 = 
wV1
;

434 if(
m_wDOSum
 > 
MAPMAX_DO_LEN
) m_wDOSum = MAPMAX_DO_LEN;

435 if(
m_wDOSum
==0) ;

436 
m_pDOMTab
 = 
w
 
MAPITEM
[
m_wDOSum
];

437 
	`memt
((*)
m_pDOMTab
, 0, (
MAPITEM
)*
m_wDOSum
 );

439 
DZ_NUM
:

440 if(
m_wDZSum
>0) ;

441 
m_wDZSum
 = 
wV1
;

442 if(
m_wDZSum
 > 
MAPMAX_AO_LEN
) m_wDZSum = MAPMAX_AO_LEN;

443 if(
m_wDZSum
==0) ;

444 
m_pDZMTab
 = 
w
 
MAPITEM
[
m_wDZSum
];

445 
	`memt
((*)
m_pDZMTab
, 0, (
MAPITEM
)*
m_wDZSum
 );

447 
YC_DEAD
:

448 
m_wDdV
 = 
wV1
 ;

450 
YC_PROPTY
:

451 
m_wReV
 = 
wV1
 ;

453 
TIMING
:

454 
m_wRecvClock
 = 
wV1
 ;

456 
YC_PROPERTY
 :

457 if((
wNum
-1)<
m_wAISum
)

459 
m_pAIMTab
[
wNum
-1].
wS
 = 
wV1
;

460 
m_pAIMTab
[
wNum
-1].
wPNum
 = 
wV2
;

463 
YX_PROPERTY
:

464 if((
wNum
-1)<
m_wDISum
)

466 
m_pDIMTab
[
wNum
-1].
wS
 = 
wV1
;

467 
m_pDIMTab
[
wNum
-1].
wPNum
 = 
wV2
;

470 
YM_PROPERTY
:

471 if((
wNum
-1)<
m_wPISum
)

473 
m_pPIMTab
[
wNum
-1].
wS
 = 
wV1
;

474 
m_pPIMTab
[
wNum
-1].
wPNum
 = 
wV2
;

477 
YK_PROPERTY
:

478 if((
wNum
-1)<
m_wDOSum
)

480 
m_pDOMTab
[
wNum
-1].
wS
 = 
wV1
;

481 
m_pDOMTab
[
wNum
-1].
wPNum
 = 
wV2
;

484 
DZ_PROPERTY
:

485 if((
wNum
-1)<
m_wDZSum
)

487 
m_pDZMTab
[
wNum
-1].
wS
 = 
wV1
;

488 
m_pDZMTab
[
wNum
-1].
wPNum
 = 
wV2
;

493 
	`fo
(
fd
);

494 
	}
}

496 
	gCRtuBa
::
	$SObjPam
(
WORD
 
wP
, WORD 
wSignSum
, WORD 
wPos1
, WORD 
wPos2
, WORD 
wPos3
)

498 
	}
}

500 
	gCRtuBa
::
	$GPrUnAr
(
BYTE
 
byTy
, 
WORD
 
wAddr
, BYTE& 
byPro
, WORD& 
wS
, WORD& 
wP
)

503 
	}
}

505 
BOOL
 
	gCRtuBa
::
	$InRtuBa
()

507 
	`OutPromText
((*)"****CRtuBase.Init()****");

508 
m_mAIEMux
.
	`Ce
(
RTUKEY1
+
m_wObjNum
);

509 
m_mDIEMux
.
	`Ce
(
RTUKEY2
+
m_wObjNum
);

510 
m_mSOEMux
.
	`Ce
(
RTUKEY3
+
m_wObjNum
);

511  
TRUE
;

512 
	}
}

514 
RTUMSG
* 
	gCRtuBa
::
	$LdRtuMesge
()

516  
NULL
;

517 
	}
}

519 
	gCRtuBa
::
	$RtuCommdProc

BYTE
* 
pRecvBuf
, 
nL
 )

521 
	}
}

523 
	gCRtuBa
::
	$GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
)

526 
	}
}

528 
	gCRtuBa
::
	$GDIVue
(
WORD
 
wP
, WORD 
wSrcNo
, *
v
)

531 
	}
}

533 
	gCRtuBa
::
	$RayEchoProc
(
BYTE
 
byCommd
, 
WORD
 
wIndex
, BYTE 
byResu
)

535 
	}
}

537 
	gCRtuBa
::
	$WrePrMesge
(
BYTE
 
byPro
, 
WORD
 
wPam
, BYTE* 
pBuf
, 
nBy
)

539 
	}
}

541 
	gCRtuBa
::
	$WrePrV
(
WORD
 
wP
, 
BYTE
 
byTy
, WORD 
wNum
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

543 
	}
}

545 
	gCRtuBa
::
	$TnsMesge

BYTE
 
byTy
, BYTE* 
pBuf
, 
nL
 )

548 
	}
}

550 
	gCRtuBa
::
	$RdAlogDa
(*
pDa
)

552 if(
m_pAIMTab
==
NULL
) ;

553  
WORD
 
i
=0; i<
m_wAISum
; i++ )

555 if
m_pAIMTab
[
i
].
wS
 == 0 ||

556 
m_pAIMTab
[
i
].
wPNum
 == 0 ) ;

557 cڡ 
ANALOGITEM
 *
pIm
 =

558 
	`G_RTDB_Alog
(
m_pAIMTab
[
i
].
wS
-1, m_pAIMTab[i].
wPNum
-1);

559 if!
pIm
 ) ;

560 
pDa
[
i
] = (
WORD
)
pIm
->
fRlV
;

562 
	}
}

564 
	gCRtuBa
::
	$RdDigDa
(
BYTE
 *
pDa
 )

566 if(
m_pDIMTab
==
NULL
) ;

567  
WORD
 
i
=0; i<
m_wDISum
; i++ )

569 if
m_pDIMTab
[
i
].
wS
 == 0 ||

570 
m_pDIMTab
[
i
].
wPNum
 == 0 ) ;

571 cڡ 
DIGITALITEM
 *
pIm
 =

572 
	`G_RTDB_Dig
(
m_pDIMTab
[
i
].
wS
-1, m_pDIMTab[i].
wPNum
-1);

573 if!
pIm
 ) ;

575 if(
pIm
->
wStus
 & 
DISTATUS_VALUE
) != 0 )

576 
pDa
[ 
i
 ] = 1 ;

578 
pDa
[ 
i
 ] = 0 ;

580 
	}
}

582 
	gCRtuBa
::
	$RdPulDa
(
DWORD
 *
pDa
)

584 if(
m_pPIMTab
==
NULL
) ;

585  
WORD
 
i
=0; i<
m_wPISum
; i++ )

587 if
m_pPIMTab
[
i
].
wS
 == 0 ||

588 
m_pPIMTab
[
i
].
wPNum
 == 0 ) ;

589 cڡ 
PULSEITEM
 *
pIm
 =

590 
	`G_RTDB_Pul
(
m_pPIMTab
[
i
].
wS
-1, m_pPIMTab[i].
wPNum
-1);

591 if!
pIm
 ) ;

592 
pDa
[
i
] = 
pIm
->
dwRawV
;

594 
	}
}

605 
DWORD
 
	gCRtuBa
::
	$GPulDa
 ( 
WORD
 
wS
, WORD 
wP
, 
BOOL
 *
bIsG
 )

607 *
bIsG
 = 
FALSE
;

609 i0 =
wS
 || 0 =
wP
 )

614 cڡ 
PULSEITEM
 *
pIm
 = 
	`G_RTDB_Pul

wS
-1, 
wP
-1 );

615 if!
pIm
 )

620 *
bIsG
 = 
TRUE
;

621  
pIm
->
dwRawV
;

622 
	}
}

624 
	gCRtuBa
::
	$AddAlogEvt

WORD
 
wSlNo
 ,WORD 
wP
, 
fV
)

626 if((
wSlNo
 > 511|| (
wP
 > 4095)){

627 
	`tf
("\nr܅oovowe:%d\n", 
__LINE__
);

630 
m_mAIEMux
.
	`mTake
();

632 
SETDATA
 
da
 ;

633 
da
.
wP
 = wPnt ;

634 
da
.
fV
 = fVal ;

635 
da
.
wSlNo
 = wSerialNo ;

636 
m_dwAIEQueue
.
	`push_back

da
 );

638 if(
m_dwAIEQueue
.
	`size
()>
RTUMAX_AIE_LEN
)

639 
m_dwAIEQueue
.
	`p_t
();

641 
m_mAIEMux
.
	`mGive
();

642 
	}
}

644 
BOOL
 
	gCRtuBa
::
	$GAlogEvt

WORD
 &
wSlNo
 ,WORD& 
wP
, & 
fV
)

646 
m_mAIEMux
.
	`mTake
();

647 if(
m_dwAIEQueue
.
	`emy
()){

648 
m_mAIEMux
.
	`mGive
();

649  
FALSE
;

652 
SETDATA
 
da
 = 
m_dwAIEQueue
.
	`t
() ;

653 if((
da
.
wSlNo
 > 511|| (da.
wP
 > 4095)){

654 
	`tf
("\nr܅oovowe:%d\n", 
__LINE__
);

655 
m_dwAIEQueue
.
	`p_t
();

656 
m_mAIEMux
.
	`mGive
();

657  
FALSE
;

659 
wSlNo
 = 
da
.wSerialNo ;

660 
wP
 = 
da
.wPnt ;

661 
fV
 = 
da
.fVal ;

663 
m_dwAIEQueue
.
	`p_t
();

664 
m_mAIEMux
.
	`mGive
();

666  
TRUE
;

667 
	}
}

678 
	gCRtuBa
::
	$GAIReV
 ( 
WORD
 
wS
, WORD 
wP
, 
BOOL
 *
bIsG
 )

680 
fV
;

681 if
NULL
 !
bIsG
 )

682 *
bIsG
 = 
FALSE
;

683 if0 =
wS
 || 0 =
wP
 )

688 cڡ 
ANALOGITEM
 *
pIm
 = 
	`G_RTDB_Alog
(
wS
-1, 
wP
-1);

689 if
pIm
 )

691 
fV
 = 
pIm
->
fRlV
 *Im->
fRio
 +Im->
fOfft
;

697 if
NULL
 !
bIsG
 )

698 *
bIsG
 = 
TRUE
;

699  
fV
;

700 
	}
}

711 
	gCRtuBa
::
	$CcAIReV
 ( 
WORD
 
wS
, WORD 
wP
, 
fYcV
, 
BOOL
 *
bIsG
 )

713 
fV
;

714 if
NULL
 !
bIsG
 )

715 *
bIsG
 = 
FALSE
;

716 if0 =
wS
 || 0 =
wP
 )

721 cڡ 
ANALOGITEM
 *
pIm
 = 
	`G_RTDB_Alog
(
wS
-1, 
wP
-1);

722 if
pIm
 )

724 
fV
 = 
fYcV
 * 
pIm
->
fRio
 +Im->
fOfft
;

730 if
NULL
 !
bIsG
 )

731 *
bIsG
 = 
TRUE
;

732  
fV
;

733 
	}
}

742 
DWORD
 
	gCRtuBa
::
	$CcPulReV

WORD
 
wS
, WORD 
wP
, 
DWORD
 
dwYmV
, 
BOOL
 *
bIsG
 )

744 
DWORD
 
dwV
 = 0;

746 if
NULL
 !
bIsG
 )

747 *
bIsG
 = 
FALSE
;

749 if0 =
wS
 || 0 =
wP
 )

754 cڡ 
PULSEITEM
 *
pIm
 = 
	`G_RTDB_Pul
(
wS
-1, 
wP
-1);

755 if
pIm
 )

757 
dwV
 = ( 
DWORD
)
dwYmV
 * 
pIm
->
fRio
 );

764 if
NULL
 !
bIsG
 )

765 *
bIsG
 = 
TRUE
;

767  
dwV
;

769 
	}
}

771 
	gCRtuBa
::
	$AddDigEvt
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
)

773 
m_mDIEMux
.
	`mTake
();

775 
SETDATA
 
da
 ;

776 
da
.
wP
 = wPnt ;

777 
da
.
wV
 = wVal ;

778 
da
.
wSlNo
 = wSerialNo ;

780 
m_dwDIEQueue
.
	`push_back
(
da
);

781 if(
m_dwDIEQueue
.
	`size
()>
RTUMAX_DIE_LEN
)

782 
m_dwDIEQueue
.
	`p_t
();

783 
m_mDIEMux
.
	`mGive
();

785 
	}
}

787 
BOOL
 
	gCRtuBa
::
	$GDigEvt
(
WORD
 &
wSlNo
 ,WORD& 
wP
, WORD& 
wV
)

789 if(
m_dwDIEQueue
.
	`emy
() 
FALSE
;

790 
m_mDIEMux
.
	`mTake
();

792 
SETDATA
 
da
 = 
m_dwDIEQueue
.
	`t
() ;

793 
wSlNo
 = 
da
.wSerialNo ;

794 
wV
 = 
da
.wVal ;

795 
wP
 = 
da
.wPnt ;

797 
m_dwDIEQueue
.
	`p_t
();

798 
m_mDIEMux
.
	`mGive
();

800  
TRUE
;

801 
	}
}

803 
	gCRtuBa
::
	$AddSOEInfo
(
WORD
 
wSlNo
 ,WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

805 
m_mSOEMux
.
	`mTake
();

806 
m_sBufr
[
m_iSOE_wr_p
].
lTime
 =Time;

807 
m_sBufr
[
m_iSOE_wr_p
].
wMiSecd
 = wMiSecond;

808 
m_sBufr
[
m_iSOE_wr_p
].
wPNum
 = 
wP
;

809 
m_sBufr
[
m_iSOE_wr_p
].
wStus
 = 
wV
;

810 
m_sBufr
[
m_iSOE_wr_p
].
wSlNo
 = wSerialNo ;

811 
m_iSOE_wr_p
 = (m_iSOE_wr_p+1% 
RTUMAX_SOE_LEN
;

812 if
m_iSOE_wr_p
 =
m_iSOE_rd_p
 )

813 
m_iSOE_rd_p
 = (m_iSOE_rd_p+1% 
RTUMAX_SOE_LEN
;

814 
m_mSOEMux
.
	`mGive
();

815 
	}
}

817 
BOOL
 
	gCRtuBa
::
	$GSOEInfo
(
WORD
 &
wSlNo
 ,WORD& 
wP
, WORD& 
wV
, 
LONG
& 
lTime
, WORD& 
wMiSecd
)

820 
m_mSOEMux
.
	`mTake
();

821 
lTime
 = 
m_sBufr
[
m_iSOE_rd_p
].lTime;

822 
wMiSecd
 = 
m_sBufr
[
m_iSOE_rd_p
].wMiSecond;

823 
wP
 = 
m_sBufr
[
m_iSOE_rd_p
].
wPNum
;

824 
wV
 = 
m_sBufr
[
m_iSOE_rd_p
].
wStus
;

825 
wSlNo
 = 
m_sBufr
[
m_iSOE_rd_p
].wSerialNo ;

826 
m_iSOE_rd_p
 = (m_iSOE_rd_p+1% 
RTUMAX_SOE_LEN
;

827 
m_mSOEMux
.
	`mGive
();

828  
TRUE
;

829 
	}
}

831 
BOOL
 
	gCRtuBa
::
	$GSOEInfo
(
WORD
 &
wSlNo
 ,WORD *
wP
, WORD *
wV
, *
pTime
, WORD *
wMiSecd
)

833 if(
m_iSOE_rd_p
==
m_iSOE_wr_p
)

834  
FALSE
;

836 
m_mSOEMux
.
	`mTake
();

837 
	`GOwnSuTm

m_sBufr
[
m_iSOE_rd_p
].
lTime
, (
tm
 *)
pTime
);

841 *
wMiSecd
 = 
m_sBufr
[
m_iSOE_rd_p
].wMiSecond;

842 *
wP
 = 
m_sBufr
[
m_iSOE_rd_p
].
wPNum
;

843 *
wV
 = 
m_sBufr
[
m_iSOE_rd_p
].
wStus
;

844 
wSlNo
 = 
m_sBufr
[
m_iSOE_rd_p
].wSerialNo ;

845 
m_iSOE_rd_p
 = (m_iSOE_rd_p+1% 
RTUMAX_SOE_LEN
;

846 
m_mSOEMux
.
	`mGive
();

847  
TRUE
;

848 
	}
}

850 
	gCRtuBa
::
	$GCommObjPr
(
COMMOBJ_PROP
* 
pObjPr
)

852 
pObjPr
->
bySty
 = 1;

853 
pObjPr
->
byObjNum
 = 
	`LOBYTE
(
m_wObjNum
);

854 
	`rtf
(
pObjPr
->
szObjName
, 
m_szObjName
);

855 
	`rtf
(
pObjPr
->
szChl
, "%s", "");

856 
pObjPr
->
wPtNum
 = 0;

857 
pObjPr
->
wStus
 = 0;

859 
	}
}

862 
	$GPSum
(
BYTE
 
byTy
)

864 cڡ 
SYSINFO
 *
pDBInfo
 = 
	`G_RTDB_SysInfo
();

865 if!
pDBInfo
 )  -1;

866  
byTy
 )

868 0:  
pDBInfo
->
nAlogSum
;

869 1:  
pDBInfo
->
nDigSum
;

870 2:  
pDBInfo
->
nPulSum
;

871 3:  
pDBInfo
->
nRaySum
;

874 
	}
}

876 
	gCRtuBa
::
	$RtuWreCIV
(
WORD
 
wS
, WORD 
wP
, 
fV
)

878 
	`WreCIV

wS
 , 
wP
, 
fV
);

879 
	}
}

881 
	gCRtuBa
::
	$RtuWreAIV
(
WORD
 
wS
, WORD 
wP
, 
fV
)

883 
k
;

885 
k
 = 
	`GTnsNum
(0, 
wS
, 
wP
);

886 if
k
 < 0 || k >
MAX_ANALOG_SUM
 ) ;

887 
WORD
 
wNum
 = (WORD)
k
;

888 
	`WreAIV

wS
 , 
wNum
, 
fV
 );

890 
	}
}

892 
	gCRtuBa
::
	$RtuWreDIV
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
)

894 
k
;

895 
k
 = 
	`GTnsNum
(1, 
wS
, 
wP
);

896 if
k
 < 0 || k >
MAX_DIGITAL_SUM
 ) ;

897 
WORD
 
wNum
 = (WORD)
k
;

898 
	`WreDIV

wS
 , 
wNum
, 
wV
);

900 
	}
}

902 
	gCRtuBa
::
	$RtuWrePIV
(
WORD
 
wS
, WORD 
wP
, 
DWORD
 
dwV
)

904 
k
;

905 
k
 = 
	`GTnsNum
(2, 
wS
, 
wP
);

906 if
k
 < 0 || k >
MAX_PULSE_SUM
 ) ;

907 
WORD
 
wNum
 = (WORD)
k
;

908 
	`WrePIV

wS
 , 
wNum
, 
dwV
);

909 
	}
}

911 
	gCRtuBa
::
	$RtuWreSOEInfo
(
WORD
 
wS
, WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
)

913 
k
;

914 
k
 = 
	`GTnsNum
(1, 
wS
, 
wP
);

915 if
k
 < 0 || k >
MAX_DIGITAL_SUM
 ) ;

916 
WORD
 
wNum
 = (WORD)
k
;

917 
	`WreSOEInfo

wS
 , 
wNum
, 
wV
, 
lTime
, 
wMiSecd
);

918 
	}
}

920 
	gCRtuBa
::
	$RayProc
(
BYTE
 
byCommd
, 
WORD
 
wS
, WORD 
wClNum
, BYTE 
byResu
)

922 
k
 = 0 ;

924 
k
 = 
	`GTnsNum
(3, 
wS
, 
wClNum
);

925 if
k
 < 0 || k >
	`GPSum
(3) ) ;

926 
WORD
 
wIndex
 = (WORD)
k
;

927 
	`RayEchoProc
(
byCommd
, 
wIndex
, 
byResu
);

928 
	}
}

938 
	gCRtuBa
::
	$RdChgDa
 ( )

941  
m_iSOEPos
 !
m_pDBInfo
->
nSOEWrePos
 )

943 cڡ 
SOEITEM
 *
p
 = 
	`Rd_RTDB_SOE
(
m_iSOEPos
);

944 if(
p
->
wArib
 =0
	`RtuWreDIV
->
wSID
,->
wPNum
,->
byS
);

947 if(
p
->
wArib
 >= 2)

948 
	`RtuWreDIV
(
p
->
wSID
,->
wPNum
,->
byS
);

950 
	`RtuWreSOEInfo
(
p
->
wSID
,->
wPNum
,->
byS
,->
lTime
,->
wMiSecd
);

954 
m_iSOEPos
 = (m_iSOEPos+1)%
SOE_QUEUE_SUM
;

958  
m_iAIEPos
 !
m_pDBInfo
->
nAIEWrePos
 )

960 cڡ 
AIEITEM
 *
p
 = 
	`Rd_RTDB_AIE
(
m_iAIEPos
);

961 
	`RtuWreAIV
(
p
->
wSID
,->
wPNum
,->
fVue
 );

962 
m_iAIEPos
 = (m_iAIEPos+1)%
AIE_QUEUE_SUM
;

966 
	}
}

972 
	gCRtuBa
::
RdChgeStus
(
d
::
m
<
WORD
, 
BYTE
> &
m_
, std::
deque
<
Si_
> &
deque_
)

974 
WORD
 
i
,
	gsize
 = 
m_
.
size
();

975 
BOOL
 
	gus
;

977 
	gi
 = 0; i < 
	gsize
; i++){

978 
	gus
 = 
m_pMhod
->
GDevCommS
(
i
);

981 if(
	gus
 !
m_
[
i
]){

982 
m_
[
i
] = 
us
;

983 if(
	gdeque_
.
size
() > 256)

984 
	gdeque_
.
p_t
();

985 
	gdeque_
.
push_back
(
Si_
(
i
, 
us
));

991 
WORD
 
	gCRtuBa
::
	$GSlNoFromTns

BYTE
 
byTy
 , 
WORD
 
wTnNum
 )

993 
WORD
 
wSlNo
 = 0xFFFF ;

994  
byTy
 )

996 
YC_TRANSTOSERIALNO
:

998 if
wTnNum
 > 
m_wAISum
 )

999  
wSlNo
 ;

1001 
wSlNo
 = 
m_pAIMTab
[ 
wTnNum
 ].
wS
 -1 ;

1004 
YX_TRANSTOSERIALNO
:

1006 if
wTnNum
 > 
m_wDISum
 )

1007  
wSlNo
 ;

1009 
wSlNo
 = 
m_pDIMTab
[ 
wTnNum
 ].
wS
 -1 ;

1012 
YK_TRANSTOSERIALNO
:

1014 if
wTnNum
 > 
m_wDOSum
 )

1015  
wSlNo
 ;

1017 
wSlNo
 = 
m_pDOMTab
[ 
wTnNum
 ].
wS
 -1 ;

1020 
DD_TRANSTOSERIALNO
:

1022 if
wTnNum
 > 
m_wPISum
 )

1023  
wSlNo
 ;

1025 
wSlNo
 = 
m_pPIMTab
[ 
wTnNum
 ].
wS
 -1 ;

1030  
wSlNo
 ;

1031 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/Rtu.h

5 #ide
_RTUBASE_H_


6 
	#_RTUBASE_H_


	)

8 
	~<ve
>

9 
	~<deque
>

10 
	~<m
>

11 
	~<had.h
>

13 
	~"../libdb/mObj.h
"

14 
	~"BaPt.h
"

15 
	~"CProc.h
"

17 
	gd
::
	tdeque
< 
	tSETDATA
> 
	tCSDaQueue
;

19 
	#YC_TRANSTOSERIALNO
 1

	)

20 
	#YX_TRANSTOSERIALNO
 2

	)

21 
	#YK_TRANSTOSERIALNO
 3

	)

22 
	#DD_TRANSTOSERIALNO
 4

	)

24 
	#RTUSTATUS_STANDBY
 0x00

	)

25 
	#RTUSTATUS_ONLINE
 0x01

	)

26 
	#RTUSTATUS_FAULT
 0x02

	)

27 
	#RTUSTATUS_STOPUSE
 0x03

	)

29 
	#MAPMAX_AI_LEN
 4096

	)

30 
	#MAPMAX_DI_LEN
 8192

	)

31 
	#MAPMAX_PI_LEN
 4096

	)

32 
	#MAPMAX_DO_LEN
 512

	)

33 
	#MAPMAX_AO_LEN
 128

	)

35 
	#MAX_RTUDATA_LEN
 1024

	)

37 
	s_gRTUMSG


39 
WORD
 
	mwPtNo
;

40 
WORD
 
	mwMsgL
;

41 
BYTE
 * 
	mMsgDa
;

42 } 
	tRTUMSG
;

44 
	s_gMAPITEM


46 
WORD
 
	mwS
;

47 
BYTE
 
	mbyUn
;

48 
WORD
 
	mwPNum
;

49 } 
	tMAPITEM
;

51 
	s_gPROTITEM


53 
WORD
 
	mwS
;

54 
BYTE
 
	mbyPro
;

55 
WORD
 
	mwP
;

56 
WORD
 
	mwAddr
;

57 
WORD
 
	mwCode
;

58 } 
	tPROTITEM
;

60 
	s_gMAPPROT


62 
BYTE
 
	mbyMode
;

63 
WORD
 
	mwTnsNo
;

64 
WORD
 
	mwSignSum
;

65 
WORD
 
	mwSignCou
[3];

66 
WORD
 
	mwSignOfft
[3];

67 } 
	tMAPPROT
;

69 
	s_gMAPTAB


71 
WORD
 
	mwAISum
;

72 
WORD
 
	mwDISum
;

73 
WORD
 
	mwPISum
;

74 
WORD
 
	mwDOSum
;

75 
WORD
 
	mwAOSum
;

76 
MAPITEM
* 
	mpAIMTab
;

77 
MAPITEM
* 
	mpDIMTab
;

78 
MAPITEM
* 
	mpPIMTab
;

79 
MAPITEM
* 
	mpDOMTab
;

80 
MAPITEM
* 
	mpAOMTab
;

81 }
	tMAPTAB
;

83 
	s_gSOEINFO


85 
LONG
 
	mlTime
;

86 
WORD
 
	mwMiSecd
;

87 
WORD
 
	mwPNum
;

88 
WORD
 
	mwStus
;

89 
WORD
 
	mwSlNo
 ;

90 } 
	tSOEINFO
;

92 
	s_gCommObjPr


94 
BYTE
 
	mbySty
;

95 
BYTE
 
	mbyObjNum
;

96 
	mszObjName
[24];

97 
	mszChl
[24];

98 
WORD
 
	mwPtNum
;

99 
WORD
 
	mwStus
;

100 } 
	tCOMMOBJ_PROP
;

102 
	#RTUMAX_AIE_LEN
 4096

	)

103 
	#RTUMAX_DIE_LEN
 96

	)

104 
	#RTUMAX_SOE_LEN
 96

	)

108 
DWORD
 
	mdwVue
;

111 
BYTE
 
	mbyV0
;

112 
BYTE
 
	mbyV1
;

113 
BYTE
 
	mbyV2
;

114 
BYTE
 
	mbyV3
;

115 } 
	mpi
;

116 } 
	tPIDBDEF
;

118 #agm
ck
(1)

120 
	#MAX_DATA_LEN
 512

	)

121 
	s_gRTDBDATA


123 
DWORD
 
	mdwAddrID
;

124 
WORD
 
	mwDaL
;

125 
BYTE
 
	mbyTyID
;

126 
BYTE
 
	mbyDevNum
;

127 
BYTE
 
	mbyDaBuf
[
MAX_DATA_LEN
];

128 } 
	tRTDBDATA
;

130 as
	cSi_
{

131 
	mpublic
:

132 
	$Si_
(
WORD
 
m
, WORD 
n
):
	`ro
(m), 
	$
(
n
){};

133 
WORD
 
ro
;

134 
WORD
 

;

135 
	}
};

137 #agm
ck
()

142 as
	cCRtuBa
 : 
public
 
CProc


144 
public
:

145 
CRtuBa
();

146 
	mvtu
 ~
CRtuBa
();

149 
	mpublic
:

150 
BYTE
 
m_byProID
;

151 
BYTE
 
	mm_byEb
;

152 
WORD
 
	mm_wObjNum
;

153 
	mm_szObjName
[24];

154 
WORD
 
	mm_wPtNum
;

155 
	mm_ComCl1
[24];

156 
	mm_ComCl2
[24];

157 
WORD
 
	mm_wRtuAddr
;

158 
WORD
 
	mm_wDdV
;

159 
WORD
 
	mm_wReV
;

160 
WORD
 
	mm_wRecvClock
;

163 
BYTE
 
	mm_byAi
;

164 
BYTE
 
	mm_byABay
, 
	mm_byAMk
;

165 
WORD
 
	mm_wANum
;

166 
WORD
 
	mm_wRayNum
;

167 
WORD
 
	mm_wSeTim
;

170 
WORD
 
	mm_wAISum
;

171 
WORD
 
	mm_wDISum
;

172 
WORD
 
	mm_wPISum
;

173 
WORD
 
	mm_wDOSum
;

174 
WORD
 
	mm_wAOSum
;

175 
WORD
 
	mm_wSignSum
;

176 
WORD
 
	mm_wDZSum
 ;

178 
BOOL
 
	mm_bTaskRun
;

179 
	meed
:

180 
WORD
* 
m_pwCITns
;

181 
MAPITEM
* 
	mm_pAIMTab
; 
WORD
* 
	mm_pwAITns
;

182 
MAPITEM
* 
	mm_pDIMTab
; 
WORD
* 
	mm_pwDITns
;

183 
MAPITEM
* 
	mm_pPIMTab
; 
WORD
* 
	mm_pwPITns
;

184 
MAPITEM
* 
	mm_pDOMTab
; 
WORD
* 
	mm_pwDOTns
;

185 
MAPITEM
* 
	mm_pAOMTab
; 
WORD
* 
	mm_pwAOTns
;

186 
MAPITEM
* 
	mm_pDZMTab
; 
WORD
 * 
	mm_pwDZTns
 ;

188 
CSDaQueue
 
	mm_dwAIEQueue
;

189 
CSDaQueue
 
	mm_dwDIEQueue
;

190 
SOEINFO
 
	mm_sBufr
[
RTUMAX_SOE_LEN
];

191 
	mm_iSOE_wr_p
;

192 
	mm_iSOE_rd_p
;

194 
SYSINFO
* 
	mm_pDBInfo
;

195 
	mm_iSOEPos
;

196 
	mm_iAIEPos
;

198 
CSemObj
 
	mm_mAIEMux
;

199 
CSemObj
 
	mm_mDIEMux
;

200 
CSemObj
 
	mm_mSOEMux
;

203 
	md
::
m
<
WORD
, 
	mBYTE
> 
	mm_
;

204 
	md
::
deque
<
Si_
> 
deque_
;

207 
	meed
:

208 
BOOL
 
IsPtVid
();

209 
CloPt
();

210 
	mpublic
:

211 
CeTnsTab
();

212 
RdMCfig
(
LPCSTR
 
szFe
);

213 
SObjPam
(
WORD
 
wP
, WORD 
wSignSum
, WORD 
wPos1
, WORD 
wPos2
, WORD 
wPos3
);

214 
GPrUnAr
(
BYTE
 
byTy
, 
WORD
 
wAddr
, BYTE& 
byPro
, WORD& 
wS
, WORD& 
wP
);

215 
AddAlogEvt

WORD
 
wSlNo
 , WORD 
wP
, 
fV
);

216 
AddDigEvt

WORD
 
wSlNo
 , WORD 
wP
, WORD 
wV
);

217 
AddSOEInfo

WORD
 
wSlNo
 , WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
);

218 
BOOL
 
GAlogEvt
(
WORD
 &
wSlNo
 , WORD& 
wP
, & 
fV
 );

219 
BOOL
 
GDigEvt

WORD
 &
wSlNo
 , WORD& 
wP
, WORD& 
wV
);

220 
BOOL
 
GSOEInfo

WORD
 &
wSlNo
 , WORD& 
wP
, WORD& 
wV
, 
LONG
& 
lTime
, WORD& 
wMiSecd
);

221 
BOOL
 
GSOEInfo
(
WORD
 &
wSlNo
 , WORD *
wP
, WORD *
wV
, *
pTime
, WORD *
wMiSecd
);

223 
DWORD
 
GPulDa
 ( 
WORD
 
wS
 , WORD 
wP
 , 
BOOL
 *
bIsG
 = 
NULL
 );

225 
CcAIReV
 ( 
WORD
 
wS
 = 0, WORD 
wP
 = 0, 
fYcV
 = 0, 
BOOL
 *
bIsG
 = 
NULL
 );

226 
GAIReV
 ( 
WORD
 
wS
 = 0, WORD 
wP
 = 0, 
BOOL
 *
bIsG
 = 
NULL
 );

228 
DWORD
 
CcPulReV

WORD
 
wS
, WORD 
wP
, DWORD 
dwYmV
, 
BOOL
 *
bIsG
 = 
NULL
 );

230 
RtuWreCIV
(
WORD
 
wSlNo
, WORD 
wP
, 
fV
);

231 
RtuWreAIV
(
WORD
 
wSlNo
, WORD 
wP
, 
fV
 );

232 
RtuWrePIV
(
WORD
 
wSlNo
, WORD 
wP
, 
DWORD
 
dwV
);

233 
RtuWreDIV
(
WORD
 
wSlNo
, WORD 
wP
, WORD 
wV
);

234 
RtuWreSOEInfo
(
WORD
 
wSlNo
, WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
);

236 
RayProc
(
BYTE
 
byCommd
, 
WORD
 
wS
, WORD 
wClNum
, BYTE 
byResu
);

237 
RdChgDa
 ( );

238 
WORD
 
GSlNoFromTns

BYTE
 
byTy
 , WORD 
wTnNum
 ) ;

240 
vtu
 * 
	$ProName
(){ (*)"Base";}

241 
vtu
 
BOOL
 
	`InRtuBa
();

242 
vtu
 
RTUMSG
* 
	`LdRtuMesge
();

243 
vtu
 
	`RtuCommdProc

BYTE
* 
pRecvBuf
, 
nL
 );

244 
vtu
 
BOOL
 
	$GUrossBuf
 ( cڡ 
BYTE
 *
pBuf
, cڡ 
iL
, *
pVoid
 ){ 
FALSE
;
	}
}

245 
vtu
 
	$TimProc
(){
	`tf
("u\n"); ; 
	}
}

246 
vtu
 
RdAlogDa
(*
pDa
);

247 
vtu
 
RdDigDa

BYTE
 *
pDa
 );

248 
vtu
 
RdPulDa
(
DWORD
 *
pDa
);

250 
vtu
 
GRlV
(
BYTE
 
byTy
, 
WORD
 
wP
, *
v
);

251 
vtu
 
GDIVue
(
WORD
 
wP
, WORD 
wSrcNo
, *
v
);

253 
vtu
 
BOOL
 
	$WreCIV
(
WORD
 
wSlNo
, WORD 
wP
, 
fV
){  
FALSE
 ;
	}
}

254 
vtu
 
BOOL
 
	$WreAIV
(
WORD
 
wSlNo
, WORD 
wP
, 
fV
 ){  
FALSE
 ;
	}
}

255 
vtu
 
BOOL
 
	$WreDIV
(
WORD
 
wSlNo
, WORD 
wP
, WORD 
wV
){  
FALSE
 ;
	}
}

256 
vtu
 
BOOL
 
	$WrePIV
(
WORD
 
wSlNo
, WORD 
wP
, 
DWORD
 
dwV
){  
FALSE
 ;
	}
}

257 
vtu
 
BOOL
 
	$WreSOEInfo
(
WORD
 
wSlNo
, WORD 
wP
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
){  
FALSE
 ;
	}
}

259 
vtu
 
RayEchoProc
(
BYTE
 
byCommd
, 
WORD
 
wIndex
, BYTE 
byResu
);

260 
vtu
 
WrePrMesge
(
BYTE
 
byPro
, 
WORD
 
wPam
, BYTE* 
pBuf
, 
nBy
);

261 
vtu
 
WrePrV
(
WORD
 
wP
, 
BYTE
 
byTy
,

262 
WORD
 
wNum
, WORD 
wV
, 
LONG
 
lTime
, WORD 
wMiSecd
);

263 
vtu
 
TnsMesge
(
BYTE
 
byTy
, BYTE* 
pBuf
, 
nL
);

264 
vtu
 
GCommObjPr
(
COMMOBJ_PROP
* 
pObjPr
);

267 
vtu
 
RdChgeStus
(
d
::
m
<
WORD
, 
BYTE
> &, std::
deque
<
Si_
> &);

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/SerialPort.cpp

7 
	~<dio.h
>

8 
	~<dlib.h
>

9 
	~<rg.h
>

10 
	~<unid.h
>

11 
	~<f.h
>

12 
	~<rmios.h
>

13 
	~<sys/iol.h
>

14 
	~<sys/tys.h
>

15 
	~<sys/.h
>

16 
	~<sys/time.h
>

17 
	~<o.h
>

19 
	~"SlPt.h
"

23 
	#MAX_COMM_NUM
 6

	)

24 *
	gSERIAL_NAME
[
MAX_COMM_NUM
] =

34 
	#MAX_COMM_NUM
 16

	)

37 *
	gSERIAL_NAME
[
MAX_COMM_NUM
] =

60 *
	gSERIAL_NAME
[
MAX_COMM_NUM
]={

80 *
	gSERIAL_NAME
[
MAX_COMM_NUM
]={

93 
	gCSlPt
::
	$CSlPt
()

95 
m_uThePt
 = 1;

96 
m_hComm
 = 
ERROR
;

97 
m_nBaudRe
 = 1200;

98 
	}
}

100 
	gCSlPt
::~
	$CSlPt
()

102 
	`CloPt
();

103 
	}
}

105 
BOOL
 
	gCSlPt
::
	$IsPtVid
( )

107  (
m_hComm
 > 0);

108 
	}
}

110 
	gCSlPt
::
	$CloPt
( )

112 if!
	`IsPtVid
() ) ;

113 
	`tcush
(
m_hComm
, 
TCIFLUSH
);

114 
	`tcush
(
m_hComm
, 
TCOFLUSH
);

115 
	`o
(
m_hComm
);

116 
	}
}

119 
BOOL
 
	gCSlPt
::
	$OnPt
* 
szE
 )

121 
i
, 
k
, 
nL
;

122 
szName
[32];

123 
rmios
 
tio
;

124 cڡ * 
p
 = 
m_szArib
;

126 
nL
 = 
	`
(
m_szArib
);

127  
i
=0, 
k
=0; i<
nL
; i++, 
p
++ )

129 if*
p
 !',' ) { 
szName
[
k
++] = *p; }

130 { 
szName
[
k
] = '\0'; ; }

132  
	`oi
(
szName
) )

134 300: 
m_nBaudRe
=
B300
; ;

135 600: 
m_nBaudRe
=
B600
; ;

136 1200: 
m_nBaudRe
=
B1200
; ;

137 2400: 
m_nBaudRe
=
B2400
; ;

138 4800: 
m_nBaudRe
=
B4800
; ;

139 9600: 
m_nBaudRe
=
B9600
; ;

140 19200: 
m_nBaudRe
=
B19200
; ;

141 38400: 
m_nBaudRe
=
B38400
; ;

142 57600: 
m_nBaudRe
=
B57600
; ;

143 115200: 
m_nBaudRe
=
B115200
; ;

145 if
szE
 )

146 
	`rtf

szE
, "Baud(%sr!", 
szName
 );

147  
FALSE
;

149 if(
m_uThePt
>0 && m_uThePt<=
MAX_COMM_NUM
)

150 
	`rtf

szName
, "%s", 
SERIAL_NAME
[
m_uThePt
-1] );

153 if
szE
 )

154 
	`rtf

szE
, "p܊um(%dnex!", 
m_uThePt
 );

155  
FALSE
;

157 
m_hComm
 = 
	`ݒ

szName
, 
O_RDWR
|
O_NOCTTY
|
O_NDELAY
, 0 );

158 if
m_hComm
 < 0 )

160 if
szE
 )

161 
	`rtf

szE
, "ݒ %r!", 
szName
 );

162  
FALSE
;

164 
	`f

m_hComm
, 
F_SETFL
, 0 );

167 
	`tcg

m_hComm
, &
tio
 );

169 
	`cftid
&
tio
, 
m_nBaudRe
 );

170 
	`cftod
&
tio
, 
m_nBaudRe
 );

171 
	`cfmakaw
&
tio
 );

173 
p
++;

195  *
p
 )

199 
tio
.
c_cag
 &~
PARENB
;

200 
tio
.
c_iag
 &~
INPCK
;

204 
tio
.
c_cag
 |(
PARODD
 | 
PARENB
);

205 
tio
.
c_iag
 |
INPCK
;

209 
tio
.
c_cag
 |
PARENB
;

210 
tio
.
c_cag
 &~
PARODD
;

211 
tio
.
c_iag
 |
INPCK
;

215 
tio
.
c_cag
 &~
PARENB
;

216 
tio
.
c_cag
 &~
CSTOPB
;

219 
	`rtf
(
dr
,"Unsupportedarity/n");

220  (
FALSE
);

224 
tio
.
c_cag
 &~
CSIZE
;

225  
p
[2] )

228 
tio
.
c_cag
 |
CS5
;

231 
tio
.
c_cag
 |
CS6
;

234 
tio
.
c_cag
 |
CS7
;

237 
tio
.
c_cag
 |
CS8
;

240 
	`rtf
(
dr
,"Unsupported data size/n");

241  (
FALSE
);

245  
p
[4] )

248 
tio
.
c_cag
 &~
CSTOPB
;

251 
tio
.
c_cag
 |
CSTOPB
;

254 
	`rtf
(
dr
,"Unsupported stop bits/n");

255  (
FALSE
);

259 
	`tcr

m_hComm
, 
TCSANOW
, &
tio
 );

260 
	`tcush

m_hComm
, 
TCIOFLUSH
 );

262 if
szE
 )

263 
	`rtf

szE
, "ݒ %s(BAUDRATE=%dok!", 
szName
, 
m_nBaudRe
 );

264  
TRUE
;

265 
	}
}

267 
BOOL
 
	gCSlPt
::
	$SQueue

DWORD
 
dwInQueueSize
, DWORD 
dwOutQueueSize
 )

269 if!
	`IsPtVid
( 
FALSE
;

272  
TRUE
;

273 
	}
}

275 
	gCSlPt
::
	$GInQueue
( )

277 
nBys
 = 0;

278 if!
	`IsPtVid
() )  -1;

279 
	`iol
(
m_hComm
, 
FIONREAD
, ()&
nBys
);

280  
nBys
;

281 
	}
}

283 
	gCSlPt
::
	$GOutQueue
( )

285 
nBys
 = 0;

286 if!
	`IsPtVid
() )  -1;

288  
nBys
;

289 
	}
}

291 
	gCSlPt
::
	$RdPt

BYTE
 *
pBuf
, 
nRd
 )

293 if!
	`IsPtVid
(|| 
nRd
<=0 )  -1;

294  
	`ad
(
m_hComm
, (*)
pBuf
, 
nRd
);

295 
	}
}

297 
	gCSlPt
::
	$WrePt

BYTE
 *
pBuf
, 
nWre
 )

299 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

300 
	`tcush

m_hComm
, 
TCOFLUSH
 );

301 
iR
 = 
	`wre
(
m_hComm
, (*)
pBuf
, 
nWre
);

302  
iR
;

303 
	}
}

305 
	gCSlPt
::
	$AsyRdDa

BYTE
 *
pBuf
, 
nRd
 )

307 
iR
;

315 if!
	`IsPtVid
(|| 
nRd
<=0 )  -1;

316 
fd_t
 
rfds
;

317 
timev
 
tv
;

319 
	`FD_ZERO
(&
rfds
);

320 
	`FD_SET
(
m_hComm
, &
rfds
);

321 
tv
.
tv_c
 = 0;

322 
tv
.
tv_uc
 = 100000;

323  
	`
(
m_hComm
+1, &
rfds
, 
NULL
, NULL, &
tv
) )

325 
ERROR
:

330 if(
	`FD_ISSET
(
m_hComm
, &
rfds
))

332 
iR
 = 
	`ad
(
m_hComm
, (*)
pBuf
, 
nRd
);

333 
	`tcush

m_hComm
, 
TCIFLUSH
 );

334  
iR
;

340 
	}
}

342 
	gCSlPt
::
	$AsySdDa

BYTE
 *
pBuf
, 
nWre
 )

344 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

346 
fd_t
 
wfds
;

347 
timev
 
tv
;

349 
	`FD_ZERO
(&
wfds
);

350 
	`FD_SET
(
m_hComm
, &
wfds
);

351 
tv
.
tv_c
 = 0;

352 
tv
.
tv_uc
 = 100000;

353  
	`
(
m_hComm
+1, 
NULL
, &
wfds
, NULL, &
tv
) )

355 
ERROR
:

360 if(
	`FD_ISSET
(
m_hComm
, &
wfds
))

361  
	`wre
(
m_hComm
, (*)
pBuf
, 
nWre
);

365 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/SerialPort.h

6 #ide
_SERIALPORT_H_


7 
	#_SERIALPORT_H_


	)

9 
	~"BaPt.h
"

14 as
	cCSlPt
 : 
public
 
CBaPt


17 
public
:

18 
CSlPt
();

19 
	mvtu
 ~
CSlPt
();

20 
vtu
 * 
	$CssName
(){ (*)"CSerialPort";}

23 
ive
:

24 
m_nBaudRe
;

26 
eed
:

28 
public
:

31 
public
:

32 
vtu
 
BOOL
 
	`IsPtVid
( );

33 
vtu
 
BOOL
 
	`OnPt
* 
szE
=
NULL
 );

34 
vtu
 
	`CloPt
( );

35 
vtu
 
BOOL
 
	`SQueue

DWORD
 
dwInQueueSize
, DWORD 
dwOutQueueSize
 );

36 
vtu
 
	`GInQueue
( );

37 
vtu
 
	`GOutQueue
( );

38 
vtu
 
	`RdPt

BYTE
 *
pBuf
, 
nRd
 );

39 
vtu
 
	`WrePt

BYTE
 *
pBuf
, 
nWre
 );

40 
vtu
 
	`AsyRdDa

BYTE
 *
pBuf
, 
nRd
 );

41 
vtu
 
	`AsySdDa

BYTE
 *
pBuf
, 
nWre
 );

43 
ive
:

45 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpClient.cpp

4 
	~<dio.h
>

5 
	~<dlib.h
>

6 
	~<rg.h
>

7 
	~<unid.h
>

8 
	~<f.h
>

9 
	~<rmios.h
>

10 
	~<y.h
>

11 
	~<sys/iol.h
>

12 
	~<sys/mm.h
>

13 
	~<sys/tys.h
>

14 
	~<sys/m.h
>

15 
	~<sys/.h
>

16 
	~<sys/time.h
>

17 
	~<sigl.h
>

18 
	~<o.h
>

19 
	~<t/.h
>

20 
	~<sys/sock.h
>

21 
	~</.h
>

22 
	~<tdb.h
>

24 
	~"TCl.h
"

25 
	#MAX_TCP_SIZE
 1280

	)

30 
	gCTCl
::
	$CTCl
()

32 
m_hComm
 = 
ERROR
 ;

33 
m_bCt
 = 
FALSE
 ;

34 
	}
}

36 
	gCTCl
::~
	$CTCl
()

38 
	`CloPt
() ;

39 
	}
}

41 
BOOL
 
	gCTCl
::
	$IsPtVid
( )

43 if(
m_hComm
 <= 0)

46  
FALSE
;

49 if(
m_bCt
 <= 0)

52  
FALSE
 ;

55  
TRUE
;

56 
	}
}

58 
BOOL
 
	gCTCl
::
	$OnPt
* 
szE
 )

60 
nV
;

61 
buf
[ 24 ] ;

65 
	`memy
(
m_szRemeAddr
, 
m_szArib
, 24);

66 
	`memy

buf
 , 
m_szArib
 , 24 ) ;

67 if(
m_hComm
=
	`sock
(
AF_INET
, 
SOCK_STREAM
, 0))==
ERROR
 )

69 if
szE
 )

70 
	`rtf

szE
, "CTcpPort: %s", "Create socketrror!" );

71  
FALSE
;

74 
nAddrSize
 = (
sockaddr_
);

75 
	`bzo
((*)&
m_RemeAddr
, 
nAddrSize
);

76 
m_RemeAddr
.
s_my
 = 
AF_INET
;

77 
m_RemeAddr
.
s_pt
 = 
	`hts

m_uThePt
 );

78 
m_RemeAddr
.
s_addr
.
s_addr
 = 
	`_addr

m_szArib
 );

81 
nV
 = 1;

82 
	`tsockt
(
m_hComm
, 
SOL_SOCKET
, 
SO_REUSEADDR
, (*)&
nV
, (nVal));

85 
nV
 = 
MAX_TCP_SIZE
;

86 
	`tsockt
(
m_hComm
, 
SOL_SOCKET
, 
SO_RCVBUF
, (*)&
nV
, (nVal));

89 
	`C
();

91  
TRUE
 ;

92 
	}
}

94 
BOOL
 
	gCTCl
::
	$C
( )

96 if
m_hComm
 <0 )  
FALSE
;

97 if
	`c

m_hComm
,

98 (
sockaddr
*)&
m_RemeAddr
,

99 (
m_RemeAddr
=
ERROR
 )

101  
FALSE
;

103 
m_bCt
 = 
TRUE
 ;

104  
TRUE
;

105 
	}
}

107 
	gCTCl
::
	$CloPt
( )

109 if(
m_hComm
==
ERROR
) ;

110 
	`shutdown
(
m_hComm
, 2);

111 
	`o
(
m_hComm
);

112 
m_hComm
 = 
ERROR
;

113 
m_bCt
 = 0;

114 
	}
}

116 
	gCTCl
::
	$RdPt

BYTE
 *
pBuf
, 
nRd
 )

118 
nBys
 = 0;

120 if!
	`IsPtVid
(|| 
nRd
<=0 )  -1;

121 
nBys
 = 
	`cv

m_hComm
, (*)
pBuf
, 
nRd
, 0 );

122 if
nBys
 =
ERROR
 )

124 
m_bCt
 = 
FALSE
 ;

128  
nBys
;

129 
	}
}

131 
	gCTCl
::
	$WrePt

BYTE
 *
pBuf
, 
nWre
 )

133 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

135 
nBys
 = 
	`nd

m_hComm
, (*)
pBuf
, 
nWre
, 
MSG_NOSIGNAL
 );

136 if
nBys
 =
ERROR
 )

138 
	`
( "send" ) ;

139 
m_bCt
 = 0;

142  
nBys
;

143 
	}
}

145 
	gCTCl
::
	$AsyRdDa

BYTE
 *
pBuf
, 
nRd
 )

147 
nBys
 = 0;

148 
fd_t
 
rfds
;

149 
timev
 
tv
;

151 if!
	`IsPtVid
(|| 
nRd
<=0 )  -1;

152 
	`FD_ZERO
(&
rfds
);

153 
	`FD_SET
(
m_hComm
, &
rfds
);

154 
tv
.
tv_c
 = 0;

155 
tv
.
tv_uc
 = 10000;

156  
	`
(
m_hComm
+1, &
rfds
, 
NULL
, NULL, &
tv
) )

158 
ERROR
:

159 
m_bCt
 = 0;

164 if(
	`FD_ISSET
(
m_hComm
, &
rfds
))

166 
nBys
 = 
	`cv

m_hComm
, (*)
pBuf
, 
nRd
, 0 );

167 if
nBys
 =
ERROR
 )

169 if
nBys
 == 0 )

170 
	`CloPt
() ;

174  
nBys
;

175 
	}
}

177 
	gCTCl
::
	$AsySdDa

BYTE
 *
pBuf
, 
nWre
 )

180 
	}
}

182 
BOOL
 
	gCTCl
::
	$Pg
* 
cIp
 )

184 if
cIp
 =
NULL
 )

185  
FALSE
 ;

187 
m_Pg
.
	`Pg

cIp
 ) ;

189  
TRUE
 ;

190 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpClient.h

6 #ide
_TCPCLIENT_H_


7 
	#_TCPCLIENT_H_


	)

9 
	~<t/.h
>

10 
	~"BaPt.h
"

11 
	~"PtTe.h
"

13 as
	cCTCl
 : 
public
 
CBaPt


15 
public
:

16 
CTCl
();

17 
	mvtu
 ~
CTCl
();

18 
vtu
 
BOOL
 
IsPtVid
( );

19 
vtu
 
BOOL
 
OnPt
* 
szE
=
NULL
 );

20 
vtu
 
CloPt
( );

21 
vtu
 
RdPt

BYTE
 *
pBuf
, 
nRd
 );

22 
vtu
 
WrePt

BYTE
 *
pBuf
, 
nWre
 );

23 
vtu
 
AsyRdDa

BYTE
 *
pBuf
, 
nRd
 );

24 
vtu
 
AsySdDa

BYTE
 *
pBuf
, 
nWre
 );

25 
vtu
 
BOOL
 
C
( );

26 
	meed
:

27 
BOOL
 
m_bCt
 ;

28 
sockaddr_
 
	mm_RemeAddr
;

29 
BOOL
 
Pg
* 
cIp
 ) ;

30 
CPtTe
 
	mm_Pg
 ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpClientShort.cpp

5 
	~"TClSht.h
"

11 
	gCTClSht
::
	$CTClSht
()

14 
	}
}

16 
CTClSht
::~
	$CTClSht
()

19 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpClientShort.h

5 #i!
defed
(
AFX_TCPCLIENTSHORT_H__1D95CAB6_9303_46D6_BE27_EDD7D0FCE928__INCLUDED_
)

6 
	#AFX_TCPCLIENTSHORT_H__1D95CAB6_9303_46D6_BE27_EDD7D0FCE928__INCLUDED_


	)

8 #i
_MSC_VER
 > 1000

9 #agm



12 
	~"TCl.h
"

18 as
	cCTClSht
 : 
public
 
CTCl


20 
public
:

21 
CTClSht
();

22 
	mvtu
 ~
CTClSht
();

23 
vtu
 * 
	$CssName
(){ (*)"CTcpClientShort";}

24 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpListen.cpp

5 
	~<dio.h
>

6 
	~<dlib.h
>

7 
	~<rg.h
>

8 
	~<unid.h
>

9 
	~<f.h
>

10 
	~<rmios.h
>

11 
	~<y.h
>

12 
	~<sys/iol.h
>

13 
	~<sys/mm.h
>

14 
	~<sys/tys.h
>

15 
	~<sys/m.h
>

16 
	~<sys/.h
>

17 
	~<sys/time.h
>

18 
	~<sigl.h
>

19 
	~<o.h
>

20 
	~<t/.h
>

21 
	~<sys/sock.h
>

22 
	~</.h
>

23 
	~<tdb.h
>

25 
	~"TLi.h
"

27 
	#SERVER_MAX_CONNECTIONS
 4

	)

29 #ifdef 
__lulus


33 
OutPromText
(*
szText
);

34 
LogPromText
(cڡ *
fmt
, ...);

35 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
);

37 * 
TSvrTask
(*
pLiObj
)

39 ((
CTLi
*)
pLiObj
)->
WkTaskProc
();

40 
had_ex
(0);

41  
NULL
;

44 #ifdef 
__lulus


49 
CTLi
::
	$CTLi
()

51 
m_nThePt
 = 3066;

52 
m_hSock
 = 
ERROR
;

53 
m_pAcObj
 = 
NULL
;

54 
m_nAddrSize
 = (
sockaddr_
);

55 
m_tTaskID
 = 0;

56 
m_bTaskRun
 = 
FALSE
;

57 
	}
}

59 
CTLi
::~
	$CTLi
()

61 
	`RunEx
();

62 
	}
}

64 
BOOL
 
CTLi
::
	$IsObjVid
( )

66 if(
m_hSock
 <0 
FALSE
;

67  
TRUE
;

68 
	}
}

70 
CTLi
::
	$RObj
( )

72 if(
m_hSock
<=0) ;

73 
	`o
(
m_hSock
);

74 
m_hSock
 = 
ERROR
;

75 
	}
}

77 
CTLi
::
	$RunEx
( )

79 
m_bTaskRun
 = 
FALSE
;

80 if
m_tTaskID
 >= 0 )

85 
	`RObj
();

86 
m_pAcObj
 = 
NULL
;

87 
	}
}

89 
BOOL
 
CTLi
::
	$CeObj
* 
szE
 )

91 
nV
=0;

92 
sockaddr_
 
lolAddr
;

95 if(
m_hSock
=
	`sock
(
AF_INET
, 
SOCK_STREAM
, 0))==
ERROR
 )

97 if
szE
 )

98 
	`rtf

szE
, "CTcpListen: %s", "Create socketrror!" );

99  
FALSE
;

102 
m_nAddrSize
 = (
sockaddr_
);

103 
	`bzo
((*)&
lolAddr
, 
m_nAddrSize
);

104 
lolAddr
.
s_my
 = 
AF_INET
;

105 
lolAddr
.
s_pt
 = 
	`hts
(
m_nThePt
);

106 
lolAddr
.
s_addr
.
s_addr
 = 
	`_addr
(
m_szLolAddr
);

108 
nV
 = 1;

109 
	`tsockt
(
m_hSock
, 
SOL_SOCKET
, 
SO_REUSEADDR
, (*)&
nV
, (nVal));

111 if
	`bd
(
m_hSock
, (
sockaddr
 *)&
lolAddr
, 
m_nAddrSize
=
ERROR
 )

113 if
szE
 )

114 
	`rtf

szE
, "CTLi: bd(%s:%dr!", 
m_szLolAddr
, 
m_nThePt
 );

115 
	`o
(
m_hSock
);

116 
m_hSock
 = 
ERROR
;

117  
FALSE
;

120 if
	`li
(
m_hSock
, 
SERVER_MAX_CONNECTIONS
=
ERROR
 )

122 if
szE
 )

123 
	`rtf

szE
, "CTcpListen:isten()rror!" );

124 
	`o
(
m_hSock
);

125 
m_hSock
 = 
ERROR
;

126  
FALSE
;

128 if
szE
 )

129 
	`rtf

szE
, "CTLi::CeObj(%s:%dok.", 
m_szLolAddr
, 
m_nThePt
 );

130  
TRUE
;

131 
	}
}

133 
BOOL
 
CTLi
::
	$SRun

CDegeBa
* 
AcObj
 )

135 
m_pAcObj
 = 
AcObj
;

136 
m_bTaskRun
 = 
TRUE
;

137 if(
m_tTaskID
 = 
	`had_
(&
m_tThadID
, 
NULL
, 
TSvrTask
, (*)
this
)) < 0 )

139 
	`LogPromText
("****CTLi(%s:%d).SRun(Fau****\n", 
m_szLolAddr
, 
m_nThePt
);

140  
FALSE
;

142 
	`LogPromText
("****CTLi(%s:%d).SRun(sucss****\n", 
m_szLolAddr
, 
m_nThePt
);

143  
TRUE
;

144 
	}
}

149 
CTLi
::
	$WkTaskProc
()

151 
hClFd
;

152 
sockAddrSize
;

154 
	`OutPromText
((*)"****CTcpListen::WorkTaskProc() Run****");

155 
sockAddrSize
 = (
sockaddr_
);

156 
m_bTaskRun
)

158 if!
	`IsObjVid
() )

160 
	`CeObj
();

165 if(
hClFd
 = 
	`ac

m_hSock
,

166 (
sockaddr
*)&
m_ClAddr
,

167 (
sockn_t
*)&
sockAddrSize
=
ERROR
 )

169 
	`RObj
();

172 if
m_pAcObj
 )

174 
	`rtf
(
m_szRemeAddr
, "%s", 
	`_
(
m_ClAddr
.
s_addr
) );

175 
m_pAcObj
->
	`AcProc

hClFd
, 
m_nThePt
,

176 
m_szRemeAddr
, 
m_szLolAddr
 );

180 
	`o
(
hClFd
);

183 
	`up
(500000);

185 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpListen.h

6 #ide
_TCPLISTEN_H_


7 
	#_TCPLISTEN_H_


	)

9 
	~<ve
>

10 
	~<t/.h
>

11 
	~<had.h
>

13 
	~"../she/tydef.h
"

15 (*
	tACCEPTPROC
)(, , *, * );

18 as
	cCDegeBa


20 
public
:

21 
	$CDegeBa
(){}

22 
vtu
 
BOOL
 
	$AcProc
(
hSock
, 
nPt
,

23 * 
szReme
, * 
szLol
{
	`o
(
hSock
);  
FALSE
;
	}
}

24 
	gvtu
 ~
	$CDegeBa
({ 
	}
}

29 as
	cCTLi


32 
	mpublic
:

33 
CTLi
();

34 
	mvtu
 ~
CTLi
();

35 * 
	$CssName
(){ (*)"CTcpListen";}

38 
ive
:

39 
m_nAddrSize
;

40 
sockaddr_
 
m_ClAddr
;

42 
eed
:

43 
CDegeBa
* 
m_pAcObj
;

44 
HANDLE
 
m_hSock
;

46 
public
:

47 
m_nThePt
;

48 
m_szLolAddr
[24];

49 
m_szRemeAddr
[24];

51 
BOOL
 
m_bTaskRun
;

52 
m_tTaskID
;

53 
had_t
 
m_tThadID
;

56 
public
:

57 
	`RunEx
( );

58 
BOOL
 
	`IsObjVid
( );

59 
BOOL
 
	`CeObj
* 
szE
=
NULL
 );

60 
	`RObj
( );

61 
BOOL
 
	`SRun

CDegeBa
* 
AcObj
 );

62 
	`WkTaskProc
( );

63 
	}
};

65 
	gd
::
	tve
<
	tCTLi
*> 
	tCTPVe
;

66 
	gCTPVe
::
	t
 
	tTIt
;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpPort.cpp

5 
	~<dio.h
>

6 
	~<dlib.h
>

7 
	~<rg.h
>

8 
	~<unid.h
>

9 
	~<f.h
>

10 
	~<rmios.h
>

11 
	~<y.h
>

12 
	~<sys/iol.h
>

13 
	~<sys/mm.h
>

14 
	~<sys/tys.h
>

15 
	~<sys/m.h
>

16 
	~<sys/.h
>

17 
	~<sys/time.h
>

18 
	~<sigl.h
>

19 
	~<o.h
>

20 
	~<t/.h
>

21 
	~<sys/sock.h
>

22 
	~</.h
>

23 
	~<tdb.h
>

25 
	~"TPt.h
"

28 
	gCTPt
::
	$CTPt
()

30 
m_nS
 = 0;

31 
m_uThePt
 = 3066;

32 
m_hComm
 = 
ERROR
;

34 
m_nAddrSize
 = (
sockaddr_
);

35 
	`bzo
((*)&
m_RemeAddr
, 
m_nAddrSize
);

36 
m_RemeAddr
.
s_my
 = 
AF_INET
;

37 
	}
}

39 
	gCTPt
::~
	$CTPt
()

41 
	`CloPt
();

42 
	}
}

44 
BOOL
 
	gCTPt
::
	$IsPtVid
( )

46 if(
m_hComm
 <0 
FALSE
;

47 if(
m_nS
 <0 
FALSE
;

48  
TRUE
;

49 
	}
}

51 
	gCTPt
::
	$CloPt
( )

53 if(
m_hComm
==
ERROR
) ;

54 
	`shutdown
(
m_hComm
, 2);

55 
	`o
(
m_hComm
);

56 
m_hComm
 = 
ERROR
;

57 
m_nS
 = 0;

58 
	}
}

60 
	gCTPt
::
	$Aach

hSock
 )

62 if
m_hComm
 >= 0 )

64 
	`shutdown
(
m_hComm
, 2);

65 
	`o
(
m_hComm
);

66 
m_hComm
 = 
ERROR
;

68 
m_hComm
 = 
hSock
;

69 
m_nS
 = 1;

70 
	}
}

72 
BOOL
 
	gCTPt
::
	$C

nTimeout
 )

78 if
m_hComm
 <0 )  
FALSE
;

79 if
	`c

m_hComm
,

80 (
sockaddr
*)&
m_RemeAddr
,

81 (
m_RemeAddr
=
ERROR
 )

83  
FALSE
;

85 
m_nS
 = 1;

86  
TRUE
;

87 
	}
}

89 
BOOL
 
	gCTPt
::
	$OnPt
* 
szE
 )

91 
nV
;

92 
sockaddr_
 
lolAddr
;

96 
	`memy
(
m_szRemeAddr
, 
m_szArib
, 24);

97 if(
m_hComm
=
	`sock
(
AF_INET
, 
SOCK_STREAM
, 0))==
ERROR
 )

99 if
szE
 )

100 
	`rtf

szE
, "CTcpPort: %s", "Create socketrror!" );

101  
FALSE
;

104 
nV
 = 1;

105 
	`tsockt
(
m_hComm
, 
SOL_SOCKET
, 
SO_REUSEADDR
, (*)&
nV
, (nVal));

107 
nV
 = 
MAX_TCP_SIZE
;

108 
	`tsockt
(
m_hComm
, 
SOL_SOCKET
, 
SO_RCVBUF
, (*)&
nV
, (nVal));

110 
	`bzo
((*)&
lolAddr
, 
m_nAddrSize
);

111 
lolAddr
.
s_my
 = 
AF_INET
;

112 
lolAddr
.
s_pt
 = 
	`hts
(()
m_uThePt
);

113 
lolAddr
.
s_addr
.
s_addr
 = 
	`_addr
(
m_szLolAddr
);

115 if
	`bd
(
m_hComm
, (
sockaddr
 *)&
lolAddr
, (sockaddr)=
ERROR
 )

117 if
szE
 )

118 
	`rtf

szE
, "CTPt: Bd(%sr!", 
m_szLolAddr
 );

119 
	`o
(
m_hComm
);

120 
m_hComm
 = 
ERROR
;

121  
FALSE
;

127 
m_RemeAddr
.
s_pt
 = 
	`hts
(()
m_uThePt
);

128 
m_RemeAddr
.
s_addr
.
s_addr
 = 
	`_addr
(
m_szRemeAddr
);

129 if
szE
 )

130 
	`rtf

szE
, "ݒ%d i%ok.", 
m_uThePt
, 
m_szLolAddr
 );

131  
TRUE
;

132 
	}
}

134 
BOOL
 
	gCTPt
::
	$SQueue

DWORD
 
dwInQueueSize
, DWORD 
dwOutQueueSize
 )

143  
TRUE
;

144 
	}
}

146 
	gCTPt
::
	$GInQueue
( )

148 
nBys
 = 0;

149 if!
	`IsPtVid
() )  -1;

150 
	`iol
(
m_hComm
, 
FIONREAD
, ()&
nBys
);

151  
nBys
;

152 
	}
}

154 
	gCTPt
::
	$GOutQueue
( )

157 
	}
}

159 
	gCTPt
::
	$RdPt

BYTE
 *
pBuf
, 
nRd
 )

161 
nBys
 = 0;

163 if!
	`IsPtVid
(|| 
nRd
<=0 )  -1;

164 
nBys
 = 
	`cv

m_hComm
, (*)
pBuf
, 
nRd
, 0 );

165 if
nBys
 =
ERROR
 )

167 
m_nS
 = 0;

170  
nBys
;

171 
	}
}

173 
	gCTPt
::
	$WrePt

BYTE
 *
pBuf
, 
nWre
 )

175 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

176 
nBys
 = 
	`nd

m_hComm
, (*)
pBuf
, 
nWre
, 
MSG_NOSIGNAL
 );

177 if
nBys
 =
ERROR
 )

179 
m_nS
 = 0;

182  
nBys
;

183 
	}
}

185 
	gCTPt
::
	$AsyRdDa

BYTE
 *
pBuf
, 
nRd
 )

187 
nBys
 = 0;

188 
fd_t
 
rfds
;

189 
timev
 
tv
;

191 if!
	`IsPtVid
(|| 
nRd
<=0 )  -1;

192 
	`FD_ZERO
(&
rfds
);

193 
	`FD_SET
(
m_hComm
, &
rfds
);

194 
tv
.
tv_c
 = 0;

195 
tv
.
tv_uc
 = 10000;

196  
	`
(
m_hComm
+1, &
rfds
, 
NULL
, NULL, &
tv
) )

198 
ERROR
:

199 
m_nS
 = 0;

204 if(
	`FD_ISSET
(
m_hComm
, &
rfds
))

206 
nBys
 = 
	`cv

m_hComm
, (*)
pBuf
, 
nRd
, 0 );

207 if
nBys
 =
ERROR
 )

209 if
nBys
 == 0 )

210 
	`CloPt
() ;

214  
nBys
;

215 
	}
}

217 
	gCTPt
::
	$AsySdDa

BYTE
 *
pBuf
, 
nWre
 )

219 
fd_t
 
wfds
;

220 
timev
 
tv
;

222 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

223 
	`FD_ZERO
(&
wfds
);

224 
	`FD_SET
(
m_hComm
, &
wfds
);

225 
tv
.
tv_c
 = 3;

226 
tv
.
tv_uc
 = 0;

227  
	`
(
m_hComm
+1, 
NULL
, &
wfds
, NULL, &
tv
) )

229 
ERROR
:

230 
m_nS
 = 0;

235 if(
	`FD_ISSET
(
m_hComm
, &
wfds
))

236  
	`nd
(
m_hComm
, (*)
pBuf
, 
nWre
, 
MSG_NOSIGNAL
 );

240 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpPort.h

7 #ide
_TCPPORT_H_


8 
	#_TCPPORT_H_


	)

10 
	~<t/.h
>

11 
	~"BaPt.h
"

13 
	#MAX_TCP_SIZE
 1280

	)

16 as
	cCTPt
 : 
public
 
CBaPt


19 
public
:

20 
CTPt
();

21 
	mvtu
 ~
CTPt
();

22 
vtu
 * 
	$CssName
(){ (*)"CTcpPort";}

25 
ive
:

26 
m_nS
;

27 
m_nAddrSize
;

28 
sockaddr_
 
m_RemeAddr
;

30 
eed
:

33 
public
:

34 
	`Aach

hSock
 );

35 
BOOL
 
	`C

nTimeout
 );

36 
vtu
 
BOOL
 
	`IsPtVid
( );

37 
vtu
 
BOOL
 
	`OnPt
* 
szE
=
NULL
 );

38 
vtu
 
	`CloPt
( );

39 
vtu
 
BOOL
 
	`SQueue

DWORD
 
dwInQueueSize
, DWORD 
dwOutQueueSize
 );

40 
vtu
 
	`GInQueue
( );

41 
vtu
 
	`GOutQueue
( );

42 
vtu
 
	`RdPt

BYTE
 *
pBuf
, 
nRd
 );

43 
vtu
 
	`WrePt

BYTE
 *
pBuf
, 
nWre
 );

44 
vtu
 
	`AsyRdDa

BYTE
 *
pBuf
, 
nRd
 );

45 
vtu
 
	`AsySdDa

BYTE
 *
pBuf
, 
nWre
 );

46 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/UdpPort.cpp

5 
	~<dio.h
>

6 
	~<dlib.h
>

7 
	~<rg.h
>

8 
	~<unid.h
>

9 
	~<f.h
>

10 
	~<rmios.h
>

11 
	~<y.h
>

12 
	~<sys/iol.h
>

13 
	~<sys/mm.h
>

14 
	~<sys/tys.h
>

15 
	~<sys/m.h
>

16 
	~<sys/.h
>

17 
	~<sys/time.h
>

18 
	~<sigl.h
>

19 
	~<o.h
>

20 
	~<t/.h
>

21 
	~<sys/sock.h
>

22 
	~</.h
>

23 
	~<tdb.h
>

25 
	~"UdpPt.h
"

28 
	gCUdpPt
::
	$CUdpPt
()

30 
m_uThePt
 = 3069;

31 
m_hComm
 = 
ERROR
;

33 
m_nAddrSize
 = (
sockaddr_
);

34 
	`bzo
((*)&
m_RemeAddr
, 
m_nAddrSize
);

35 
m_RemeAddr
.
s_my
 = 
AF_INET
;

36 
	}
}

38 
	gCUdpPt
::~
	$CUdpPt
()

40 
	`CloPt
();

41 
	}
}

43 
BOOL
 
	gCUdpPt
::
	$IsPtVid
( )

45  (
m_hComm
 > 0);

46 
	}
}

48 
	gCUdpPt
::
	$CloPt
( )

50 if!
	`IsPtVid
() ) ;

51 
	`shutdown
(
m_hComm
, 2);

52 
	`o
(
m_hComm
);

53 
	}
}

55 
BOOL
 
	gCUdpPt
::
	$OnPt
* 
szE
 )

57 
nV
;

58 
sockaddr_
 
lolAddr
;

61 
	`memy
(
m_szRemeAddr
, 
m_szArib
, 24);

63 if(
m_hComm
=
	`sock
(
AF_INET
, 
SOCK_DGRAM
, 0))==
ERROR
 )

65 if
szE
 )

66 
	`rtf

szE
, "CUdpPort: %s", "Create socketrror!" );

67  
FALSE
;

70 
nV
 = 
MAX_UDP_SIZE
;

71 
	`tsockt
(
m_hComm
, 
SOL_SOCKET
, 
SO_RCVBUF
, (*)&
nV
, (nVal));

73 
nV
 = 1;

74 
	`tsockt
(
m_hComm
, 
SOL_SOCKET
, 
SO_BROADCAST
, (*)&
nV
, (nVal));

76 
	`tsockt
(
m_hComm
, 
SOL_SOCKET
, 
SO_REUSEADDR
, (*)&
nV
, (nVal));

78 
	`bzo
((*)&
lolAddr
, 
m_nAddrSize
);

79 
lolAddr
.
s_my
 = 
AF_INET
;

80 
lolAddr
.
s_pt
 = 
	`hts
(
m_uThePt
);

81 
lolAddr
.
s_addr
.
s_addr
 = 
	`_addr
(
m_szLolAddr
);

86 if
	`bd
(
m_hComm
, (
sockaddr
 *)&
lolAddr
, (sockaddr)=
ERROR
 )

88 if
szE
 )

89 
	`rtf

szE
, "%s", "CUdpPort: Bindddress failure!" );

90 
	`o
(
m_hComm
);

91 
m_hComm
 = 
ERROR
;

92  
FALSE
;

98 
m_RemeAddr
.
s_pt
 = 
	`hts
(
m_uThePt
);

99 
m_RemeAddr
.
s_addr
.
s_addr
 = 
	`_addr
(
m_szRemeAddr
);

100 if
szE
 )

101 
	`rtf

szE
, "ݒ udp%d i%ok.", 
m_uThePt
, 
m_szLolAddr
 );

102  
TRUE
;

103 
	}
}

105 
BOOL
 
	gCUdpPt
::
	$SQueue

DWORD
 
dwInQueueSize
, DWORD 
dwOutQueueSize
 )

114  
TRUE
;

115 
	}
}

117 
	gCUdpPt
::
	$GInQueue
( )

119 
nBys
 = 0;

120 if!
	`IsPtVid
() )  -1;

121 
	`iol
(
m_hComm
, 
FIONREAD
, ()&
nBys
);

122  
nBys
;

123 
	}
}

125 
	gCUdpPt
::
	$GOutQueue
( )

128 
	}
}

130 
	gCUdpPt
::
	$RdPt

BYTE
 *
pBuf
, 
nRd
 )

132 
nBys
, 
nL
;

133 
sockaddr_
 
om
;

134 
Addr
[32];

136 if!
	`IsPtVid
(|| 
nRd
<=0 )  -1;

137 
nBys
 = 
	`cvom

m_hComm
, (*)
pBuf
, 
nRd
, 0,

138 (
sockaddr
 *)&
om
, (
sockn_t
*)&
nL
 );

139 if
nBys
 =
ERROR
 )  -2;

140 
	`rtf
(
Addr
, "%s", 
	`_
(
om
.
s_addr
));

142  
nBys
;

143 
	}
}

145 
	gCUdpPt
::
	$WrePt

BYTE
 *
pBuf
, 
nWre
 )

147 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

148  
	`ndto

m_hComm
, (*)
pBuf
, 
nWre
, 0,

149 (
sockaddr
 *)&
m_RemeAddr
, (sockaddr) );

150 
	}
}

152 
	gCUdpPt
::
	$WreTo

BYTE
 *
pBuf
, 
nWre
, * 
szIPAddr
, 
nPt
 )

154 
sockaddr_
 
to
;

155 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

156 
	`memy
((*)&
to
, (*)&
m_RemeAddr
, 
m_nAddrSize
);

157 
to
.
s_pt
 = 
	`hts
(
nPt
);

158 
to
.
s_addr
.
s_addr
 = 
	`_addr
(
szIPAddr
);

159  
	`ndto

m_hComm
, (*)
pBuf
, 
nWre
, 0,

160 (
sockaddr
 *)&
to
, (sockaddr) );

161 
	}
}

163 
	gCUdpPt
::
	$WreTo

BYTE
 *
pBuf
, 
nWre
, * 
szIPAddr
 )

165  
	`WreTo

pBuf
, 
nWre
, 
szIPAddr
, 
m_uThePt
 );

166 
	}
}

168 
	gCUdpPt
::
	$AsyRdDa

BYTE
 *
pBuf
, 
nRd
 )

170 
nBys
=0, 
nL
;

171 
Addr
[32];

172 
sockaddr_
 
om
;

173 
fd_t
 
rfds
;

174 
timev
 
tv
;

176 if!
	`IsPtVid
(|| 
nRd
<=0 )  -1;

177 
	`FD_ZERO
(&
rfds
);

178 
	`FD_SET
(
m_hComm
, &
rfds
);

179 
tv
.
tv_c
 = 0;

180 
tv
.
tv_uc
 = 10000;

181  
	`
(
m_hComm
+1, &
rfds
, 
NULL
, NULL, &
tv
) )

183 
ERROR
:

188 if
	`FD_ISSET
(
m_hComm
, &
rfds
) )

190 
nBys
 = 
	`cvom

m_hComm
, (*)
pBuf
, 
nRd
, 0,

191 (
sockaddr
 *)&
om
, (
sockn_t
*)&
nL
 );

192 if
nBys
 =
ERROR
 )  -2;

193 
	`rtf
(
Addr
, "%s", 
	`_
(
om
.
s_addr
));

197  
nBys
;

198 
	}
}

200 
	gCUdpPt
::
	$AsySdDa

BYTE
 *
pBuf
, 
nWre
 )

202 
fd_t
 
wfds
;

203 
timev
 
tv
;

205 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

206 
	`FD_ZERO
(&
wfds
);

207 
	`FD_SET
(
m_hComm
, &
wfds
);

208 
tv
.
tv_c
 = 0;

209 
tv
.
tv_uc
 = 0;

210  
	`
(
m_hComm
+1, 
NULL
, &
wfds
, NULL, &
tv
) )

212 
ERROR
:

217 if
	`FD_ISSET
(
m_hComm
, &
wfds
) )

218  
	`ndto

m_hComm
, (*)
pBuf
, 
nWre
, 0,

219 (
sockaddr
 *)&
m_RemeAddr
, (sockaddr) );

223 
	}
}

225 
	gCUdpPt
::
	$AsySdTo

BYTE
 *
pBuf
, 
nWre
, * 
szIPAddr
, 
nPt
 )

227 
sockaddr_
 
to
;

228 if!
	`IsPtVid
(|| 
nWre
<=0 )  -1;

229 
	`memy
((*)&
to
, (*)&
m_RemeAddr
, 
m_nAddrSize
);

230 
to
.
s_pt
 = 
	`hts
(
nPt
);

231 
to
.
s_addr
.
s_addr
 = 
	`_addr
(
szIPAddr
);

233 
fd_t
 
wfds
;

234 
timev
 
tv
;

235 
	`FD_ZERO
(&
wfds
);

236 
	`FD_SET
(
m_hComm
, &
wfds
);

237 
tv
.
tv_c
 = 0;

238 
tv
.
tv_uc
 = 0;

239  
	`
(
m_hComm
+1, 
NULL
, &
wfds
, NULL, &
tv
) )

241 
ERROR
:

246 if
	`FD_ISSET
(
m_hComm
, &
wfds
) )

247  
	`ndto

m_hComm
, (*)
pBuf
, 
nWre
, 0,

248 (
sockaddr
 *)&
to
, (sockaddr) );

252 
	}
}

254 
	gCUdpPt
::
	$AsySdTo

BYTE
 *
pBuf
, 
nWre
, * 
szIPAddr
 )

256  
	`AsySdTo

pBuf
, 
nWre
, 
szIPAddr
, 
m_uThePt
 );

257 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/UdpPort.h

7 #ide
_UDPPORT_H_


8 
	#_UDPPORT_H_


	)

10 
	~<t/.h
>

11 
	~"BaPt.h
"

13 
	#MAX_UDP_SIZE
 1280

	)

16 as
	cCUdpPt
 : 
public
 
CBaPt


19 
public
:

20 
CUdpPt
();

21 
	mvtu
 ~
CUdpPt
();

22 
vtu
 * 
	$CssName
(){ (*)"CUdpPort";}

25 
ive
:

26 
m_nAddrSize
;

27 
sockaddr_
 
m_RemeAddr
;

29 
eed
:

31 
public
:

32 
	`WreTo

BYTE
 *
pBuf
, 
nWre
, * 
szIPAddr
, 
nPt
 );

33 
	`WreTo

BYTE
 *
pBuf
, 
nWre
, * 
szIPAddr
 );

34 
	`AsySdTo

BYTE
 *
pBuf
, 
nWre
, * 
szIPAddr
, 
nPt
 );

35 
	`AsySdTo

BYTE
 *
pBuf
, 
nWre
, * 
szIPAddr
 );

38 
public
:

39 
vtu
 
BOOL
 
	`IsPtVid
( );

40 
vtu
 
BOOL
 
	`OnPt
* 
szE
=
NULL
 );

41 
vtu
 
	`CloPt
( );

42 
vtu
 
BOOL
 
	`SQueue

DWORD
 
dwInQueueSize
, DWORD 
dwOutQueueSize
 );

43 
vtu
 
	`GInQueue
( );

44 
vtu
 
	`GOutQueue
( );

45 
vtu
 
	`RdPt

BYTE
 *
pBuf
, 
nRd
 );

46 
vtu
 
	`WrePt

BYTE
 *
pBuf
, 
nWre
 );

47 
vtu
 
	`AsyRdDa

BYTE
 *
pBuf
, 
nRd
 );

48 
vtu
 
	`AsySdDa

BYTE
 *
pBuf
, 
nWre
 );

49 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/gDataType.h

19 #ide 
_GDATATYPE_H__


20 
	#_GDATATYPE_H__


	)

22 
	~"tydef.h
"

23 
	~<rg.h
>

25 
	#MAX_DATA_LEN
 512

	)

27 
	#MAX_UNPROCESSBUF_LEN
 1024

	)

28 
	#YC_TYPE
 1

	)

29 
	#YX_TYPE
 2

	)

30 
	#YM_TYPE
 3

	)

65 
	s_gUNPROCESSBUF


67 
	mn
;

68 
BYTE
 
	mbuf
[
MAX_UNPROCESSBUF_LEN
];

69 }
	tUNPROCESSBUF
;

71 #agm
ck
(1)

75 
	sgYcDa


77 
WORD
 
	mwSlNo
;

78 
WORD
 
	mwP
;

79 
	mfYcVue
;

80 
t32
 
	mYcVue
;

81 
BYTE
 
	mbyYcTy
;

82 
WORD
 
	mMSecd
;

83 
BYTE
 
	mSecd
;

84 
BYTE
 
	mMu
;

85 
BYTE
 
	mHour
;

86 
BYTE
 
	mDay
;

87 
BYTE
 
	mMth
;

88 
WORD
 
	mYr
;

90 
gYcDa
( )

92 
	mwSlNo
 = 0xFFFF ;

93 
	mwP
 = 0xFFFF;

94 
	mfYcVue
 = 0 ;

95 
	mYcVue
 = 0 ;

96 
	mbyYcTy
 = 0 ;

97 
	mMSecd
 = 0 ;

98 
	mSecd
 = 0 ;

99 
	mMu
 = 0 ;

100 
	mHour
 = 0 ;

101 
	mDay
 = 0 ;

102 
	mMth
 = 0 ;

103 
	mYr
 = 0 ;

106 }
	tYC_DATA
 , *
	tPYC_DATA
;

109 
	sgYxDa


111 
WORD
 
	mwSlNo
;

112 
WORD
 
	mwP
;

113 
BYTE
 
	mYxVue
;

114 
BYTE
 
	mbyYxTy
;

115 
WORD
 
	mMSecd
;

116 
BYTE
 
	mSecd
;

117 
BYTE
 
	mMu
;

118 
BYTE
 
	mHour
;

119 
BYTE
 
	mDay
;

120 
BYTE
 
	mMth
;

121 
WORD
 
	mYr
;

123 
gYxDa
( )

125 
	mwSlNo
 = 0xFFFF ;

126 
	mwP
 = 0xFFFF;

127 
	mYxVue
 = 0 ;

128 
	mbyYxTy
 = 0 ;

129 
	mMSecd
 = 0 ;

130 
	mSecd
 = 0 ;

131 
	mMu
 = 0 ;

132 
	mHour
 = 0 ;

133 
	mDay
 = 0 ;

134 
	mMth
 = 0 ;

135 
	mYr
 = 0 ;

138 }
	tYX_DATA
, *
	tPYX_DATA
;

141 
	sgYmDa


143 
WORD
 
	mwP
;

144 
	mYmVue
;

145 
WORD
 
	mwSlNo
;

147 
gYmDa
( )

149 
	mwP
 = 0 ;

150 
	mYmVue
 = 0 ;

151 
	mwSlNo
 = 0 ;

154 }
	tYM_DATA
 , *
	tPYM_DATA
;

157 
	sgYkDa


159 
WORD
 
	mwP
;

160 
BYTE
 
	mbyV
;

161 
BYTE
 
	mbyTy
;

163 
gYkDa
( )

165 
	mwP
 = 0 ;

166 
	mbyV
 = 0 ;

167 
	mbyTy
 = 0 ;

169 }
	tYK_DATA
 , *
	tPYK_DATA
;

171 
	s_DDBYK_DATA


173 
BYTE
 
	mbyDeBusNo
 ;

174 
WORD
 
	mwDeAddr
 ;

175 
WORD
 
	mwP
 ;

176 
BYTE
 
	mbyV
 ;

177 
BYTE
 
	mbyTy
 ;

178 
_DDBYK_DATA
( )

180 
	mbyDeBusNo
 = 0 ;

181 
	mwDeAddr
 = 0 ;

182 
	mwP
 = 0 ;

183 
	mbyV
 = 0 ;

184 
	mbyTy
 = 0 ;

186 }
	tDDBYK_DATA
 , *
	tPDDBYK_DATA
;

188 
	sgDzDa


190 
WORD
 
	mwP
;

191 
BYTE
 
	mbyTy
;

192 
BYTE
 
	mbyV
[4];

194 
gDzDa
()

196 
	mwP
 = 0;

197 
	mbyTy
 = 0;

198 
memt

byV
, 0, 4 );

201 }
	tDZ_DATA
, *
	tPDZ_DATA
;

203 #agm
ck
()

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/global.cpp

19 
	~<dio.h
>

20 
	~<dlib.h
>

21 
	~<f.h
>

22 
	~<sys/tys.h
>

23 
	~<unid.h
>

24 
	~<rg.h
>

25 
	~<o.h
>

26 
	~<sys/iol.h
>

27 
	~<dg.h
>

28 
	~<y.h
>

29 
	~<unid.h
>

30 
	~<sys/iol.h
>

31 
	~<sys/mm.h
>

32 
	~<sys/tys.h
>

33 
	~<sys/m.h
>

34 
	~<sys/bo.h
>

35 
	~<lux/kl.h
>

36 
	~<sys/sysfo.h
>

37 
	~<sys/.h
>

40 
	~"glob.h
"

42 
	#LOCKMODE
 (
S_IRUSR
 | 
S_IWUSR
 | 
S_IRGRP
 | 
S_IROTH
)

	)

50 
bo
 
	$IsBigEndn
()

52 
i
=1;

54 *
p
=(*)&
i
;

56 i1 =*
p
)

58  
l
;

62  
ue
;

65  
ue
;

66 
	}
}

76 
bo
 
	$GlobCyByEndn
*
de
, *
c
, 
num
 )

78 i
NULL
 =
de
 || NULL =
c
 )

80  
l
;

84 i
	`IsBigEndn
( ) )

86 
c
 +
num
-1;

87  0 !
num
-- )

89 *
de
++ ) = *
c
-- );

94  0 !
num
-- )

96 *
de
++ ) = *
c
++ );

100  
ue
;

101 
	}
}

105 
	$lockfe
(
fd
)

107 
ock
 

;

109 

.
l_ty
 = 
F_WRLCK
;

110 

.
l_t
 = 0;

111 

.
l_wh
 = 
SEEK_SET
;

112 

.
l_n
 = 0;

113 (
	`f
(
fd
, 
F_SETLK
, &

));

114 
	}
}

116 
	$ady_rug
(cڡ *
fame
)

118 
fd
;

119 
buf
[16];

121 
fd
 = 
	`ݒ
(
fame
, 
O_RDWR
 | 
O_CREAT
, 
LOCKMODE
);

122 i(
fd
 < 0)

124 
	`tf
"n'ݒ %s: %m\n", 
fame
);

125 
	`ex
(1);

128 i(
	`lockfe
(
fd
) == -1)

130 i(
o
 =
EACCES
 ||n=
EAGAIN
)

132 
	`tf
"fe: %adyocked", 
fame
);

133 
	`o
(
fd
);

137 
	`tf
("n'lock %s: %m\n", 
fame
);

138 
	`ex
(1);

142 
	`run
(
fd
, 0);

143 
	`rtf
(
buf
, "%ld", ()
	`gpid
());

144 
	`wre
(
fd
, 
buf
, 
	`
(buf) + 1);

146 
	}
}

148 
	$SSlCfigMode

byMode
 )

150 
BYTE
 
byTy
 = 0 ;

151  
byMode
 )

155 
byTy
 = 
CMD_SET_UT1_NON_RS485
 ;

156 
	`tf
( "Set RS01 = RS232 \n" );

161 
byTy
 = 
CMD_SET_UT2_NON_RS485
 ;

162 
	`tf
( "Set RS02 = RS232 \n" );

167 
byTy
 = 
CMD_SET_UT3_NON_RS485
 ;

168 
	`tf
( "Set RS03 = RS422 \n" );

173 
byTy
 = 
CMD_SET_UT4_NON_RS485
 ;

174 
	`tf
( "Set RS04 = RS422 \n" );

181 
gpiofd
;

182 
gpiofd
 = 
	`ݒ
(
GPIO_DEV_NAME
, 
O_RDWR
);

183 if
gpiofd
 < 1 ) ;

184 
	`iol
(
gpiofd
, 
byTy
, 0);

185 
	`o
(
gpiofd
);

186 
	}
}

195 
tm
 
	$SSuTm
 ( 
TIMEDATA
 
cTime
, 
tm
 &
t
, &
lTime
 )

197 
t
.
tm_yr
 = 
cTime
.
Yr
;

198 
t
.
tm_m
 = 
cTime
.
Mth
 - 1;

199 
t
.
tm_mday
 = 
cTime
.
Day
;

200 
t
.
tm_hour
 = 
cTime
.
Hour
;

201 
t
.
tm_m
 = 
cTime
.
Mu
;

202 
t
.
tm_c
 = 
cTime
.
Secd
;

204 
lTime
 = 
	`mktime
&
t
 ) ;

205  
t
;

206 
	}
}

215 
	$GOwnSuTm
 ( 
lTime
, 
tm
 *
t
 )

217 
	`loime_r
((
time_t
 *)&
lTime
, 
t
);

218 
t
->
tm_m
 =->tm_mon + 1;

219 
	}
}

226 #ifdef 
__lulus


229 
BOOL
 
g_bDebugA
 = 
TRUE
;

230 
BOOL
 
g_bARun
 = 
TRUE
;

232 
rim
(*
s
)

234 *
p
 = 
s
;

235 if*
p
==' ' || *p=='\t' )

237  *
p
==' ' || *p=='\t' )++;

238  (*
s
++ = *
p
++) );

243 
rim
(*
s
)

245 *
p
 = 
s
;

246  *
p
 )++;

247 if
p
 !
s
 )

249 
p
--;

250  *
p
==' ' || *p=='\t' || *p=='\r' || *p=='\n' )--;

251 *(++
p
) = 0;

255 
OutPromText
(*
szText
)

257 if!
g_bDebugA
 ) ;

258 
tf
("%s\n", 
szText
);

261 
LogPromText
(cڡ *
fmt
, ...)

263 if!
g_bDebugA
 ) ;

264 
va_li
 
gs
;

265 
va_t
(
gs
, 
fmt
);

266 
vtf
(
fmt
, 
gs
);

267 
va_d
(
gs
);

270 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
)

272 
i
, 
k
;

273 
szBuff
[96];

275 if!
g_bDebugA
 ) ;

276 
k
 = 0;

277 
rtf
(
szBuff
, "\n%s\n", 
szSrc
);

278 
tf
(
szBuff
);

279  
i
=0; i<
nL
; i++ )

281 
k
 +
rtf
(&
szBuff
[k], " %02X", 
pDa
[
i
]);

282 if((
i
+1)%24==0)

284 
tf
(
szBuff
);

285 
szBuff
[0] = '\n';

286 
k
 = 1;

289 if
k
 > 1 ) 
tf
(
szBuff
);

297 
SiglHook
(
iSigNo
, 
LPSIGPROC
 
func
)

299 
sigai
 
a
, 

;

301 
a
.
_sigai
 = 
func
;

302 
sigemyt
(&
a
.
_mask
);

303 
a
.
_ags
 = 
SA_SIGINFO
|
SA_RESTART
;

305 if(
sigai
(
iSigNo
, &
a
, &

) < 0)

311 
_dm
()

313 
i
;

314 
pid_t
 
chd1
, 
chd2
;

316 
chd1
 = 
fk
();

317 if
chd1
 < 0 )

319 

("Create first childrocess fail!\n");

320 
ex
(1);

322 if(
chd1
>0
ex
(0);

324 
tsid
();

326 
chd2
 = 
fk
();

327 if
chd2
 < 0 )

329 

("Create second childrocess fail!\n");

330 
ex
(2);

332 if(
chd2
>0
ex
(0);

335 
i
=0; i<
NOFILE
; ++i)

336 
o
(
i
);

338 
chd
("/tmp");

340 
umask
(0);

342 
sigl
(
SIGCHLD
, 
SIG_IGN
);

345 #ifdef 
__lulus


	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/global.h

24 #ide 
GLOBAL_INC


25 
	#GLOBAL_INC


	)

28 
	#EMU2000_VERSION
 0x01030003

	)

29 #ifde 
__lulus


32 
	~<sigl.h
>

33 
	~<time.h
>

35 
	~"tydef.h
"

36 
	~"gDaTy.h
"

37 (*
LPSIGPROC
)(, 
	tsigfo_t
*, *);

39 
ady_rug
(cڡ *
fame
);

40 
tm
 
SSuTm
 ( 
TIMEDATA
 
cTime
, tm &
t
, &
lTime
 );

41 
GOwnSuTm
 ( 
lTime
, 
tm
 *
t
 );

42 
rim
(*
s
);

43 
rim
(*
s
);

44 
OutPromText
(*
szText
);

45 
LogPromText
(cڡ *
fmt
, ...);

46 
OutMesgeText
(*
szSrc
, *
pDa
, 
nL
);

47 
SiglHook
(
iSigNo
, 
LPSIGPROC
 
func
);

48 
_dm
();

49 
bo
 
GlobCyByEndn
*
de
, *
c
, 
num
 );

50 
bo
 
IsBigEndn
();

51 #ifde 
__lulus


55 
	#MAX_BUFFER
 1024

	)

56 
	#MAX_DEBUG_BUFFER
 3 * 1024 + 100

	)

59 
	#COM_PAUSE
 0

	)

60 
	#COMRS232
 1

	)

61 
	#COMRS485
 2

	)

62 
	#COMRS422
 3

	)

63 
	#SOCKETTCP
 4

	)

64 
	#TCP_CLIENT
 5

	)

65 
	#TCP_CLIENT_SHORT
 6

	)

67 
	#PASUE
 "PAUSE"

	)

68 
	#COMRS_232
 "COMRS232_"

	)

69 
	#COMRS_485
 "COMRS485_"

	)

70 
	#COMRS_422
 "COMRS422_"

	)

71 
	#LAN_TCP
 "TCP_"

	)

72 
	#LAN_TCP_CLIENT
 "TCPCLIENT_"

	)

73 
	#LAN_TCP_CLIENT_SHORT
 "TCPCLIENT-SHORT_"

	)

75 
	#GPIO_DEV_NAME
 "/dev/gpio_drv"

	)

76 
	#CMD_SET_UT1_RS485
 11

	)

77 
	#CMD_SET_UT1_NON_RS485
 12

78 
	#CMD_SET_UT2_RS485
 13

	)

79 
	#CMD_SET_UT2_NON_RS485
 14

80 
	#CMD_SET_UT3_RS485
 15

	)

81 
	#CMD_SET_UT3_NON_RS485
 16

82 
	#CMD_SET_UT4_RS485
 17

	)

83 
	#CMD_SET_UT4_NON_RS485
 18

84 
	#CMD_GET_UT_STATUS
 19

	)

86 
SSlCfigMode

byMode
 ) ;

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/md5.c

1 
	~<dio.h
>

2 
	~<rg.h
>

3 
	~"md5.h
"

5 
	gPADDING
[64] =

12 
	$MD5_Encode
(* 
ouut
, * 
put
, 
n
)

14 
i
, 
j
;

16 
i
 = 0, 
j
 = 0; j < 
n
; i++, j += 4)

18 
ouut
[
j
] = ((
put
[
i
] & 0xff);

19 
ouut
[
j
 + 1] = (((
put
[
i
] >> 8) & 0xff);

20 
ouut
[
j
 + 2] = (((
put
[
i
] >> 16) & 0xff);

21 
ouut
[
j
 + 3] = (((
put
[
i
] >> 24) & 0xff);

23 
	}
}

25 
	$MD5_Decode
(* 
ouut
, * 
put
, 
n
)

27 
i
, 
j
;

29 
i
 = 0, 
j
 = 0; j < 
n
; i++, j += 4)

31 
ouut
[
i
] = ((
put
[
j
]) |

32 (((
put
[
j
 + 1]) << 8) |

33 (((
put
[
j
 + 2]) << 16) |

34 (((
put
[
j
 + 3]) << 24);

36 
	}
}

38 
	$MD5_Tnsfm
(
e
[4], 
block
[64])

40 
a
 = 
e
[0], 
b
 = s[1], 
c
 = s[2], 
d
 = s[3], 
x
[16];

42 
	`MD5_Decode
(
x
, 
block
, 64);

45 
	`FF
(
a
, 
b
, 
c
, 
d
, 
x
[0], 
S11
, 0xd76aa478);

46 
	`FF
(
d
, 
a
, 
b
, 
c
, 
x
[1], 
S12
, 0xe8c7b756);

47 
	`FF
(
c
, 
d
, 
a
, 
b
, 
x
[2], 
S13
, 0x242070db);

48 
	`FF
(
b
, 
c
, 
d
, 
a
, 
x
[3], 
S14
, 0xc1bdceee);

49 
	`FF
(
a
, 
b
, 
c
, 
d
, 
x
[4], 
S11
, 0xf57c0faf);

50 
	`FF
(
d
, 
a
, 
b
, 
c
, 
x
[5], 
S12
, 0x4787c62a);

51 
	`FF
(
c
, 
d
, 
a
, 
b
, 
x
[6], 
S13
, 0xa8304613);

52 
	`FF
(
b
, 
c
, 
d
, 
a
, 
x
[7], 
S14
, 0xfd469501);

53 
	`FF
(
a
, 
b
, 
c
, 
d
, 
x
[8], 
S11
, 0x698098d8);

54 
	`FF
(
d
, 
a
, 
b
, 
c
, 
x
[9], 
S12
, 0x8b44f7af);

55 
	`FF
(
c
, 
d
, 
a
, 
b
, 
x
[10], 
S13
, 0xffff5bb1);

56 
	`FF
(
b
, 
c
, 
d
, 
a
, 
x
[11], 
S14
, 0x895cd7be);

57 
	`FF
(
a
, 
b
, 
c
, 
d
, 
x
[12], 
S11
, 0x6b901122);

58 
	`FF
(
d
, 
a
, 
b
, 
c
, 
x
[13], 
S12
, 0xfd987193);

59 
	`FF
(
c
, 
d
, 
a
, 
b
, 
x
[14], 
S13
, 0xa679438e);

60 
	`FF
(
b
, 
c
, 
d
, 
a
, 
x
[15], 
S14
, 0x49b40821);

63 
	`GG
(
a
, 
b
, 
c
, 
d
, 
x
[1], 
S21
, 0xf61e2562);

64 
	`GG
(
d
, 
a
, 
b
, 
c
, 
x
[6], 
S22
, 0xc040b340);

65 
	`GG
(
c
, 
d
, 
a
, 
b
, 
x
[11], 
S23
, 0x265e5a51);

66 
	`GG
(
b
, 
c
, 
d
, 
a
, 
x
[0], 
S24
, 0xe9b6c7aa);

67 
	`GG
(
a
, 
b
, 
c
, 
d
, 
x
[5], 
S21
, 0xd62f105d);

68 
	`GG
(
d
, 
a
, 
b
, 
c
, 
x
[10], 
S22
, 0x2441453);

69 
	`GG
(
c
, 
d
, 
a
, 
b
, 
x
[15], 
S23
, 0xd8a1e681);

70 
	`GG
(
b
, 
c
, 
d
, 
a
, 
x
[4], 
S24
, 0xe7d3fbc8);

71 
	`GG
(
a
, 
b
, 
c
, 
d
, 
x
[9], 
S21
, 0x21e1cde6);

72 
	`GG
(
d
, 
a
, 
b
, 
c
, 
x
[14], 
S22
, 0xc33707d6);

73 
	`GG
(
c
, 
d
, 
a
, 
b
, 
x
[3], 
S23
, 0xf4d50d87);

74 
	`GG
(
b
, 
c
, 
d
, 
a
, 
x
[8], 
S24
, 0x455a14ed);

75 
	`GG
(
a
, 
b
, 
c
, 
d
, 
x
[13], 
S21
, 0xa9e3e905);

76 
	`GG
(
d
, 
a
, 
b
, 
c
, 
x
[2], 
S22
, 0xfcefa3f8);

77 
	`GG
(
c
, 
d
, 
a
, 
b
, 
x
[7], 
S23
, 0x676f02d9);

78 
	`GG
(
b
, 
c
, 
d
, 
a
, 
x
[12], 
S24
, 0x8d2a4c8a);

81 
	`HH
(
a
, 
b
, 
c
, 
d
, 
x
[5], 
S31
, 0xfffa3942);

82 
	`HH
(
d
, 
a
, 
b
, 
c
, 
x
[8], 
S32
, 0x8771f681);

83 
	`HH
(
c
, 
d
, 
a
, 
b
, 
x
[11], 
S33
, 0x6d9d6122);

84 
	`HH
(
b
, 
c
, 
d
, 
a
, 
x
[14], 
S34
, 0xfde5380c);

85 
	`HH
(
a
, 
b
, 
c
, 
d
, 
x
[1], 
S31
, 0xa4beea44);

86 
	`HH
(
d
, 
a
, 
b
, 
c
, 
x
[4], 
S32
, 0x4bdecfa9);

87 
	`HH
(
c
, 
d
, 
a
, 
b
, 
x
[7], 
S33
, 0xf6bb4b60);

88 
	`HH
(
b
, 
c
, 
d
, 
a
, 
x
[10], 
S34
, 0xbebfbc70);

89 
	`HH
(
a
, 
b
, 
c
, 
d
, 
x
[13], 
S31
, 0x289b7ec6);

90 
	`HH
(
d
, 
a
, 
b
, 
c
, 
x
[0], 
S32
, 0xeaa127fa);

91 
	`HH
(
c
, 
d
, 
a
, 
b
, 
x
[3], 
S33
, 0xd4ef3085);

92 
	`HH
(
b
, 
c
, 
d
, 
a
, 
x
[6], 
S34
, 0x4881d05);

93 
	`HH
(
a
, 
b
, 
c
, 
d
, 
x
[9], 
S31
, 0xd9d4d039);

94 
	`HH
(
d
, 
a
, 
b
, 
c
, 
x
[12], 
S32
, 0xe6db99e5);

95 
	`HH
(
c
, 
d
, 
a
, 
b
, 
x
[15], 
S33
, 0x1fa27cf8);

96 
	`HH
(
b
, 
c
, 
d
, 
a
, 
x
[2], 
S34
, 0xc4ac5665);

99 
	`II
(
a
, 
b
, 
c
, 
d
, 
x
[0], 
S41
, 0xf4292244);

100 
	`II
(
d
, 
a
, 
b
, 
c
, 
x
[7], 
S42
, 0x432aff97);

101 
	`II
(
c
, 
d
, 
a
, 
b
, 
x
[14], 
S43
, 0xab9423a7);

102 
	`II
(
b
, 
c
, 
d
, 
a
, 
x
[5], 
S44
, 0xfc93a039);

103 
	`II
(
a
, 
b
, 
c
, 
d
, 
x
[12], 
S41
, 0x655b59c3);

104 
	`II
(
d
, 
a
, 
b
, 
c
, 
x
[3], 
S42
, 0x8f0ccc92);

105 
	`II
(
c
, 
d
, 
a
, 
b
, 
x
[10], 
S43
, 0xffeff47d);

106 
	`II
(
b
, 
c
, 
d
, 
a
, 
x
[1], 
S44
, 0x85845dd1);

107 
	`II
(
a
, 
b
, 
c
, 
d
, 
x
[8], 
S41
, 0x6fa87e4f);

108 
	`II
(
d
, 
a
, 
b
, 
c
, 
x
[15], 
S42
, 0xfe2ce6e0);

109 
	`II
(
c
, 
d
, 
a
, 
b
, 
x
[6], 
S43
, 0xa3014314);

110 
	`II
(
b
, 
c
, 
d
, 
a
, 
x
[13], 
S44
, 0x4e0811a1);

111 
	`II
(
a
, 
b
, 
c
, 
d
, 
x
[4], 
S41
, 0xf7537e82);

112 
	`II
(
d
, 
a
, 
b
, 
c
, 
x
[11], 
S42
, 0xbd3af235);

113 
	`II
(
c
, 
d
, 
a
, 
b
, 
x
[2], 
S43
, 0x2ad7d2bb);

114 
	`II
(
b
, 
c
, 
d
, 
a
, 
x
[9], 
S44
, 0xeb86d391);

116 
e
[0] +
a
;

117 
e
[1] +
b
;

118 
e
[2] +
c
;

119 
e
[3] +
d
;

121 
	`memt
((*
x
, 0, (x));

122 
	}
}

124 
	$MD5_In
(
MD5Cڋxt
 * 
cڋxt
)

126 
cڋxt
->
cou
[0] = context->count[1] = 0;

128 
cڋxt
->
e
[0] = 0x67452301;

129 
cڋxt
->
e
[1] = 0xefcdab89;

130 
cڋxt
->
e
[2] = 0x98badcfe;

131 
cڋxt
->
e
[3] = 0x10325476;

132 
	}
}

134 
	$MD5_Upde
(
MD5Cڋxt
 * 
cڋxt
, * 
buf
, 
n
)

136 
i
, 
dex
, 
L
;

138 
dex
 = (((
cڋxt
->
cou
[0] >> 3) & 0x3F);

140 i((
cڋxt
->
cou
[0] +((
n
 << 3)) < (()en << 3))

141 
cڋxt
->
cou
[1]++;

142 
cڋxt
->
cou
[1] +((
n
 >> 29);

144 
L
 = 64 - 
dex
;

146 i(
n
 >
L
)

148 
	`memy
((*&
cڋxt
->
bufr
[
dex
], (*
buf
, 
L
);

149 
	`MD5_Tnsfm
(
cڋxt
->
e
, cڋxt->
bufr
);

151 
i
 = 
L
; i + 63 < 
n
; i += 64)

152 
	`MD5_Tnsfm
(
cڋxt
->
e
, &
buf
[
i
]);

154 
dex
 = 0;

158 
i
 = 0;

161 
	`memy
((*&
cڋxt
->
bufr
[
dex
], (*&
buf
[
i
], 
n
 - i);

162 
	}
}

164 
	$MD5_F
(
MD5Cڋxt
 * 
cڋxt
, 
dige
[16])

166 
bs
[8];

167 
dex
, 
dL
;

169 
	`MD5_Encode
(
bs
, 
cڋxt
->
cou
, 8);

171 
dex
 = (((
cڋxt
->
cou
[0] >> 3) & 0x3f);

172 
dL
 = (
dex
 < 56) ? (56 - index) : (120 - index);

173 
	`MD5_Upde
(
cڋxt
, 
PADDING
, 
dL
);

175 
	`MD5_Upde
(
cڋxt
, 
bs
, 8);

177 
	`MD5_Encode
(
dige
, 
cڋxt
->
e
, 16);

179 
	`memt
((*
cڋxt
, 0, (*context));

180 
	}
}

181 * 
	$GFeMD5
 (* 
fame
 , *
pchMD5FeBuf
)

183 
FILE
 *
fe
;

184 
MD5Cڋxt
 
cڋxt
;

185 
n
;

186 
bufr
[0x0400];

188 i(!(
fe
 = 
	`fݒ
 (
fame
, "rb")))

189 
	`tf
 ("%n'bݒed\n", 
fame
);

192 
	`MD5_In
 (&
cڋxt
);

193  ( 
n
 = 
	`d
 (
bufr
, 1, 1024, 
fe
) ))

194 
	`MD5_Upde
 (&
cڋxt
, 
bufr
, 
n
);

195 
	`MD5_F
(&
cڋxt
,
pchMD5FeBuf
);

196 
	`fo
 (
fe
);

205  
pchMD5FeBuf
;

206 
	}
}

208 
	$MD5
* 
md5
 , * 
qu
 )

210 
j
,
n
;

211 
MD5Cڋxt
 
cڋxt
;

212 
buff
[16];

214 
n
 = 
	`
(
qu
);

215 
	`MD5_In
(&
cڋxt
);

216 
	`MD5_Upde
(&
cڋxt
,(*)
qu
, 
n
);

217 
	`MD5_F
(&
cڋxt
,
buff
);

218 
j
=0;j<16;j++)

222 
	`rtf
 (
md5
+2*
j
,"%02x", 
buff
[j]);

227 
	}
}

239 
bo
 
	$IsFeMD5Right
 ( *
pchFeName
, *
pchMd5Buf
 )

241 
chMd5Buf
[16];

243 if
NULL
 !
	`GFeMD5

pchFeName
, (*)
chMd5Buf
 ) )

245 if0 =
	`cmp

chMd5Buf
, 
pchMd5Buf
, 16 ) )

247  
ue
;

251  
l
;

252 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/md5.h

1 #ide
_MD5_H_


2 
	#_MD5_H_


	)

4 
	~<dlib.h
>

5 
	~"unid.h
"

6 
	~<dbo.h
>

7 #ifde 
__lulus


12 
e
[4];

13 
cou
[2];

14 
bufr
[64];

15 } 
	tMD5Cڋxt
;

18 
	#S11
 7

	)

19 
	#S12
 12

	)

20 
	#S13
 17

	)

21 
	#S14
 22

	)

22 
	#S21
 5

	)

23 
	#S22
 9

	)

24 
	#S23
 14

	)

25 
	#S24
 20

	)

26 
	#S31
 4

	)

27 
	#S32
 11

	)

28 
	#S33
 16

	)

29 
	#S34
 23

	)

30 
	#S41
 6

	)

31 
	#S42
 10

	)

32 
	#S43
 15

	)

33 
	#S44
 21

	)

35 
	#F
(
x
, 
y
, 
z
(((x& (y)| ((~x& (z)))

	)

36 
	#G
(
x
, 
y
, 
z
(((x& (z)| ((y& (~z)))

	)

37 
	#H
(
x
, 
y
, 
z
((x^ (y^ (z))

	)

38 
	#I
(
x
, 
y
, 
z
((y^ ((x| (~z)))

	)

40 
	#ROTATE_LEFT
(
x
, 
n
(((x<< (n)| ((x>> (32-))))

	)

42 
	#FF
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) \

44 (
a
+
	`F
((
b
), (
c
), (
d
)+ (
x
+ ()(
ac
); \

45 (
a

	`ROTATE_LEFT
(), (
s
)); \

46 (
a
+(
b
); \

47 }

	)

49 
	#GG
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) \

51 (
a
+
	`G
((
b
), (
c
), (
d
)+ (
x
+ ()(
ac
); \

52 (
a

	`ROTATE_LEFT
(), (
s
)); \

53 (
a
+(
b
); \

54 }

	)

56 
	#HH
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) \

58 (
a
+
	`H
((
b
), (
c
), (
d
)+ (
x
+ ()(
ac
); \

59 (
a

	`ROTATE_LEFT
(), (
s
)); \

60 (
a
+(
b
); \

61 }

	)

63 
	#II
(
a
, 
b
, 
c
, 
d
, 
x
, 
s
, 
ac
) \

65 (
a
+
	`I
((
b
), (
c
), (
d
)+ (
x
+ ()(
ac
); \

66 (
a

	`ROTATE_LEFT
(), (
s
)); \

67 (
a
+(
b
); \

68 }

	)

71 
MD5
* 
md5
 , * 
qu
 );

72 * 
GFeMD5
 (* 
fame
 , *
pchMD5FeBuf
);

74 
bo
 
IsFeMD5Right
 ( *
pchFeName
, *
pchMd5Buf
 );

76 #ifde 
__lulus


	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/msgdef.h

4 #ide 
_MSGDEF_H_


5 
	#_MSGDEF_H_


	)

8 
	#MSG_NAME_LEN
 24

	)

9 
	#MSG_BODY_LEN
 512

	)

10 
	#MSG_POOL_SUM
 64

	)

11 
	#MSG_SLOT_SUM
 16

	)

14 
	#MSGSET_RAW_DATA
 0

	)

15 
	#MSGSET_CTRL_ECHO
 1

	)

16 
	#MSGSET_DEVS_DATA
 2

	)

17 
	#MSGSET_FES_NOTIFY
 3

	)

18 
	#MSGSET_FES_REQUEST
 4

	)

21 
	#MSGSET_CTRL_DATA
 8

	)

22 
	#MSGSET_DEVS_COMM
 9

	)

23 
	#MSGSET_FES_RECEIVE
 10

	)

24 
	#MSGSET_FES_SWITCH
 11

	)

27 #agm
ck
(1)

32 
	mnSrcKey
;

33 
	mnAive
;

34 
	mwLev
;

35 
	mwTys
;

36 
	mwMsgL
;

37 
	mbyBuff
[
MSG_BODY_LEN
];

38 } 
	tMSGITEM
;

41 
	sgMSGLIST


43 
	mlf
;

44 
	mxt
;

45 } 
	tMSGLIST
;

48 
	sgPROCSLOT


50 
	mszProcName
[
MSG_NAME_LEN
];

51 
	mnStus
;

52 
	mnProcKey
;

53 
	mdwMsgCl
;

54 
	mnMsgPos
;

55 } 
	tPROCSLOT
;

60 
	mnQuy
;

61 
	mnFeNum
;

62 
	mnFePos
, 
	mnFeTa
;

63 
MSGLIST
 
	mve
[
MSG_POOL_SUM
];

64 
MSGITEM
 
	mpo
[
MSG_POOL_SUM
];

65 
PROCSLOT
 
	m
[
MSG_SLOT_SUM
];

66 } 
	tMSGSTORE
;

68 #agm
ck
()

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/profile.cpp

5 
	~<dio.h
>

6 
	~<dlib.h
>

7 
	~<rg.h
>

8 
	~<unid.h
>

9 
	~<f.h
>

10 
	~<y.h
>

11 
	~<sys/iol.h
>

12 
	~<sys/tys.h
>

13 
	~<sys/.h
>

14 
	~<sys/time.h
>

15 
	~<sigl.h
>

16 
	~<o.h
>

17 
	~<sys/mm.h
>

18 
	~<sys/m.h
>

19 
	~<dg.h
>

20 
	~<ioam
>

21 
usg
 
mea
 
	gd
;

24 
	~"ofe.h
"

25 
	~"glob.h
"

27 
	#MAX_LINE_LEN
 1024

	)

32 #ifde
__lulus


37 
rim
(*
s
);

40 
rim
(*
s
);

43 
GTextLe
(
FILE
* 
fd
, * 
szBuf
, 
nSize
)

45 if
fd
 =
NULL
)  -1;

46 if
fgs
(
szBuf
, 
nSize
, 
fd
=
NULL
 )  -2;

50 
ricmp
(cڡ *
s
, cڡ *
t
)

52 
a
, 
b
;

54  *
s
 && *
t
 )

56 
a
 = ()*
s
; 
b
 = ()*
t
;

57 if
isu
(
a

tow
(a);

58 if
isu
(
b
b = 
tow
(b);

59 if
a
 !
b
 )  (a > b ? 1 : -1);

60 
s
++; 
t
++;

63 if*
s
 !*
t
 )

64  (*
s
 > *
t
 ? 1 : -1);

69 
LogPromText
(cڡ *
fmt
, ...);

72 #ifde
__lulus


78 
CDaBufr
::
	$CDaBufr
()

80 
m_nL
 = 0;

81 
m_pBuff
 = 
NULL
;

82 
m_objPv
 = 
NULL
;

83 
m_objNext
 = 
NULL
;

84 
	}
}

86 
CDaBufr
::
	$CDaBufr
(*
pBuf
, 
nL
)

88 
	`CDaBufr
();

89 if
nL
 <= 0 ) ;

90 
m_pBuff
 = 
w
 [
nL
];

91 if
m_pBuff
 )

93 
m_nL
 = 
nL
;

94 
	`memy
(
m_pBuff
, 
pBuf
, 
m_nL
);

96 
	}
}

98 
CDaBufr
::~
	$CDaBufr
()

100 if(
m_nL
>0)

102 if(
m_pBuff
)

104 
de
 
m_pBuff
;

105 
m_pBuff
 = 
NULL
;

107 
m_nL
 = 0;

109 
m_objPv
 = 
NULL
;

110 
m_objNext
 = 
NULL
;

111 
	}
}

113 
CDaBufr
::
	$GBufr
(*
pBuf
)

115 if
m_pBuff
 ) 
	`memy
(
pBuf
, m_pBuff, 
m_nL
);

116  
m_nL
;

117 
	}
}

119 * 
CDaBufr
::
	$GBufr
()

121  
m_pBuff
;

122 
	}
}

124 
CDaBufr
::
	$GBufL
()

126  
m_nL
;

127 
	}
}

131 
CMyLi
::
	$CMyLi
()

133 
m_nSize
 = 0;

134 
m_objFt
 = 
NULL
;

135 
m_objLa
 = 
m_objFt
;

136 
m_objAu
 = 
m_objFt
;

137 
	}
}

139 
CMyLi
::~
	$CMyLi
()

141  
m_objFt
 )

143 
CDaBufr
* 
pTemp
 = 
m_objFt
;

144 
m_objFt
 = m_objFt->
m_objNext
;

145 
de
 
pTemp
;

146 
pTemp
 = 
NULL
;

148 
	`CMyLi
();

149 
	}
}

151 
CMyLi
::
	$GSize
()

153  
m_nSize
;

154 
	}
}

156 
bo
 
CMyLi
::
	$AddObj
(
CDaBufr
* 
pObj
)

158 if!
pObj
 )  
l
;

159  
ue
;

160 
	}
}

162 
CDaBufr
* 
CMyLi
::
	$GFt
()

164 
m_objAu
 = 
m_objFt
;

165  
m_objFt
;

166 
	}
}

168 
CDaBufr
* 
CMyLi
::
	$GLa
()

170 
m_objFt
 = 
m_objLa
;

171  
m_objLa
;

172 
	}
}

174 
CDaBufr
* 
CMyLi
::
	$GNext
(
CDaBufr
* 
pObj
)

176 if!
pObj
 )  
NULL
;

177  
pObj
->
m_objNext
;

178 
	}
}

180 
CDaBufr
* 
CMyLi
::
	$GPv
(
CDaBufr
* 
pObj
)

182 if!
pObj
 )  
NULL
;

183  
pObj
->
m_objPv
;

184 
	}
}

189 
CProfe
::
	$CProfe
()

191 
m_fdFe
 = 0;

192 
	`rtf
(
m_szFeName
, "%s", "");

193 
	}
}

195 
CProfe
::
	$CProfe
(* 
szName
)

197 
	`rtf
(
m_szFeName
, "%s", 
szName
);

199 if
	`OnFe
(
szName
) )

201 
szLe
[
MAX_LINE_LEN
];

202  
	`GTextLe
(
m_fdFe
, 
szLe
, (szLine)) > 0 )

204 
	`rim
(
szLe
);

205 
	`rim
(
szLe
);

206 if
szLe
[0]==';' || szLine[0]=='#' ) ;

207 
nL
 = 
	`
(
szLe
);

208 if
nL
 <= 0 ) ;

210 
CDaBufr
 *
pObj
 = 
w
 
	`CDaBufr
(
szLe
, 
nL
+1);

211 
m_LeAay
.
	`push_back
(
pObj
);

213 
	`CBufrAay
(
m_LeAay
).
	`sw
(m_LineArray);

215 
	}
}

217 
CProfe
::~
	$CProfe
()

219 if(
m_fdFe

	`fo
(m_fdFile);

221 
nCou
 = 
m_LeAay
.
	`size
();

222 if
nCou
 > 0 )

224 
nCou
--
de
 
m_LeAay
[nCount];

225 
m_LeAay
.
	`r
();

227 
	}
}

229 
bo
 
CProfe
::
	$IsVid
()

231  (
m_fdFe
 !
NULL
);

232 
	}
}

234 
bo
 
CProfe
::
	$OnFe
(* 
szName
)

236 
m_fdFe
 = 
	`fݒ
(
szName
, "r");

237  
	`IsVid
();

238 
	}
}

240 
CProfe
::
	$GProfeSg
(* 
AName
,

241 * 
KeyName
,

242 * 
Deu
,

243 * 
szBuff
, 
nSize
,

244 
FILE
* 
fd
)

246 
nL
;

247 
szSe
[64], *
p
;

248 
szLe
[
MAX_LINE_LEN
];

250 if
fd
 > 0 )

252 
	`rtf
(
szSe
, "[%s]", 
AName
);

253 
	`fek
(
fd
, 0, 
SEEK_SET
);

254  
	`GTextLe
(
fd
, 
szLe
, (szLine)) > 0 )

256 
	`rim
(
szLe
);

257 
	`rim
(
szLe
);

258 if
szLe
[0]==';' || szLine[0]=='#' ) ;

260 if
	`rcmp
(
szLe
, 
szSe
) == 0 ) ;

262  
	`GTextLe
(
fd
, 
szLe
, (szLine)) > 0 )

264 
	`rim
(
szLe
);

265 
	`rim
(
szLe
);

266 if
szLe
[0]==';' || szLine[0]=='#' ) ;

268 if
	`rchr
(
szLe
, '[') < strchr(szLine, ']') ) ;

269 if!
	`brk
(
szLe
, "=") ) ;

270 
p
 = 
	`ok
(
szLe
, "=");

271 if!
	`rcmp
(
p
, 
KeyName
) )

273 
p
 = 
	`ok
(
NULL
, "= ");

274 
nL
 = 
	`m
(()
	`
(
p
), 
nSize
-1);

275 
	`y
(
szBuff
, 
p
, 
nL
);

276 
szBuff
[
nL
] = '\0';

277  
nL
;

281 
nL
 = 
	`
(
Deu
);

282 
	`ry
(
szBuff
, 
Deu
);

283  
nL
;

284 
	}
}

286 
CProfe
::
	$GProfeI
(* 
AName
,

287 * 
KeyName
,

288 
nDeu
,

289 
FILE
* 
fd
)

291 
nV
=
nDeu
;

292 
szDeu
[16], 
szBuff
[32];

294 
	`rtf
(
szDeu
, "%d", 
nDeu
);

295 if(
	`GProfeSg
(
AName
, 
KeyName
, 
szDeu
, 
szBuff
, 32, 
fd
)>0)

297 
nV
 = 
	`oi
(
szBuff
);

299  
nV
;

300 
	}
}

302 
CProfe
::
	$FdProfeSg
* 
AName
,

303 * 
KeyName
,

304 * 
Deu
,

305 * 
szBuff
, 
nSize
 )

307 
i
, 
nCou
, 
nL
;

308 
szSe
[64], *
p
;

309 
szLe
[
MAX_LINE_LEN
];

310 
CDaBufr
 *
pObj
;

312 
nCou
 = 
m_LeAay
.
	`size
();

313 if
nCou
 > 0 )

315 
	`rtf
(
szSe
, "[%s]", 
AName
);

316  
i
=0; i<
nCou
; i++ )

318 
pObj
 = 
m_LeAay
[
i
];

319 if
pObj
 =
NULL
 ) ;

320 
pObj
->
	`GBufr
(
szLe
);

321 if
	`rcmp
(
szLe
, 
szSe
) == 0 ) ;

324  
i
=i+1; i<
nCou
; i++ )

326 
pObj
 = 
m_LeAay
[
i
];

327 if
pObj
 =
NULL
 ) ;

328 
pObj
->
	`GBufr
(
szLe
);

329 if
	`rchr
(
szLe
, '[') < strchr(szLine, ']') ) ;

330 if!
	`brk
(
szLe
, "=") ) ;

331 
p
 = 
	`ok
(
szLe
, "=");

332 if
	`rcmp
(
p
, 
KeyName
) == 0 )

334 
p
 = 
	`ok
(
NULL
, "= ");

335 if
p
 =
NULL
 )

338 
nL
 = 
	`m
(()
	`
(
p
), 
nSize
-1);

339 
	`y
(
szBuff
, 
p
, 
nL
);

340 
szBuff
[
nL
] = '\0';

341  
nL
;

345 
nL
 = 
	`
(
Deu
);

346 
	`ry
(
szBuff
, 
Deu
);

347  
nL
;

348 
	}
}

350 
CProfe
::
	$FdProfeI
* 
AName
,

351 * 
KeyName
,

352 
nDeu
 )

354 
nV
=
nDeu
;

355 
szDeu
[16], 
szBuff
[32];

357 
	`rtf
(
szDeu
, "%d", 
nDeu
);

358 if(
	`FdProfeSg
(
AName
, 
KeyName
, 
szDeu
, 
szBuff
, 32)>0)

360 
nV
 = 
	`oi
(
szBuff
);

362  
nV
;

363 
	}
}

365 
CProfe
::
	$GProfeSg
(* 
AName
,

366 * 
KeyName
,

367 * 
Deu
,

368 * 
szBuff
,

369 
nSize
)

371 if
m_LeAay
.
	`size
() > 0 )

372  
	`FdProfeSg
(
AName
, 
KeyName
, 
Deu
, 
szBuff
, 
nSize
);

374  
	`GProfeSg
(
AName
, 
KeyName
, 
Deu
, 
szBuff
, 
nSize
, 
m_fdFe
);

375 
	}
}

377 
CProfe
::
	$GProfeI
(* 
AName
,

378 * 
KeyName
,

379 
nDeu
 )

381 if
m_LeAay
.
	`size
() > 0 )

382  
	`FdProfeI
(
AName
, 
KeyName
, 
nDeu
);

384  
	`GProfeI
(
AName
, 
KeyName
, 
nDeu
, 
m_fdFe
);

385 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/profile.h

5 #ide
_PROFILE_H__


6 
	#_PROFILE_H__


	)

8 
	~<dio.h
>

9 
	~<ve
>

10 
	~"rdbFun.h
"

13 #ifde
__lulus


16 #ifde
__lulus


23 as
	cCDaBufr


25 
public
:

26 
CDaBufr
();

27 
CDaBufr
(*
pBuf
, 
nL
);

28 
vtu
 ~
CDaBufr
();

31 
public
:

32 
m_nL
;

33 *
m_pBuff
;

35 
public
:

36 
CDaBufr
* 
m_objPv
;

37 
CDaBufr
* 
m_objNext
;

40 
public
:

41 
GBufr
(*
pBuf
);

42 * 
GBufr
();

43 
GBufL
();

46 
d
::
	tve
<
	tCDaBufr
*> 
	tCBufrAay
;

51 as
	cCMyLi


53 
public
:

54 
CMyLi
();

55 
vtu
 ~
CMyLi
();

58 
eed
:

59 
m_nSize
;

60 
CDaBufr
* 
m_objFt
;

61 
CDaBufr
* 
m_objLa
;

62 
CDaBufr
* 
m_objAu
;

65 
public
:

66 
GSize
();

67 
bo
 
AddObj
(
CDaBufr
* 
pObj
);

68 
CDaBufr
* 
GFt
();

69 
CDaBufr
* 
GLa
();

70 
CDaBufr
* 
GNext
(CDaBufr* 
pObj
);

71 
CDaBufr
* 
GPv
(CDaBufr* 
pObj
);

77 as
	cCProfe


79 
public
:

80 
CProfe
();

81 
CProfe
(* 
szName
);

82 ~
CProfe
();

85 
public
:

86 
FILE
* 
m_fdFe
;

87 
m_szFeName
[64];

88 
CBufrAay
 
m_LeAay
;

91 
public
:

92 
bo
 
IsVid
();

93 
bo
 
OnFe
(* 
szName
);

94 
GProfeSg
* 
AName
,

95 * 
KeyName
,

96 * 
Deu
,

97 * 
szBuff
, 
nSize
,

98 
FILE
* 
fd
 );

99 
GProfeI
* 
AName
,

100 * 
KeyName
,

101 
nDeu
,

102 
FILE
* 
fd
 );

104 
FdProfeSg
* 
AName
,

105 * 
KeyName
,

106 * 
Deu
,

107 * 
szBuff
, 
nSize
 );

108 
FdProfeI
* 
AName
,

109 * 
KeyName
,

110 
nDeu
 );

112 
GProfeSg
* 
AName
,

113 * 
KeyName
,

114 * 
Deu
,

115 * 
szBuff
, 
nSize
 );

116 
GProfeI
* 
AName
,

117 * 
KeyName
,

118 
nDeu
 );

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/rdbDef.h

4 #ide 
_RTDB_H_


5 
	#_RTDB_H_


	)

7 
	~"msgdef.h
"

8 
	~"tydef.h
"

10 
	#SHM_STRUCT_VER
 0x02000001

	)

12 
	#STN_NAME_SIZE
 16

	)

13 
	#PNT_CODE_SIZE
 24

	)

14 
	#PNT_NAME_SIZE
 48

	)

16 
	#MAX_STN_SUM
 600

	)

19 
	#MAX_ANALOG_SUM
 16384

	)

20 
	#MAX_DIGITAL_SUM
 16384

	)

21 
	#MAX_PULSE_SUM
 10240

	)

22 
	#MAX_RELAY_SUM
 1024

	)

23 
	#MAX_ADJUST_SUM
 256

	)

25 
	#SOE_QUEUE_SUM
 256

	)

26 
	#AIE_QUEUE_SUM
 256

	)

29 
	#AICTRL_ENABLE
 0x0001

	)

30 
	#AICTRL_POLARITY
 0x0002

	)

33 
	#DICTRL_ENABLE
 0x0001

	)

34 
	#DICTRL_DOUBLEBIT
 0x0002

	)

35 
	#DICTRL_OPPOSITE
 0x0004

	)

36 
	#DICTRL_AUTORESET
 0x0008

	)

38 
	#DISTATUS_VALUE
 0x0003

	)

39 
	#DISTATUS_VALID
 0x0100

	)

40 
	#DISTATUS_ALARMING
 0x0200

	)

42 
	#DIVALUE_FALSE1
 0

	)

43 
	#DIVALUE_ON
 1

	)

44 
	#DIVALUE_OFF
 2

	)

45 
	#DIVALUE_FALSE2
 3

	)

48 #agm
ck
(1)

53 
	mSecdSEpoch
:32;

54 
	mFiOfSecd
:24;

55 
	mTimeQuy
:8;

56 }
	tACSI_TIMESTAMP
;

61 
LONG
 
	mlTime
;

62 
WORD
 
	mwMiSecd
;

63 
BYTE
 
	mbyS
;

64 
WORD
 
	mwSID
;

65 
WORD
 
	mwPNum
;

66 
WORD
 
	mwArib
;

67 } 
	tSOEITEM
;

72 
BYTE
 
	mbyTy
;

73 
WORD
 
	mwSID
;

74 
WORD
 
	mwPNum
;

75 
t32
 
	mdwVue
;

76 
	mfVue
;

77 } 
	tAIEITEM
;

81 
	sgAI_ITEM


83 
WORD
 
	mwPID
;

84 
BYTE
 
	mbyTy
;

85 
BYTE
 
	mbyUn
;

86 
	mszName
[
PNT_NAME_SIZE
];

87 
	miTnsNum
;

88 
WORD
 
	mwPCl
;

89 
WORD
 
	mwThshd
;

90 
	mfRio
;

91 
	mfOfft
;

93 
t32
 
	mdwRawV
;

94 
	mfRlV
;

95 
ACSI_TIMESTAMP
 
	mACSITime
;

96 } 
	tANALOGITEM
;

99 
	sgDI_ITEM


101 
WORD
 
	mwPID
;

102 
BYTE
 
	mbyTy
;

103 
BYTE
 
	mbyAr
;

104 
	mszName
[
PNT_NAME_SIZE
];

105 
	miTnsNum
;

106 
WORD
 
	mwPCl
;

107 
	mwEvtCode
;

108 
WORD
 
	mwRerve
;

109 
WORD
 
	mwStus
;

110 
ACSI_TIMESTAMP
 
	mACSITime
;

111 } 
	tDIGITALITEM
;

114 
	sgPI_ITEM


116 
WORD
 
	mwPID
;

117 
BYTE
 
	mbyTy
;

118 
BYTE
 
	mbyAr
;

119 
	mszName
[
PNT_NAME_SIZE
];

120 
	miTnsNum
;

121 
WORD
 
	mwPCl
;

122 
WORD
 
	mwRerve
;

123 
	mfRio
;

124 
DWORD
 
	mdwRawV
;

125 
ACSI_TIMESTAMP
 
	mACSITime
;

126 } 
	tPULSEITEM
;

129 
	sgDO_ITEM


131 
WORD
 
	mwPID
;

132 
BYTE
 
	mbyTy
;

133 
BYTE
 
	mbyAr
;

134 
	mszName
[
PNT_NAME_SIZE
];

135 
	miTnsNum
;

136 
WORD
 
	mwPCl
;

137 
WORD
 
	mwStus
;

138 } 
	tRELAYITEM
;

141 
	sgDA_ITEM


143 
WORD
 
	mwPID
;

144 
BYTE
 
	mbyTy
;

145 
BYTE
 
	mbyAr
;

146 
	mszName
[
PNT_NAME_SIZE
];

147 
	miTnsNum
;

148 
	mfRio
;

149 
	mfOfft
;

150 
t32
 
	mdwRawV
;

151 
	mfRlV
;

152 } 
	tADJUSTITEM
;

157 
WORD
 
	mwSNum
;

158 
WORD
 
	mwStus
;

159 
	mszSName
[
STN_NAME_SIZE
];

161 
WORD
 
	mwAlogSum
;

162 
WORD
 
	mwDigSum
;

163 
WORD
 
	mwRaySum
;

164 
WORD
 
	mwPulSum
;

165 
WORD
 
	mwAdjuSum
;

166 
WORD
 
	mwBak1Sum
;

167 
WORD
 
	mwBak2Sum
;

168 
WORD
 
	mwBak3Sum
;

170 
DWORD
 
	mdwAlogPos
;

171 
DWORD
 
	mdwDigPos
;

172 
DWORD
 
	mdwRayPos
;

173 
DWORD
 
	mdwPulPos
;

174 
DWORD
 
	mdwAdjuPos
;

175 
DWORD
 
	mdwBak1Pos
;

176 
DWORD
 
	mdwBak2Pos
;

177 
DWORD
 
	mdwBak3Pos
;

179 
ANALOGITEM
 *
	mpAlogTab
;

180 
DIGITALITEM
 *
	mpDigTab
;

181 
RELAYITEM
 *
	mpRayTab
;

182 
PULSEITEM
 *
	mpPulTab
;

183 *
	mpTabRes0
;

184 *
	mpTabRes1
;

185 *
	mpTabRes2
;

186 *
	mpTabRes3
;

187 } 
	tSTNPARAM
;

193 
STNPARAM
 
	mSUn
[
MAX_STN_SUM
];

195 
ANALOGITEM
 
	mAlogTab
[
MAX_ANALOG_SUM
];

196 
DIGITALITEM
 
	mDigTab
[
MAX_DIGITAL_SUM
];

197 
RELAYITEM
 
	mRayTab
[
MAX_RELAY_SUM
];

198 
PULSEITEM
 
	mPulTab
[
MAX_PULSE_SUM
];

199 }
	tRTDBASE
;

204 
WORD
 
	mwS
;

205 
WORD
 
	mwSSum
;

206 
t32
 
	mnAlogSum
;

207 
t32
 
	mnDigSum
;

208 
t32
 
	mnRaySum
;

209 
t32
 
	mnPulSum
;

210 
t32
 
	mnAdjuSum
;

211 
t32
 
	mnS1
;

212 
t32
 
	mnS2
;

213 
t32
 
	mnS3
;

214 
t32
 
	mnSOEWrePos
;

215 
t32
 
	mnAIEWrePos
;

216 
t32
 
	mnS4
;

217 
t32
 
	mnS5
;

218 
t32
 
	mnS6
;

219 
t32
 
	mnRunMode
;

220 
t32
 
	mnIsDuty
;

221 }
	tSYSINFO
;

226 
DWORD
 
	mdwASize
;

227 
DWORD
 
	mdwExtSize
;

228 
DWORD
 
	mdwQuy
;

229 
DWORD
 
	mdwEdi
;

230 
SYSINFO
 
	msysInfo
;

231 
RTDBASE
 
	mRTDBa
;

232 
SOEITEM
 
	msAay
[
SOE_QUEUE_SUM
];

233 
AIEITEM
 
	maAay
[
AIE_QUEUE_SUM
];

234 
MSGSTORE
 
	mmsgSte
;

236 *
	mpExtAddr
;

237 }
	tSHM_SPACE
;

239 #agm
ck
()

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/rdbFun.h

4 #ide 
_RDBFUN_H_


5 
	#_RDBFUN_H_


	)

7 
	~"rdbDef.h
"

9 #ifdef 
__lulus


13 
On_SHM_DBa
();

14 
Clo_SHM_DBa
();

15 
Ce_SHM_DBa
(* 
szPh
, 
nExtL
);

16 
Check_SHM_DBa
();

17 
BOOL
 
EbDebug
(BOOL 
bEb
);

18 
ShowRTDBInfo
();

20 *
GWkPh
();

21 *
G_RTDB_S
();

22 
G_RTDB_Exnd
(*
addr
);

23 cڡ 
SYSINFO
* 
G_RTDB_SysInfo
();

24 cڡ 
STNPARAM
* 
G_RTDB_Sti
(
WORD
 
wSNum
);

25 cڡ 
ANALOGITEM
* 
G_RTDB_Alog
(
WORD
 
wS
, WORD 
wP
);

26 cڡ 
DIGITALITEM
* 
G_RTDB_Dig
(
WORD
 
wS
, WORD 
wP
);

27 cڡ 
RELAYITEM
* 
G_RTDB_Ray
(
WORD
 
wS
, WORD 
wP
);

28 cڡ 
PULSEITEM
* 
G_RTDB_Pul
(
WORD
 
wS
, WORD 
wP
);

29 cڡ 
SOEITEM
* 
Rd_RTDB_SOE
(
iPos
);

30 cڡ 
AIEITEM
* 
Rd_RTDB_AIE
(
iPos
);

32 
Wre_RTDB_Da
(*
pBuf
, 
nL
);

33 
Rd_RTDB_Da
(*
pBuf
, 
nL
);

35 
LogMesgeBus
(*
szProcName
);

36 
ExMesgeBus
(
nProcKey
);

37 
MesgeSd
(
MSGITEM
 *
pMesge
, *
pD
);

38 
MesgeRecv
(
nProcKey
, 
MSGITEM
 *
pMesge
, 
nSync
);

39 
MesgeSubsibe
(
nProcKey
, 
dwOi
);

40 
MesgeUnSubsibe
(
nProcKey
, 
dwOi
);

41 
rim
(*
s
);

42 
rim
(*
s
);

43 
GTextLe
(
FILE
* 
fd
, * 
szBuf
, 
nSize
);

44 
ricmp
(cڡ *
s
, cڡ *
t
);

45 
LogPromText
(cڡ *
fmt
, ...);

46 
GPSum
(
BYTE
 
byTy
);

47 
GTnsNum
(
BYTE
 
byTy
, 
WORD
 
wS
, WORD 
wP
);

48 
ass
 
CSlPt
 ;

49 
ass
 
CBaPt
 ;

50 
ass
 
CTLi
 ;

51 
ass
 
CUdpPt
 ;

52 
ass
 
CProfe
;

53 
ass
 
CTPtSv
 ;

54 
ass
 
CProc
;

55 
ass
 
CMhod
 ;

56 
ass
 
CSemObj
 ;

57 
ass
 
CRtuBa
 ;

58 
ass
 
CTCl
 ;

59 
ass
 
CTClSht
 ;

60 
ass
 
CSockF
;

61 #ifdef 
__lulus


	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/semObj.cpp

4 
	~<dio.h
>

5 
	~<dlib.h
>

6 
	~<rg.h
>

7 
	~<dg.h
>

8 
	~<y.h
>

9 
	~<o.h
>

11 
	~"mObj.h
"

14 
	gCSemObj
::
	$CSemObj
()

16 
m_iSemId
 = -1;

17 
m_bCe
 = 
l
;

18 
m_tKey
 = 
	`ok
(".", 's');

19 
	}
}

21 
	gCSemObj
::
	$CSemObj
(
key_t
 
tKey
, 
iMode
)

22 : 
	$m_tKey
(
tKey
)

24 
m_bCe
 = 
l
;

25 
	`Ce
(
m_tKey
, 
iMode
);

26 
	}
}

28 
	gCSemObj
::~
	$CSemObj
()

30 if(
m_bCe
)

31 
	`Remove
();

32 
	}
}

34 
	gCSemObj
::
	$Ce
(
key_t
 
tKey
, 
iMode
)

36 
m_tKey
 = 
tKey
;

37 if(
m_iSemId
 = 
	`mg
(
m_tKey
, 1, 
IPC_CREAT
 | 
IPC_EXCL
 | 
iMode
)) < 0 )

39 if(
o
 !
EEXIST
)

41 
	`
("semget(IPC_CREAT) fail");

44 if(
m_iSemId
 = 
	`mg
(
m_tKey
, 1, 
iMode
)) < 0 )

46 
	`
("semget() fail");

49 
m_bCe
 = 
l
;

53 
	`SVue
(1);

54 
m_bCe
 = 
ue
;

57 
	}
}

59 
	gCSemObj
::
	$Remove
()

61 
mun
 
unSem
;

62 
	`ml
(
m_iSemId
, 0, 
IPC_RMID
, 
unSem
);

63 
m_iSemId
 = -1;

64 
m_bCe
 = 
l
;

65 
	}
}

67 
bo
 
	gCSemObj
::
	$mTake
()

69 
mbuf
 
mb
;

70 
mb
.
m_num
 = 0;

71 
mb
.
m_
 = -1;

72 
mb
.
m_g
 = 
SEM_UNDO
;

73 if
	`m
(
m_iSemId
, &
mb
, 1) < 0 )

75 if(
o
 =
EAGAIN
 ||n=
EINTR
)

77  
l
;

79  
l
;

81  
ue
;

82 
	}
}

84 
	gCSemObj
::
	$mGive
()

86 
mbuf
 
mb
;

87 
mb
.
m_num
 = 0;

88 
mb
.
m_
 = 1;

89 
mb
.
m_g
 = 
SEM_UNDO
;

90 
	`m
(
m_iSemId
, &
mb
, 1);

91 
	}
}

93 
	gCSemObj
::
	$SVue
(
iVue
)

95 
mun
 
unSem
;

96 
unSem
.
v
 = 
iVue
;

97 
	`ml
(
m_iSemId
, 0, 
SETVAL
, 
unSem
);

98 
	}
}

100 
	gCSemObj
::
	$GVue
()

102 
mun
 
unSem
;

103 
iVue
 = 
	`ml
(
m_iSemId
, 0, 
GETVAL
, 
unSem
);

104  
iVue
;

105 
	}
}

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/semObj.h

4 #ide
_SEMOBJ_H_


5 
	#_SEMOBJ_H_


	)

7 
	~<sys/tys.h
>

8 
	~<sys/c.h
>

9 
	~<sys/m.h
>

12 #i
defed
(
__GNU_LIBRARY__
&& !defed(
_SEM_SEMUN_UNDEFINED
)

16 
	umun
 {

17 
	mv
;

18 
mid_ds
 *
	mbuf
;

19 *
	my
;

20 
mfo
 *
	m__buf
;

26 as
	cCSemObj


28 
	meed
:

29 
m_iSemId
;

30 
key_t
 
	mm_tKey
;

31 
bo
 
	mm_bCe
;

33 
	mpublic
:

34 
CSemObj
();

35 
CSemObj
(
key_t
 
tKey
, 
iMode
 = 0600);

36 
	mvtu
 ~
CSemObj
();

38 
Ce
(
key_t
 
tKey
, 
iMode
 = 0600);

39 
Remove
();

40 
bo
 
mTake
();

41 
mGive
();

42 
SVue
(
iVue
);

43 
GVue
();

45 
bo
 
	$IfCe
({  
m_bCe
; }

46 
	}
};

	@/home/cyz/Desktop/Workspace/EMU2000/SRC/share/typedef.h

4 #ide 
_TYPEDEF_H_


5 
	#_TYPEDEF_H_


	)

7 
	~<unid.h
>

8 
	~<rg.h
>

11 #ifde
__lulus


15 
	tt16
;

16 
	tt32
;

17 
	tt8u
;

18 
	tt16u
;

19 
	tt32u
;

21 
	tBYTE
;

22 
	tWORD
;

23 
	tUINT
;

24 
	tDWORD
;

25 
	tBOOL
;

26 
	tHANDLE
;

27 
	tLONG
;

28 * 
	tLPSTR
;

29 cڡ * 
	tLPCSTR
;

30 * 
	tLPVOID
;

32 
	#TRUE
 1

	)

33 
	#FALSE
 0

	)

34 
	#ERROR
 (-1)

	)

36 
	#HIBYTE
(
x
(((x>> 8& 0xff

	)

37 
	#LOBYTE
(
x
((x& 0xff

	)

38 
	#HIWORD
(
x
(((x>> 16& 0xffff

	)

39 
	#LOWORD
(
x
((x& 0xffff

	)

41 
	#MAKEWORD
(
l
, 
h
(((h<< 8| (l))

	)

42 
	#MAKELONG
(
l
, 
h
(((h<< 16| (l))

	)

44 #ide
max


48 #ide
m


52 #ifde
__lulus


56 #agm
ck
(1)

58 
	s_gTIMEDATA


60 
MiSec
:10;

61 
Secd
:6;

62 
Mu
:6;

63 
Hour
:5;

64 
Day
:5;

65 
Mth
:4;

66 
Yr
:12;

67 } 
	tTIMEDATA
;

69 
	s_gREALTIME
 {

70 
wYr
;

71 
wMth
;

72 
wDayOfWk
;

73 
wDay
;

74 
wHour
;

75 
wMu
;

76 
wSecd
;

77 
wMliSec
;

78 } 
	tREALTIME
;

80 #agm
ck
()

	@
1
.
0
199
13792
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/BusManger.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/BusManger.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/CBusDebug.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/CBusDebug.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/CPublicMethod.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/CPublicMethod.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/GetProtocol.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/GetProtocol.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/cmsg.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/cmsg.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/globleDef.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/BayLayer/main.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/CProtocol_Cdt.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/CProtocol_Cdt.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/cdt.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/cdt.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/CDT/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/CProtocol_Cjt188.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/CProtocol_Cjt188.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/Cjt188_2004.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/Cjt188_2004.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Cjt188/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/CProtocol_DDB.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/CProtocol_DDB.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/DDB.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/DDB.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DDB/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDTWithTime.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDTWithTime.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDataTrans.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDataTrans.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDirFile.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CDirFile.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CProtocol_DataTrans.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/CProtocol_DataTrans.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/DataTransS/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/CProtocol_Dlt645.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/CProtocol_Dlt645.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/Dlt645_1997.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/Dlt645_1997.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/Dlt645_2007.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/Dlt645_2007.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Dlt645/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/CProtocol_ESDCMMI.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/CProtocol_ESDCMMI.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/ESDCMMI.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/ESDCMMI.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ESDCMMI/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/CProtocol_IEC101S.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/CProtocol_IEC101S.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/IEC101S_1997.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/IEC101S_1997.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/IEC101S_2002.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/IEC101S_2002.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC101S/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/CProtocol_IEC103.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/CProtocol_IEC103.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/IEC103.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/IEC103.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC103/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/CProtocol_IEC104.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/CProtocol_IEC104.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/Protocol_ESD_IEC104.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/Protocol_ESD_IEC104.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/Rtu104.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/Rtu104.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/IEC104/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/CProtocol_ModBusTcp.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/CProtocol_ModBusTcp.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/ModBusTcp_Transfer.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/ModBusTcp_Transfer.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/KunMing/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/CProtocol_LFP.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/CProtocol_LFP.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/Lfp_Nsa3000.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/Lfp_Nsa3000.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/LFP/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/CProtocol_ModBus.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/CProtocol_ModBus.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/ModBusRTU.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/ModBusRTU.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBus/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/CProtocol_ModBusMaster.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/CProtocol_ModBusMaster.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusControl.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusControl.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusDSE7320FDJ.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusDSE7320FDJ.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusEPS.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusEPS.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusLekuThermometer.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusLekuThermometer.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusLiuLiangJi.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusLiuLiangJi.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusSD96E3.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusSD96E3.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusWenKongyi.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusWenKongyi.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusXiaoDianLiu.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusXiaoDianLiu.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusXiaoHuMCU.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/ModBusXiaoHuMCU.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/PMC_530.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/PMC_530.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusMaster/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/CProtocol_ModBus.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/CProtocol_ModBus.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/ModBusRTU.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/ModBusRTU.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusQuickly/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_ESD_ModBusSlave.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_ESD_ModBusSlave.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_ModBusSlave.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_ModBusSlave.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_SultanModBusSlave.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/Protocol_SultanModBusSlave.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusSlave/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/CProtocol_ModBusTcp.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/CProtocol_ModBusTcp.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/ModBusTcp.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/ModBusTcp.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/CProtocol_ModBusTcp.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/CProtocol_ModBusTcp.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/ModBusTcp_Gather.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/ModBusTcp_Gather.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/ModBusTcp_Gather/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/CProtocol_Resume.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/CProtocol_Resume.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/Resume.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/Resume.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/Resume/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CGroupBroadProto.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CGroupBroadProto.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtp.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtp.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtpFile.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtpFile.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtpProto.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/CSocketFtpProto.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/GroupBroad.c
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/SocketFtp/GroupBroad.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/Protocol_UPS.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/Protocol_UPS.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/ups.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/Protocol/UPS/ups.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/cgi/getdata.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/msgManage.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/msgManage.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/rdbObj.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/rdbObj.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/rdbms.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/semObj.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/semObj.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/shm.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/librtdb/shm.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/procman/CWatchDog.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/procman/CWatchDog.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/procman/main.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/procman/proc.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/rdbms/rdbServer.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/BasePort.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/BasePort.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/CMethod.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/CProtocol.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/CTcpPortServer.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/CTcpPortServer.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/PintTest.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/PintTest.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/Rtu.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/Rtu.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/SerialPort.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/SerialPort.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpClient.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpClient.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpClientShort.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpClientShort.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpListen.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpListen.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpPort.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/TcpPort.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/UdpPort.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/UdpPort.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/gDataType.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/global.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/global.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/md5.c
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/md5.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/msgdef.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/profile.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/profile.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/rdbDef.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/rdbFun.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/semObj.cpp
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/semObj.h
/home/cyz/Desktop/Workspace/EMU2000/SRC/share/typedef.h
